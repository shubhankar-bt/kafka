import React, { useState, useRef, useEffect } from "react";
import {
  Box,
  Typography,
  Paper,
  TextField,
  Button,
  CircularProgress,
  Chip,
  Alert,
  Stack,
  Stepper,
  Step,
  StepLabel,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  IconButton,
  Tooltip,
} from "@mui/material";
import {
  CloudUpload as CloudUploadIcon,
  RestartAlt as RestartAltIcon,
  Description as DescriptionIcon,
  Send as SendIcon,
  FileDownload as FileDownloadIcon,
  ArrowBack as ArrowBackIcon,
  Close as CloseIcon,
} from "@mui/icons-material";

import useApi from "../../hooks/useApi";
import useCustomSnackbar from "../../utils/useCustomSnackbar";

// --- YOUR STYLES (Restored) ---
const mainContainerStyle = {
  padding: 3,
  height: "100%",
  width: "100%",
};

const controlPanelStyle = {
  padding: "2%",
};

const uploadBoxStyle = {
  display: "grid",
  justifyContent: "center",
  border: "2px dashed #9b78c7",
  padding: "3% 0% 5% 0%",
  cursor: "pointer",
};

const iconStyle = {
  fontSize: "6rem",
  margin: "1% 0% 1% 30% ",
  color: "#9b78c7",
};

const headerTextStyle = {
  textAlign: "center",
  fontWeight: "bold",
};

const subTextStyle = {
  display: "flex",
  justifyContent: "center",
  color: "text.secondary",
};

const dateinputfield = {
  display: "flex",
  justifyContent: "center",
  marginBottom: "30px",
  "& .MuiTextField-root": { minWidth: "250px" },
};

const tableContainerStyle = {
  borderRadius: "12px",
  border: "1px solid",
  borderColor: "divider",
  overflow: "hidden",
  marginTop: "20px",
  boxShadow: 1,
  maxHeight: 600,
};

const tableHeaderStyle = {
  backgroundColor: "#f5f5f5",
};

const tableHeaderCellStyle = {
  color: "text.primary",
  fontWeight: "bold",
  fontSize: "0.95rem",
};

const actionButtonsContainer = {
  display: "flex",
  justifyContent: "center",
  marginTop: 4,
  gap: 2,
};

const mainSteps = ["Upload & Validate", "Preview & Submit"];
const validationSteps = [
  "Format Validation",
  "Database Validation",
  "Balance Validation",
];

const JournalBulkUpload = () => {
  const { callApi } = useApi();
  const showSnackBar = useCustomSnackbar();

  const [activeStep, setActiveStep] = useState(0);
  const [selectedDate, setSelectedDate] = useState("");
  const [file, setFile] = useState(null);
  const [isCsvFile, setIsCsvFile] = useState(false);
  const fileInputRef = useRef(null);

  const [requestId, setRequestId] = useState(null);
  const [isProcessing, setIsProcessing] = useState(false);

  const [validationStage, setValidationStage] = useState(0);
  const [resultStatus, setResultStatus] = useState(null);
  const [resultMsg, setResultMsg] = useState("");
  const [autoDlTriggered, setAutoDlTriggered] = useState(false);
  const [downloadMsg, setDownloadMsg] = useState("Downloading Error Report...");

  const [previewRows, setPreviewRows] = useState([]);
  const [totalRows, setTotalRows] = useState(0);

  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(50);
  const [isCreatingBatch, setIsCreatingBatch] = useState(false);

  const handleDateChange = (e) => setSelectedDate(e.target.value);

  const handleFileSelect = (e) => {
    if (e.target.files[0]) {
      const selected = e.target.files[0];
      setFile(selected);
      setIsCsvFile(
        selected.name.toLowerCase().endsWith(".csv") ||
          selected.name.toLowerCase().endsWith(".txt")
      );
      setResultStatus(null);
      setResultMsg("");
      setValidationStage(0);
      setPreviewRows([]);
      setAutoDlTriggered(false);
      setIsProcessing(false);
      setDownloadMsg("Downloading Error Report...");
    }
  };

  const handleClearFile = (e) => {
    e.stopPropagation();
    setFile(null);
    setIsCsvFile(false);
    if (fileInputRef.current) fileInputRef.current.value = "";
    setResultStatus(null);
    setResultMsg("");
    setValidationStage(0);
    setIsProcessing(false);
  };

  const resetAll = () => {
    setActiveStep(0);
    setRequestId(null);
    setResultStatus(null);
    setValidationStage(0);
    setResultMsg("");
    setPreviewRows([]);
    setTotalRows(0);
    setIsProcessing(false);
    setAutoDlTriggered(false);
    setIsCsvFile(false);
    setFile(null);
    setPage(0);
    setDownloadMsg("Downloading Error Report...");
    if (fileInputRef.current) fileInputRef.current.value = "";
  };

  const handleBack = () => {
    setActiveStep(0);
    setResultStatus(null);
    setValidationStage(0);
    setResultMsg("");
    setIsProcessing(false);
    setAutoDlTriggered(false);
    setDownloadMsg("Downloading Error Report...");
  };

  const downloadFileHelper = async (url, filename) => {
    try {
      const response = await callApi(
        url,
        null,
        "GET",
        "blob",
        null,
        {},
        false
      );

      const blobData = response.data || response;
      if (!blobData) throw new Error("Empty response data");

      const blob = new Blob([blobData], {
        type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      });

      const link = document.createElement("a");
      const objectUrl = window.URL.createObjectURL(blob);

      link.href = objectUrl;
      link.setAttribute("download", filename);
      document.body.appendChild(link);
      link.click();

      link.remove();
      window.URL.revokeObjectURL(objectUrl);

      return true;
    } catch (e) {
      console.error("Download Error:", e);
      showSnackBar("File download failed", "error");
      return false;
    }
  };

  const handleDownloadTemplate = () =>
    downloadFileHelper(
      "/JS/journals/download-template",
      "Journal_Upload_Template.xlsx"
    );

  const handleDownloadFile = async (type, reqId = requestId) => {
    if (type === "ERROR") showSnackBar("Downloading Error Report...", "info");

    const success = await downloadFileHelper(
      `/JS/journals/download-bulk-file/${reqId}?type=${type}`,
      type === "ERROR" ? "Error_Report.xlsx" : "Success_Batch.csv"
    );

    if (success && type === "SUCCESS")
      showSnackBar("Downloaded successfully.", "success");
    if (success && type === "ERROR") setDownloadMsg("Error Report Downloaded");
  };

  const handleStartValidation = async () => {
    if (!selectedDate || !file) {
      showSnackBar("Please select Date and File.", "warning");
      return;
    }

    setResultStatus(null);
    setResultMsg("");
    setValidationStage(0);
    setIsProcessing(true);
    setAutoDlTriggered(false);
    setDownloadMsg("Downloading Error Report...");

    const formData = new FormData();
    formData.append("file", file);
    formData.append("postingDate", selectedDate);

    try {
      const data = await callApi(
        "/JS/journals/bulk-validate-init",
        formData,
        "POST"
      );

      if (data && data.requestId) {
        setRequestId(data.requestId);
      } else {
        throw new Error("Invalid response from server");
      }
    } catch (err) {
      console.error("Upload Failed:", err);
      setIsProcessing(false);
      setResultStatus("ERROR");
      setResultMsg("Init Failed: " + (err.message || "Unknown Error"));
    }
  };

  const handleCreateBatch = async () => {
    if (!requestId) {
      showSnackBar("Invalid Request ID. Please try uploading again.", "error");
      return;
    }

    setIsCreatingBatch(true);
    try {
      const payload = {
        requestId: requestId,
        commonBatchRemarks: `Bulk Upload - ${selectedDate}`,
      };
      const response = await callApi(
        "/JS/journals/create-batch-from-cache",
        payload,
        "POST"
      );

      if (response && (response.status === "SUCCESS" || response.batchId)) {
        showSnackBar(
          `Batch Created Successfully! ID: ${response.batchId}`,
          "success",
          5000
        );
        setTimeout(() => resetAll(), 1500);
      } else {
        throw new Error(response.message || "Failed");
      }
    } catch (e) {
      let msg = e.message || "Unknown error";
      if (e.response && e.response.data && e.response.data.message) {
        msg = e.response.data.message;
      }
      showSnackBar("Failed to create batch: " + msg, "error");
    } finally {
      setIsCreatingBatch(false);
    }
  };

  useEffect(() => {
    let interval;
    if (isProcessing && requestId) {
      interval = setInterval(async () => {
        try {
          const res = await callApi(
            `/JS/journals/bulk-status/${requestId}`,
            null,
            "GET"
          );
          if (!res) return;
          if (res.totalRows) setTotalRows(res.totalRows);

          if (res.status === "ERROR") {
            setIsProcessing(false);
            setResultStatus("ERROR");
            setResultMsg(res.message);
            setValidationStage(res.currentStage || 1);
            clearInterval(interval);
            showSnackBar(res.message, "error", 5000);
            if (res.hasErrorFile && !autoDlTriggered) {
              setAutoDlTriggered(true);
              handleDownloadFile("ERROR", res.requestId);
            }
          } else if (res.status === "SUCCESS") {
            setIsProcessing(false);
            setResultStatus("SUCCESS");
            setValidationStage(4);
            setTotalRows(res.totalRows);
            if (res.previewDataJson)
              setPreviewRows(JSON.parse(res.previewDataJson));
            clearInterval(interval);
            showSnackBar(
              "Validation Complete. Proceeding to Preview...",
              "success"
            );
            setTimeout(() => {
              setActiveStep(1);
            }, 1000);
          } else {
            setValidationStage(res.currentStage);
          }
        } catch (e) {}
      }, 800);
    }
    return () => clearInterval(interval);
  }, [isProcessing, requestId, callApi, showSnackBar, autoDlTriggered]);

  const handleChangePage = (event, newPage) => setPage(newPage);
  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };
  const visibleRows = previewRows.slice(
    page * rowsPerPage,
    page * rowsPerPage + rowsPerPage
  );
  const isValidationStepFailed = (index) => {
    return resultStatus === "ERROR" && index === validationStage - 1;
  };

  return (
    <Box sx={mainContainerStyle}>
      <Paper elevation={1} sx={controlPanelStyle}>
        <Box sx={{ display: "flex", justifyContent: "flex-end", mb: 2 }}>
          <Button
            variant="text"
            startIcon={<FileDownloadIcon />}
            onClick={handleDownloadTemplate}
          >
            Download Template
          </Button>
        </Box>
        <Box sx={{ width: "100%", maxWidth: "600px", margin: "0 auto", mb: 4 }}>
          <Stepper activeStep={activeStep}>
            {mainSteps.map((label) => (
              <Step key={label}>
                <StepLabel>{label}</StepLabel>
              </Step>
            ))}
          </Stepper>
        </Box>

        {activeStep === 0 && (
          <Box>
            <Box sx={dateinputfield}>
              <TextField
                type="date"
                label="Posting Date"
                value={selectedDate}
                onChange={handleDateChange}
                InputLabelProps={{ shrink: true }}
                size="small"
                disabled={isProcessing}
                sx={{ width: 200 }}
              />
            </Box>
            <Box
              sx={{
                ...uploadBoxStyle,
                borderColor:
                  resultStatus === "ERROR" ? "error.main" : "#9b78c7",
                opacity: isProcessing ? 0.6 : 1,
              }}
              onClick={() => {
                if (!isProcessing) fileInputRef.current.click();
              }}
            >
              <input
                type="file"
                hidden
                ref={fileInputRef}
                onChange={handleFileSelect}
                onClick={(e) => (e.target.value = null)}
                accept=".xlsx,.csv"
              />
              {file ? (
                <>
                  <DescriptionIcon
                    sx={iconStyle} // Using your custom icon style with margin
                  />
                  <Typography sx={headerTextStyle}>{file.name}</Typography>
                  <Typography sx={subTextStyle}>Click to change</Typography>
                  <Tooltip title="Remove File">
                    <IconButton
                      size="small"
                      onClick={handleClearFile}
                      sx={{
                        position: "absolute",
                        top: 10,
                        right: 10,
                        bgcolor: "background.paper",
                        "&:hover": { bgcolor: "error.light", color: "white" },
                      }}
                    >
                      <CloseIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                </>
              ) : (
                <>
                  <CloudUploadIcon sx={iconStyle} />
                  <Typography sx={headerTextStyle}>
                    Click to Upload File
                  </Typography>
                  <Typography sx={subTextStyle}>
                    .xlsx, .csv (Max 50MB)
                  </Typography>
                </>
              )}
            </Box>
            {(isProcessing || resultStatus) && (
              <Box sx={{ mt: 4, mb: 2 }}>
                <Stepper activeStep={validationStage - 1} alternativeLabel>
                  {validationSteps.map((label, index) => {
                    const labelProps = {};
                    if (isValidationStepFailed(index)) {
                      labelProps.optional = (
                        <Typography variant="caption" color="error">
                          Failed
                        </Typography>
                      );
                      labelProps.error = true;
                    }
                    return (
                      <Step key={label}>
                        <StepLabel {...labelProps}>{label}</StepLabel>
                      </Step>
                    );
                  })}
                </Stepper>
              </Box>
            )}
            {resultStatus === "ERROR" && (
              <Alert
                severity="error"
                sx={{ mt: 3, mx: "auto", maxWidth: "80%" }}
              >
                {resultMsg} â€” {downloadMsg}
              </Alert>
            )}
            <Stack direction="row" sx={actionButtonsContainer}>
              <Button
                variant="contained"
                size="large"
                onClick={handleStartValidation}
                disabled={!file || !selectedDate || isProcessing}
                startIcon={
                  isProcessing ? (
                    <CircularProgress size={20} color="inherit" />
                  ) : (
                    <SendIcon />
                  )
                }
              >
                {isProcessing ? "Validating..." : "Start Validation"}
              </Button>
            </Stack>
          </Box>
        )}

        {activeStep === 1 && (
          <Box>
            <Stack
              direction="row"
              justifyContent="space-between"
              alignItems="center"
              sx={{ mb: 2 }}
            >
              <Alert severity="success" sx={{ flexGrow: 1, mr: 2 }}>
                Validation Successful! Total Rows to Create:{" "}
                <strong>{totalRows.toLocaleString()}</strong>
                {totalRows > 2000 && " (Preview limited to first 2000)"}
              </Alert>
              {!isCsvFile && (
                <Button
                  variant="outlined"
                  startIcon={<FileDownloadIcon />}
                  onClick={() => handleDownloadFile("SUCCESS")}
                >
                  Download CSV
                </Button>
              )}
            </Stack>
            <TableContainer sx={tableContainerStyle}>
              <Table stickyHeader size="small">
                <TableHead sx={tableHeaderStyle}>
                  <TableRow>
                    <TableCell sx={tableHeaderCellStyle} align="center">
                      Branch
                    </TableCell>
                    <TableCell sx={tableHeaderCellStyle} align="center">
                      Currency
                    </TableCell>
                    <TableCell sx={tableHeaderCellStyle} align="center">
                      CGL
                    </TableCell>
                    <TableCell sx={tableHeaderCellStyle} align="right">
                      Amount
                    </TableCell>
                    <TableCell sx={tableHeaderCellStyle} align="center">
                      Type
                    </TableCell>
                    <TableCell sx={tableHeaderCellStyle} align="center">
                      Remarks
                    </TableCell>
                    <TableCell sx={tableHeaderCellStyle} align="center">
                      Product
                    </TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {visibleRows.map((row, index) => (
                    <TableRow key={index} hover>
                      <TableCell align="center">{row.branch}</TableCell>
                      <TableCell align="center">{row.currency}</TableCell>
                      <TableCell align="center">{row.cgl}</TableCell>
                      <TableCell align="right">{row.amount}</TableCell>
                      <TableCell align="center">
                        <Chip
                          label={row.txnType}
                          color={
                            row.txnType.includes("Credit") ? "error" : "success"
                          }
                          size="small"
                          variant="filled"
                        />
                      </TableCell>
                      <TableCell align="center">{row.remarks}</TableCell>
                      <TableCell align="center">
                        {row.productCode || "-"}
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
            <TablePagination
              rowsPerPageOptions={[50, 100, 200]}
              component="div"
              count={previewRows.length}
              rowsPerPage={rowsPerPage}
              page={page}
              onPageChange={handleChangePage}
              onRowsPerPageChange={handleChangeRowsPerPage}
              labelDisplayedRows={({ from, to, count }) =>
                `${from}-${to} of Preview`
              }
            />
            <Stack direction="row" sx={actionButtonsContainer}>
              <Button
                variant="outlined"
                onClick={handleBack}
                disabled={isCreatingBatch}
                startIcon={<ArrowBackIcon />}
              >
                Back
              </Button>
              <Button
                variant="text"
                onClick={resetAll}
                disabled={isCreatingBatch}
                startIcon={<RestartAltIcon />}
              >
                Cancel
              </Button>
              <Button
                variant="contained"
                color="success"
                size="large"
                onClick={handleCreateBatch}
                disabled={isCreatingBatch}
                startIcon={
                  isCreatingBatch ? (
                    <CircularProgress size={20} color="inherit" />
                  ) : (
                    <SendIcon />
                  )
                }
              >
                {isCreatingBatch ? "Creating Batch..." : "Submit Batch"}
              </Button>
            </Stack>
          </Box>
        )}
      </Paper>
    </Box>
  );
};
export default JournalBulkUpload;


import React, { useState, useEffect, useCallback, useRef } from "react";
import {
  Box,
  Typography,
  Chip,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  TextField,
  Button,
  CircularProgress,
  Tooltip,
  IconButton,
  Stack,
  Grid,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Checkbox,
  TablePagination,
} from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import {
  Check as CheckIcon,
  Clear as ClearIcon,
  Visibility as VisibilityIcon,
  Close as CloseIcon,
} from "@mui/icons-material";
import AccountCircleIcon from "@mui/icons-material/AccountCircle";
import InfoIcon from "@mui/icons-material/Info";
import { alpha } from "@mui/material/styles";
import useApi from "../../hooks/useApi";
import useCustomSnackbar from "../../utils/useCustomSnackbar";

const styles = {
  mainContainer: {
    padding: 3,
    height: "100%",
    width: "100%",
    backgroundColor: "background.default",
  },
  dataGridContainer: {
    height: 600,
    width: "100%",
    backgroundColor: "background.paper",
    boxShadow: 2,
    borderRadius: 2,
    border: 1,
    borderColor: "divider",
    "& .MuiDataGrid-columnHeaders": {
      backgroundColor: (theme) => alpha(theme.palette.primary.main, 0.08),
      fontWeight: "bold",
      fontSize: "0.95rem",
    },
    "& .MuiDataGrid-row:hover": {
      backgroundColor: (theme) => alpha(theme.palette.primary.main, 0.04),
    },
  },
  tableContainer: { height: 450, border: 1, borderColor: "divider", mt: 1 },
  fixedContentBox: {
    height: 500,
    display: "flex",
    flexDirection: "column",
    justifyContent: "space-between",
  },
  tableHeaderCell: {
    fontWeight: "bold",
    backgroundColor: (theme) => alpha(theme.palette.primary.main, 0.08),
    whiteSpace: "nowrap",
    zIndex: 10,
  },
  stickyHeaderColumn: (leftOffset) => ({
    position: "sticky",
    left: leftOffset,
    top: 0,
    zIndex: 20,
    backgroundColor: "background.paper",
    borderBottom: 1,
    borderRight: 1,
    borderColor: "divider",
    fontWeight: "bold",
  }),
  stickyBodyColumn: (leftOffset) => ({
    position: "sticky",
    left: leftOffset,
    zIndex: 5,
    backgroundColor: "background.paper",
    borderRight: 1,
    borderColor: "divider",
  }),
  dialogTitle: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    pb: 1,
  },
  dialogActions: { p: 2, borderTop: 1, borderColor: "divider" },
  loadingContainer: {
    height: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
  },
};
const formatCurrency = (num) => Number(num).toFixed(4);
const getTxnTypeColor = (txnType) =>
  txnType === "Credit" ? "error" : "success";
function CustomNoRowsOverlay() {
  return (
    <Stack height="100%" alignItems="center" justifyContent="center">
      {" "}
      <InfoIcon sx={{ fontSize: 48, color: "text.secondary", mb: 2 }} />{" "}
      <Typography variant="h6">No Pending Requests</Typography>{" "}
    </Stack>
  );
}

export default function JournalRequestApproval() {
  const { callApi } = useApi();
  const showSnackBar = useCustomSnackbar();
  const isMounted = useRef(true);
  const [currentUserId, setCurrentUserId] = useState(null);
  const [loading, setLoading] = useState(true);
  const [rows, setRows] = useState([]);

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [selectedBatch, setSelectedBatch] = useState(null);
  const [modalMode, setModalMode] = useState("ACCEPTED");
  const [executorRemarks, setExecutorRemarks] = useState("");

  const [isViewModalOpen, setIsViewModalOpen] = useState(false);
  const [batchDetails, setBatchDetails] = useState([]);
  const [detailLoading, setDetailLoading] = useState(false);
  const [viewingBatchId, setViewingBatchId] = useState(null);
  const [viewingBatchCreatorId, setViewingBatchCreatorId] = useState(null);
  const [detailPage, setDetailPage] = useState(0);
  const [detailRowsPerPage, setDetailRowsPerPage] = useState(10);
  const [detailTotalCount, setDetailTotalCount] = useState(0);
  const [selectedJournalPrefixes, setSelectedJournalPrefixes] = useState([]);
  const [partialExecutorRemarks, setPartialExecutorRemarks] = useState("");
  const [isPartialSubmitting, setIsPartialSubmitting] = useState(false);

  useEffect(() => {
    isMounted.current = true;
    try {
      const auth =
        sessionStorage.getItem("persist:auth") ||
        localStorage.getItem("persist:auth");
      if (auth) {
        const user = JSON.parse(JSON.parse(auth).user);
        if (user?.userId) setCurrentUserId(String(user.userId));
      }
    } catch (e) { }
    return () => {
      isMounted.current = false;
    };
  }, []);

  const isViewingSelfCreated =
    currentUserId &&
    viewingBatchCreatorId &&
    String(currentUserId).trim().toUpperCase() ===
    String(viewingBatchCreatorId).trim().toUpperCase();

  const fetchPendingBatches = useCallback(async () => {
    setLoading(true);
    try {
      const data = await callApi(
        "/JS/journals/pending-requests-summary",
        null,
        "GET"
      );
      if (isMounted.current) setRows(Array.isArray(data) ? data : []);
    } catch (err) {
      if (isMounted.current && err.name !== "CanceledError")
        showSnackBar("Failed to load requests", "error");
    } finally {
      if (isMounted.current) setLoading(false);
    }
  }, [callApi, showSnackBar]);

  useEffect(() => {
    fetchPendingBatches();
  }, [fetchPendingBatches]);

  const fetchBatchDetailsPaginated = async (batchId, page, size) => {
    setDetailLoading(true);
    try {
      const res = await callApi(
        `/JS/journals/by-batch-paginated/${batchId}?page=${page}&size=${size}`,
        null,
        "GET"
      );
      if (res && res.content && isMounted.current) {
        setDetailTotalCount(res.totalElements);
        const journalGroups = new Map();
        res.content.forEach((req) => {
          try {
            const payload = JSON.parse(req.payload);
            const prefix = req.journalId.split("-")[0];
            const amount = parseFloat(payload.amount) || 0;
            const row = {
              ...req,
              payload,
              journalPrefix: prefix,
              amount: Math.abs(amount),
              transactionType: amount < 0 ? "Credit" : "Debit",
            };
            if (!journalGroups.has(prefix)) journalGroups.set(prefix, []);
            journalGroups.get(prefix).push(row);
          } catch (e) { }
        });
        setBatchDetails(Array.from(journalGroups.values()));
      }
    } catch (e) {
      if (isMounted.current) showSnackBar("Failed to load details", "error");
    } finally {
      if (isMounted.current) setDetailLoading(false);
    }
  };

  const handleOpenViewModal = (batchId, creatorId) => {
    setViewingBatchId(batchId);
    setViewingBatchCreatorId(String(creatorId));
    setDetailPage(0);
    setDetailRowsPerPage(10);
    setSelectedJournalPrefixes([]);
    setIsViewModalOpen(true);
    fetchBatchDetailsPaginated(batchId, 0, 10);
  };
  const handleDetailPageChange = (event, newPage) => {
    setDetailPage(newPage);
    fetchBatchDetailsPaginated(viewingBatchId, newPage, detailRowsPerPage);
  };
  const handleDetailRowsPerPageChange = (event) => {
    const newSize = parseInt(event.target.value, 10);
    setDetailRowsPerPage(newSize);
    setDetailPage(0);
    fetchBatchDetailsPaginated(viewingBatchId, 0, newSize);
  };
  const handleCloseViewModal = () => {
    setIsViewModalOpen(false);
    setBatchDetails([]);
    setViewingBatchId(null);
    setViewingBatchCreatorId(null);
    setSelectedJournalPrefixes([]);
    setIsPartialSubmitting(false);
    fetchPendingBatches();
  };

  const handleOpenModal = (batch, mode) => {
    setSelectedBatch(batch);
    setModalMode(mode);
    setExecutorRemarks("");
    setIsModalOpen(true);
  };
  const handleCloseModal = () => {
    if (isSubmitting) return;
    setIsModalOpen(false);
    setSelectedBatch(null);
  };

  const handleSubmitAction = async () => {
    if (modalMode === "REJECTED" && !executorRemarks.trim()) {
      showSnackBar("Remarks required.", "warning");
      return;
    }
    setIsSubmitting(true);
    try {
      await callApi(
        "/JS/journals/process-bulk",
        {
          batchId: selectedBatch.batchId,
          status: modalMode,
          remarks:
            executorRemarks.trim() ||
            (modalMode === "ACCEPTED" ? "Accepted" : "Rejected"),
        },
        "POST"
      );
      // --- FIX: Dynamic Message ---
      showSnackBar(
        modalMode === "ACCEPTED"
          ? "Request Accepted Successfully"
          : "Request Rejected Successfully",
        "success"
      );
      handleCloseModal();
      fetchPendingBatches();
    } catch (e) {
      showSnackBar("Failed to process", "error");
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleSubmitPartialAction = async (mode) => {
    if (mode === "REJECTED" && !partialExecutorRemarks.trim()) {
      showSnackBar("Remarks required.", "warning");
      return;
    }
    if (selectedJournalPrefixes.length === 0) {
      showSnackBar("Select at least one.", "warning");
      return;
    }
    setIsPartialSubmitting(true);
    try {
      await callApi(
        "/JS/journals/process-bulk",
        {
          journalIdPrefixes: selectedJournalPrefixes,
          status: mode,
          remarks:
            partialExecutorRemarks.trim() ||
            (mode === "ACCEPTED" ? "Accepted" : "Rejected"),
        },
        "POST"
      );
      showSnackBar(
        mode === "ACCEPTED"
          ? "Selected Entries Accepted Successfully"
          : "Selected Entries Rejected Successfully",
        "success"
      );
      handleCloseViewModal();
    } catch (e) {
      showSnackBar("Failed", "error");
      setIsPartialSubmitting(false);
    }
  };

  const handleSelectAllClick = (event) => {
    if (event.target.checked)
      setSelectedJournalPrefixes(batchDetails.map((g) => g[0].journalPrefix));
    else setSelectedJournalPrefixes([]);
  };
  const handleRowCheckboxClick = (event, prefix) => {
    if (event) event.stopPropagation();
    const index = selectedJournalPrefixes.indexOf(prefix);
    let newSelected = [];
    if (index === -1) newSelected = [...selectedJournalPrefixes, prefix];
    else newSelected = selectedJournalPrefixes.filter((p) => p !== prefix);
    setSelectedJournalPrefixes(newSelected);
  };

  const columns = [
    {
      field: "batchId",
      headerName: "Batch ID",
      width: 125,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
    },
    {
      field: "requestStatus",
      headerName: "Status",
      width: 125,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (p) => (
        <Chip label={p.value} color="warning" size="small" variant="outlined" />
      ),
    },
    {
      field: "creatorId",
      headerName: "Creator",
      width: 150,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (p) => (
        <Chip icon={<AccountCircleIcon />} label={p.value} size="small" />
      ),
    },
    {
      field: "requestDate",
      headerName: "Submitted On",
      width: 200,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (p) =>
        new Date(p.value).toLocaleString("en-IN", {
          dateStyle: "medium",
          timeStyle: "short",
        }),
    },
    {
      field: "commonBatchRemarks",
      headerName: "Creator Remarks",
      width: 200,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
    },
    {
      field: "requestCount",
      headerName: "Entries",
      width: 100,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
    },
    {
      field: "totalDebit",
      headerName: "Total Debit",
      width: 150,
      align: "right",
      headerAlign: "right",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (p) => (
        <Typography variant="body2" sx={{ mt: 1.5, fontWeight: 500 }}>
          {formatCurrency(p.value)}
        </Typography>
      ),
    },
    {
      field: "totalCredit",
      headerName: "Total Credit",
      width: 150,
      align: "right",
      headerAlign: "right",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (p) => (
        <Typography variant="body2" sx={{ mt: 1.5, fontWeight: 500 }}>
          {formatCurrency(p.value)}
        </Typography>
      ),
    },
    {
      field: "actions",
      headerName: "Actions",
      flex: 0.8,
      minWidth: 150,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (params) => {
        const isSelf =
          currentUserId &&
          params.row.creatorId &&
          String(currentUserId).trim().toUpperCase() ===
          String(params.row.creatorId).trim().toUpperCase();
        return (
          <Stack direction="row" spacing={1} justifyContent="center">
            {" "}
            <Tooltip title="View">
              {" "}
              <IconButton
                onClick={() =>
                  handleOpenViewModal(params.row.batchId, params.row.creatorId)
                }
                color="primary"
              >
                <VisibilityIcon />
              </IconButton>{" "}
            </Tooltip>{" "}
            <Tooltip title={isSelf ? "Self-approval disabled" : "Accept"}>
              {" "}
              <span>
                {" "}
                <IconButton
                  onClick={() => handleOpenModal(params.row, "ACCEPTED")}
                  color="success"
                  disabled={isSelf}
                >
                  <CheckIcon />
                </IconButton>{" "}
              </span>{" "}
            </Tooltip>{" "}
            <Tooltip title={isSelf ? "Self-rejection disabled" : "Reject"}>
              {" "}
              <span>
                {" "}
                <IconButton
                  onClick={() => handleOpenModal(params.row, "REJECTED")}
                  color="error"
                  disabled={isSelf}
                >
                  <ClearIcon />
                </IconButton>{" "}
              </span>{" "}
            </Tooltip>{" "}
          </Stack>
        );
      },
    },
  ];

  return (
    <Box sx={styles.mainContainer}>
      <DataGrid
        rows={rows}
        columns={columns}
        loading={loading}
        getRowId={(row) => row.batchId}
        disableRowSelectionOnClick
        pageSizeOptions={[5, 10, 25]}
        disableColumnResize
        rowHeight={52}
        initialState={{
          pagination: { paginationModel: { page: 0, pageSize: 10 } },
        }}
        slots={{ noRowsOverlay: CustomNoRowsOverlay }}
        sx={styles.dataGridContainer}
      />
      <Dialog
        open={isModalOpen}
        onClose={handleCloseModal}
        fullWidth
        maxWidth="sm"
      >
        {" "}
        <DialogTitle>
          {modalMode === "ACCEPTED" ? "Approve" : "Reject"} Batch
        </DialogTitle>{" "}
        <DialogContent>
          {" "}
          <DialogContentText>
            Confirm {modalMode.toLowerCase()} for batch{" "}
            <strong>{selectedBatch?.batchId}</strong>?
          </DialogContentText>{" "}
          <TextField
            autoFocus={modalMode === "REJECTED"}
            required={modalMode === "REJECTED"}
            margin="dense"
            label="Remarks"
            fullWidth
            variant="standard"
            value={executorRemarks}
            onChange={(e) => setExecutorRemarks(e.target.value)}
            disabled={isSubmitting}
          />{" "}
        </DialogContent>{" "}
        <DialogActions sx={styles.dialogActions}>
          {" "}
          <Button onClick={handleCloseModal} disabled={isSubmitting}>
            Cancel
          </Button>{" "}
          <Button
            onClick={handleSubmitAction}
            variant="contained"
            color={modalMode === "ACCEPTED" ? "success" : "error"}
            disabled={isSubmitting}
          >
            {isSubmitting ? <CircularProgress size={24} /> : "Confirm"}
          </Button>{" "}
        </DialogActions>{" "}
      </Dialog>
      <Dialog
        open={isViewModalOpen}
        onClose={handleCloseViewModal}
        fullWidth
        maxWidth="lg"
      >
        {" "}
        <DialogTitle sx={styles.dialogTitle}>
          {" "}
          <Typography variant="h6">
            Batch Details: {viewingBatchId}
          </Typography>{" "}
          <IconButton onClick={handleCloseViewModal}>
            <CloseIcon />
          </IconButton>{" "}
        </DialogTitle>{" "}
        <DialogContent dividers sx={{ p: 0 }}>
          {" "}
          <Box sx={styles.fixedContentBox}>
            {" "}
            {detailLoading ? (
              <Box sx={styles.loadingContainer}>
                <CircularProgress />
              </Box>
            ) : batchDetails.length > 0 ? (
              <>
                {" "}
                <TableContainer component={Paper} sx={styles.tableContainer}>
                  {" "}
                  <Table sx={{ minWidth: 650 }} size="small" stickyHeader>
                    {" "}
                    <TableHead>
                      {" "}
                      <TableRow>
                        {" "}
                        <TableCell
                          padding="checkbox"
                          sx={styles.stickyHeaderColumn(0)}
                        >
                          <Checkbox
                            color="primary"
                            indeterminate={
                              selectedJournalPrefixes.length > 0 &&
                              selectedJournalPrefixes.length <
                              batchDetails.length
                            }
                            checked={
                              batchDetails.length > 0 &&
                              selectedJournalPrefixes.length ===
                              batchDetails.length
                            }
                            onChange={handleSelectAllClick}
                            disabled={!isViewingSelfCreated}
                          />
                        </TableCell>{" "}
                        <TableCell
                          align="center"
                          sx={styles.stickyHeaderColumn(48)}
                        >
                          Journal ID
                        </TableCell>{" "}
                        <TableCell align="center" sx={styles.tableHeaderCell}>
                          Branch
                        </TableCell>{" "}
                        <TableCell align="center" sx={styles.tableHeaderCell}>
                          Currency
                        </TableCell>{" "}
                        <TableCell align="center" sx={styles.tableHeaderCell}>
                          CGL
                        </TableCell>{" "}
                        <TableCell align="center" sx={styles.tableHeaderCell}>
                          Amount
                        </TableCell>{" "}
                        <TableCell align="center" sx={styles.tableHeaderCell}>
                          Type
                        </TableCell>{" "}
                      </TableRow>{" "}
                    </TableHead>{" "}
                    <TableBody>
                      {" "}
                      {batchDetails.map((group, groupIndex) => {
                        const isSelected = selectedJournalPrefixes.includes(
                          group[0].journalPrefix
                        );
                        return group.map((row, rowIndex) => (
                          <TableRow
                            key={row.id}
                            hover={isViewingSelfCreated}
                            onClick={() =>
                              isViewingSelfCreated &&
                              handleRowCheckboxClick(null, row.journalPrefix)
                            }
                            selected={isSelected}
                            sx={{
                              cursor: isViewingSelfCreated
                                ? "not-allowed"
                                : "pointer",
                              ...(rowIndex === 0 &&
                                groupIndex > 0 && {
                                borderTop: 1,
                                borderColor: "divider",
                              }),
                            }}
                          >
                            {" "}
                            {rowIndex === 0 && (
                              <>
                                <TableCell
                                  padding="checkbox"
                                  rowSpan={group.length}
                                  sx={styles.stickyBodyColumn(0)}
                                >
                                  <Checkbox
                                    color="primary"
                                    checked={isSelected}
                                    disabled={!isViewingSelfCreated}
                                    onClick={(e) =>
                                      handleRowCheckboxClick(
                                        e,
                                        row.journalPrefix
                                      )
                                    }
                                  />{" "}
                                </TableCell>{" "}
                                <TableCell
                                  align="center"
                                  rowSpan={group.length}
                                  sx={styles.stickyBodyColumn(48)}
                                >
                                  {row.journalPrefix}
                                </TableCell>
                              </>
                            )}{" "}
                            <TableCell align="center">
                              {row.payload.branch}
                            </TableCell>
                            <TableCell align="center">
                              {row.payload.currency}
                            </TableCell>
                            <TableCell align="center">
                              {row.payload.cgl}
                            </TableCell>
                            <TableCell align="center">
                              {formatCurrency(row.amount)}
                            </TableCell>
                            <TableCell align="center">
                              <Chip
                                label={row.transactionType}
                                color={getTxnTypeColor(row.transactionType)}
                                size="small"
                              />
                            </TableCell>{" "}
                          </TableRow>
                        ));
                      })}{" "}
                    </TableBody>{" "}
                  </Table>{" "}
                </TableContainer>{" "}
                <TablePagination
                  component="div"
                  count={detailTotalCount}
                  page={detailPage}
                  onPageChange={handleDetailPageChange}
                  rowsPerPage={detailRowsPerPage}
                  onRowsPerPageChange={handleDetailRowsPerPageChange}
                  rowsPerPageOptions={[10, 25, 50]}
                />{" "}
              </>
            ) : (
              <Typography sx={{ p: 3 }}>No details.</Typography>
            )}{" "}
          </Box>{" "}
        </DialogContent>{" "}
        <DialogActions sx={styles.dialogActions}>
          {" "}
          <Grid container spacing={2} alignItems="center">
            {" "}
            <Grid item xs={12} md={6}>
              <TextField
                margin="dense"
                label="Remarks (Selected)"
                fullWidth
                size="small"
                value={partialExecutorRemarks}
                onChange={(e) => setPartialExecutorRemarks(e.target.value)}
                disabled={
                  isPartialSubmitting ||
                  selectedJournalPrefixes.length === 0 ||
                  isViewingSelfCreated
                }
              />
            </Grid>{" "}
            <Grid item xs={12} md={6}>
              <Stack direction="row" spacing={1} justifyContent="flex-end">
                <Button
                  variant="contained"
                  color="success"
                  onClick={() => handleSubmitPartialAction("ACCEPTED")}
                  disabled={
                    isPartialSubmitting ||
                    selectedJournalPrefixes.length === 0 ||
                    isViewingSelfCreated
                  }
                >
                  Accept
                </Button>
                <Button
                  variant="contained"
                  color="error"
                  onClick={() => handleSubmitPartialAction("REJECTED")}
                  disabled={
                    isPartialSubmitting ||
                    selectedJournalPrefixes.length === 0 ||
                    isViewingSelfCreated
                  }
                >
                  Reject
                </Button>
              </Stack>
            </Grid>{" "}
          </Grid>{" "}
        </DialogActions>{" "}
      </Dialog>
    </Box>
  );
}
import React, { useState, useEffect, useCallback, useRef } from "react";
import {
  Box,
  Typography,
  Chip,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  Button,
  CircularProgress,
  Tooltip,
  IconButton,
  Stack,
  Grid,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Checkbox,
  TablePagination,
} from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import {
  DeleteSweep as DeleteSweepIcon,
  Visibility as VisibilityIcon,
  Close as CloseIcon,
} from "@mui/icons-material";
import AccountCircleIcon from "@mui/icons-material/AccountCircle";
import InfoIcon from "@mui/icons-material/Info";
import DeleteIcon from "@mui/icons-material/Delete";
import { alpha } from "@mui/material/styles";
import useApi from "../../hooks/useApi";
import useCustomSnackbar from "../../utils/useCustomSnackbar";

const styles = {
  mainContainer: {
    padding: 3,
    height: "100%",
    width: "100%",
    backgroundColor: "background.default",
  },
  dataGridContainer: {
    height: 600,
    width: "100%",
    backgroundColor: "background.paper",
    boxShadow: 2,
    borderRadius: 2,
    border: 1,
    borderColor: "divider",
    "& .MuiDataGrid-columnHeaders": {
      backgroundColor: (theme) => alpha(theme.palette.primary.main, 0.08),
      fontWeight: "bold",
      fontSize: "0.95rem",
    },
    "& .MuiDataGrid-row:hover": {
      backgroundColor: (theme) => alpha(theme.palette.primary.main, 0.04),
    },
  },
  tableContainer: { maxHeight: 500, border: 1, borderColor: "divider", mt: 1 },
  fixedContentBox: {
    height: 500,
    display: "flex",
    flexDirection: "column",
    justifyContent: "space-between",
  },
  tableHeaderCell: {
    fontWeight: "bold",
    backgroundColor: (theme) => alpha(theme.palette.primary.main, 0.08),
    whiteSpace: "nowrap",
    zIndex: 10,
  },
  stickyHeaderColumn: (leftOffset) => ({
    position: "sticky",
    left: leftOffset,
    top: 0,
    zIndex: 20,
    backgroundColor: "background.paper",
    borderBottom: 1,
    borderRight: 1,
    borderColor: "divider",
    fontWeight: "bold",
  }),
  stickyBodyColumn: (leftOffset) => ({
    position: "sticky",
    left: leftOffset,
    zIndex: 5,
    backgroundColor: "background.paper",
    borderRight: 1,
    borderColor: "divider",
  }),
  dialogTitle: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    pb: 1,
  },
  dialogActions: { p: 2, borderTop: 1, borderColor: "divider" },
  loadingContainer: {
    height: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
  },
};
const formatCurrency = (num) => Number(num).toFixed(4);
const getStatusChipColor = (status) => {
  switch (status) {
    case "ACCEPTED":
      return "success";
    case "REJECTED":
      return "error";
    default:
      return "warning";
  }
};
const getTxnTypeColor = (txnType) =>
  txnType === "Credit" ? "error" : "success";
function CustomNoRowsOverlay() {
  return (
    <Stack height="100%" alignItems="center" justifyContent="center">
      {" "}
      <InfoIcon sx={{ fontSize: 48, color: "text.secondary", mb: 2 }} />{" "}
      <Typography variant="h6">No Requests Found</Typography>{" "}
    </Stack>
  );
}

export default function JournalPostingStatus() {
  const { callApi } = useApi();
  const showSnackBar = useCustomSnackbar();
  const isMounted = useRef(true);
  const [currentUserId, setCurrentUserId] = useState(null);
  const [loading, setLoading] = useState(true);
  const [rows, setRows] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [selectedBatch, setSelectedBatch] = useState(null);

  // View/Paginate States
  const [isViewModalOpen, setIsViewModalOpen] = useState(false);
  const [batchDetails, setBatchDetails] = useState([]);
  const [detailLoading, setDetailLoading] = useState(false);
  const [viewingBatchId, setViewingBatchId] = useState(null);
  const [viewingBatchStatus, setViewingBatchStatus] = useState(null);
  const [detailPage, setDetailPage] = useState(0);
  const [detailRowsPerPage, setDetailRowsPerPage] = useState(10);
  const [detailTotalCount, setDetailTotalCount] = useState(0);
  const [selectedJournalPrefixes, setSelectedJournalPrefixes] = useState([]);
  const [isPartialSubmitting, setIsPartialSubmitting] = useState(false);

  // --- SAFE AUTH CHECK ---
  useEffect(() => {
    isMounted.current = true;
    try {
      const auth =
        sessionStorage.getItem("persist:auth") ||
        localStorage.getItem("persist:auth");
      if (auth) {
        const user = JSON.parse(JSON.parse(auth).user);
        console.log(user);
        // Force string to ensure match
        if (user?.userId) setCurrentUserId(String(user.userId));
      }
    } catch (e) {}
    return () => {
      isMounted.current = false;
    };
  }, []);

  const fetchMyBatches = useCallback(async () => {
    setLoading(true);
    try {
      const data = await callApi(
        "/JS/journals/all-requests-summary",
        null,
        "GET"
      );
      if (isMounted.current) setRows(Array.isArray(data) ? data : []);
    } catch (err) {
      if (isMounted.current && err.name !== "CanceledError")
        showSnackBar("Failed to load requests", "error");
    } finally {
      if (isMounted.current) setLoading(false);
    }
  }, [callApi, showSnackBar]);

  useEffect(() => {
    fetchMyBatches();
  }, [fetchMyBatches]);

  const handleOpenModal = (batch) => {
    setSelectedBatch(batch);
    setIsModalOpen(true);
  };
  const handleCloseModal = () => {
    if (isSubmitting) return;
    setIsModalOpen(false);
    setSelectedBatch(null);
  };

  const handleSubmitBatchCancel = async () => {
    setIsSubmitting(true);
    try {
      await callApi(
        `/JS/journals/my-requests/by-batch/${selectedBatch.batchId}`,
        null,
        "DELETE"
      );
      showSnackBar(
        `Batch ${selectedBatch.batchId} deleted successfully.`,
        "success"
      );
      handleCloseModal();
      fetchMyBatches();
    } catch (error) {
      showSnackBar("Failed to delete batch", "error");
    } finally {
      setIsSubmitting(false);
    }
  };

  const fetchDetailRows = async (batchId, page, size) => {
    setDetailLoading(true);
    try {
      const res = await callApi(
        `/JS/journals/by-batch-paginated/${batchId}?page=${page}&size=${size}`,
        null,
        "GET"
      );
      if (res && res.content && isMounted.current) {
        setDetailTotalCount(res.totalElements);
        const journalGroups = new Map();
        res.content.forEach((req) => {
          try {
            const payload = JSON.parse(req.payload);
            const prefix = req.journalId.split("-")[0];
            const amount = parseFloat(payload.amount) || 0;
            const row = {
              ...req,
              payload,
              journalPrefix: prefix,
              amount: Math.abs(amount),
              transactionType: amount < 0 ? "Credit" : "Debit",
            };
            if (!journalGroups.has(prefix)) journalGroups.set(prefix, []);
            journalGroups.get(prefix).push(row);
          } catch (e) {}
        });
        setBatchDetails(Array.from(journalGroups.values()));
      }
    } catch (e) {
      if (isMounted.current) showSnackBar("Failed to load details", "error");
    } finally {
      if (isMounted.current) setDetailLoading(false);
    }
  };

  const handleOpenViewModal = (batchId, status) => {
    setViewingBatchId(batchId);
    setViewingBatchStatus(status);
    setDetailPage(0);
    setDetailRowsPerPage(10);
    setSelectedJournalPrefixes([]);
    setIsViewModalOpen(true);
    fetchDetailRows(batchId, 0, 10);
  };
  const handleDetailPageChange = (event, newPage) => {
    setDetailPage(newPage);
    fetchDetailRows(viewingBatchId, newPage, detailRowsPerPage);
  };
  const handleDetailRowsPerPageChange = (event) => {
    const newSize = parseInt(event.target.value, 10);
    setDetailRowsPerPage(newSize);
    setDetailPage(0);
    fetchDetailRows(viewingBatchId, 0, newSize);
  };
  const handleCloseViewModal = () => {
    setIsViewModalOpen(false);
    setBatchDetails([]);
    setViewingBatchId(null);
    setSelectedJournalPrefixes([]);
    setIsPartialSubmitting(false);
    setViewingBatchStatus(null);
    fetchMyBatches();
  };

  const handleCancelSelectedJournals = async () => {
    if (selectedJournalPrefixes.length === 0) {
      showSnackBar("Select at least one entry.", "warning");
      return;
    }
    setIsPartialSubmitting(true);
    try {
      await callApi(
        "/JS/journals/my-requests/by-journal-list",
        selectedJournalPrefixes,
        "DELETE"
      );
      showSnackBar("Selected entries deleted successfully.", "success");
      handleCloseViewModal();
    } catch (error) {
      showSnackBar("Failed to delete selection", "error");
      setIsPartialSubmitting(false);
    }
  };

  const handleSelectAllClick = (event) => {
    if (event.target.checked)
      setSelectedJournalPrefixes(batchDetails.map((g) => g[0].journalPrefix));
    else setSelectedJournalPrefixes([]);
  };
  const handleRowCheckboxClick = (event, prefix) => {
    if (event) event.stopPropagation();
    const index = selectedJournalPrefixes.indexOf(prefix);
    let newSelected = [];
    if (index === -1) newSelected = [...selectedJournalPrefixes, prefix];
    else newSelected = selectedJournalPrefixes.filter((p) => p !== prefix);
    setSelectedJournalPrefixes(newSelected);
  };

  const columns = [
    {
      field: "batchId",
      headerName: "Batch ID",
      width: 125,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
    },
    {
      field: "requestStatus",
      headerName: "Status",
      width: 125,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (p) => (
        <Chip
          label={p.value}
          color={getStatusChipColor(p.value)}
          size="small"
          variant="outlined"
        />
      ),
    },
    {
      field: "creatorId",
      headerName: "Creator",
      width: 150,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (p) => (
        <Chip icon={<AccountCircleIcon />} label={p.value} size="small" />
      ),
    },
    {
      field: "requestDate",
      headerName: "Submitted On",
      width: 200,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (p) =>
        new Date(p.value).toLocaleString("en-IN", {
          dateStyle: "medium",
          timeStyle: "short",
        }),
    },
    {
      field: "commonBatchRemarks",
      headerName: "Creator Remarks",
      width: 200,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
    },
    {
      field: "requestCount",
      headerName: "Entries",
      width: 100,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
    },
    {
      field: "totalDebit",
      headerName: "Total Debit",
      width: 150,
      align: "right",
      headerAlign: "right",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (p) => (
        <Typography variant="body2" sx={{ mt: 1.5, fontWeight: 500 }}>
          {formatCurrency(p.value)}
        </Typography>
      ),
    },
    {
      field: "totalCredit",
      headerName: "Total Credit",
      width: 150,
      align: "right",
      headerAlign: "right",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (p) => (
        <Typography variant="body2" sx={{ mt: 1.5, fontWeight: 500 }}>
          {formatCurrency(p.value)}
        </Typography>
      ),
    },
    {
      field: "actions",
      headerName: "Actions",
      flex: 0.8,
      minWidth: 130,
      align: "center",
      headerAlign: "center",
      disableColumnMenu: true,
      sortable: false,
      renderCell: (params) => {
        // --- LOGIC: ENABLE DELETE ---
        // 1. Is it Pending?
        const isPending =
          String(params.row.requestStatus).toUpperCase() === "PENDING";
        // 2. Did *I* create it? 
        const creator = String(params.row.creatorId || "")
          .trim()
          .toUpperCase();
          console.log("d"+creator);
        const me = String(currentUserId || "")
          .trim()
          .toUpperCase();
        const isMyBatch = creator === me;

        const canDelete = isPending && isMyBatch;

        return (
          <Stack direction="row" spacing={1} justifyContent="center">
            <Tooltip title="View Details">
              {" "}
              <IconButton
                onClick={() =>
                  handleOpenViewModal(
                    params.row.batchId,
                    params.row.requestStatus
                  )
                }
                color="primary"
              >
                {" "}
                <VisibilityIcon />{" "}
              </IconButton>{" "}
            </Tooltip>
            <Tooltip
              title={
                !isMyBatch
                  ? "You cannot delete other users' requests"
                  : !isPending
                  ? "Cannot delete processed batch"
                  : "Delete Batch"
              }
            >
              <span>
                {" "}
                <IconButton
                  onClick={() => handleOpenModal(params.row)}
                  color="error"
                  disabled={!canDelete}
                >
                  {" "}
                  <DeleteIcon />{" "}
                </IconButton>{" "}
              </span>
            </Tooltip>
          </Stack>
        );
      },
    },
  ];

  return (
    <Box sx={styles.mainContainer}>
      <DataGrid
        rows={rows}
        columns={columns}
        loading={loading}
        getRowId={(row) => row.batchId}
        disableRowSelectionOnClick
        pageSizeOptions={[5, 10, 25]}
        disableColumnResize
        rowHeight={52}
        initialState={{
          pagination: { paginationModel: { page: 0, pageSize: 10 } },
        }}
        slots={{ noRowsOverlay: CustomNoRowsOverlay }}
        sx={styles.dataGridContainer}
      />
      <Dialog
        open={isModalOpen}
        onClose={handleCloseModal}
        fullWidth
        maxWidth="sm"
      >
        {" "}
        <DialogTitle sx={{ display: "flex", alignItems: "center" }}>
          {" "}
          <DeleteSweepIcon sx={{ mr: 1, color: "error.main" }} /> Confirm
          Deletion{" "}
        </DialogTitle>{" "}
        <DialogContent>
          {" "}
          <DialogContentText>
            {" "}
            Are you sure you want to delete batch{" "}
            <strong>{selectedBatch?.batchId}</strong>? This action cannot be
            undone.{" "}
          </DialogContentText>{" "}
        </DialogContent>{" "}
        <DialogActions sx={styles.dialogActions}>
          {" "}
          <Button onClick={handleCloseModal} disabled={isSubmitting}>
            Back
          </Button>{" "}
          <Button
            onClick={handleSubmitBatchCancel}
            variant="contained"
            color="error"
            disabled={isSubmitting}
          >
            {" "}
            {isSubmitting ? (
              <CircularProgress size={24} color="inherit" />
            ) : (
              "Confirm Delete"
            )}{" "}
          </Button>{" "}
        </DialogActions>{" "}
      </Dialog>

      {/* PAGINATED DETAILS */}
      <Dialog
        open={isViewModalOpen}
        onClose={handleCloseViewModal}
        fullWidth
        maxWidth="lg"
      >
        {" "}
        <DialogTitle sx={styles.dialogTitle}>
          {" "}
          <Typography variant="h6">
            Batch Details: {viewingBatchId}
          </Typography>{" "}
          <IconButton onClick={handleCloseViewModal}>
            <CloseIcon />
          </IconButton>{" "}
        </DialogTitle>{" "}
        <DialogContent dividers sx={{ p: 0 }}>
          {" "}
          <Box sx={styles.fixedContentBox}>
            {" "}
            {detailLoading ? (
              <Box sx={styles.loadingContainer}>
                <CircularProgress />
              </Box>
            ) : batchDetails.length > 0 ? (
              <>
                {" "}
                <TableContainer component={Paper} sx={styles.tableContainer}>
                  {" "}
                  <Table sx={{ minWidth: 650 }} size="small" stickyHeader>
                    {" "}
                    <TableHead>
                      {" "}
                      <TableRow>
                        {" "}
                        {viewingBatchStatus === "PENDING" && (
                          <TableCell
                            padding="checkbox"
                            sx={styles.stickyHeaderColumn(0)}
                          >
                            <Checkbox
                              color="primary"
                              indeterminate={
                                selectedJournalPrefixes.length > 0 &&
                                selectedJournalPrefixes.length <
                                  batchDetails.length
                              }
                              checked={
                                batchDetails.length > 0 &&
                                selectedJournalPrefixes.length ===
                                  batchDetails.length
                              }
                              onChange={handleSelectAllClick}
                            />
                          </TableCell>
                        )}{" "}
                        <TableCell
                          align="center"
                          sx={styles.stickyHeaderColumn(
                            viewingBatchStatus === "PENDING" ? 48 : 0
                          )}
                        >
                          Journal ID
                        </TableCell>{" "}
                        <TableCell align="center" sx={styles.tableHeaderCell}>
                          Status
                        </TableCell>{" "}
                        <TableCell align="center" sx={styles.tableHeaderCell}>
                          Branch
                        </TableCell>{" "}
                        <TableCell align="center" sx={styles.tableHeaderCell}>
                          Currency
                        </TableCell>{" "}
                        <TableCell align="center" sx={styles.tableHeaderCell}>
                          CGL
                        </TableCell>{" "}
                        <TableCell align="center" sx={styles.tableHeaderCell}>
                          Amount
                        </TableCell>{" "}
                        <TableCell align="center" sx={styles.tableHeaderCell}>
                          Type
                        </TableCell>{" "}
                      </TableRow>{" "}
                    </TableHead>{" "}
                    <TableBody>
                      {" "}
                      {batchDetails.map((group, groupIndex) => {
                        const isSelected = selectedJournalPrefixes.includes(
                          group[0].journalPrefix
                        );
                        return group.map((row, rowIndex) => (
                          <TableRow
                            key={row.id}
                            hover={viewingBatchStatus === "PENDING"}
                            onClick={() =>
                              viewingBatchStatus === "PENDING" &&
                              handleRowCheckboxClick(null, row.journalPrefix)
                            }
                            selected={
                              viewingBatchStatus === "PENDING" && isSelected
                            }
                            sx={{
                              cursor:
                                viewingBatchStatus === "PENDING"
                                  ? "pointer"
                                  : "default",
                              ...(rowIndex === 0 &&
                                groupIndex > 0 && {
                                  borderTop: 1,
                                  borderColor: "divider",
                                }),
                            }}
                          >
                            {" "}
                            {viewingBatchStatus === "PENDING" &&
                              rowIndex === 0 && (
                                <TableCell
                                  padding="checkbox"
                                  rowSpan={group.length}
                                  sx={styles.stickyBodyColumn(0)}
                                >
                                  {" "}
                                  <Checkbox
                                    color="primary"
                                    checked={isSelected}
                                    onClick={(e) =>
                                      handleRowCheckboxClick(
                                        e,
                                        row.journalPrefix
                                      )
                                    }
                                  />{" "}
                                </TableCell>
                              )}{" "}
                            {rowIndex === 0 && (
                              <TableCell
                                align="center"
                                rowSpan={group.length}
                                sx={styles.stickyBodyColumn(
                                  viewingBatchStatus === "PENDING" ? 48 : 0
                                )}
                              >
                                {" "}
                                {row.journalPrefix}{" "}
                              </TableCell>
                            )}{" "}
                            {rowIndex === 0 && (
                              <TableCell
                                align="center"
                                rowSpan={group.length}
                                sx={{
                                  ...styles.stickyBodyColumn(
                                    viewingBatchStatus === "PENDING" ? 150 : 100
                                  ),
                                  zIndex: 4,
                                }}
                              >
                                {" "}
                                <Chip
                                  label={row.requestStatus}
                                  color={getStatusChipColor(row.requestStatus)}
                                  size="small"
                                />{" "}
                              </TableCell>
                            )}{" "}
                            <TableCell align="center">
                              {row.payload.branch}
                            </TableCell>
                            <TableCell align="center">
                              {row.payload.currency}
                            </TableCell>
                            <TableCell align="center">
                              {row.payload.cgl}
                            </TableCell>
                            <TableCell align="center">
                              {formatCurrency(row.amount)}
                            </TableCell>
                            <TableCell align="center">
                              <Chip
                                label={row.transactionType}
                                color={getTxnTypeColor(row.transactionType)}
                                size="small"
                              />
                            </TableCell>{" "}
                          </TableRow>
                        ));
                      })}{" "}
                    </TableBody>{" "}
                  </Table>{" "}
                </TableContainer>{" "}
                <TablePagination
                  component="div"
                  count={detailTotalCount}
                  page={detailPage}
                  onPageChange={handleDetailPageChange}
                  rowsPerPage={detailRowsPerPage}
                  onRowsPerPageChange={handleDetailRowsPerPageChange}
                  rowsPerPageOptions={[10, 25, 50]}
                />{" "}
              </>
            ) : (
              <Typography sx={{ p: 3 }}>No details.</Typography>
            )}{" "}
          </Box>{" "}
        </DialogContent>{" "}
        <DialogActions sx={styles.dialogActions}>
          {" "}
          {viewingBatchStatus === "PENDING" && (
            <Button
              variant="contained"
              color="error"
              onClick={handleCancelSelectedJournals}
              disabled={
                isPartialSubmitting || selectedJournalPrefixes.length === 0
              }
            >
              {" "}
              Delete Selected{" "}
            </Button>
          )}{" "}
        </DialogActions>{" "}
      </Dialog>
    </Box>
  );
}


import React, { useState, useEffect, useCallback } from "react";
import {
  Box,
  Typography,
  Grid,
  TextField,
  Button,
  Paper,
  IconButton,
  MenuItem,
  CircularProgress,
  Autocomplete,
  Tooltip,
  Checkbox,
  FormControlLabel,
  Chip // Added Chip for Memo UI
} from "@mui/material";
import AddIcon from "@mui/icons-material/Add";
import DeleteIcon from "@mui/icons-material/Delete";
import { debounce } from "lodash";

import useApi from "../../hooks/useApi";
import useCustomSnackbar from "../../utils/useCustomSnackbar";

const initialRowState = {
  id: Date.now(),
  branch: null,
  currency: "",
  cgl: null,
  amount: "",
  txnType: "",
  remarks: "",
  productCode: "",
};

const formatBigIntForDisplay = (val) => {
  if (typeof val !== "bigint") {
    val = BigInt(val || 0);
  }
  const str = val.toString().padStart(5, "0");
  const integer = str.slice(0, -4);
  const fractional = str.slice(-4);
  return `${integer || "0"}.${fractional}`;
};

export default function JournalPosting() {
  const { callApi } = useApi();
  const showSnackBar = useCustomSnackbar();

  const [rows, setRows] = useState([initialRowState]);
  const [currencyOptions, setCurrencyOptions] = useState([]);

  const [isSubmitting, setIsSubmitting] = useState(false);

  const [commonBatchRemarks, setCommonBatchRemarks] = useState("");
  const [postingDate, setPostingDate] = useState("");

  // Checkbox
  const [checked, setChecked] = useState(false);

  const [branchSearch, setBranchSearch] = useState({
    loading: false,
    options: [],
  });
  const [cglSearch, setCglSearch] = useState({ loading: false, options: [] });

  useEffect(() => {
    const fetchInitialData = async () => {
      try {
        const dateResponse = await callApi(
          "/JS/journals/current-posting-date",
          null,
          "GET"
        );

        if (dateResponse) {
          try {
            const [year, month, day] = dateResponse.split("-");
            const formattedDate = `${day}-${month}-${year}`;
            setPostingDate(formattedDate);
          } catch (e) {
            console.error("Could not parse date:", dateResponse, e);
            setPostingDate(dateResponse);
          }
        } else {
          showSnackBar("Failed to load official posting date.", "error");
          setPostingDate("Error");
        }

        const currencyResponse = await callApi("/CM/currency", null, "GET");
        if (currencyResponse?.success && Array.isArray(currencyResponse.data)) {
          const uniqueCurrencies = [...new Set(currencyResponse.data)];
          setCurrencyOptions(uniqueCurrencies);
        } else {
          showSnackBar("Failed to load currencies.", "error");
        }
      } catch (error) {
        console.error("Error fetching initial data:", error);
        showSnackBar("An error occurred while loading page data.", "error");
      }
    };

    fetchInitialData();
  }, [callApi, showSnackBar]);

  const handleAddRow = () => {
    const lastRow = rows[rows.length - 1];

    if (
      !lastRow.branch ||
      !lastRow.currency ||
      !lastRow.cgl ||
      !lastRow.amount ||
      !lastRow.txnType
    ) {
      showSnackBar(
        "Please fill all required fields (*) in the current row before adding a new one.",
        "warning"
      );
      return;
    }

    const newRow = {
      ...initialRowState,
      id: Date.now(),
      remarks: checked ? commonBatchRemarks : "",
    };
    setRows([...rows, newRow]);
  };
  const handleChange = (event) => {
    const isChecked = event.target.checked;
    setChecked(isChecked);

    if (isChecked) {
      const newRows = rows.map((row) => ({
        ...row,
        remarks: commonBatchRemarks,
      }));
      setRows(newRows);
    } else {
      const newRows = rows.map((row) => ({
        ...row,
        remarks: "",
      }));
      setRows(newRows);
    }
  };

  const handleDeleteRow = (id) => {
    if (rows.length > 1) {
      setRows(rows.filter((row) => row.id !== id));
    } else {
      showSnackBar("Cannot delete the last row.", "warning");
    }
  };

  const handleRowChange = (id, field, value) => {
    const newRows = rows.map((row) => {
      if (row.id === id) {
        return { ...row, [field]: value };
      }
      return row;
    });
    setRows(newRows);
  };

  const searchBranches = useCallback(
    debounce(async (query) => {
      if (!query) {
        setBranchSearch({ loading: false, options: [] });
        return;
      }
      setBranchSearch((prev) => ({ ...prev, loading: true }));
      try {
        const response = await callApi(
          `/JS/branches-journal/search?query=${encodeURIComponent(query)}`,
          null,
          "GET"
        );

        setBranchSearch({ loading: false, options: response || [] });
      } catch (error) {
        showSnackBar("Branch search failed.", "error");
        setBranchSearch({ loading: false, options: [] });
      }
    }, 300),
    [callApi, showSnackBar]
  );

  const searchCgls = useCallback(
    debounce(async (query) => {
      if (!query) {
        setCglSearch({ loading: false, options: [] });
        return;
      }
      setCglSearch((prev) => ({ ...prev, loading: true }));
      try { 
        const response = await callApi(
          `/JS/cgl-journal/search?query=${encodeURIComponent(query)}`,
          null,
          "GET"
        );


        setCglSearch({ loading: false, options: response || [] });
      } catch (error) {
        showSnackBar("CGL search failed.", "error");
        setCglSearch({ loading: false, options: [] });
      }
    }, 300),
    [callApi, showSnackBar]
  );

  const handleSubmit = async () => {
    setIsSubmitting(true);

    if (!commonBatchRemarks.trim()) {
      showSnackBar(
        "Please enter Common Batch Remarks before submitting.",
        "error"
      );
      setIsSubmitting(false);
      return;
    }

    const cglCheck = new Map();
    for (const row of rows) {
      if (!row.branch || !row.currency || !row.cgl) {
        continue;
      }
      const key = `${row.branch.code}-${row.currency}`;
      const cgl = row.cgl.cglNumber;

      if (!cglCheck.has(key)) {
        cglCheck.set(key, new Set());
      }

      const cglSet = cglCheck.get(key);
      if (cglSet.has(cgl)) {
        showSnackBar(
          `Duplicate CGL entry: "${cgl}" is used more than once for branch "${row.branch.name}" and currency "${row.currency}".`,
          "error"
        );
        setIsSubmitting(false);
        return;
      }
      cglSet.add(cgl);
    }

    // --- MEMO LOGIC UPDATE START ---
    const branchCurrencyTotals = new Map();
    const branchEntryCheck = new Map();
    const rowPayloads = [];

    for (const [index, row] of rows.entries()) {
      if (
        !row.branch ||
        !row.currency ||
        !row.cgl ||
        !row.amount ||
        !row.txnType
      ) {
        showSnackBar(
          `Row ${index + 1} is incomplete. Please fill all required fields.`,
          "error"
        );
        setIsSubmitting(false);
        return;
      }

      const branchCode = row.branch.code;
      const branchName = row.branch.name;
      const currency = row.currency;

      // Identify Memo vs Normal
      const cglNumber = String(row.cgl.cglNumber);
      const isMemo = cglNumber.startsWith("5");
      const type = isMemo ? "MEMO" : "NORMAL";

      const [integerPart = "0", fractionalPart = "0"] = (
        row.amount || "0"
      ).split(".");
      const fractionalPadded = fractionalPart.substring(0, 4).padEnd(4, "0");
      const amountAsBigInt = BigInt(integerPart + fractionalPadded);

      // Composite key now includes Type (Memo/Normal)
      const compositeKey = `${branchCode}-${currency}-${type}`;

      if (!branchCurrencyTotals.has(compositeKey)) {
        branchCurrencyTotals.set(compositeKey, {
          totalDebit: 0n,
          totalCredit: 0n,
          branchName: branchName,
          branchCode: branchCode,
          currency: currency,
          type: type, // Store type for validation message
        });
      }
      const currencyTotals = branchCurrencyTotals.get(compositeKey);

      if (row.txnType === "Debit") {
        currencyTotals.totalDebit += amountAsBigInt;
      } else if (row.txnType === "Credit") {
        currencyTotals.totalCredit += amountAsBigInt;
      }

      if (!branchEntryCheck.has(branchCode)) {
        branchEntryCheck.set(branchCode, {
          hasDebit: false,
          hasCredit: false,
          branchName: branchName,
        });
      }
      const branchCheck = branchEntryCheck.get(branchCode);

      if (row.txnType === "Debit" && amountAsBigInt > 0n) {
        branchCheck.hasDebit = true;
      } else if (row.txnType === "Credit" && amountAsBigInt > 0n) {
        branchCheck.hasCredit = true;
      }

      const finalAmount =
        row.txnType === "Credit" ? "-" + row.amount : row.amount;

      rowPayloads.push({
        changeType: "ADD",
        branch: row.branch.code,
        currency: row.currency,
        cgl: row.cgl.cglNumber,
        amount: finalAmount,
        productType: row.productCode,
        remarks: row.remarks,
        arFlag: "A",
      });
    }

    for (const [branchCode, totals] of branchEntryCheck.entries()) {
      const { hasDebit, hasCredit, branchName } = totals;
      if (!hasDebit || !hasCredit) {
        showSnackBar(
          `Submission failed. Branch "${branchName}" (${branchCode}) must have at least one Debit and one Credit entry.`,
          "error"
        );
        setIsSubmitting(false);
        return;
      }
    }

    // Validate Totals (Bucket-wise: Branch + Currency + Type)
    for (const [compositeKey, totals] of branchCurrencyTotals.entries()) {
      const { totalDebit, totalCredit, branchName, branchCode, currency, type } =
        totals;

      if (totalDebit !== totalCredit) {
        showSnackBar(
          `Submission failed. Totals for ${type} entries in branch "${branchName}" (${branchCode}) and currency "${currency}" do not match. Debit: ${formatBigIntForDisplay(
            totalDebit
          )}, Credit: ${formatBigIntForDisplay(totalCredit)}`,
          "error"
        );
        setIsSubmitting(false);
        return;
      }
    }
    // --- MEMO LOGIC UPDATE END ---

    const finalPayload = {
      commonBatchRemarks: commonBatchRemarks.trim(),
      rows: rowPayloads,
    };

    try {
      const response = await callApi(
        "/JS/journals/create-batch",
        finalPayload,
        "POST"
      );

      const newBatchId = response?.[0]?.batchId || "N/A";

      showSnackBar(
        `All ${response.length} Journal entries submitted successfully! Batch ID: ${newBatchId}`,
        "success"
      );
      setRows([{ ...initialRowState, id: Date.now() }]);
      setCommonBatchRemarks("");
      setChecked(false);
    } catch (error) {
      showSnackBar("Journal Batch submission failed", "error");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Box sx={{ p: 3, maxWidth: "98%" }}>
      <Paper elevation={3} sx={{ p: 3 }}>
        <Box>
          <Box sx={{ display: "flex", alignItems: "center", gap: 0.5 }}>
            <Typography variant="body1" fontWeight="bold" component="span">
              Posting Date:
            </Typography>
            <Typography variant="body1" fontWeight="bold" component="span">
              {postingDate}
            </Typography>
          </Box>
          <Box sx={{ marginTop: 0.5 }}>
            <Typography
              variant="body2"
              component="span"
              sx={{ color: "#ec0101ff" }}
            >
              Note: All Journals will be Posted on this Date
            </Typography>
          </Box>
        </Box>

        <Grid item xs={12} md={12} sx={{ margin: "1% 0%", width: "95%" }}>
          <TextField
            label="Common Batch Remarks"
            value={commonBatchRemarks}
            onChange={(e) => {
              const newValue = e.target.value;
              if (newValue.length <= 50) {
                setCommonBatchRemarks(newValue);

                if (checked && newValue.trim()) {
                  setRows(
                    rows.map((row) => ({
                      ...row,
                      remarks: newValue,
                    }))
                  );
                }

                if (!newValue.trim()) {
                  setChecked(false);
                  setRows(
                    rows.map((row) => ({
                      ...row,
                      remarks: "",
                    }))
                  );
                }
              }
            }}
            fullWidth
            required
            multiline
            rows={1}
            InputProps={{
              inputProps: {
                maxLength: 50,
              },
            }}
          />
          <Box sx={{ display: "flex", alignItems: "center" }}>
            <FormControlLabel
              control={
                <Checkbox
                  checked={checked}
                  onChange={handleChange}
                  color="primary"
                  disabled={!commonBatchRemarks.trim()}
                />
              }
              label="Apply This Remark To All Below Transaction"
            />
          </Box>
        </Grid>

        <Box>
          {rows.map((row, index) => (
            <React.Fragment key={row.id}>
              <Grid container spacing={2} alignItems="center">
                {/* Branch */}
                <Grid item xs={12} md={3} size={1.8}>
                  <Autocomplete
                    popupIcon={null}
                    autoHighlight
                    options={branchSearch.options}
                    getOptionLabel={(option) =>
                      `${option.code} - ${option.name}`
                    }
                    value={row.branch}
                    onChange={(event, newValue) =>
                      handleRowChange(row.id, "branch", newValue)
                    }
                    onInputChange={(event, newInputValue) =>
                      searchBranches(newInputValue)
                    }
                    loading={branchSearch.loading}
                    filterOptions={(x) => x}
                    isOptionEqualToValue={(option, value) =>
                      option.code === value.code
                    }
                    noOptionsText=""
                    renderInput={(params) => (
                      <Tooltip
                        title="Search by Branch name or Branch code"
                        placement="top-start"
                      >
                        <TextField
                          {...params}
                          label="Branch *"
                          placeholder="Search by name or code"
                          InputLabelProps={{ shrink: true }}
                          InputProps={{
                            ...params.InputProps,
                            endAdornment: (
                              <Box>
                                {branchSearch.loading ? (
                                  <CircularProgress color="inherit" size={20} />
                                ) : null}
                                {params.InputProps.endAdornment}
                              </Box>
                            ),
                          }}
                        />
                      </Tooltip>
                    )}
                  />
                </Grid>

                {/* Currency */}
                <Grid item xs={12} md={1.5} size={1.5}>
                  <TextField
                    popupIcon={null}
                    select
                    label="Currency *"
                    value={row.currency}
                    onChange={(e) =>
                      handleRowChange(row.id, "currency", e.target.value)
                    }
                    fullWidth
                  >
                    <MenuItem value="" disabled>
                      <em>Select Currency</em>
                    </MenuItem>
                    {currencyOptions.map((c) => (
                      <MenuItem key={c} value={c}>
                        {c}
                      </MenuItem>
                    ))}
                  </TextField>
                </Grid>

                {/* CGL */}
                <Grid item xs={12} md={2} size={1.8}>
                  <Autocomplete
                    popupIcon={null}
                    autoHighlight
                    options={cglSearch.options}
                    getOptionLabel={(option) =>
                      `${option.cglNumber} - ${option.description}`
                    }
                    value={row.cgl}
                    onChange={(event, newValue) =>
                      handleRowChange(row.id, "cgl", newValue)
                    }
                    onInputChange={(event, newInputValue) =>
                      searchCgls(newInputValue)
                    }
                    loading={cglSearch.loading}
                    filterOptions={(x) => x}
                    isOptionEqualToValue={(option, value) =>
                      option.cglNumber === value.cglNumber
                    }
                    noOptionsText=""
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        label="CGL *"
                        placeholder="Search CGL by number or name"
                        InputLabelProps={{ shrink: true }}
                        InputProps={{
                          ...params.InputProps,
                          endAdornment: (
                            <Box sx={{ marginLeft: "2%", display: "flex", alignItems: "center" }}>
                                {/* UI UPDATE: Added Chip for Memo Indication */}
                              {row.cgl && String(row.cgl.cglNumber).startsWith("5") && (
                                <Chip label="MEMO" size="small" color="warning" sx={{ height: 20, fontSize: "0.7rem", mr: 1 }} />
                              )}
                              {cglSearch.loading ? (
                                <CircularProgress color="inherit" size={20} />
                              ) : null}
                              {params.InputProps.endAdornment}
                            </Box>
                          ),
                        }}
                      />
                    )}
                  />
                </Grid>

                {/* Amount */}
                <Grid item xs={12} md={2} size={1.5}>
                  <TextField
                    label="Amount *"
                    type="text"
                    value={row.amount}
                    onChange={(e) => {
                      const val = e.target.value;
                      if (/^\d{0,21}(\.\d{0,4})?$/.test(val)) {
                        handleRowChange(row.id, "amount", val);
                      }
                    }}
                    fullWidth
                    placeholder="0.0000"
                  />
                </Grid>

                {/* Txn Type */}
                <Grid item xs={12} md={1} size={1.3}>
                  <TextField
                    select
                    label="Txn Type *"
                    value={row.txnType}
                    onChange={(e) =>
                      handleRowChange(row.id, "txnType", e.target.value)
                    }
                    fullWidth
                  >
                    <MenuItem value="" disabled>
                      <em>Select Type</em>
                    </MenuItem>
                    <MenuItem value="Debit">Debit</MenuItem>
                    <MenuItem value="Credit">Credit</MenuItem>
                  </TextField>
                </Grid>

                {/* Product Code */}
                <Grid item xs={12} md={2} size={1.5}>
                  <TextField
                    label="Product Code"
                    value={row.productCode}
                    onChange={(e) => {
                      const val = e.target.value;
                      if (/^\d{0,8}$/.test(val)) {
                        handleRowChange(row.id, "productCode", val);
                      }
                    }}
                    fullWidth
                    InputProps={{
                      inputProps: {
                        maxLength: 8,
                      },
                    }}
                  />
                </Grid>

                {/* Remarks (Individual) */}
                <Grid item xs={12} md={2} size={2}>
                  <TextField
                    label="Remarks"
                    value={row.remarks}
                    onChange={(e) => {
                      const val = e.target.value;

                      if (val.length <= 50) {
                        handleRowChange(row.id, "remarks", val);
                      }
                    }}
                    fullWidth
                    InputProps={{
                      inputProps: {
                        maxLength: 50,
                      },
                      readOnly: checked,
                    }}
                  />
                </Grid>

                {/* Actions */}
                <Grid item xs={12} md={0.5} sx={{ textAlign: "center" }}>
                  <IconButton
                    onClick={() => handleDeleteRow(row.id)}
                    aria-label="delete row"
                  >
                    <DeleteIcon />
                  </IconButton>
                </Grid>
              </Grid>

              {index < rows.length - 1 && (
                <Box
                  sx={{
                    borderBottom: 1,
                    borderColor: "divider",
                    my: 2,
                  }}
                />
              )}
            </React.Fragment>
          ))}

          <Box sx={{ mt: 3, display: "flex", gap: 2, justifyContent: "right" }}>
            <Button
              variant="contained"
              startIcon={<AddIcon />}
              onClick={handleAddRow}
            >
              Add Row
            </Button>

            <Button
              variant="contained"
              color="success"
              onClick={handleSubmit}
              disabled={isSubmitting}
            >
              {isSubmitting ? <CircularProgress size={24} /> : "Submit"}
            </Button>
          </Box>
        </Box>
      </Paper>
    </Box>
  );
}


