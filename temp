package com.tcs.fincore.CommonRequestService.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.NotificationTable;
import com.tcs.fincore.CommonRequestService.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import java.time.Instant;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationWriterService {

    private final NotificationRepository notificationRepository;
    private final ObjectMapper objectMapper;

    /**
     * GENERIC METHOD: Can be used for 1-to-1 (userId provided) or 1-to-Many (targetRole provided).
     */
    @SneakyThrows
    public void createNotification(String userId, String targetRole, String message, String linkUrl, String aggregateId, String eventSource) {
        
        NotificationTable notification = NotificationTable.builder()
                .eventId(java.util.UUID.randomUUID()) // Generate UUID here
                .userId(userId)          // Can be null if targetRole is set
                .targetRole(targetRole)  // Can be null if userId is set
                .message(message)
                .linkUrl(linkUrl)
                .aggregateId(aggregateId)
                .eventSource(eventSource)
                .build();

        notificationRepository.save(notification);
        log.info("Outbox: Written notification for AggregateID: {}", aggregateId);
    }

    // ... Keep your existing helper methods (createRequestApprovedNotification, etc.) if you want, 
    // or replace them with calls to the generic method above.
    
    @SneakyThrows
    public void createRequestApprovedNotification(CommonReq request, String approverId) {
        createNotification(
            request.getCreatorId(), 
            null, 
            "Your request " + request.getTargetId() + " was Approved", 
            "/my-requests", // Or specific link
            request.getId().toString(), 
            "CommonRequestService"
        );
    }

    @SneakyThrows
    public void createRequestRejectedNotification(CommonReq request, String rejectorId, String reason) {
        createNotification(
            request.getCreatorId(), 
            null, 
            "Your request " + request.getTargetId() + " was Rejected: " + reason, 
            "/my-requests", 
            request.getId().toString(), 
            "CommonRequestService"
        );
    }
}










package com.tcs.fincore.CommonRequestService.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.dto.CreateRequestDto;
import com.tcs.fincore.CommonRequestService.dto.NotificationConfigDto;
import com.tcs.fincore.CommonRequestService.dto.ProcessRequestDto;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;
import com.tcs.fincore.CommonRequestService.exception.ResourceNotFoundException;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.RequestStatus;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.CommonRequestRepository;
import com.tcs.fincore.CommonRequestService.service.strategy.RequestStrategyFactory;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
public class RequestServiceImpl implements RequestService {

    private final CommonRequestRepository commonRequestRepository;
    private final RequestStrategyFactory strategyFactory;
    private final ObjectMapper objectMapper;
    private final NotificationWriterService notificationWriterService;
    private final PermissionConfigService permissionConfigService; // Caching Service

    @Override
    @Transactional
    public CommonReq createRequest(CreateRequestDto dto, String creatorId) throws JsonProcessingException {
        // ... (Your existing create logic) ...
        
        // Validation & Save
        KeyablePayload payload = (KeyablePayload) dto.getPayload();
        String targetId = payload.getKey();
        // ... uniqueness checks ...
        
        CommonReq request = new CommonReq();
        request.setCreatorId(creatorId);
        request.setReqType(dto.getRequestType());
        request.setChangeType(dto.getChangeType());
        request.setPayload(objectMapper.writeValueAsString(payload));
        request.setTargetId(targetId);
        request.setReqStatus(RequestStatus.PENDING);
        
        CommonReq savedRequest = commonRequestRepository.save(request);

        // --- NOTIFICATION: NEW PENDING REQUEST ---
        try {
            // 1. Fetch Config (Cached - Fast)
            NotificationConfigDto config = permissionConfigService.getConfig(dto.getRequestType().name());

            // 2. Send to Group (1-to-Many)
            notificationWriterService.createNotification(
                null,                       
                config.getTargetRoles(),    
                "New " + dto.getChangeType() + " request (" + targetId + ") pending approval",
                config.getTargetUrl(),      
                savedRequest.getId().toString(),
                "CommonRequestService"
            );
        } catch (Exception e) {
            log.error("Failed to send creation notification", e);
        }

        return savedRequest;
    }

    @Override
    @Transactional(rollbackOn = RuntimeException.class)
    public Optional<CommonReq> updateRequestStatus(ProcessRequestDto dto, String executorId) throws JsonProcessingException {
        Long requestId = dto.getRequestId();
        log.info("Processing request ID: {} by executor: {}", requestId, executorId);

        CommonReq request = commonRequestRepository.findById(requestId)
                .orElseThrow(() -> new ResourceNotFoundException("Request not found."));

        // 1. Validation
        if (executorId.equals(request.getCreatorId())) {
            throw new IllegalStateException("User cannot approve or reject their own request.");
        }
        if (request.getReqStatus() != RequestStatus.PENDING) {
            throw new IllegalStateException("Request has already been processed.");
        }

        // 2. Update Entity
        request.setExecutorId(executorId);
        request.setExecutorRemarks(dto.getRemarks());
        request.setExecutionDate(LocalDateTime.now());
        request.setReqStatus(dto.getStatus());

        // 3. Execute Strategy (Business Logic)
        if (RequestStatus.ACCEPTED.equals(dto.getStatus())) {
            strategyFactory.getStrategy(request.getReqType()).processApproval(request);
            request.setExecutionRemarks("Success");
            
            // Notify Maker: Approved
            notificationWriterService.createRequestApprovedNotification(request, executorId);
        } else {
            request.setExecutionRemarks("Rejected");
            
            // Notify Maker: Rejected
            notificationWriterService.createRequestRejectedNotification(request, executorId, dto.getRemarks());
        }

        // 4. CLOSURE NOTIFICATION (To the Group)
        // We wrap this in Try/Catch because if this fails, we do NOT want to rollback the actual Approval.
        // The approval is critical data; the "FYI" notification to the group is secondary.
        try {
            // A. Get Group Config from Cache (Zero DB Cost)
            NotificationConfigDto config = permissionConfigService.getConfig(request.getReqType().name());
            
            // B. Prepare Message
            String action = dto.getStatus().equals(RequestStatus.ACCEPTED) ? "Approved" : "Rejected";
            String closureMessage = "Request " + request.getTargetId() + " was " + action + " by " + executorId;

            // C. Send to Group (1-to-Many)
            notificationWriterService.createNotification(
                null,                       // userId null -> Targeting Group
                config.getTargetRoles(),    // The same roles that received the Pending alert
                closureMessage,
                config.getTargetUrl(),      // Link to history
                request.getId().toString(),
                "CommonRequestService"
            );
            log.info("Sent closure notification to group for Request ID: {}", requestId);

        } catch (Exception e) {
            // Log error but allow transaction to commit
            log.error("Failed to send closure notification for Request ID: {}", requestId, e);
        }

        return Optional.of(commonRequestRepository.save(request));
    }

    // ... other getters ...
    @Override
    public List<CommonReq> getMyRequests(String userId, RequestType requestType) {
        if (requestType == null) throw new IllegalArgumentException("Request type is missing.");
        return commonRequestRepository.findByCreatorIdAndReqType(userId, requestType);
    }

    @Override
    public List<CommonReq> getPendingRequests(RequestType requestType) {
        if (requestType == null) throw new IllegalArgumentException("Request type is missing.");
        return commonRequestRepository.findByReqStatusAndReqType(RequestStatus.PENDING, requestType);
    }

    @Override
    public List<CommonReq> getAllRequests() {
        return commonRequestRepository.findAll();
    }
}


