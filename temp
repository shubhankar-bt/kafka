package com.tcs.dashboard.model;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Immutable;

import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;

// --- 1. CONFIG & PERMISSIONS ---

@Entity
@Data
@Immutable
@Table(name = "ANNOUNCEMENTS")
public class Announcement {
    @Id
    @Column(name = "ID")
    private Long id;
    @Column(name = "TITLE")
    private String title;
    @Column(name = "MESSAGE")
    private String message;
    @Column(name = "SEVERITY")
    private String severity; // INFO, WARN, CRITICAL
    @Column(name = "TARGET_ROLE")
    private String targetRole; // 'ALL' or '51', etc.
    @Column(name = "START_DATE")
    private Timestamp startDate;
    @Column(name = "EXPIRY_DATE")
    private Timestamp expiryDate;
    @Column(name = "IS_ACTIVE")
    private String isActive; // 'Y' or 'N'
    @Column(name = "CREATED_AT")
    private Timestamp createdAt;
}

@Entity
@Data
@Immutable
@Table(name = "PERMISSIONS")
public class Permission {
    @Id
    @Column(name = "MENU_ID")
    private Integer menuId;
    @Column(name = "MAPPED_REQUEST_TYPE")
    private String mappedRequestType; // E.g., 'JOURNAL_AUTH', 'CGL_CODE'
    @Column(name = "MENU_ACTION")
    private String menuAction; // E.g., 'view|approve|reject'
}

@Entity
@Data
@Immutable
@Table(name = "ROLE_PERMISSIONS")
public class RolePermission {
    @EmbeddedId
    private RolePermissionId id;

    @Embeddable
    @Data
    public static class RolePermissionId implements java.io.Serializable {
        @Column(name = "ROLE_ID")
        private int roleId;
        @Column(name = "PERMISSION_ID")
        private int permissionId;
    }
}

// --- 2. LOGS & AUDIT ---

@Entity
@Data
@Immutable
@Table(name = "USER_LOGS") // Corrected from AUDIT_LOG based on your input
public class UserLog {
    @Id
    @Column(name = "LOG_ID")
    private Long logId;
    @Column(name = "USER_ID")
    private String userId;
    @Column(name = "ACTION_TYPE")
    private String actionType;
    @Column(name = "ACTION_TIME")
    private Timestamp actionTime;
    @Column(name = "CHANGE_TYPE")
    private String changeType;
    @Column(name = "NEW_VALUE")
    private String newValue;
}

// --- 3. REQUEST TABLES (The sources of truth) ---

@Entity
@Data
@Immutable
@Table(name = "COMMON_REQ")
public class CommonReq {
    @Id
    @Column(name = "REQ_ID")
    private Long reqId;
    @Column(name = "REQ_TYPE")
    private String reqType; // SEGMENT_CODE, CGL_CODE, BRANCH, etc.
    @Column(name = "REQ_STATUS")
    private String reqStatus; // P, A, R
    @Column(name = "CREATOR_ID")
    private String creatorId;
    @Column(name = "REQ_DATE")
    private LocalDateTime reqDate;
    @Column(name = "EXECUTOR_ID")
    private String executorId;
    @Column(name = "EXECUTION_DATE")
    private LocalDateTime executionDate;
    @Column(name = "TARGET_ID")
    private String targetId;
}

@Entity
@Data
@Immutable
@Table(name = "USER_REQUESTS")
public class UserRequest {
    @Id
    @Column(name = "REQUEST_ID")
    private Long requestId;
    @Column(name = "REQUESTOR_USER_ID")
    private String requestorUserId;
    @Column(name = "REQUEST_STATUS")
    private String requestStatus; 
    @Column(name = "REQUEST_TYPE")
    private String requestType; // CREATE, MODIFY
    @Column(name = "TARGET_USER_ID")
    private String targetUserId;
    @Column(name = "REQUEST_DATE")
    private Timestamp requestDate;
    @Column(name = "APPROVER_USER_ID")
    private String approverUserId;
    @Column(name = "APPROVAL_DATE")
    private Timestamp approvalDate;
}

@Entity
@Data
@Immutable
@Table(name = "ROLE_REQUESTS")
public class RoleRequest {
    @Id
    @Column(name = "REQUEST_ID")
    private Long requestId;
    @Column(name = "REQUESTOR_USER_ID")
    private String requestorUserId;
    @Column(name = "REQUEST_STATUS")
    private String requestStatus;
    @Column(name = "REQUEST_DATE")
    private Timestamp requestDate;
    @Column(name = "APPROVER_USER_ID")
    private String approverUserId;
    @Column(name = "APPROVAL_DATE")
    private Timestamp approvalDate;
}

@Entity
@Data
@Immutable
@Table(name = "JOURNAL_REQUESTS") // Assuming table name based on context
public class JournalRequest {
    @Id
    @Column(name = "REQ_ID")
    private Long reqId;
    @Column(name = "REQ_STATUS")
    private String reqStatus; 
    @Column(name = "CHANGE_TYPE")
    private String changeType;
    @Column(name = "REQ_DATE")
    private LocalDateTime reqDate;
    @Column(name = "CREATOR_ID")
    private String creatorId;
    @Column(name = "EXECUTOR_ID")
    private String executorId;
    @Column(name = "EXECUTION_DATE")
    private LocalDateTime executionDate;
    @Column(name = "BATCH_ID")
    private String batchId;
    @Column(name = "JOURNAL_ID")
    private String journalId;
}












----



package com.tcs.dashboard.repository;

import com.tcs.dashboard.model.*;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface PermissionRepository extends JpaRepository<Permission, Integer> {
    
    // Find what this role can APPROVE (Checker Context)
    @Query(value = """
        SELECT DISTINCT p.MAPPED_REQUEST_TYPE 
        FROM PERMISSIONS p
        JOIN ROLE_PERMISSIONS rp ON p.MENU_ID = rp.PERMISSION_ID
        WHERE rp.ROLE_ID = :roleId
        AND (lower(p.MENU_ACTION) LIKE '%approve%' OR lower(p.MENU_ACTION) LIKE '%reject%')
        AND p.MAPPED_REQUEST_TYPE IS NOT NULL
    """, nativeQuery = true)
    List<String> findApprovalTypesForRole(@Param("roleId") int roleId);
}

@Repository
public interface AnnouncementRepository extends JpaRepository<Announcement, Long> {
    @Query("SELECT a FROM Announcement a WHERE a.isActive = 'Y' " +
           "AND :now BETWEEN a.startDate AND a.expiryDate " +
           "AND (a.targetRole = 'ALL' OR a.targetRole = :roleId) " +
           "ORDER BY a.createdAt DESC")
    List<Announcement> findActive(@Param("now") Timestamp now, @Param("roleId") String roleId);
}

@Repository
public interface UserLogRepository extends JpaRepository<UserLog, Long> {
    List<UserLog> findTop20ByUserIdOrderByActionTimeDesc(String userId);
    List<UserLog> findTop20ByOrderByActionTimeDesc();
}

@Repository
public interface CommonReqRepository extends JpaRepository<CommonReq, Long> {
    // Stats
    List<CommonReq> findByCreatorId(String creatorId); // My Requests
    @Query("SELECT c FROM CommonReq c WHERE c.reqStatus = 'PENDING' AND c.reqType IN :types")
    List<CommonReq> findPendingByTypes(@Param("types") List<String> types); // Waiting for Me

    // Logs
    List<CommonReq> findTop10ByCreatorIdOrderByReqDateDesc(String creatorId);
    List<CommonReq> findTop10ByExecutorIdOrderByExecutionDateDesc(String executorId);
}

@Repository
public interface JournalRequestRepository extends JpaRepository<JournalRequest, Long> {
    // Stats
    List<JournalRequest> findByCreatorId(String creatorId); // My Requests
    
    // Waiting for Me (If user has JOURNAL_AUTH permission)
    @Query("SELECT j FROM JournalRequest j WHERE j.reqStatus = 'PENDING'")
    List<JournalRequest> findAllPending(); 

    // Logs
    List<JournalRequest> findTop10ByCreatorIdOrderByReqDateDesc(String creatorId);
    List<JournalRequest> findTop10ByExecutorIdOrderByExecutionDateDesc(String executorId);
}

@Repository
public interface UserRequestRepository extends JpaRepository<UserRequest, Long> {
    List<UserRequest> findByRequestorUserId(String userId);
    @Query("SELECT u FROM UserRequest u WHERE u.requestStatus = 'PENDING'")
    List<UserRequest> findAllPending(); 
    
    // Logs
    List<UserRequest> findTop10ByRequestorUserIdOrderByRequestDateDesc(String userId);
    List<UserRequest> findTop10ByApproverUserIdOrderByApprovalDateDesc(String userId);
}

@Repository
public interface RoleRequestRepository extends JpaRepository<RoleRequest, Long> {
    List<RoleRequest> findByRequestorUserId(String userId);
    @Query("SELECT r FROM RoleRequest r WHERE r.requestStatus = 'PENDING'")
    List<RoleRequest> findAllPending();
    
    // Logs
    List<RoleRequest> findTop10ByRequestorUserIdOrderByRequestDateDesc(String userId);
    List<RoleRequest> findTop10ByApproverUserIdOrderByApprovalDateDesc(String userId);
}






--------


package com.tcs.dashboard.service;

import com.tcs.dashboard.dto.*;
import com.tcs.dashboard.model.*;
import com.tcs.dashboard.repository.*;
import com.fincore.commonutilities.jwt.JwtUtil; 
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class DashboardServiceImpl {

    private final PermissionRepository permissionRepo;
    private final AnnouncementRepository announcementRepo;
    private final UserLogRepository userLogRepo;
    
    private final CommonReqRepository commonReqRepo;
    private final UserRequestRepository userReqRepo;
    private final RoleRequestRepository roleReqRepo;
    private final JournalRequestRepository journalReqRepo;
    
    private final JwtUtil jwtUtil;

    @Transactional(readOnly = true)
    public DashboardResponse getDashboardData(String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        int roleIdInt = jwtUtil.getUserRoleFromToken(token);
        String roleIdStr = String.valueOf(roleIdInt);

        log.info("Generating dashboard for User: {}, Role: {}", userId, roleIdStr);

        DashboardResponse response = new DashboardResponse();

        // 1. ANNOUNCEMENTS (Role Aware)
        response.setAnnouncements(fetchAnnouncements(roleIdStr));

        // 2. PERMISSIONS (What can this user Approve?)
        List<String> approvalTypes = permissionRepo.findApprovalTypesForRole(roleIdInt);
        log.info("User has approval rights for: {}", approvalTypes);

        // 3. STATS (Two Buckets: "My Requests" vs "Waiting for Me")
        StatsDto stats = new StatsDto();
        
        // 3a. My Requests (Things I created)
        calculateMyRequestStats(stats, userId);
        
        // 3b. Action Items (Things waiting for my approval based on permissions)
        calculateActionStats(stats, approvalTypes);
        
        response.setStats(stats);

        // 4. ACTIVITY FEED (Unified Timeline)
        response.setRecentActivity(fetchUnifiedActivity(userId, approvalTypes.isEmpty()));

        return response;
    }

    // --- STATS LOGIC ---

    private void calculateMyRequestStats(StatsDto stats, String userId) {
        // Fetch
        List<CommonReq> myCrs = commonReqRepo.findByCreatorId(userId);
        List<JournalRequest> myJournal = journalReqRepo.findByCreatorId(userId);
        List<UserRequest> myUser = userReqRepo.findByRequestorUserId(userId);
        List<RoleRequest> myRole = roleReqRepo.findByRequestorUserId(userId);

        // Aggregate
        stats.setMyPending(
            count(myCrs, "PENDING", "P") + count(myJournal, "PENDING", "P") + 
            count(myUser, "PENDING") + count(myRole, "PENDING")
        );
        stats.setMyApproved(
            count(myCrs, "ACCEPTED", "A") + count(myJournal, "ACCEPTED", "A") + 
            count(myUser, "ACCEPTED") + count(myRole, "ACCEPTED")
        );
        stats.setMyRejected(
            count(myCrs, "REJECTED", "R") + count(myJournal, "REJECTED", "R") + 
            count(myUser, "REJECTED") + count(myRole, "REJECTED")
        );
    }

    private void calculateActionStats(StatsDto stats, List<String> approvalTypes) {
        if (approvalTypes.isEmpty()) {
            stats.setPendingForMe(0);
            return;
        }

        int count = 0;

        // CRS (Segment, CGL, Branch, etc)
        // If approvalTypes contains any CRS types, repo filters them
        List<CommonReq> crsPending = commonReqRepo.findPendingByTypes(approvalTypes);
        count += crsPending.size();

        // User Mgmt
        if (approvalTypes.contains("USER_MANAGEMENT")) {
            count += userReqRepo.findAllPending().size();
        }

        // Role Mgmt
        if (approvalTypes.contains("ROLE_MANAGEMENT")) {
            count += roleReqRepo.findAllPending().size();
        }

        // Journal
        if (approvalTypes.contains("JOURNAL_AUTH")) {
            count += journalReqRepo.findAllPending().size();
        }

        stats.setPendingForMe(count);
    }

    // --- ACTIVITY LOGIC (Merger) ---

    private List<ActivityLogDto> fetchUnifiedActivity(String userId, boolean isMakerOnly) {
        List<ActivityLogDto> timeline = new ArrayList<>();

        // 1. User Logs (Login, direct edits)
        List<UserLog> userLogs = userLogRepo.findTop20ByUserIdOrderByActionTimeDesc(userId);
        for (UserLog log : userLogs) {
            timeline.add(toActivity(log.getActionType(), log.getActionTime().getTime(), 
                "USER_LOG", log.getChangeType()));
        }

        // 2. CRS Activity (Virtual Logs)
        // Created by me
        for (CommonReq r : commonReqRepo.findTop10ByCreatorIdOrderByReqDateDesc(userId)) {
            timeline.add(toActivity("Raised Request", toMillis(r.getReqDate()), 
                r.getReqType(), r.getTargetId()));
        }
        // Executed by me (Approvals)
        for (CommonReq r : commonReqRepo.findTop10ByExecutorIdOrderByExecutionDateDesc(userId)) {
            if(r.getExecutionDate() != null)
                timeline.add(toActivity("Processed Request", toMillis(r.getExecutionDate()), 
                    r.getReqType(), "Status: " + r.getReqStatus()));
        }

        // 3. User/Role Request Activity
        for (UserRequest r : userReqRepo.findTop10ByRequestorUserIdOrderByRequestDateDesc(userId)) {
            timeline.add(toActivity("User Request", r.getRequestDate().getTime(), 
                r.getRequestType(), "Target: " + r.getTargetUserId()));
        }
        for (UserRequest r : userReqRepo.findTop10ByApproverUserIdOrderByApprovalDateDesc(userId)) {
            if(r.getApprovalDate() != null)
                timeline.add(toActivity("Approved User", r.getApprovalDate().getTime(), 
                    r.getRequestType(), "Target: " + r.getTargetUserId()));
        }

        // 4. Journal Activity
        for (JournalRequest j : journalReqRepo.findTop10ByCreatorIdOrderByReqDateDesc(userId)) {
            timeline.add(toActivity("Journal Entry", toMillis(j.getReqDate()), 
                "Journal", "Batch: " + j.getBatchId()));
        }
        for (JournalRequest j : journalReqRepo.findTop10ByExecutorIdOrderByExecutionDateDesc(userId)) {
            if(j.getExecutionDate() != null)
                timeline.add(toActivity("Journal Auth", toMillis(j.getExecutionDate()), 
                    "Journal", "Status: " + j.getReqStatus()));
        }

        // Sort Descending
        Collections.sort(timeline);
        
        return timeline.stream().limit(15).collect(Collectors.toList());
    }

    // --- HELPERS ---

    private List<AnnouncementDto> fetchAnnouncements(String roleId) {
        return announcementRepo.findActive(new Timestamp(System.currentTimeMillis()), roleId)
            .stream().map(a -> AnnouncementDto.builder()
                .id(a.getId())
                .title(a.getTitle())
                .message(a.getMessage())
                .severity(a.getSeverity())
                .date(a.getCreatedAt().toString())
                .build())
            .collect(Collectors.toList());
    }

    private ActivityLogDto toActivity(String action, long millis, String source, String details) {
        return ActivityLogDto.builder()
                .action(action)
                .timestamp(millis)
                .displayTime(new Timestamp(millis).toString())
                .source(source)
                .details(details)
                .build();
    }

    private long toMillis(LocalDateTime ldt) {
        if (ldt == null) return 0;
        return ldt.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
    }

    private <T> int count(List<T> list, String... statuses) {
        int c = 0;
        for (T item : list) {
            String s = "";
            if (item instanceof CommonReq) s = ((CommonReq) item).getReqStatus();
            if (item instanceof JournalRequest) s = ((JournalRequest) item).getReqStatus();
            if (item instanceof UserRequest) s = ((UserRequest) item).getRequestStatus();
            if (item instanceof RoleRequest) s = ((RoleRequest) item).getRequestStatus();
            
            for (String alias : statuses) {
                if (alias.equalsIgnoreCase(s)) { c++; break; }
            }
        }
        return c;
    }
}













package com.tcs.dashboard.controller;

import com.tcs.dashboard.dto.ApiResponse;
import com.tcs.dashboard.dto.DashboardResponse;
import com.tcs.dashboard.service.DashboardServiceImpl;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/dashboard")
@RequiredArgsConstructor
public class DashboardController {

    private final DashboardServiceImpl dashboardService;

    @GetMapping("/init")
    public ResponseEntity<ApiResponse<DashboardResponse>> getDashboard(
            @RequestHeader("Authorization") String token) {
        
        DashboardResponse data = dashboardService.getDashboardData(token);
        return ResponseEntity.ok(ApiResponse.success(data, "Dashboard loaded"));
    }
}

// ---------------- DTOs -----------------
package com.tcs.dashboard.dto;

import lombok.Builder;
import lombok.Data;
import java.util.List;

@Data
@Builder
public class DashboardResponse {
    private List<AnnouncementDto> announcements;
    private StatsDto stats;
    private List<ActivityLogDto> recentActivity;
}

@Data
public class StatsDto {
    // Things I Created
    private int myPending;
    private int myApproved;
    private int myRejected;
    
    // Things Waiting for My Action (Specific to Permissions)
    private int pendingForMe; 
}

@Data
@Builder
public class ActivityLogDto implements Comparable<ActivityLogDto> {
    private String action;
    private long timestamp; // For sorting
    private String displayTime;
    private String source; // e.g. "CGL_CODE" or "USER_LOG"
    private String details;

    @Override
    public int compareTo(ActivityLogDto o) {
        return Long.compare(o.timestamp, this.timestamp);
    }
}

@Data
@Builder
public class AnnouncementDto {
    private Long id;
    private String title;
    private String message;
    private String severity;
    private String date;
}












package com.tcs.dashboard.controller;

import com.tcs.dashboard.dto.ApiResponse;
import com.tcs.dashboard.dto.DashboardResponse;
import com.tcs.dashboard.service.DashboardServiceImpl;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/dashboard")
@RequiredArgsConstructor
public class DashboardController {

    private final DashboardServiceImpl dashboardService;

    @GetMapping("/init")
    public ResponseEntity<ApiResponse<DashboardResponse>> getDashboard(
            @RequestHeader("Authorization") String token) {
        
        DashboardResponse data = dashboardService.getDashboardData(token);
        return ResponseEntity.ok(ApiResponse.success(data, "Dashboard loaded"));
    }
}

// ---------------- DTOs -----------------
package com.tcs.dashboard.dto;

import lombok.Builder;
import lombok.Data;
import java.util.List;

@Data
@Builder
public class DashboardResponse {
    private List<AnnouncementDto> announcements;
    private StatsDto stats;
    private List<ActivityLogDto> recentActivity;
}

@Data
public class StatsDto {
    // Things I Created
    private int myPending;
    private int myApproved;
    private int myRejected;
    
    // Things Waiting for My Action (Specific to Permissions)
    private int pendingForMe; 
}

@Data
@Builder
public class ActivityLogDto implements Comparable<ActivityLogDto> {
    private String action;
    private long timestamp; // For sorting
    private String displayTime;
    private String source; // e.g. "CGL_CODE" or "USER_LOG"
    private String details;

    @Override
    public int compareTo(ActivityLogDto o) {
        return Long.compare(o.timestamp, this.timestamp);
    }
}

@Data
@Builder
public class AnnouncementDto {
    private Long id;
    private String title;
    private String message;
    private String severity;
    private String date;
}










package com.tcs.dashboard.dto;

import lombok.Data;
import java.time.Instant;

@Data
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
    private Instant timestamp;

    public static <T> ApiResponse<T> success(T data, String msg) {
        ApiResponse<T> r = new ApiResponse<>();
        r.success = true;
        r.message = msg;
        r.data = data;
        r.timestamp = Instant.now();
        return r;
    }
}

// --------------------------------------------------------

package com.fincore.commonutilities.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import javax.crypto.SecretKey;

@Component
public class JwtUtil {
    @Value("${jwt.secret}")
    private String secretKey;

    public String getUserIdFromToken(String token) {
        return extractClaim(token, Claims::getSubject);
    }
    
    public int getUserRoleFromToken(String token) {
        return extractClaim(token, c -> {
            Object r = c.get("role");
            return (r instanceof Number) ? ((Number) r).intValue() : 0;
        });
    }

    private <T> T extractClaim(String token, java.util.function.Function<Claims, T> resolver) {
        String clean = token.startsWith("Bearer ") ? token.startsWith(7) : token;
        Claims claims = Jwts.parser().verifyWith(getSigningKey()).build()
                .parseSignedClaims(clean).getPayload();
        return resolver.apply(claims);
    }

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey));
    }
}









