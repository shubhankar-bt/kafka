PERMISSIONS :-
MENU_ID	NUMBER(38,0)	No	"FINCORE"."MENU_ITEMS_SEQ"."NEXTVAL"	1	
MENU_TITLE	VARCHAR2(255 CHAR)	No		2	
MENU_ICON	VARCHAR2(255 CHAR)	Yes		3	
MENU_SUBMENU	VARCHAR2(255 CHAR)	Yes		4	
MENU_ACTION	VARCHAR2(255 CHAR)	No	NULL	5	
MENU_URL	VARCHAR2(255 CHAR)	No		6	
MENU_COMPONENT_PATH	VARCHAR2(255 CHAR)	No		7	
MENU_DESCRIPTION	VARCHAR2(255 BYTE)	No		8	
MENU_DEPENDANT	NUMBER(38,0)	Yes		9	
MAPPED_REQUEST_TYPE	VARCHAR2(255 CHAR)	Yes		10	
MENU_ORDER	VARCHAR2(255 CHAR)	Yes		11	

1	Circle Management	AccountTree		create|modify|delete|cancel	/circle-management	circle/CircleMaster	To manage circles in application		CIRCLE	
2	Circle Requests	Ballot		approve|reject	/circle-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for circle master.		CIRCLE	
5	CGL Management	Casino		create|modify|delete|cancel	/cgl-management	cgl/CGLMaster	To edit or update active CGLs and to view pending cgl requests		CGL_CODE	
6	CGL Requests	WorkspacePremium		approve|reject	/cgl-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for cgl master.		CGL_CODE	
7	Segment Management	Segment		create|modify|delete|cancel	/segment-management	segment/SegmentMaster	To manage segments in application		SEGMENT_CODE	
8	Segment Requests	Grading		approve|reject	/segment-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for segment master.		SEGMENT_CODE	
9	Branch Management	AccountBalance		create|modify|delete|cancel	/branch-management	branch/BranchMaster	To edit update branches and to check pending branch update requests			
10	Branch Requests	AssuredWorkload		approve|reject	/branch-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for branch master.		BRANCH	
11	Downloads	Download		download	/download	branch/BranchMaster	This is demo description			
12	User Management	People	User Creation	create|modify|delete|cancel	/user-management/create	user/pages/UserManagement	For creating new user		USER_MANAGEMENT	
13	User Management	WorkspacePremium	User Requests	approve|reject	/user-management/requests	user/pages/UserApprovals	To approve or reject user requests		USER_MANAGEMENT	
14	Calendar Configuration	EditCalendar		create|modify|delete|cancel	/calendar-configuration	calendarConfig/CalendarConfig	To manage financial calender configuration in application		CALENDER	
15	Calendar Config Requests	EventAvailable		approve|reject	/calendar-config-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for calender config master.		CALENDER	
16	State Management	Domain		create|modify|delete|cancel	/state-management	state/StateMaster	To manage states in application		STATE	
17	State Requests	DomainVerification		approve|reject	/state-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for state master.		STATE	
18	Currency Management	LocalAtm		create|modify|delete|cancel	/currency-management	currency/CurrencyMaster	To manage currency in application		CURRENCY	
19	Currency Requests	CreditScore		approve|reject	/currency-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for currency master.		CURRENCY	
20	Currency Rate Change	PriceChange		create|modify|delete|cancel	/currency-rate-change	currency/CurrencyRateChange	To manage currency rate in application		CURRENCY_RATE_CHANGE	
21	Currency Rate Requests	CurrencyRupee		approve|reject	/currency-rate-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for currency rate master.		CURRENCY_RATE_CHANGE	
22	Role Management	Badge		create|modify|delete|cancel	/role-management	role/RoleManagement	To manage roles in application		ROLE_MANAGEMENT	
23	Role Management Requests	Elevator		approve|reject	/role-management-requests	role/RoleApprovals	To approve/reject role management related requests.		ROLE_MANAGEMENT	
24	User Management	People	User Requests Audit	view	/user-management/user-audit	user/pages/UserLogs	Shows user audit requests			
25	Process Status	Memory		view	/process-status	process-status/ProcessStatusPage	This is demo description			
26	GLIF Reports	Summarize		view | download	/glif-Reports	glifReports/GlifReports	This is demo description			
30	Journal Posting	EditCalendar		Create MOC	/journal-posting	journal/JournalPosting	This is demo description		JOURNAL_AUTH	
31	Journal Authrization	Ballot		approve|reject	/journal-authrization	journal/JournalAuthrization	This is demo description		JOURNAL_AUTH	
32	Journal Posting Status	Ballot		Cansel Reqest | Status	/journal-posting-status	journal/JournalPostingStatus	to cansel there own Request			
33	Balance Enquiry	AccountBalance		view	/balance-enquiry	balanceEnquiry/BalanceEnquiryScreen	This provides closing balance for each day according to selected range.			
34	Transaction Enquiry	ReceiptLong		view	/transaction-enquiry	transaction-enquiry/TransactionEnquiry	This is demo description			
35	Dashboard	GridView		view	/dashboard	user/pages/Dashboard	Sample Dashboard screen MUI			
36	Journal Bulk Upload	GridView		Bulk Upload	/journal-bulk-upload	journal/JournalBulkUpload	To Upload the Bulk Journals			












ROLE_PERMISSIONS :-

ROLE_ID	NUMBER(10,0)	No		1	Foreign key to the ROLES table.
PERMISSION_ID	NUMBER(10,0)	No		2	Foreign key to the PERMISSIONS table.
PERMISSION_ORDER	NUMBER	Yes		3	Storing permission order against each role.


51	33	19
56	33	2
56	26	1
53	25	12
51	35	1
51	22	13
53	23	9
53	19	11
51	11	2
53	2	1
51	1	3
53	10	2
51	25	4
51	5	5
53	13	3
51	14	6
53	6	4
51	9	7
53	8	5
51	7	8
51	12	9
53	15	6
51	16	10
53	17	7
51	18	11
51	20	12
53	21	8
51	24	14
51	26	15
51	30	16
53	31	10
51	32	17
51	34	18
58	19	1
58	11	2
58	2	3
58	1	4
58	10	5
58	25	6
58	5	7
58	13	8
58	14	9
58	6	10
58	9	11
58	8	12
58	7	13
58	12	14
58	15	15
58	16	16
58	17	17
58	18	18
58	20	19
58	21	20
58	22	21
58	23	22
58	24	23
58	26	24
58	30	25
58	31	26
58	32	27
58	34	28
55	22	21
55	23	22
55	34	28
55	32	27
55	31	26
55	30	25
55	26	24
55	24	23
55	21	20
55	20	19
55	18	18
55	17	17
55	16	16
55	15	15
55	12	14
55	7	13
55	8	12
55	9	11
55	6	10
55	14	9
55	13	8
55	5	7
55	25	6
55	10	5
55	1	4
55	2	3
55	11	2
55	19	1
51	19	20
54	9	1
54	10	2
56	22	3
56	12	4
56	13	5
54	16	3
54	17	4
54	15	5
54	18	6
54	19	7
54	20	8
54	21	9
54	24	10
54	25	11
54	35	12
54	23	13
54	32	14
54	11	15
54	22	16
54	12	17
54	13	18
54	26	19
54	31	20
54	34	21
54	30	22
54	1	23
54	33	24
54	5	25
54	6	26
54	7	27
54	8	28
54	14	29
54	2	30
51	36	2






CONTROLLERS :

CommmonMasterService :
package com.tcs.fincore.CommonMasterService.Controller;


import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.tcs.fincore.CommonMasterService.dto.ApiResponse;
import com.tcs.fincore.CommonMasterService.dto.BalanceRequestDTO;
import com.tcs.fincore.CommonMasterService.dto.BalanceResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.PaginatedResponseDto;
import com.tcs.fincore.CommonMasterService.service.CommonMasterService;

import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.PostMapping;

@RestController
@RequestMapping("/balance")
@RequiredArgsConstructor
public class BalanceController {

    private final CommonMasterService service;

    @PostMapping("/enquirys")

    public ResponseEntity<ApiResponse<PaginatedResponseDto<BalanceResponseDTO>>> getBalance(
            @RequestBody BalanceRequestDTO request) {

        PaginatedResponseDto<BalanceResponseDTO> result = service.getBalanceDetails(request);

        return ResponseEntity.ok(ApiResponse.success(result, "Balance records feched Successfully"));

    }

}



package com.tcs.fincore.CommonMasterService.Controller;

import java.util.List;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.tcs.fincore.CommonMasterService.model.BranchCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.BranchMaster;
import com.tcs.fincore.CommonMasterService.model.CGLCodeDescriptionOnly;
import com.tcs.fincore.CommonMasterService.model.CGLMaster;
import com.tcs.fincore.CommonMasterService.model.CalenderConfigModel;
import com.tcs.fincore.CommonMasterService.model.CircleMaster;
import com.tcs.fincore.CommonMasterService.model.CurrencyCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.CurrencyMasterModel;
import com.tcs.fincore.CommonMasterService.model.CurrencyRateChange;
import com.tcs.fincore.CommonMasterService.model.SegmentCodeMaster;
import com.tcs.fincore.CommonMasterService.model.StateMaster;
import com.tcs.fincore.CommonMasterService.model.ZoneMaster;
import com.tcs.fincore.CommonMasterService.service.CommonMasterService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@RestController

public class CommonMasterController {

	private final CommonMasterService service;

	@GetMapping("/segment-codes")
	public List<SegmentCodeMaster> getSegmentCodes(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getSegmentCodes();
	}

	@GetMapping("/cgls")
	public List<CGLMaster> getCGLs(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCGLs();
	}

	@GetMapping("/cgl-code-description-only")
	public List<CGLCodeDescriptionOnly> getCGLsCodeDescriptionOnly(@RequestParam String q) {
		return service.getCGLsCodeDescriptionOnly(q);
	}

	@GetMapping("/cgl-codes")
	public List<String> getCGLCodes(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCGLCodes();
	}

	@GetMapping("/states")
	public List<StateMaster> getStateList(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getStateList();
	}

	@GetMapping("/branches")
	public List<BranchMaster> getBranches(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getBranches();
	}

	@GetMapping("/branches-code-name-only")
	public List<BranchCodeNameOnly> getBranchesCodeNameOnly(@RequestParam String q) {
		return service.getBranchesCodeNameOnly(q);
	}

	@GetMapping("/zone-codes")
	public List<ZoneMaster> getZoneCodes() {
		return service.getZoneCodes();
	}

	@GetMapping("/circle-codes")
	public List<CircleMaster> getCircleList() {
		return service.getCircleList();
	}

	@GetMapping("/currency-master")
	public List<CurrencyMasterModel> getCurrency(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCurrency();
	}

	@GetMapping("/currency-code-name-only")
	public List<CurrencyCodeNameOnly> getCurrencyCodeNameOnly(
			@RequestHeader("Authorization") String authorizationHeader
	) {
		return service.getCurrencyCodeNameOnly();
	}

	@GetMapping("/currency")
	public List<String> getCurrencys(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCurrencys();
	}

	@GetMapping("/calendar-configuration")
	public CalenderConfigModel getCalenderConfig(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCalenderConfig();
	}

	@GetMapping("/currency-rate-change")
	public List<CurrencyRateChange> getRateChange(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getRateChange();
	}
}







CommonRequestService :-

package com.tcs.fincore.CommonRequestService.controller;

import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.fincore.CommonRequestService.dto.CreateRequestDto;
import com.tcs.fincore.CommonRequestService.dto.MyRequestFilterDto;
import com.tcs.fincore.CommonRequestService.dto.ProcessRequestDto;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.service.RequestService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * RequestController :-
 *
 * This controller handles API requests related to creating, retrieving, and processing common requests within the FinCore Application.
 * It provides endpoints for users to manage their requests, view pending items, and for approvers to update request statuses.
 *
 * @author Shubhankar [v1018405]
 * @version 1.0
 * @since 2025-10-01
 */
@RestController
@RequiredArgsConstructor
@Slf4j
public class RequestController {

	private final RequestService requestService;
    private final JwtUtil jwtUtil;

    /**
     * Creates a new request initiated by a user (maker).
     *
     * @param createRequestDto The data transfer object containing the details of the new request.
     * @param token The authorization token used to identify the user making the request.
     * @return The created CommonReq entity.
     * @throws JsonProcessingException If there is an issue processing the request data.
     */
	@PostMapping("/create-request")
	@ResponseStatus(HttpStatus.CREATED)
	public CommonReq createRequest(
			@Valid @RequestBody CreateRequestDto createRequestDto,
			@RequestHeader("Authorization") String token
	) throws JsonProcessingException {
		String userId = jwtUtil.getUserIdFromToken(token);
		log.info("Received request creation call from user: {}", userId);
		return requestService.createRequest(createRequestDto, userId);
	}

    /**
     * Fetches requests created by the current user (maker). Requests can be filtered by `requestType`.
     *
     * @param token The authorization token of the user.
     * @param filterDto An object that may contain a `requestType` for filtering (e.g., `{"requestType": "SEGMENT_CODE"}`).
     * @return A list of CommonReq entities matching the criteria.
     */
	// tab2 master screen
	@PostMapping("/my-requests")
	public List<CommonReq> getMyRequests(
			@RequestHeader("Authorization") String token,
			@RequestBody MyRequestFilterDto filterDto
	) {
		String userId = jwtUtil.getUserIdFromToken(token);
		log.info(
				"Received request for fetch data for the user: {} and request type: {}", userId,
				filterDto.getRequestType()
		);
		return requestService.getMyRequests(userId, filterDto.getRequestType());
	}

    /**
     * Retrieves a list of requests that are pending approval for the current user (excluding the own requests).
     *
     * @param authorizationHeader The authorization token of the user.
     * @param filterDto An object that contain a `requestType` for filtering pending requests.
     * @return A list of pending CommonReq entities excluding the own requests.
     */
	// accept
	@PostMapping("/pending-requests")
	public List<CommonReq> getPendingRequests(
			@RequestHeader("Authorization") String authorizationHeader,
			@RequestBody MyRequestFilterDto filterDto
	) {
		String userId = jwtUtil.getUserIdFromToken(authorizationHeader);
		log.info("Received request for pending data for the request type: {}", filterDto.getRequestType());
		return requestService.getPendingRequests(userId, filterDto.getRequestType());
	}

    /**
     * Retrieves all requests present in the system (intended for admin/supervisory roles).
     *
     * @param authorizationHeader The authorization token.
     * @return A list of all CommonReq entities.
     */
	@GetMapping("/all-requests")
	public List<CommonReq> getAllRequests(@RequestHeader("Authorization") String authorizationHeader) {
		return requestService.getAllRequests();
	}


    /**
     * Updates the status of a request (Accepts/Rejects) by a checker (approver role).
     *
     * @param token The authorization token of the executor (checker).
     * @param processRequestDto The DTO containing the request ID, new status, and any remarks.
     * @return The updated CommonReq entity.
     * @throws JsonProcessingException If there is an issue processing the request data.
     */
	@PatchMapping("/update-request")
	public CommonReq updateRequestStatus(
			@RequestHeader("Authorization") String token,
			@RequestBody ProcessRequestDto processRequestDto
	) throws JsonProcessingException {
		String executorId = jwtUtil.getUserIdFromToken(token);
		// The service layer throws a ResourceNotFoundException if the optional is
		// empty,
		// which is caught by the GlobalExceptionHandler.
		return requestService.updateRequestStatus(processRequestDto, executorId).get();
	}
}









NotificationService :

@Slf4j
@RestController
@RequestMapping("/notifications")
public class NotificationController {

    private final NotificationService notificationService;

    private final SsePushService ssePushService;

    private final JwtUtil jwtUtil;

    public NotificationController(NotificationService notificationService, SsePushService ssePushService, JwtUtil jwtUtil) {
        this.notificationService = notificationService;
        this.ssePushService = ssePushService;
        this.jwtUtil = jwtUtil;
    }

    /**
     * GET /notifications/stream
     * The real-time SSE connection endpoint.
     */
    @GetMapping("/stream")
    public SseEmitter streamNotifications(@RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return ssePushService.subscribe(userId);
    }

    /**
     * GET /notifications
     * Fetches notification history for the user, with pagination.
     */
    @GetMapping
    public ResponseEntity<Page<Notification>> getNotifications(@RequestParam(defaultValue = "0") int page, @RequestParam(defaultValue = "10") int size, @RequestHeader("Authorization") String token) {

        String userId = jwtUtil.getUserIdFromToken(token);
        Page<Notification> notifications = notificationService.getNotificationsForUser(userId, page, size);
        return ResponseEntity.ok(notifications);
    }

    /**
     * GET /notifications/unread-count
     * Gets the count for the notification bell badge.
     */
    @GetMapping("/unread-count")
    public ResponseEntity<Map<String, Long>> getUnreadCount(@RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        long count = notificationService.getUnreadNotificationCount(userId);
        return ResponseEntity.ok(Map.of("count", count));
    }

    /**
     * POST /notifications/{id}/read
     * Marks a single notification as read.
     */
    @PostMapping("/{id}/read")
    public ResponseEntity<Boolean> markNotificationAsRead(@RequestHeader("Authorization") String token, @PathVariable("id") UUID id) {
        String userId = jwtUtil.getUserIdFromToken(token);
        boolean success = notificationService.markAsRead(userId, id);

        if (success) {
            return ResponseEntity.ok(true);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * POST /notifications/read-all
     * Mark all notifications as read for the particular user
     * */
    @PostMapping("/read-all")
    public ResponseEntity<Boolean> markAllAsRead(@RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        notificationService.markAllAsRead(userId);
        return ResponseEntity.ok(true);
    }
}









ProcessStatusService :-

@Slf4j
@RequiredArgsConstructor
@RestController
public class ProcessStatusController {

	private final ProcessStatusService processStatusService;

	@PostMapping("/processes")
	public ResponseEntity<ResponseVO<ProcessStatus>> insert(
			@Valid @RequestBody InsertDTO insertDTO
	) {
		ResponseEntity<ResponseVO<ProcessStatus>> responseEntity = processStatusService.insert(insertDTO);
		return responseEntity;
	}

	@PatchMapping("/processes")
	public ResponseEntity<ResponseVO<ProcessStatus>> update(@Valid @RequestBody UpdateDTO updateDTO) {
		ResponseEntity<ResponseVO<ProcessStatus>> responseEntity = processStatusService.update(updateDTO);
		return responseEntity;
	}

	@GetMapping(path = "/processes", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	public SseEmitter getProcessData() throws JsonProcessingException {
		return processStatusService.getProcessDataSSE();
	}
}




ReportService :-

@Slf4j
@RestController
@RequestMapping("/reports") 
public class ReportController {

    private final ReportService reportService;
    private final JwtUtil jwtUtil; // Declare an instance field
    
    public ReportController(ReportService reportService, JwtUtil jwtUtil) {
        this.reportService = reportService;
        this.jwtUtil = jwtUtil;
    }

    @PostMapping("/types")
    public List<ReportTypeDto> getReportTypes(@RequestHeader("Authorization") String token) {
        log.info("role and user id from token  : {},  {}", jwtUtil.getUserRoleFromToken(token), jwtUtil.getUserIdFromToken(token));
        return reportService.getReportTypes(jwtUtil.getUserRoleFromToken(token));
    }
   
    /**
    *
    */
    @PostMapping("/download")
    public List<ReportFileDto> downloadReport(@RequestHeader("Authorization") String token, @RequestBody ReportDownloadRequest request) {
        return reportService.getReport(request.getFileName(), request.getDate(), jwtUtil.getUserRoleFromToken(token), jwtUtil.getUserIdFromToken(token));
    }

}






TransactionsService :-

package com.fincore.transactions_service.controller;

import java.io.IOException;
import java.util.Map;

import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import com.fincore.transactions_service.dto.GetPayloadDTO;
import com.fincore.transactions_service.service.TransactionsService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
public class TransactionsController {

	public final TransactionsService transactionsService;

	@PostMapping("/transactions")
	public Map<String, Object> getTransactionsData(@RequestBody @Valid GetPayloadDTO getPayloadDTO) {
		return transactionsService.getTransactionsData(getPayloadDTO);
	}

	@PostMapping("/transactions-download")
	public byte[] getTransactionsFile(@RequestBody @Valid GetPayloadDTO getPayloadDTO) throws IOException {
		return transactionsService.getTransactionsFile(getPayloadDTO);
	}
}






UserService :

@RestController()
@RequestMapping("/role") //context path
public class RoleRequestController {

	private final RoleRequestService roleRequestService;
    private final JwtUtil jwtUtil;

	public RoleRequestController(RoleRequestService roleRequestService, JwtUtil jwtUtil) {
		this.roleRequestService = roleRequestService;
        this.jwtUtil = jwtUtil;
	}

	@GetMapping("/get-roles") //end point
	public ResponseEntity getAllRoles(@RequestParam Map<String, Object> requestParams) {
		return roleRequestService.getAllRoles(requestParams);
	}

	@PostMapping("/create-role-request")//end point
	public ResponseEntity createNewRequest(@RequestBody Map<String, Object> request, @RequestHeader("Authorization")String token) {
		String userId = jwtUtil.getUserIdFromToken(token);
		return roleRequestService.createNewRoleRequest(request, userId);
	}

	@GetMapping("/pending-role-requests")//end point
	public ResponseEntity getPendingRequests(@RequestHeader("Authorization") String token) {
		String userId = jwtUtil.getUserIdFromToken(token);
		return roleRequestService.getPendingRoleRequests(userId);
	}

	@PostMapping("/role-request-action")//end point
	public ResponseEntity acceptRequest(@RequestBody Map<String, Object> request, @RequestHeader("Authorization") String token) {
		String userId = jwtUtil.getUserIdFromToken(token);
		return roleRequestService.acceptOrRejectRoleRequest(request, userId);
	}

	@GetMapping("/my-role-requests")//end point
	public ResponseEntity getMyRequests(@RequestHeader("Authorization") String token) {
		String userId = jwtUtil.getUserIdFromToken(token);
		return roleRequestService.getMyRoleRequests(userId);
	}

	@PostMapping("/cancel-role-request")//end point
	public ResponseEntity cancelRoleRequest(@RequestBody Map<String, Object> request, @RequestHeader("Authorization") String token) {
		return roleRequestService.cancelRoleRequest(request, jwtUtil.getUserIdFromToken(token));
	}

	@GetMapping("/get-all-permissions")//end point
	public ResponseEntity getRoleWisePermissions() {
		return roleRequestService.getAllPermissions();
	}
	
	@PatchMapping("/save-permission-order")
	public ResponseEntity savePermissionOrder(@RequestBody PermissionOrderDto payload) {
		return roleRequestService.savePermissionOrder(payload);
	}

}










package com.tcs.userservice.controller;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.userservice.dto.UserLogsDto;
import com.tcs.userservice.dto.UserRequestDto;
import com.tcs.userservice.service.UserLogsService;
import com.tcs.userservice.service.UserRequestService;
import com.tcs.userservice.utility.RequestUtility;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@Slf4j
@RestController()
@RequestMapping("/user")
public class UserRequestController {


    @Autowired
    private UserRequestService userRequestService;

    @Autowired
    private UserLogsService userLogsService;

    @Autowired
    private JwtUtil jwtUtil;

    @PostMapping("/create-request")
    public ResponseEntity createNewRequest(@RequestBody Map<String, Object> request, @RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return userRequestService.createNewRequest(request, userId);
    }

    @GetMapping("/pending-user-requests")
    public ResponseEntity getPendingRequests(@RequestParam Map<String, Object> params) {
        return userRequestService.getPendingRequests(params);
    }

    @PostMapping("/accept-request")
    public ResponseEntity acceptRequest(ServerHttpRequest request, @RequestBody UserRequestDto userRequest) {
        String clientIp = RequestUtility.getClientIp(request);
        return userRequestService.acceptOrRejectUserRequest(userRequest, clientIp);
    }


    @GetMapping("/user-details")
    public ResponseEntity getUserDetails(@RequestParam Map<String, String> request) {
        return userRequestService.getUserDetails(request);
    }

    @GetMapping("/my-requests")
    public ResponseEntity getMyRequests(@RequestParam Map<String, String> params) {
        return userRequestService.getMyRequests(params);
    }

    @PostMapping("/cancel-request")
    public ResponseEntity cancelRequest(@RequestBody Map<String, Object> request) {
        return userRequestService.cancelRequest(request);
    }


    @PostMapping("/logs-batch")
    public ResponseEntity<List<UserLogsDto>> createLogsBatch(@RequestBody List<UserLogsDto> payload) {
        List<UserLogsDto> savedLogs = (List<UserLogsDto>) userLogsService.saveLogs(payload);

        // Returning the saved DTOs with the CREATED status
        return new ResponseEntity<>(savedLogs, HttpStatus.CREATED);
    }

    // GET API to fetch all user logs
    @GetMapping("/all-logs")
    public ResponseEntity<List<UserLogsDto>> findAllLogs() {
        List<UserLogsDto> logs = userLogsService.findAllLogs();
        return ResponseEntity.ok(logs);
    }

    // GET API to fetch a user log by ID
    @GetMapping("/{id}")
    public ResponseEntity<UserLogsDto> findLogById(@PathVariable Integer id) {
        UserLogsDto log = userLogsService.findLogById(id);
        return ResponseEntity.ok(log);
    }

}



