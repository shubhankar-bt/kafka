package com.fincore.UserService.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class RolePermissionEventDto {
    @JsonProperty("payload")
    private Payload payload;

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Payload {
        private DataBlock after;  // State after change
        private DataBlock before; // State before change (for deletes)
        private String op;        // 'c', 'u', 'd'
    }

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class DataBlock {
        @JsonProperty("ROLE_ID")
        private Long roleId;

        @JsonProperty("PERMISSION_ID")
        private Long permissionId;
    }
}







package com.fincore.UserService.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class PermissionEventDto {
    @JsonProperty("payload")
    private Payload payload;

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Payload {
        private DataBlock after;
        private DataBlock before;
        private String op;
    }

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class DataBlock {
        @JsonProperty("MENU_ID")
        private Long menuId;
        
        // Other fields if needed, but ID is enough to trigger refresh
    }
}










package com.fincore.UserService.repository;

import com.fincore.UserService.model.Permissions;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface PermissionRepository extends JpaRepository<Permissions, Long> {

    // Joins ROLES -> ROLE_PERMISSIONS -> PERMISSIONS
    @Query(value = """
        SELECT p.* FROM PERMISSIONS p
        JOIN ROLE_PERMISSIONS rp ON p.MENU_ID = rp.PERMISSION_ID
        WHERE rp.ROLE_ID = :roleId
    """, nativeQuery = true)
    List<Permissions> findAllByRoleId(@Param("roleId") Long roleId);
}








package com.fincore.UserService.service;

import com.fincore.UserService.model.Permissions;
import com.fincore.UserService.repository.PermissionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor
@Slf4j
public class PermissionCacheService {

    private final PermissionRepository permissionRepository;
    private final StringRedisTemplate redisTemplate;

    /**
     * Refreshes the Redis cache for a specific Role ID.
     * Call this on Startup and whenever a Role is updated.
     */
    @Transactional(readOnly = true)
    public void refreshRolePermissions(Long roleId) {
        log.info("‚ôªÔ∏è Refreshing Redis Permissions for Role ID: {}", roleId);
        
        List<Permissions> perms = permissionRepository.findAllByRoleId(roleId);
        String redisKey = "RBAC::PERMISSIONS::" + roleId;
        
        // 1. Clear old permissions
        redisTemplate.delete(redisKey);

        Set<String> redisValues = new HashSet<>();

        for (Permissions p : perms) {
            String url = p.getMenuUrl(); 
            String action = p.getMenuAction(); // "create|modify", "approve|reject"
            String context = p.getMappedRequestType(); // "SEGMENT_CODE", "CGL_CODE"

            // Default context to "*" if null (for non-generic services)
            String contextSuffix = (context == null || context.isEmpty()) ? "*" : context;

            // --- CRS GENERIC MAPPING LOGIC ---
            // If the permission has a Mapped Request Type or URL implies a request
            if (context != null && !context.isEmpty()) {
                
                // MAKER ACTIONS: create, modify, delete, cancel
                // Maps to: POST /create-request (Handles Add/Update/Delete via ChangeType)
                if (containsAny(action, "create", "modify", "delete", "cancel")) {
                    redisValues.add("POST:/create-request|" + contextSuffix);
                }
                
                // CHECKER ACTIONS: approve, reject
                // Maps to: PATCH /update-request (To take action) AND POST /pending-requests (To view list)
                if (containsAny(action, "approve", "reject")) {
                    redisValues.add("PATCH:/update-request|" + contextSuffix);
                    redisValues.add("POST:/pending-requests|" + contextSuffix);
                }
                
                // VIEW ACTION: view
                // Maps to: POST /my-requests (Maker view)
                if (action.contains("view")) {
                    redisValues.add("POST:/my-requests|" + contextSuffix);
                    // Also allow getting all requests if needed
                    redisValues.add("GET:/all-requests|" + contextSuffix);
                }
            } 
            
            // --- STANDARD REST MAPPING (Reports, User Mgmt, etc.) ---
            else {
                // Wildcard context |* allows access regardless of X-Request-Type header
                
                if (action.contains("create")) redisValues.add("POST:" + url + "|*");
                if (action.contains("modify")) {
                    redisValues.add("PUT:" + url + "|*");
                    redisValues.add("PATCH:" + url + "|*");
                }
                if (action.contains("delete")) redisValues.add("DELETE:" + url + "|*");
                
                // View typically maps to GET
                if (action.contains("view")) redisValues.add("GET:" + url + "|*");
                
                // Special case for Report Download (It's a POST in your ReportService)
                if (action.contains("download")) redisValues.add("POST:" + url + "|*");
            }
        }

        // 2. Push to Redis
        if (!redisValues.isEmpty()) {
            redisTemplate.opsForSet().add(redisKey, redisValues.toArray(new String[0]));
        }
        log.info("‚úÖ Cached {} permissions for Role {}", redisValues.size(), roleId);
    }

    private boolean containsAny(String input, String... keywords) {
        if (input == null) return false;
        for (String keyword : keywords) {
            if (input.contains(keyword)) return true;
        }
        return false;
    }
}











package com.fincore.UserService.config;

import com.fincore.UserService.service.PermissionCacheService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class CacheWarmer {

    private final PermissionCacheService permissionCacheService;
    private final JdbcTemplate jdbcTemplate;

    /**
     * Runs once when the application starts.
     * Iterates over ALL Role IDs and refreshes their permissions in Redis.
     */
    @EventListener(ApplicationReadyEvent.class)
    public void onStartup() {
        log.info("üöÄ Startup: Warming Permission Cache...");

        // Fetch all Role IDs (using JDBC for speed/simplicity)
        List<Long> roleIds = jdbcTemplate.queryForList("SELECT ROLE_ID FROM ROLES", Long.class);

        for (Long roleId : roleIds) {
            try {
                permissionCacheService.refreshRolePermissions(roleId);
            } catch (Exception e) {
                log.error("Failed to refresh permissions for Role {}", roleId, e);
            }
        }
        log.info("üèÅ Cache Warming Complete. Processed {} roles.", roleIds.size());
    }
}












    // ... existing refreshRolePermissions method ...

    /**
     * Called when a PERMISSION definition changes (e.g. URL update).
     * Finds all roles using this permission and refreshes them.
     */
    @Transactional(readOnly = true)
    public void refreshRolesByPermissionId(Long permissionId) {
        // Query DB: Find all Role IDs associated with this Permission ID
        // You'll need to add this query to your Repository
        List<Long> affectedRoleIds = rolePermissionRepository.findRoleIdsByPermissionId(permissionId);
        
        log.info("Permission {} changed. Refreshing {} affected roles.", permissionId, affectedRoleIds.size());
        
        for (Long roleId : affectedRoleIds) {
            refreshRolePermissions(roleId);
        }
    }








package com.fincore.UserService.service;

import com.fincore.UserService.dto.PermissionEventDto;
import com.fincore.UserService.dto.RolePermissionEventDto;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
@Slf4j
@RequiredArgsConstructor
public class RbacEventListener {

    private final PermissionCacheService cacheService;

    /**
     * Scenario 1: A Role is assigned/unassigned a Permission.
     * Table: ROLE_PERMISSIONS
     */
    @KafkaListener(topics = "fincore.FINCORE.ROLE_PERMISSIONS", groupId = "rbac-cache-group")
    public void handleRolePermissionChange(RolePermissionEventDto event) {
        if (event == null || event.getPayload() == null) return;

        String op = event.getPayload().getOp();
        Long roleId = null;

        // If Create or Update, use 'after'
        if ("c".equals(op) || "u".equals(op)) {
            roleId = event.getPayload().getAfter().getRoleId();
        } 
        // If Delete, use 'before'
        else if ("d".equals(op)) {
            roleId = event.getPayload().getBefore().getRoleId();
        }

        if (roleId != null) {
            log.info("‚ö° Real-time RBAC Update: Role {} permissions changed.", roleId);
            cacheService.refreshRolePermissions(roleId);
        }
    }

    /**
     * Scenario 2: A Permission definition itself changes (e.g. URL update).
     * Table: PERMISSIONS
     */
    @KafkaListener(topics = "fincore.FINCORE.PERMISSIONS", groupId = "rbac-cache-group")
    public void handlePermissionDefinitionChange(PermissionEventDto event) {
        if (event == null || event.getPayload() == null) return;

        String op = event.getPayload().getOp();
        Long menuId = null;

        if ("c".equals(op) || "u".equals(op)) {
            menuId = event.getPayload().getAfter().getMenuId();
        } else if ("d".equals(op)) {
            menuId = event.getPayload().getBefore().getMenuId();
        }

        if (menuId != null) {
            log.info("‚ö° Real-time RBAC Update: Permission Definition {} changed.", menuId);
            cacheService.refreshRolesByPermissionId(menuId);
        }
    }
}








