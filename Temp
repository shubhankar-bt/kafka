package com.fincore.helpservice.service;

import com.fincore.helpservice.model.PermissionEntity;
import com.fincore.helpservice.repository.PermissionRepository;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * THE BRAIN.
 * Responsible for understanding English grammar, identifying intents,
 * and normalizing complex sentences into executable commands.
 * * FIXES APPLIED:
 * 1. Removed hardcoded screen checks (now loads from DB).
 * 2. Removed static ACTION_ROOTS map (now uses AdaptiveSearchService).
 * 3. Added caching for screen titles.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class NLPEngine {

    private final AdaptiveSearchService adaptiveService;
    private final PermissionRepository permissionRepository;

    // Cache known screens for detection (Normalized Upper -> Display Name)
    private final Map<String, String> KNOWN_SCREENS = new ConcurrentHashMap<>();

    private static final Set<String> NEGATION_WORDS = Set.of(
            "not", "cant", "cannot", "unable", "fail", "failed", "failing", "error", "issue", "problem", "broken", "wont"
    );
    
    private static final Set<String> KNOWN_ACTIONS = Set.of("CREATE", "MODIFY", "APPROVE", "VIEW", "DELETE", "DOWNLOAD");

    // REGEX PATTERNS
    private static final Pattern ERROR_CODE_PATTERN = Pattern.compile("\\b[A-Z]{3,4}-\\d{3,5}\\b"); 
    private static final Pattern NAV_PATTERN = Pattern.compile("\\b(go to|open|take me to|navigate to)\\b");
    private static final Pattern CAPABILITY_PATTERN = Pattern.compile("\\b(what can i do|my rights|my permissions|access do i have)\\b");
    private static final Pattern DEFINITION_PATTERN = Pattern.compile("\\b(what is|define|meaning of)\\b");
    private static final Pattern RESET_PATTERN = Pattern.compile("\\b(stop|cancel|wrong|start over|reset)\\b");
    private static final Pattern PRONOUN_PATTERN = Pattern.compile("\\b(it|this|that)\\b", Pattern.CASE_INSENSITIVE);
    private static final Pattern TROUBLE_PATTERN = Pattern.compile("\\b(cant|cannot|fail|error|issue)\\b", Pattern.CASE_INSENSITIVE);
    
    // Noise words
    private static final Set<String> STOP_WORDS = Set.of(
            "i", "me", "my", "myself", "we", "our", "ours", "ourselves", "you", "your", "yours",
            "yourself", "yourselves", "he", "him", "his", "himself", "she", "her", "hers",
            "herself", "it", "its", "itself", "they", "them", "their", "theirs", "themselves",
            "what", "which", "who", "whom", "this", "that", "these", "those", "am", "is", "are",
            "was", "were", "be", "been", "being", "have", "has", "had", "having", "do", "does",
            "did", "doing", "a", "an", "the", "and", "but", "if", "or", "because", "as", "until",
            "while", "of", "at", "by", "for", "with", "about", "against", "between", "into",
            "through", "during", "before", "after", "above", "below", "to", "from", "up", "down",
            "in", "out", "on", "off", "over", "under", "again", "further", "then", "once", "here",
            "there", "when", "where", "why", "how", "all", "any", "both", "each", "few", "more",
            "most", "other", "some", "such", "no", "nor", "not", "only", "own", "same", "so",
            "than", "too", "very", "s", "t", "can", "will", "just", "don", "should", "now", "please", "kindly", "help"
    );

    /**
     * DYNAMICALLY LOAD SCREENS FROM DB
     * Replaces hardcoded "if (lower.contains('cgl'))" logic.
     */
    @PostConstruct
    @Scheduled(fixedRate = 3600000) // Refresh every hour
    public void loadScreenKnowledge() {
        try {
            List<PermissionEntity> allPermissions = permissionRepository.findAll();
            KNOWN_SCREENS.clear();
            for (PermissionEntity p : allPermissions) {
                if (p.getMenuTitle() != null) {
                    // Map "CGL MANAGEMENT" -> "CGL Management"
                    KNOWN_SCREENS.put(p.getMenuTitle().toUpperCase().trim(), p.getMenuTitle().trim());
                }
            }
            log.info("NLPEngine: Loaded {} screens into knowledge base.", KNOWN_SCREENS.size());
        } catch (Exception e) {
            log.error("NLPEngine: Failed to load screens.", e);
        }
    }

    /**
     * Input: "Can I please creating a new CGL?"
     * Output: "create cgl"
     */
    public String extractNormalizedIntent(String sentence) {
        if (sentence == null) return "";
        String clean = sentence.toLowerCase().replaceAll("[^a-z0-9\\s]", " ");
        StringBuilder normalized = new StringBuilder();

        for (String word : clean.split("\\s+")) {
            if (word.isEmpty()) continue;
            if (STOP_WORDS.contains(word)) continue;

            // DYNAMIC LOOKUP from DB via AdaptiveSearchService
            String root = adaptiveService.getRootFromSynonym(word);
            normalized.append(root).append(" ");
        }
        return normalized.toString().trim();
    }

    /**
     * Identifies the ACTION verb from the sentence.
     * Uses AdaptiveSearchService to resolve synonyms (e.g. "add" -> "CREATE")
     */
    public String detectAction(String normalizedSentence) {
        for (String word : normalizedSentence.split(" ")) {
            // "word" might already be normalized to "CREATE" by extractNormalizedIntent
            // But we double check the root just in case
            String root = adaptiveService.getRootFromSynonym(word);
            if (KNOWN_ACTIONS.contains(root.toUpperCase())) {
                return root.toUpperCase();
            }
        }
        return null;
    }

    /**
     * Identifies the MODULE/CONTEXT from the sentence based on DB Screens.
     * Now Dynamic!
     */
    public String detectScreen(String sentence) {
        if (sentence == null) return null;
        String upperSentence = sentence.toUpperCase();
        
        // 1. Check for Exact Multi-Word Matches from DB (e.g. "CGL MANAGEMENT")
        // We iterate KNOWN_SCREENS to find the longest matching substring
        for (String dbScreenUpper : KNOWN_SCREENS.keySet()) {
            if (upperSentence.contains(dbScreenUpper)) {
                return KNOWN_SCREENS.get(dbScreenUpper); // Return display name
            }
        }

        // 2. Check for Synonyms (e.g. "cgl" -> "CGL Management")
        // We tokenize the sentence and check if any word maps to a screen name
        List<String> tokens = Arrays.asList(sentence.split("\\W+"));
        for (String token : tokens) {
            // e.g. token="cgl" -> root="CGL Management" (from AdaptiveService)
            String root = adaptiveService.getRootFromSynonym(token);
            
            // Check if this root is a known screen key
            if (KNOWN_SCREENS.containsKey(root.toUpperCase().trim())) {
                return KNOWN_SCREENS.get(root.toUpperCase().trim());
            }
        }

        return null;
    }

    /**
     * Detects if the user is expressing inability to perform an action.
     * "I cannot create" -> true
     */
    public boolean isNegatedOrTrouble(String sentence) {
        if (sentence == null) return false;
        String lower = sentence.toLowerCase();

        for (String neg : NEGATION_WORDS) {
            // Check word boundaries so "note" doesn't trigger "not"
            if (Pattern.compile("\\b" + neg + "\\b").matcher(lower).find()) {
                return true;
            }
        }
        return false;
    }

    public boolean containsPronoun(String t) {
        return t != null && PRONOUN_PATTERN.matcher(t).find();
    }

    public String resolveAnaphora(String t, String topic) {
        return PRONOUN_PATTERN.matcher(t).replaceAll(topic);
    }

    public boolean isTrouble(String t) {
        return t != null && TROUBLE_PATTERN.matcher(t).find();
    }

    /**
     * Extracts an error code like "FIN-909" from the text.
     */
    public String extractErrorCode(String text) {
        if (text == null) return null;
        Matcher m = ERROR_CODE_PATTERN.matcher(text.toUpperCase());
        if (m.find()) {
            return m.group();
        }
        return null;
    }

    public boolean isNavigationCommand(String text) {
        return text != null && NAV_PATTERN.matcher(text.toLowerCase()).find();
    }

    public boolean isCapabilityRequest(String text) {
        return text != null && CAPABILITY_PATTERN.matcher(text.toLowerCase()).find();
    }

    public boolean isDefinitionRequest(String text) {
        return text != null && DEFINITION_PATTERN.matcher(text.toLowerCase()).find();
    }

    public boolean isResetRequest(String text) {
        return text != null && RESET_PATTERN.matcher(text.toLowerCase()).find();
    }
}











