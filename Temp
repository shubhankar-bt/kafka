package com.tcs.fincore.CommonRequestService.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.dto.*;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;
import com.tcs.fincore.CommonRequestService.exception.ResourceNotFoundException;
import com.tcs.fincore.CommonRequestService.model.CGLMaster;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.ChangeType;
import com.tcs.fincore.CommonRequestService.model.enums.RequestStatus;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.CommonRequestRepository;
import com.tcs.fincore.CommonRequestService.service.strategy.RequestStrategyFactory;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;
import java.util.Optional;

/**
 * - Handle all requests for different business objects [CGL, SEGMENT, CURRENCY]
 * - Handle creator/executor scenarios
 * - Used strategy design patter to differentiate different business objects
 * - Injected NotificationWriterService and PermissionConfigService for notification
 * - Injected BusinessSecurityService for second level RBAC authentication to check BLOCK/UNBLOCK permissions
 *
 * @author Shubhankar Das [v1018405]
 * @version 1.1
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RequestServiceImpl implements RequestService {

    private static final String EVENT_SOURCE = "CommonRequestService";
    private final CommonRequestRepository commonRequestRepository;
    private final RequestStrategyFactory strategyFactory;
    private final ObjectMapper objectMapper;
    private final NotificationWriterService notificationWriterService;
    private final PermissionConfigService permissionConfigService;
    private final BusinessSecurityService businessSecurityService;

    @Override
    @Transactional(rollbackOn = Exception.class)
    public CommonReq createRequest(
            CreateRequestDto dto,
            String creatorId,
            String token
    ) throws JsonProcessingException {

        // --- LAYER 2 SECURITY CHECK ---
        businessSecurityService.validateUserAction(token, dto.getRequestType(), dto.getChangeType());

        KeyablePayload payload = (KeyablePayload) dto.getPayload();

        // --- PRE CHECKS ---
        String targetId = payload.getKey();
        if (targetId == null || targetId.isBlank()) {
            throw new IllegalArgumentException("Could not determine targetId from payload.");
        }
        log.info("Determined targetId for new request as: {}", targetId);

        List<CommonReq> existingRequests = commonRequestRepository.findByTargetIdAndReqStatus(targetId, RequestStatus.PENDING);

        if (!existingRequests.isEmpty()) {
            log.warn("Attempted to create a duplicate request for targetId {} which already has a {} request.",
                    targetId, existingRequests.get(0).getReqStatus());
            throw new DataIntegrityViolationException("An active or pending request for '" + targetId + "' already exists.");
        }
        
        // --- CREATE AND SAVE REQUEST ---
        CommonReq request = new CommonReq();
        request.setCreatorId(creatorId);
        request.setReqType(dto.getRequestType());
        request.setChangeType(dto.getChangeType());
        request.setPayload(objectMapper.writeValueAsString(payload));
        request.setTargetId(targetId);
        request.setReqStatus(RequestStatus.PENDING);
        request.setReqDate(LocalDateTime.now(ZoneId.of("Asia/Kolkata")));
        
        // [NEW FEATURE ADDED]: Map the Creator Remarks directly. Nullable column handles missing data seamlessly.
        request.setCreatorRemarks(dto.getCreatorRemarks());

        log.info("Saving new, validated request for targetId {}", targetId);
        CommonReq savedRequest = commonRequestRepository.save(request);

        // --- NOTIFICATION LOGIC ---
        try {
            String requestTypeKey = dto.getRequestType().name();
            NotificationConfigDto config = permissionConfigService.getConfig(requestTypeKey);
            String action = request.getChangeType().name(); 

            if (request.getChangeType() == ChangeType.BLOCK || request.getChangeType() == ChangeType.UNBLOCK) {
                CGLMaster payload2 = objectMapper.readValue(request.getPayload(), CGLMaster.class);
                action = (payload2.getStatus() == 0) ? "BLOCK" : "UNBLOCK";
            }
            
            String message = "New " + action + " request (" + targetId + ") pending for " + dto.getRequestType();

            notificationWriterService.createNotification(
                    creatorId,                  
                    config.getTargetRoles(),    
                    message,
                    config.getTargetUrl(),      
                    savedRequest.getId().toString(),
                    EVENT_SOURCE
            );

        } catch (JsonProcessingException e) {
            // FIX: Catch JSON specific errors
            log.error("CRITICAL: Failed to parse payload to determine BLOCK/UNBLOCK status for Request ID: {}", savedRequest.getId(), e);
            throw new IllegalArgumentException("Invalid payload structure for Notification processing", e);
            
        } catch (DataAccessException e) {
            // FIX: Catch Spring Database specific errors
            log.error("CRITICAL: Database error while creating 'pending' notification for Request ID: {}.", savedRequest.getId(), e);
            throw new IllegalStateException("Database transaction failed during notification creation.", e);
            
        } catch (ResourceNotFoundException e) {
            // FIX: Catch configuration missing errors
            log.error("CRITICAL: Missing notification configuration for Request Type: {}", dto.getRequestType(), e);
            throw new IllegalStateException("Notification configuration missing. Cannot proceed.", e);
        }
        // Note: We DO NOT catch standard RuntimeExceptions (like NPEs) anymore. They will bubble up and be visible in logs.

        return savedRequest;
    }

    @Override
    @Transactional(rollbackOn = Exception.class) 
    public Optional<CommonReq> updateRequestStatus(
            ProcessRequestDto dto,
            String executorId
    ) throws JsonProcessingException {

        Long requestId = dto.getRequestId();
        log.info("Attempting to update status for request ID: {} by executor: {}", requestId, executorId);

        CommonReq request = commonRequestRepository.findById(requestId)
                .orElseThrow(() -> new ResourceNotFoundException("Request with ID " + requestId + " not found."));

        if (executorId.equals(request.getCreatorId())) {
            log.warn("SECURITY VIOLATION: User {} attempted to approve their own request (ID: {}).", executorId, requestId);
            throw new IllegalStateException("User cannot approve or reject their own request.");
        }

        if (request.getReqStatus() != RequestStatus.PENDING) {
            log.warn("Attempted to modify an already processed request. ID: {}, Current Status: {}", dto.getRequestId(), request.getReqStatus());
            throw new IllegalStateException("Request has already been processed and cannot be modified.");
        }

        request.setExecutorId(executorId);
        request.setExecutorRemarks(dto.getRemarks());
        request.setExecutionDate(LocalDateTime.now(ZoneId.of("Asia/Kolkata")));
        request.setReqStatus(dto.getStatus());

        if (RequestStatus.ACCEPTED.equals(dto.getStatus())) {
            log.info("Request {} ACCEPTED. Applying strategy for type {}", dto.getRequestId(), request.getReqType());
            strategyFactory.getStrategy(request.getReqType()).processApproval(request);
            notificationWriterService.createRequestApprovedNotification(request, executorId);
            request.setExecutionRemarks("Successfully processed approval.");
        } else {
            log.info("Request {} REJECTED.", dto.getRequestId());
            notificationWriterService.createRequestRejectedNotification(request, executorId, dto.getRemarks());
            request.setExecutionRemarks("Request rejected by user.");
        }

        // --- NOTIFICATION 2: CLOSURE ---
        try {
            NotificationConfigDto config = permissionConfigService.getConfig(request.getReqType().name());
            String action = dto.getStatus().equals(RequestStatus.ACCEPTED) ? "Approved" : "Rejected";
            String closureMessage = "Request " + request.getTargetId() + " was " + action + " by " + executorId;

            notificationWriterService.createNotification(
                    executorId,                 
                    config.getTargetRoles(),    
                    closureMessage,
                    config.getTargetUrl(),      
                    request.getId().toString(),
                    "CommonRequestService"
            );
            log.info("Sent closure notification to group for Request ID: {}", requestId);

        } catch (DataAccessException | ResourceNotFoundException e) {
            // FIX: Narrowed down to specific expected failures.
            // We still log and suppress this so the Approval doesn't rollback if just the Group Notification fails.
            log.error("Failed to send closure notification for Request ID: {}. Reason: {}", requestId, e.getMessage());
        }

        CommonReq updatedRequest = commonRequestRepository.save(request);
        return Optional.of(updatedRequest);
    }

    @Override
    @Transactional(rollbackOn = Exception.class)
    public CommonReq cancelRequest(CancelRequestDto dto, String userId) {

        Long requestId = dto.getRequestId();
        log.info("Attempting to cancel request ID: {} by user: {}", requestId, userId);

        CommonReq request = commonRequestRepository.findById(requestId)
                .orElseThrow(() -> new ResourceNotFoundException("Request with ID " + requestId + " not found."));

        if (!request.getCreatorId().equals(userId)) {
            log.warn("SECURITY VIOLATION: User {} attempted to cancel request {} owned by {}", userId, requestId, request.getCreatorId());
            throw new AccessDeniedException("You are not authorized to cancel this request.");
        }

        if (request.getReqStatus() != RequestStatus.PENDING) {
            throw new IllegalStateException("Only pending requests can be cancelled. Current status: " + request.getReqStatus());
        }

        request.setReqStatus(RequestStatus.CANCELLED);
        request.setExecutorId(userId);
        request.setExecutionDate(LocalDateTime.now(ZoneId.of("Asia/Kolkata")));
        request.setExecutorRemarks("CANCELLED BY USER: " + (dto.getRemarks() != null ? dto.getRemarks() : "No remarks"));

        CommonReq updatedRequest = commonRequestRepository.save(request);
        log.info("Request {} successfully cancelled by user.", requestId);

        return updatedRequest;
    }

    @Override
    public List<CommonReq> getMyRequests(String userId, RequestType requestType) {
        if (requestType == null) {
            throw new IllegalArgumentException("Request type is missing.");
        }
        return commonRequestRepository.findByCreatorIdAndReqType(userId, requestType);
    }

    @Override
    public List<CommonReq> getPendingRequests(String userId, RequestType requestType) {
        if (requestType == null) {
            throw new IllegalArgumentException("Request type is missing.");
        }
        return commonRequestRepository.findByCreatorIdNotAndReqStatusAndReqType(userId, RequestStatus.PENDING, requestType);
    }

    @Override
    public List<CommonReq> getAllRequests() {
        return commonRequestRepository.findAll();
    }
}


