package com.fincore.DashboardService.repository;

import com.fincore.DashboardService.model.CommonReq;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

/**
 * OPTIMIZED REPOSITORY
 * Uses Native Queries and Projections to perform heavy aggregations at the Database level.
 */
@Repository
public interface DashboardStatsRepository extends JpaRepository<CommonReq, Long> {

    // PROJECTION INTERFACE
    interface TypeCount {
        String getType();
        String getStatus();
        Long getCount();
    }

    interface DailyStats {
        String getDateStr();
        Long getCreatedCount();
        Long getExecutedCount();
    }
    
    // NEW: Projection for Intelligence Scheduler
    // Returns Role ID (String) instead of User ID, as responsibility is Role-based.
    interface RoleBottleneck {
        String getRoleId();
        Integer getOverdueCount();
    }

    // ==================================================================================
    // 1. STATS AGGREGATION (MAKER & EXECUTOR)
    // ==================================================================================

    @Query(value = "SELECT REQ_TYPE as type, REQ_STATUS as status, COUNT(*) as count " +
            "FROM COMMON_REQ WHERE CREATOR_ID = :userId " +
            "GROUP BY REQ_TYPE, REQ_STATUS", nativeQuery = true)
    List<TypeCount> getMakerStatsCrs(@Param("userId") String userId);

    @Query(value = "SELECT REQ_TYPE as type, COUNT(*) as count " +
            "FROM COMMON_REQ " +
            "WHERE REQ_STATUS = 'P' AND REQ_TYPE IN :types " +
            "GROUP BY REQ_TYPE", nativeQuery = true)
    List<TypeCount> getPendingCountsByTypes(@Param("types") List<String> types);

    @Query(value = "SELECT REQ_STATUS as status, COUNT(*) as count " +
            "FROM JOURNAL_REQUEST WHERE CREATOR_ID = :userId " +
            "GROUP BY REQ_STATUS", nativeQuery = true)
    List<TypeCount> getMakerStatsJournal(@Param("userId") String userId);

    @Query(value = "SELECT COUNT(*) FROM JOURNAL_REQUEST WHERE REQ_STATUS = 'P'", nativeQuery = true)
    int countPendingJournals();

    @Query(value = "SELECT REQUEST_STATUS as status, COUNT(*) as count " +
            "FROM USER_REQUESTS WHERE REQUESTOR_USER_ID = :userId " +
            "GROUP BY REQUEST_STATUS", nativeQuery = true)
    List<TypeCount> getMakerStatsUser(@Param("userId") String userId);

    @Query(value = "SELECT REQUEST_STATUS as status, COUNT(*) as count " +
            "FROM ROLE_REQUESTS WHERE REQUESTOR_USER_ID = :userId " +
            "GROUP BY REQUEST_STATUS", nativeQuery = true)
    List<TypeCount> getMakerStatsRole(@Param("userId") String userId);

    @Query(value = "SELECT COUNT(*) FROM USER_REQUESTS WHERE REQUEST_STATUS = 'PENDING'", nativeQuery = true)
    int countPendingUserReqs();

    @Query(value = "SELECT COUNT(*) FROM ROLE_REQUESTS WHERE REQUEST_STATUS = 'PENDING'", nativeQuery = true)
    int countPendingRoleReqs();

    // ==================================================================================
    // 2. INTELLIGENCE: BOTTLENECK & ANOMALY DETECTION
    // ==================================================================================

    /**
     * BOTTLENECK DETECTION (Single User View):
     * Counts items pending for more than 48 hours.
     */
    @Query(value = "SELECT COUNT(*) FROM COMMON_REQ " +
            "WHERE REQ_STATUS = 'P' " +
            "AND REQ_TYPE IN :types " +
            "AND REQ_DATE < (SYSDATE - 2)", nativeQuery = true)
    int countOverdueItems(@Param("types") List<String> types);

    /**
     * ANOMALY DETECTION:
     * Counts rejections in the last 1 HOUR.
     */
    @Query(value = "SELECT COUNT(*) FROM COMMON_REQ " +
            "WHERE EXECUTOR_ID = :userId " +
            "AND REQ_STATUS = 'R' " +
            "AND EXECUTION_DATE > (SYSDATE - (1/24))", nativeQuery = true)
    int countRecentRejections(@Param("userId") String userId);
    
    // --- NEW: INTELLIGENCE SCHEDULER QUERY (CORRECTED) ---
    /**
     * Finds ALL ROLES that have > 5 items pending for more than 48 hours.
     * Logic:
     * 1. Find Pending Requests older than 48 hours.
     * 2. Join with PERMISSIONS to find which Screen handles this Request Type.
     * 3. Join with ROLE_PERMISSIONS to find which Roles have access to that Screen.
     * 4. Filter for Roles that have 'approve' or 'reject' rights.
     * 5. Group by ROLE_ID to find the bottlenecked teams.
     */
    @Query(value = """
        SELECT 
            TO_CHAR(rp.ROLE_ID) as roleId, 
            COUNT(c.REQ_ID) as overdueCount
        FROM COMMON_REQ c
        JOIN PERMISSIONS p ON c.REQ_TYPE = p.MAPPED_REQUEST_TYPE
        JOIN ROLE_PERMISSIONS rp ON p.MENU_ID = rp.PERMISSION_ID
        JOIN ROLES r ON rp.ROLE_ID = r.ROLE_ID
        WHERE c.REQ_STATUS = 'P' 
          AND c.REQ_DATE < (SYSDATE - 2)
          AND r.ROLE_STATUS = 'ACTIVE'
          AND (lower(p.MENU_ACTION) LIKE '%approve%' OR lower(p.MENU_ACTION) LIKE '%reject%')
        GROUP BY rp.ROLE_ID
        HAVING COUNT(c.REQ_ID) > 5
    """, nativeQuery = true)
    List<RoleBottleneck> findAllBottleneckRoles();

    // ==================================================================================
    // 3. INTELLIGENCE: BEHAVIORAL ANALYSIS
    // ==================================================================================

    @Query(value = "SELECT REQ_TYPE as type, COUNT(*) as count " +
            "FROM COMMON_REQ WHERE CREATOR_ID = :userId " +
            "GROUP BY REQ_TYPE", nativeQuery = true)
    List<TypeCount> getUserCrsUsageFrequency(@Param("userId") String userId);

    @Query(value = "SELECT COUNT(*) FROM JOURNAL_REQUEST WHERE CREATOR_ID = :userId", nativeQuery = true)
    int getUserJournalUsageCount(@Param("userId") String userId);

    @Query(value = "SELECT COUNT(*) FROM USER_LOGS " +
            "WHERE USER_ID = :userId AND ACTION_TYPE LIKE 'USER_%'", nativeQuery = true)
    int getUserMgmtUsageCount(@Param("userId") String userId);


    // ==================================================================================
    // 3. FREQUENCY AGGREGATION
    // ==================================================================================

    @Query(value = """
      SELECT
          TO_CHAR(TRUNC(req_date), 'YYYY-MM-DD') as dateStr,
          COUNT(*) as createdCount,
          SUM(CASE
               WHEN status IN ('A', 'R', 'ACCEPTED', 'REJECTED', 'APPROVED', 'SUCCESS', 'CANCELED', 'CANCELLED') THEN 1
               ELSE 0
          END) as executedCount
      FROM (
          SELECT REQ_DATE as req_date, REQ_STATUS as status FROM COMMON_REQ WHERE REQ_DATE BETWEEN :startDate AND :endDate
          UNION ALL
          SELECT REQ_DATE as req_date, REQ_STATUS as status FROM JOURNAL_REQUEST WHERE REQ_DATE BETWEEN :startDate AND :endDate
          UNION ALL
          SELECT REQUEST_DATE as req_date, REQUEST_STATUS as status FROM USER_REQUESTS WHERE REQUEST_DATE BETWEEN :startDate AND :endDate
          UNION ALL
          SELECT REQUEST_DATE as req_date, REQUEST_STATUS as status FROM ROLE_REQUESTS WHERE REQUEST_DATE BETWEEN :startDate AND :endDate
      ) all_requests
      GROUP BY TRUNC(req_date)
      ORDER BY dateStr ASC
  """, nativeQuery = true)
    List<DailyStats> getFrequencyStatsByRange(@Param("startDate") LocalDateTime startDate,
                                              @Param("endDate") LocalDateTime endDate);
}




















package com.fincore.DashboardService.service;

import com.fincore.DashboardService.model.NotificationOutbox;
import com.fincore.DashboardService.repository.DashboardStatsRepository;
import com.fincore.DashboardService.repository.DashboardStatsRepository.RoleBottleneck; // Updated Import
import com.fincore.DashboardService.repository.NotificationOutboxRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class IntelligenceSchedulerService {

    private final DashboardStatsRepository statsRepo;
    private final NotificationOutboxRepository outboxRepo;

    /**
     * Daily Job (9:00 AM): BOTTLENECK DETECTION
     * Scans for ROLES that have > 5 items pending for more than 48 hours.
     * Writes a warning to the Outbox table using our Outbox Pattern.
     */
    @Scheduled(cron = "0 0 9 * * ?") // 9 AM Daily
    @Transactional
    public void runBottleneckDetection() {
        log.info("üïµÔ∏è Starting Daily Intelligence Scan: Bottleneck Detection...");

        List<RoleBottleneck> bottlenecks = statsRepo.findAllBottleneckRoles();

        if (bottlenecks.isEmpty()) {
            log.info("‚úÖ No bottlenecks detected today.");
            return;
        }

        log.warn("‚ö†Ô∏è Detected {} roles with critical bottlenecks.", bottlenecks.size());

        for (RoleBottleneck role : bottlenecks) {
            String message = String.format("Team Alert: Your Role has %d overdue request(s) pending for over 48 hours. Please clear the queue.", role.getOverdueCount());
            
            // Create Notification Event (Outbox Pattern)
            // TARGET: ROLE (1-to-Many)
            NotificationOutbox event = NotificationOutbox.builder()
                    .userId(null) // Not for a specific user
                    .targetRole(role.getRoleId()) // Send to ALL users with this Role
                    .message(message)
                    .linkUrl("/dashboard") 
                    .eventSource("DASHBOARD_INTELLIGENCE")
                    .aggregateId("BOTTLENECK_" + System.currentTimeMillis()) 
                    .build();

            outboxRepo.save(event);
            log.info(" -> Notification dispatched for Role ID: {}", role.getRoleId());
        }
    }
}



