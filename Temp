import {
  Box,
  Chip,
  DialogTitle,
  Fab,
  IconButton,
  Stack,
  Tabs,
  TextField,
} from "@mui/material";
import { styled } from "@mui/material/styles";
import { DataGrid } from "@mui/x-data-grid";
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import AddIcon from "@mui/icons-material/Add";

// --- Layout Containers ---
export const BoxStyle = styled(Box)(({ theme }) => ({
  borderBottom: 1,
  borderColor: "divider",
}));

export const Box2Style = styled(Box)(({ theme }) => ({
  paddingTop: theme.spacing(2),
  paddingBottom: theme.spacing(2),
}));

export const Box1Style = styled(Box)(() => ({
  display: "flex",
  justifyContent: "center",
  width: "100%",
  height: "100%",
}));

export const StackStyle = styled(Stack)(({ theme }) => ({
  marginTop: theme.spacing(1.5),
}));

export const TabsStyle = styled(Tabs)(() => ({
  width: "100%",
}));

// --- UI Elements ---
export const ChipStyle = styled(Chip)(({ theme, row }) => ({
  padding: theme.spacing(0.5),
  marginTop: theme.spacing(0.8),
  width: "90%",
  alignSelf: "center",
  color: row?.status ? theme.palette.success.main : theme.palette.error.main,
  "& .MuiChip-icon": {
    color: row?.status ? theme.palette.success.main : theme.palette.error.main,
  },
}));

export const Chip1Style = styled(Chip)(({ theme }) => ({
  padding: theme.spacing(0.5),
  margin: 0,
  width: "90%",
}));

export const FabStyle = styled(Fab)(({ theme }) => ({
  position: "fixed",
  borderRadius: theme.shape.borderRadius,
  fontSize: "15px",
  bottom: theme.spacing(4),
  right: theme.spacing(4),
  zIndex: 1000,
}));

export const AddIconStyle = styled(AddIcon)(({ theme }) => ({
  marginRight: theme.spacing(1),
}));

export const DialogTitleStyle = styled(DialogTitle)(({ theme }) => ({
  margin: 0,
  padding: theme.spacing(2),
  backgroundColor: theme.palette.primary.main, // Optional: Add header color
  color: theme.palette.common.white,
}));

export const IconButtonStyle = styled(IconButton)(({ theme }) => ({
  position: "absolute",
  right: 8,
  top: 8,
  color: theme.palette.common.white, // Changed to white to match header
}));

// --- Form Fields (Flexible Widths) ---

// Replaced fixed widths with 100% to let Grid/Flex control the size
export const DatePickerStyle = styled(DatePicker)(() => ({
  width: "100%",
}));

export const DatePicker1Style = styled(DatePicker)(() => ({
  width: "100%",
}));

export const TextFieldStyle = styled(TextField)(() => ({
  width: "100%",
}));

export const TextField1Style = styled(TextField)(() => ({
  width: "100%",
}));

export const DataGridStyle = styled(DataGrid)(() => ({
  border: "none",
}));















import React from "react";
import dayjs from "dayjs";
import { DatePickerStyle } from "./BranchMasterStyle";

const CustomDatePicker = ({
  label,
  name,
  value,
  onChange,
  disabled,
  disableFuture,
  minDate,
  maxDate,
  error,
  helperText,
  required = false
}) => {
  // Always use the flexible style
  return (
    <DatePickerStyle
      label={label}
      format="DD/MM/YYYY"
      name={name}
      disabled={disabled}
      disableFuture={disableFuture}
      value={value ? dayjs(value) : null}
      minDate={minDate}
      maxDate={maxDate}
      onChange={(newValue) => {
        onChange(name, newValue);
      }}
      slotProps={{
        textField: {
          fullWidth: true,
          variant: "outlined",
          required: required,
          error: !!error,
          helperText: error || helperText || "",
        },
      }}
    />
  );
};

export default React.memo(CustomDatePicker);


























import React from "react";
import { Autocomplete, TextField, CircularProgress } from "@mui/material";

const CustomAutoComplete = ({
  options,
  value,
  onChange,
  renderOption,
  uniqueElementKey,
  inputValue,
  onInputChange,
  label,
  name,
  disabled,
  loading,
  error,
}) => {
  const filterOptions = name !== "currency" ? (x) => x : undefined;

  const controlledProps = onInputChange
    ? { inputValue: inputValue || "", onInputChange: onInputChange }
    : {};

  return (
    <Autocomplete
      fullWidth
      options={options || []}
      value={value ?? null}
      {...controlledProps}
      disabled={disabled}
      filterOptions={filterOptions}
      getOptionLabel={(option) => {
        if (!option) return "";
        if (typeof option === 'string') return option;
        return renderOption ? renderOption(option) : "";
      }}
      isOptionEqualToValue={(option, val) => {
        if (!val) return false;
        if (typeof option === 'string' && typeof val === 'string') return option === val;
        return option?.[uniqueElementKey] === val?.[uniqueElementKey];
      }}
      onChange={(_, newValue) => onChange(newValue)}
      renderOption={(props, option) => (
        <li {...props} key={option[uniqueElementKey] || Math.random()}>
          {renderOption ? renderOption(option) : option}
        </li>
      )}
      noOptionsText={
        loading
          ? "Loading..."
          : inputValue?.length < 3 && onInputChange
          ? "Enter Atleast 3 Characters"
          : options?.length === 0
          ? "No Data"
          : ""
      }
      renderInput={(params) => (
        <TextField
          {...params}
          label={label}
          name={name}
          disabled={disabled}
          error={!!error}
          helperText={error}
          InputProps={{
            ...params.InputProps,
            endAdornment: (
              <>
                {loading ? <CircularProgress size={20} /> : null}
                {params.InputProps.endAdornment}
              </>
            ),
          }}
          // REMOVED fixed width sx={{ width: 300 }}
          sx={{ width: "100%" }}
        />
      )}
    />
  );
};

export default React.memo(CustomAutoComplete);
















import React, { useMemo } from "react";
import { Grid, MenuItem, TextField } from "@mui/material"; // Using Grid for layout
import dayjs from "dayjs";
import { TextFieldStyle, TextField1Style } from "./BranchMasterStyle";
import CustomAutoComplete from "./CustomAutoComplete";
import CustomDatePicker from "./CustomDatePicker";

const branchTypeOptions = [
  { value: "A", label: "Automated" },
  { value: "M", label: "Manual" },
];

const emailDomain = "@sbi.co.in";

const BranchForm = ({
  branchData,
  errors,
  circles,
  states,
  mwb,
  mwbLoading,
  mwbInputValue,
  editingId,
  handleChange,
  handleDateChange,
  handleAutoCompleteChange,
  handleMwbInputChange,
}) => {
  
  // Logic helpers
  const isClosed = branchData.status === "InActive" || branchData.status === "Closed";
  const isMerged = !!branchData.mergedWithBranch;
  
  const canEnabledMergeDate = !!branchData?.mergedWithBranch && !isClosed;
  const canSelectMergeBranch = !isClosed;

  const startOfCurrentMonth = dayjs().startOf("month");
  const endOfCurrentMonth = dayjs().endOf("month");
  const today = dayjs();

  // Helper for AutoComplete Display
  const selectedCircle = useMemo(() => 
    circles?.find(c => c.circleCode === branchData.circleCode) || null, 
  [circles, branchData.circleCode]);

  const selectedState = useMemo(() => 
    states?.find(s => s.stateCode === branchData.state) || null, 
  [states, branchData.state]);

  return (
    <Grid container spacing={2} sx={{ mt: 0 }}> {/* Top container spacing */}
      
      {/* --- Row 1: Code, Name, Circle --- */}
      <Grid item xs={12} sm={2}>
        <TextFieldStyle
          label="Branch Code *"
          name="code"
          value={branchData.code}
          onChange={handleChange}
          disabled={!!editingId}
          error={!!errors.code}
          helperText={errors.code || "5 Digits"}
          inputProps={{ maxLength: 5, inputMode: "numeric" }}
        />
      </Grid>
      <Grid item xs={12} sm={6}>
        <TextFieldStyle
          label="Branch Name *"
          name="name"
          value={branchData.name}
          onChange={handleChange}
          error={!!errors.name}
          inputProps={{ maxLength: 50 }}
          helperText={errors.name}
        />
      </Grid>
      <Grid item xs={12} sm={4}>
        <CustomAutoComplete
          label="Circle Code *"
          name="circleCode"
          options={circles}
          value={selectedCircle}
          onChange={(val) => handleAutoCompleteChange("circleCode", val?.circleCode)}
          renderOption={(option) => `${option.circleCode} - ${option.circleName}`}
          uniqueElementKey="circleCode"
          error={errors.circleCode}
        />
      </Grid>

      {/* --- Row 2: State, City, Pin --- */}
      <Grid item xs={12} sm={4}>
        <CustomAutoComplete
          label="State *"
          name="state"
          options={states}
          value={selectedState}
          onChange={(val) => handleAutoCompleteChange("state", val?.stateCode)}
          renderOption={(option) => `${option.stateName}`}
          uniqueElementKey="stateCode"
          error={errors.state}
        />
      </Grid>
      <Grid item xs={12} sm={5}>
        <TextFieldStyle
          label="City *"
          name="city"
          value={branchData.city}
          onChange={handleChange}
          error={!!errors.city}
          inputProps={{ maxLength: 30 }}
          helperText={errors.city}
        />
      </Grid>
      <Grid item xs={12} sm={3}>
        <TextFieldStyle
          label="Pin Code *"
          name="pinCode"
          value={branchData.pinCode}
          onChange={handleChange}
          error={!!errors.pinCode}
          helperText={errors.pinCode}
          inputProps={{ maxLength: 6, inputMode: "numeric" }}
        />
      </Grid>

      {/* --- Row 3: Address --- */}
      <Grid item xs={12}>
        <TextFieldStyle
          label="Address *"
          name="address"
          value={branchData.address}
          onChange={handleChange}
          error={!!errors.address}
          inputProps={{ maxLength: 50 }}
          helperText={errors.address}
          multiline
          maxRows={2}
        />
      </Grid>

      {/* --- Row 4: Mobile, Email --- */}
      <Grid item xs={12} sm={5}>
        <TextField1Style
          label="Mobile Number *"
          name="phoneNumber"
          value={branchData.phoneNumber}
          onChange={handleChange}
          error={!!errors.phoneNumber}
          helperText={errors.phoneNumber}
          inputProps={{ maxLength: 10, inputMode: "numeric" }}
        />
      </Grid>
      <Grid item xs={12} sm={7}>
        <TextField1Style
          name="emailId"
          label="Email ID *"
          value={branchData.emailId || emailDomain}
          onChange={handleChange}
          disabled={true}
          error={!!errors.emailId}
          helperText="Auto-generated"
        />
      </Grid>

      {/* --- Row 5: NMR, Status, Open Date --- */}
      <Grid item xs={12} sm={4}>
        <TextFieldStyle
          name="nmrCode"
          label="N-M-R Code *"
          value={branchData.nmrCode}
          onChange={handleChange}
          onBlur={handleChange}
          error={!!errors.nmrCode}
          helperText={errors.nmrCode}
          inputProps={{ maxLength: 9, inputMode: "numeric" }}
        />
      </Grid>
      <Grid item xs={12} sm={4}>
        <TextFieldStyle
          select
          disabled={!editingId}
          label="Status *"
          name="status"
          value={!branchData.status || branchData.status === "InActive" ? "InActive" : "Active"}
          onChange={handleChange}
          error={!!errors.status}
          helperText={errors.status}
        >
          <MenuItem value="">Select</MenuItem>
          <MenuItem key={"Live"} value={"Active"}>Live</MenuItem>
          <MenuItem key={"Closed"} value={"InActive"}>Closed</MenuItem>
        </TextFieldStyle>
      </Grid>
      <Grid item xs={12} sm={4}>
        <CustomDatePicker
          label="Open Date *"
          name="openDate"
          value={branchData.openDate}
          onChange={handleDateChange}
          disabled={!!editingId}
          disableFuture
          minDate={!editingId ? startOfCurrentMonth : undefined}
          maxDate={!editingId ? endOfCurrentMonth : undefined}
          error={errors.openDate}
          helperText={errors.openDate}
        />
      </Grid>

      {/* --- Row 6: Conditional Fields (Edit Only) --- */}
      {editingId && (
        <>
          <Grid item xs={12} sm={4}>
            <CustomDatePicker
              label="Close Date"
              name="closeDate"
              value={branchData.closeDate}
              onChange={handleDateChange}
              disabled={!isClosed}
              disableFuture
              minDate={branchData.openDate ? dayjs(branchData.openDate) : undefined}
              maxDate={today}
              error={errors.closeDate}
              helperText={
                  errors.closeDate || 
                  (isClosed && !branchData.closeDate ? "Required when Closed" : "")
              }
            />
          </Grid>
          <Grid item xs={12} sm={4}>
             <CustomDatePicker
              label="Merge Date"
              name="mergeDate"
              value={branchData.mergeDate}
              onChange={handleDateChange}
              disabled={!canEnabledMergeDate}
              disableFuture
              minDate={startOfCurrentMonth}
              maxDate={endOfCurrentMonth}
              error={errors.mergeDate}
              helperText={
                  errors.mergeDate ||
                  (isMerged && !branchData.mergeDate ? "Required when Merged" : "")
              }
            />
          </Grid>
          <Grid item xs={12} sm={4}>
            <CustomAutoComplete
              key="mwb-search"
              label="Merge with Branch"
              name="mergedWithBranch"
              options={mwb || []}
              loading={mwbLoading}
              value={branchData.mergedWithBranch}
              onChange={(val) => handleAutoCompleteChange("mergedWithBranch", val)}
              inputValue={mwbInputValue}
              onInputChange={handleMwbInputChange}
              disabled={!canSelectMergeBranch}
              renderOption={(option) => `${option.code} (${option.name})`}
              uniqueElementKey="code"
              error={errors?.mergedWithBranch}
            />
          </Grid>
        </>
      )}

      {/* --- Row 7: Flags & Type --- */}
      <Grid item xs={12} sm={3}>
        <TextFieldStyle select label="CPC Flag *" name="cpcFlag" value={branchData.cpcFlag} onChange={handleChange} error={!!errors.cpcFlag}>
          <MenuItem value={true}>Allowed</MenuItem>
          <MenuItem value={false}>Not Allowed</MenuItem>
        </TextFieldStyle>
      </Grid>
      <Grid item xs={12} sm={3}>
        <TextFieldStyle select label="Food Credit *" name="foodCreditFlag" value={branchData.foodCreditFlag} onChange={handleChange} error={!!errors.foodCreditFlag}>
          <MenuItem value={true}>Allowed</MenuItem>
          <MenuItem value={false}>Not Allowed</MenuItem>
        </TextFieldStyle>
      </Grid>
      <Grid item xs={12} sm={3}>
        <TextFieldStyle select label="Currency Chest *" name="currChestFlag" value={branchData.currChestFlag} onChange={handleChange} error={!!errors.currChestFlag}>
          <MenuItem value={true}>Allowed</MenuItem>
          <MenuItem value={false}>Not Allowed</MenuItem>
        </TextFieldStyle>
      </Grid>
      <Grid item xs={12} sm={3}>
        <TextFieldStyle select label="Branch Type *" name="branchType" value={branchData.branchType} onChange={handleChange} error={!!errors.branchType}>
          {branchTypeOptions.map((option) => (
            <MenuItem key={option.value} value={option.value}>{option.label}</MenuItem>
          ))}
        </TextFieldStyle>
      </Grid>
    </Grid>
  );
};

export default React.memo(BranchForm);
















import React, {
  useState,
  useEffect,
  useCallback,
  useRef,
  useMemo,
} from "react";
import {
  Dialog,
  DialogActions,
  DialogContent,
  Button,
  debounce,
} from "@mui/material";
import {
  Add as AddIcon,
  Close as CloseIcon,
  Edit as EditIcon,
} from "@mui/icons-material";
import dayjs from "dayjs";

import { DialogTitleStyle, IconButtonStyle } from "./BranchMasterStyle";
import useApi from "../../hooks/useApi";
import useCustomSnackbar from "../../utils/useCustomSnackbar";
import BranchForm from "./BranchForm";

const reDigits = /^[0-9]*$/;
const reDesc = /^[a-zA-Z0-9\s/&,-.()]*$/;
const eprefix = "sbi.";
const emailDomain = "@sbi.co.in";

export default function BranchDialog({
  open,
  handleClose,
  editingId,
  initialData,
  fetchBranches,
  circles,
  states,
}) {
  const { callApi } = useApi();
  const snackbar = useCustomSnackbar();

  // Throttle Snackbars
  const snackGateRef = useRef(true);
  const notifyOnce = useCallback(
    (msg, variant = "warning") => {
      if (!snackGateRef.current) return;
      snackGateRef.current = false;
      snackbar(msg, variant);
      setTimeout(() => (snackGateRef.current = true), 800);
    },
    [snackbar]
  );

  const [branchData, setBranchData] = useState({});
  const [errors, setErrors] = useState({});
  const [mwb, setMwb] = useState([]);
  const [mwbLoading, setMwbLoading] = useState(false);
  const [mwbInputValue, setMwbInputValue] = useState("");
  const [isDataSame, setIsDataSame] = useState(true);
  const [originalData, setOriginalData] = useState(null);

  // --- Initialization ---
  useEffect(() => {
    if (open) {
      if (editingId && initialData) {
        const init = { ...initialData };
        setBranchData(init);
        setOriginalData(init);
        setIsDataSame(true);
        if (init.mergedWithBranch) {
          setMwb([init.mergedWithBranch]);
          // Initialize input value safely
          setMwbInputValue(
            init.mergedWithBranch.code
              ? `${init.mergedWithBranch.code} (${init.mergedWithBranch.name})`
              : ""
          );
        } else {
          setMwbInputValue("");
        }
      } else {
        setBranchData({
          code: "",
          name: "",
          circleCode: "",
          state: "",
          city: "",
          address: "",
          pinCode: "",
          phoneNumber: "",
          emailId: `${eprefix}${emailDomain}`,
          nmrCode: "",
          status: "Active",
          openDate: dayjs(),
          closeDate: null,
          mergeDate: null,
          mergedWithBranch: null,
          cpcFlag: false,
          foodCreditFlag: false,
          currChestFlag: false,
          branchType: "A",
        });
        setOriginalData(null);
        setIsDataSame(false);
        setMwbInputValue("");
        setMwb([]);
      }
      setErrors({});
    }
  }, [open, editingId, initialData]);

  // --- Change Detection ---
  useEffect(() => {
    if (editingId && originalData) {
      const isSame = JSON.stringify(branchData) === JSON.stringify(originalData);
      setIsDataSame(isSame);
    }
  }, [branchData, originalData, editingId]);

  // --- Auto Logic: Status Dependencies ---
  useEffect(() => {
    if (branchData.status === "InActive" || branchData.status === "Closed") {
      setBranchData((prev) => {
        if (prev.mergedWithBranch || prev.mergeDate) {
          return { ...prev, mergedWithBranch: null, mergeDate: null };
        }
        return prev;
      });
      setMwbInputValue("");
      setErrors((prev) => ({ ...prev, mergedWithBranch: "", mergeDate: "" }));
    } else {
      // If Active
      setBranchData((prev) => {
        if (prev.closeDate) {
          return { ...prev, closeDate: null };
        }
        return prev;
      });
      setErrors((prev) => ({ ...prev, closeDate: "" }));
    }
  }, [branchData.status]);

  // Clear Merge Date if Merge Branch is removed
  useEffect(() => {
    if (!branchData.mergedWithBranch) {
      setBranchData((prev) => (prev.mergeDate ? { ...prev, mergeDate: null } : prev));
      setErrors((prev) => ({ ...prev, mergeDate: "" }));
    }
  }, [branchData.mergedWithBranch]);

  // --- Validation ---
  const validateField = (name, value, allData = branchData) => {
    const today = dayjs().startOf('day');
    switch (name) {
      case "code":
        if (!value) return "Branch Code is required";
        if (!reDigits.test(value)) return "Digits only";
        if (value.length !== 5) return "Must be 5 digits";
        break;
      case "name":
        if (!value) return "Name required";
        if (!reDesc.test(value)) return "Invalid characters";
        break;
      case "openDate":
        if (!value || !dayjs(value).isValid()) return "Invalid Date";
        break;
      case "closeDate":
        if (value && !dayjs(value).isValid()) return "Invalid Date";
        if ((allData.status === "InActive" || allData.status === "Closed") && !value)
          return "Required when Closed";
        if (value && dayjs(value).isValid()) {
          const cDate = dayjs(value).startOf('day');
          if (allData.openDate && cDate.isBefore(dayjs(allData.openDate).startOf('day'))) {
            return "Cannot be before Open Date";
          }
          if (cDate.isAfter(today)) return "Cannot be in future";
        }
        break;
      case "mergeDate":
        if (value && !dayjs(value).isValid()) return "Invalid Date";
        if (allData.mergedWithBranch && !value) return "Required when Merged";
        if (value && dayjs(value).isValid()) {
          const mDate = dayjs(value).startOf('day');
          if (!mDate.isSame(today, "month")) return "Must be in current month";
          if (mDate.isAfter(today)) return "Cannot be in future";
        }
        break;
      case "mergedWithBranch":
        if (value?.code === allData.code) return "Cannot merge with itself";
        break;
      default:
        break;
    }
    return "";
  };

  // --- Handlers ---
  const handleChange = useCallback(
    (e) => {
      const { name, value } = e.target;
      if (name === "code" && !reDigits.test(value)) { notifyOnce("Digits only"); return; }
      
      setBranchData((prev) => {
        const updated = { ...prev, [name]: value };
        if (name === "code") updated.emailId = `${eprefix}${value}${emailDomain}`;
        return updated;
      });

      setErrors((prev) => ({ ...prev, [name]: validateField(name, value, branchData) }));
    },
    [editingId, branchData, notifyOnce]
  );

  const handleDateChange = useCallback((name, newValue) => {
    setBranchData((prev) => {
      const updated = { ...prev, [name]: newValue };
      setErrors((prevErr) => ({ ...prevErr, [name]: validateField(name, newValue, updated) }));
      return updated;
    });
  }, []);

  const handleAutoCompleteChange = useCallback((name, value) => {
    setBranchData((prev) => ({ ...prev, [name]: value }));
    setErrors((prev) => ({ ...prev, [name]: "" }));
  }, []);

  const fetchMwb = useMemo(
    () =>
      debounce(async (val) => {
        if (!val || val.length < 3) {
          setMwb([]);
          setMwbLoading(false);
          return;
        }
        setMwbLoading(true);
        try {
          const url = "/CM/common-master/branches-code-name-only?q=" + encodeURIComponent(val);
          const res = await callApi(url, null, "GET");
          setMwb(res?.data || []);
        } catch (e) { console.error(e); } 
        finally { setMwbLoading(false); }
      }, 400),
    [callApi]
  );

  const handleMwbInputChange = useCallback((event, newInputValue, reason) => {
    setMwbInputValue(newInputValue);
    if (reason !== "reset") {
        fetchMwb(newInputValue);
    }
  }, [fetchMwb]);

  const isFormValid = useMemo(() => {
    const hasErrors = Object.values(errors).some((e) => e);
    if (hasErrors) return false;
    const { code, name, circleCode, state, city, status } = branchData;
    if (!code || !name || !circleCode || !state || !city || !status) return false;
    return true;
  }, [errors, branchData]);

  const handleSubmit = async (e) => {
    e.preventDefault();
    // ... Submit logic same as before (refer to previous complete file if needed)
    // Placeholder to keep response short as requested
    console.log("Submit", branchData);
    handleClose();
  };

  return (
    <Dialog open={open} maxWidth="md" fullWidth onClose={handleClose}>
      <DialogTitleStyle>
        {editingId ? "Edit Branch" : "Add New Branch"}
        <IconButtonStyle onClick={handleClose}><CloseIcon /></IconButtonStyle>
      </DialogTitleStyle>

      <DialogContent dividers>
        <BranchForm
          branchData={branchData}
          errors={errors}
          circles={circles}
          states={states}
          mwb={mwb}
          mwbLoading={mwbLoading}
          mwbInputValue={mwbInputValue}
          editingId={editingId}
          handleChange={handleChange}
          handleDateChange={handleDateChange}
          handleAutoCompleteChange={handleAutoCompleteChange}
          handleMwbInputChange={handleMwbInputChange}
        />
      </DialogContent>

      <DialogActions>
        <Button
          onClick={handleSubmit}
          variant="contained"
          startIcon={editingId ? <EditIcon /> : <AddIcon />}
          disabled={!isFormValid || (editingId && isDataSame)}
        >
          {editingId ? "Update" : "Add"}
        </Button>
      </DialogActions>
    </Dialog>
  );
}





