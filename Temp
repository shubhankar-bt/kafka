<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/> 
    </parent>
    
    <groupId>com.fincore</groupId>
    <artifactId>HelpService</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>HelpService</name>
    <description>Fin Core Contextual Help Microservice</description>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- Web MVC -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- JPA & Oracle -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>com.oracle.database.jdbc</groupId>
            <artifactId>ojdbc11</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Redis Caching -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>

        <!-- Validation & Utils -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Common Utils (Assuming this is available in your repo) -->
        <!-- If strict jar dependency is missing, ensure you copy the ApiResponse class locally -->
        <dependency>
            <groupId>com.fincore</groupId>
            <artifactId>common-utilities</artifactId>
            <version>1.0.0</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>





















# ==============================================================
# FIN CORE - HELP SERVICE CONFIGURATION
# ==============================================================
spring.application.name=HelpService
server.port=9099

# --- ORACLE DATABASE ---
# Ensure these match your DB credentials
spring.datasource.url=jdbc:oracle:thin:@//10.1.1.1:1521/FINCOREDB
spring.datasource.username=FIN_HELP_USER
spring.datasource.password=YourSecurePassword
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# --- JPA / HIBERNATE ---
spring.jpa.database-platform=org.hibernate.dialect.OracleDialect
spring.jpa.show-sql=false
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.open-in-view=false

# --- REDIS CACHE ---
spring.data.redis.host=10.0.17.242
spring.data.redis.port=6379
spring.cache.type=redis
# Cache TTL: 1 Hour (Refresh help content periodically)
spring.cache.redis.time-to-live=3600000

# --- LOGGING ---
logging.level.com.fincore.HelpService=INFO
logging.level.org.springframework.web=WARN





















package com.fincore.HelpService.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * ENTITY: HELP_SCREEN_MASTER
 */
@Data
@Entity
@Table(name = "HELP_SCREEN_MASTER")
public class HelpScreenEntity implements Serializable {
    
    @Id
    @Column(name = "SCREEN_NAME", length = 100)
    private String screenName;

    @Column(name = "SCREEN_LABEL", length = 100)
    private String screenLabel;

    @Column(name = "IS_ACTIVE", length = 1)
    private String isActive;

    @CreationTimestamp
    @Column(name = "CREATED_AT", updatable = false)
    private LocalDateTime createdAt;
}

/**
 * ENTITY: HELP_QUESTION_MASTER
 * Includes ID generation logic.
 */
@Data
@Entity
@Table(name = "HELP_QUESTION_MASTER")
public class HelpQuestionEntity implements Serializable {

    @Id
    @Column(name = "QUESTION_ID", length = 50)
    private String questionId;

    @Column(name = "SCREEN_NAME", length = 100, nullable = false)
    private String screenName;

    @Column(name = "QUESTION_TEXT", length = 500, nullable = false)
    private String questionText;

    // Use @Lob for Oracle CLOB types
    @Lob
    @Column(name = "ANSWER_CONTENT")
    private String answerContent;

    @Column(name = "ACTION_LINK")
    private String actionLink;

    @Column(name = "ACTION_LABEL")
    private String actionLabel;

    @Column(name = "REQUIRED_ACTION", length = 50)
    private String requiredAction; 

    @Column(name = "KEYWORDS", length = 1000)
    private String keywords; 

    @Column(name = "DISPLAY_ORDER")
    private Integer displayOrder;

    @Column(name = "IS_ACTIVE", length = 1)
    private String isActive;

    @CreationTimestamp
    @Column(name = "CREATED_AT", updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "UPDATED_AT")
    private LocalDateTime updatedAt;

    // Auto-generate UUID if missing
    @PrePersist
    public void prePersist() {
        if (this.questionId == null || this.questionId.isEmpty()) {
            this.questionId = UUID.randomUUID().toString().replace("-", "").substring(0, 32);
        }
    }
}

/**
 * ENTITY: HELP_FAQ_MASTER
 */
@Data
@Entity
@Table(name = "HELP_FAQ_MASTER")
public class HelpFaqEntity implements Serializable {

    @Id
    @Column(name = "FAQ_ID", length = 50)
    private String faqId;

    @Column(name = "QUESTION_TEXT", length = 500)
    private String questionText;

    @Lob
    @Column(name = "ANSWER_CONTENT")
    private String answerContent;

    @Column(name = "DISPLAY_ORDER")
    private Integer displayOrder;

    @Column(name = "IS_ACTIVE")
    private String isActive;

    @PrePersist
    public void prePersist() {
        if (this.faqId == null || this.faqId.isEmpty()) {
            this.faqId = UUID.randomUUID().toString();
        }
    }
}





















package com.fincore.HelpService.repository;

import com.fincore.HelpService.entity.HelpFaqEntity;
import com.fincore.HelpService.entity.HelpQuestionEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface HelpQuestionRepository extends JpaRepository<HelpQuestionEntity, String> {

    // For Context Mode: Select Module
    List<HelpQuestionEntity> findByScreenNameAndIsActiveOrderByDisplayOrderAsc(String screenName, String isActive);

    // For Search Mode: Fetch All Active
    List<HelpQuestionEntity> findByIsActive(String isActive);
}

@Repository
public interface HelpFaqRepository extends JpaRepository<HelpFaqEntity, String> {
    
    // Global FAQs
    List<HelpFaqEntity> findByIsActiveOrderByDisplayOrderAsc(String isActive);
}


























package com.fincore.HelpService.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.List;

public class HelpDTOs {

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class HelpRequestDTO {
        // Mode A: Context Fetch (Select from dropdown)
        private String screenName; 
        
        // Mode B: Free Text Search
        private String searchQuery; 

        // RBAC: Derived from Login Service Token on Frontend
        @NotNull(message = "User actions cannot be null")
        private List<String> userActions;

        private boolean fetchFaqs;
    }

    @Data
    @Builder
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class HelpResponseDTO {
        private String context; // e.g. "CGL Management" or "Search Results"
        private List<HelpItemDTO> results;
        private List<HelpItemDTO> faqs;
    }

    @Data
    @Builder
    public static class HelpItemDTO implements Serializable {
        private String id;
        private String text;       // Question
        private String answer;     // HTML Content
        private String actionLink; // Deep Link
        private String actionLabel;// Button Text
        private String type;       // QUESTION, FAQ, SEARCH_RESULT
    }
}





























package com.fincore.HelpService.service;

import com.fincore.HelpService.dto.HelpDTOs.*;
import com.fincore.HelpService.entity.HelpFaqEntity;
import com.fincore.HelpService.entity.HelpQuestionEntity;
import com.fincore.HelpService.repository.HelpFaqRepository;
import com.fincore.HelpService.repository.HelpQuestionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class HelpService {

    private final HelpQuestionRepository questionRepository;
    private final HelpFaqRepository faqRepository;

    private static final Set<String> STOP_WORDS = Set.of("how", "to", "i", "can", "do", "a", "the", "in", "on", "what", "is");

    /**
     * MAIN PROCESSOR
     */
    public HelpResponseDTO processRequest(HelpRequestDTO request) {
        
        // 1. Normalize Permissions
        List<String> userActions = (request.getUserActions() == null) 
                ? new ArrayList<>() 
                : request.getUserActions().stream()
                    .map(String::toUpperCase)
                    .map(String::trim)
                    .collect(Collectors.toList());

        List<HelpItemDTO> results = new ArrayList<>();
        String contextLabel = "";

        // 2. Determine Mode
        if (request.getSearchQuery() != null && request.getSearchQuery().length() > 2) {
            contextLabel = "Search Results";
            results = performSmartSearch(request.getSearchQuery(), userActions);
        } else if (request.getScreenName() != null) {
            contextLabel = request.getScreenName();
            results = fetchContextualHelp(request.getScreenName(), userActions);
        }

        // 3. Append FAQs
        List<HelpItemDTO> faqs = null;
        if (request.isFetchFaqs()) {
            faqs = fetchGlobalFaqs();
        }

        return HelpResponseDTO.builder()
                .context(contextLabel)
                .results(results)
                .faqs(faqs)
                .build();
    }

    // --- CONTEXT LOGIC ---
    private List<HelpItemDTO> fetchContextualHelp(String screenName, List<String> userActions) {
        List<HelpQuestionEntity> rawQuestions = getQuestionsForScreen(screenName.trim());
        return rawQuestions.stream()
                .filter(q -> isActionAllowed(q, userActions))
                .map(q -> mapToDTO(q, "QUESTION"))
                .collect(Collectors.toList());
    }

    // --- SEARCH LOGIC (FUZZY) ---
    private List<HelpItemDTO> performSmartSearch(String query, List<String> userActions) {
        List<HelpQuestionEntity> allQuestions = getAllActiveQuestions();
        
        // Better Tokenization: Split by non-word characters
        List<String> tokens = Arrays.stream(query.toLowerCase().split("\\W+")) 
                .filter(s -> !s.isEmpty() && !STOP_WORDS.contains(s))
                .collect(Collectors.toList());

        return allQuestions.stream()
                .filter(q -> isActionAllowed(q, userActions))
                .map(q -> new AbstractMap.SimpleEntry<>(q, calculateScore(q, tokens)))
                .filter(entry -> entry.getValue() > 0)
                .sorted((e1, e2) -> Integer.compare(e2.getValue(), e1.getValue()))
                .limit(5) // Top 5
                .map(entry -> mapToDTO(entry.getKey(), "SEARCH_RESULT"))
                .collect(Collectors.toList());
    }

    private int calculateScore(HelpQuestionEntity q, List<String> tokens) {
        int score = 0;
        String text = q.getQuestionText().toLowerCase();
        String keywords = (q.getKeywords() != null) ? q.getKeywords().toLowerCase() : "";
        String action = (q.getRequiredAction() != null) ? q.getRequiredAction().toLowerCase() : "";

        for (String token : tokens) {
            if (token.equals(action)) score += 50; // Intent match
            if (text.contains(token)) score += 20; // Exact text match
            if (keywords.contains(token)) score += 15; // Hidden keyword match
            if (fuzzyMatch(token, text)) score += 5; // Typo match
        }
        return score;
    }

    private boolean fuzzyMatch(String token, String target) {
        // Check against each word in target to avoid matching across word boundaries
        for(String word : target.split("\\W+")) {
            if (calculateDistance(token, word) <= 2 && token.length() > 3) return true;
        }
        return false;
    }

    private int calculateDistance(String x, String y) {
        int[][] dp = new int[x.length() + 1][y.length() + 1];
        for (int i = 0; i <= x.length(); i++) {
            for (int j = 0; j <= y.length(); j++) {
                if (i == 0) dp[i][j] = j;
                else if (j == 0) dp[i][j] = i;
                else dp[i][j] = Math.min(dp[i - 1][j - 1] + (x.charAt(i - 1) == y.charAt(j - 1) ? 0 : 1),
                            Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
            }
        }
        return dp[x.length()][y.length()];
    }

    // --- CACHING & UTILS ---
    @Cacheable(value = "help_questions", key = "#screenName")
    public List<HelpQuestionEntity> getQuestionsForScreen(String screenName) {
        return questionRepository.findByScreenNameAndIsActiveOrderByDisplayOrderAsc(screenName, "Y");
    }

    @Cacheable(value = "help_questions_all", key = "'active_global'")
    public List<HelpQuestionEntity> getAllActiveQuestions() {
        return questionRepository.findByIsActive("Y");
    }

    public List<HelpItemDTO> fetchGlobalFaqs() {
        return faqRepository.findByIsActiveOrderByDisplayOrderAsc("Y").stream()
                .map(f -> HelpItemDTO.builder().id(f.getFaqId()).text(f.getQuestionText()).answer(f.getAnswerContent()).type("FAQ").build())
                .collect(Collectors.toList());
    }

    private boolean isActionAllowed(HelpQuestionEntity q, List<String> userActions) {
        if (q.getRequiredAction() == null || q.getRequiredAction().trim().isEmpty()) return true;
        if (userActions.contains("ALL") || userActions.contains("*")) return true;
        return userActions.contains(q.getRequiredAction().toUpperCase());
    }

    private HelpItemDTO mapToDTO(HelpQuestionEntity q, String type) {
        return HelpItemDTO.builder()
                .id(q.getQuestionId())
                .text(q.getQuestionText())
                .answer(q.getAnswerContent())
                .actionLink(q.getActionLink())
                .actionLabel(q.getActionLabel())
                .type(type)
                .build();
    }
}





















package com.fincore.HelpService.controller;

import com.fincore.HelpService.dto.HelpDTOs.HelpRequestDTO;
import com.fincore.HelpService.dto.HelpDTOs.HelpResponseDTO;
import com.fincore.HelpService.service.HelpService;
import com.fincore.commonutilities.dto.ApiResponse; // Ensure this is imported
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/help")
@RequiredArgsConstructor
@Slf4j
public class HelpController {

    private final HelpService helpService;

    /**
     * Unified Help Endpoint.
     * Use ResponseEntity to bypass double-wrapping if ApiResponseWrapper is active.
     */
    @PostMapping("/fetch")
    public ResponseEntity<ApiResponse<HelpResponseDTO>> getHelp(@RequestBody @Valid HelpRequestDTO request) {
        
        long startTime = System.currentTimeMillis();
        try {
            HelpResponseDTO result = helpService.processRequest(request);
            
            log.info("Help processed in {}ms | Mode: {}", 
                     (System.currentTimeMillis() - startTime), 
                     (request.getSearchQuery() != null ? "Search" : "Context"));

            // Wrapping manually in ApiResponse
            ApiResponse<HelpResponseDTO> response = new ApiResponse<>(200, "Success", "Help content retrieved", result);
            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Help Service Error", e);
            return ResponseEntity.internalServerError()
                    .body(new ApiResponse<>(500, "Error", "Internal Server Error: " + e.getMessage(), null));
        }
    }
}
























package com.fincore.HelpService;

import com.fincore.commonutilities.config.RedisConfig;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Import;

@SpringBootApplication
@EnableCaching
@Import(RedisConfig.class) // Import the Redis configuration from Common Utils
public class HelpServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(HelpServiceApplication.class, args);
    }
}



