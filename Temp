<dependencies>
    <!-- Core Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Persistence -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>com.oracle.database.jdbc</groupId>
        <artifactId>ojdbc11</artifactId>
        <scope>runtime</scope>
    </dependency>

    <!-- Caching (Redis) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>

    <!-- Tools -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    
    <!-- Importing your Common Lib (Assuming it exists locally or in nexus) -->
    <!-- 
    <dependency>
        <groupId>com.fincore</groupId>
        <artifactId>common-utilities</artifactId>
        <version>1.0.0</version>
    </dependency> 
    -->
</dependencies>



















# ==============================================================
# FIN CORE - HELP SERVICE CONFIGURATION
# ==============================================================
spring.application.name=HelpService
server.port=9099

# --- ORACLE DATABASE ---
spring.datasource.url=jdbc:oracle:thin:@//10.1.1.1:1521/FINCOREDB
spring.datasource.username=FIN_HELP_USER
spring.datasource.password=YourSecurePassword
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# --- JPA / HIBERNATE ---
spring.jpa.database-platform=org.hibernate.dialect.OracleDialect
spring.jpa.show-sql=false
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.open-in-view=false

# --- REDIS CACHE ---
spring.data.redis.host=10.0.17.242
spring.data.redis.port=6379
spring.cache.type=redis
# Cache time-to-live (1 Hour) - Refresh help content every hour
spring.cache.redis.time-to-live=3600000

# --- LOGGING ---
logging.level.com.fincore.HelpService=INFO





















package com.fincore.HelpService.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * ENTITY: HELP_SCREEN_MASTER
 * Represents a functional module in the application (e.g., "CGL Management").
 */
@Data
@Entity
@Table(name = "HELP_SCREEN_MASTER")
public class HelpScreenEntity implements Serializable {
    
    @Id
    @Column(name = "SCREEN_NAME", length = 100)
    private String screenName; // Primary Key (Natural Key)

    @Column(name = "SCREEN_LABEL", length = 100)
    private String screenLabel;

    @Column(name = "IS_ACTIVE", length = 1)
    private String isActive;

    @CreationTimestamp
    @Column(name = "CREATED_AT", updatable = false)
    private LocalDateTime createdAt;
}

/**
 * ENTITY: HELP_QUESTION_MASTER
 * Represents individual help items. 
 * Includes logic for auto-generating UUIDs if not provided.
 */
@Data
@Entity
@Table(name = "HELP_QUESTION_MASTER")
public class HelpQuestionEntity implements Serializable {

    @Id
    @Column(name = "QUESTION_ID", length = 50)
    private String questionId;

    @Column(name = "SCREEN_NAME", length = 100, nullable = false)
    private String screenName;

    @Column(name = "QUESTION_TEXT", length = 500, nullable = false)
    private String questionText;

    @Lob
    @Column(name = "ANSWER_CONTENT")
    private String answerContent;

    @Column(name = "ACTION_LINK")
    private String actionLink;

    @Column(name = "ACTION_LABEL")
    private String actionLabel;

    @Column(name = "REQUIRED_ACTION", length = 50)
    private String requiredAction; // RBAC: 'CREATE', 'APPROVE', etc.

    @Column(name = "KEYWORDS", length = 1000)
    private String keywords; // Search Optimization

    @Column(name = "DISPLAY_ORDER")
    private Integer displayOrder;

    @Column(name = "IS_ACTIVE", length = 1)
    private String isActive;

    // --- ID GENERATION HOOK ---
    @PrePersist
    public void prePersist() {
        if (this.questionId == null || this.questionId.isEmpty()) {
            this.questionId = UUID.randomUUID().toString().replace("-", "").substring(0, 32);
        }
    }
}

/**
 * ENTITY: HELP_FAQ_MASTER
 * Global FAQs.
 */
@Data
@Entity
@Table(name = "HELP_FAQ_MASTER")
public class HelpFaqEntity implements Serializable {

    @Id
    @Column(name = "FAQ_ID", length = 50)
    private String faqId;

    @Column(name = "QUESTION_TEXT", length = 500)
    private String questionText;

    @Lob
    @Column(name = "ANSWER_CONTENT")
    private String answerContent;

    @Column(name = "DISPLAY_ORDER")
    private Integer displayOrder;

    @Column(name = "IS_ACTIVE")
    private String isActive;

    @PrePersist
    public void prePersist() {
        if (this.faqId == null || this.faqId.isEmpty()) {
            this.faqId = UUID.randomUUID().toString();
        }
    }
}



















package com.fincore.HelpService.repository;

import com.fincore.HelpService.entity.HelpFaqEntity;
import com.fincore.HelpService.entity.HelpQuestionEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface HelpQuestionRepository extends JpaRepository<HelpQuestionEntity, String> {

    // Fetch active questions for a specific screen (Context Flow)
    List<HelpQuestionEntity> findByScreenNameAndIsActiveOrderByDisplayOrderAsc(String screenName, String isActive);

    // Fetch ALL active questions (Search Flow - to be cached)
    List<HelpQuestionEntity> findByIsActive(String isActive);
}

@Repository
public interface HelpFaqRepository extends JpaRepository<HelpFaqEntity, String> {
    
    // Fetch Global FAQs
    List<HelpFaqEntity> findByIsActiveOrderByDisplayOrderAsc(String isActive);
}












package com.fincore.HelpService.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.List;

public class HelpDTOs {

    /**
     * Request Payload for Contextual Fetch or Search
     */
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class HelpRequestDTO {
        // Mode 1: Context Fetch
        private String screenName; 
        
        // Mode 2: Search
        private String searchQuery; 

        // RBAC: User's Allowed Actions (from Login Token)
        // e.g., ["VIEW", "CREATE", "APPROVE"]
        @NotNull(message = "User actions cannot be null")
        private List<String> userActions;

        private boolean fetchFaqs;
    }

    /**
     * Standard Response
     */
    @Data
    @Builder
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class HelpResponseDTO {
        private String context; // Screen Name or "Search Results"
        private List<HelpItemDTO> results;
        private List<HelpItemDTO> faqs;
    }

    /**
     * Individual Item (Question/Answer)
     */
    @Data
    @Builder
    public static class HelpItemDTO implements Serializable {
        private String id;
        private String text;       // The Question
        private String answer;     // The Answer (HTML/Text)
        private String actionLink; // Deep Link
        private String actionLabel;// Button Text
        private String type;       // QUESTION, FAQ, SEARCH_RESULT
        private double searchScore; // Internal use (optional to expose)
    }
}














package com.fincore.HelpService.service;

import com.fincore.HelpService.dto.HelpDTOs.*;
import com.fincore.HelpService.entity.HelpFaqEntity;
import com.fincore.HelpService.entity.HelpQuestionEntity;
import com.fincore.HelpService.repository.HelpFaqRepository;
import com.fincore.HelpService.repository.HelpQuestionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class HelpService {

    private final HelpQuestionRepository questionRepository;
    private final HelpFaqRepository faqRepository;

    // Words to ignore in search to improve relevance
    private static final Set<String> STOP_WORDS = Set.of("how", "to", "i", "can", "do", "a", "the", "in", "on");

    /**
     * ORCHESTRATOR: Decides whether to Fetch by Screen OR Perform Search
     */
    public HelpResponseDTO processRequest(HelpRequestDTO request) {
        
        // 1. Normalize User Actions (Upper Case for safety)
        List<String> userActions = (request.getUserActions() == null) 
                ? new ArrayList<>() 
                : request.getUserActions().stream().map(String::toUpperCase).collect(Collectors.toList());

        List<HelpItemDTO> results = new ArrayList<>();
        String contextLabel = "";

        // 2. SEARCH MODE
        if (request.getSearchQuery() != null && request.getSearchQuery().length() > 2) {
            contextLabel = "Search Results";
            results = performSmartSearch(request.getSearchQuery(), userActions);
        } 
        // 3. CONTEXT MODE (Select Module)
        else if (request.getScreenName() != null) {
            contextLabel = request.getScreenName();
            results = fetchContextualHelp(request.getScreenName(), userActions);
        }

        // 4. Attach FAQs if requested
        List<HelpItemDTO> faqs = null;
        if (request.isFetchFaqs()) {
            faqs = fetchGlobalFaqs();
        }

        return HelpResponseDTO.builder()
                .context(contextLabel)
                .results(results)
                .faqs(faqs)
                .build();
    }

    // =========================================================================
    // LOGIC 1: CONTEXTUAL FETCH
    // =========================================================================
    
    private List<HelpItemDTO> fetchContextualHelp(String screenName, List<String> userActions) {
        // Fetch from Cache/DB
        List<HelpQuestionEntity> rawQuestions = getQuestionsForScreen(screenName.trim());

        // Filter by Action Permissions
        return rawQuestions.stream()
                .filter(q -> isActionAllowed(q, userActions))
                .map(q -> mapToDTO(q, "QUESTION"))
                .collect(Collectors.toList());
    }

    // =========================================================================
    // LOGIC 2: SMART FUZZY SEARCH
    // =========================================================================

    private List<HelpItemDTO> performSmartSearch(String query, List<String> userActions) {
        // Fetch ALL questions (Cached)
        List<HelpQuestionEntity> allQuestions = getAllActiveQuestions();

        // Tokenize Query (e.g., "create cgl" -> ["create", "cgl"])
        List<String> tokens = Arrays.stream(query.toLowerCase().split("\\s+"))
                .filter(s -> !STOP_WORDS.contains(s))
                .collect(Collectors.toList());

        // Score, Filter & Sort
        return allQuestions.stream()
                .filter(q -> isActionAllowed(q, userActions)) // RBAC Check
                .map(q -> new AbstractMap.SimpleEntry<>(q, calculateScore(q, tokens)))
                .filter(entry -> entry.getValue() > 0) // Remove irrelevant
                .sorted((e1, e2) -> Integer.compare(e2.getValue(), e1.getValue())) // Sort High to Low
                .limit(5) // Top 5 Only
                .map(entry -> mapToDTO(entry.getKey(), "SEARCH_RESULT"))
                .collect(Collectors.toList());
    }

    // Custom Scoring Algorithm (No AI needed)
    private int calculateScore(HelpQuestionEntity q, List<String> tokens) {
        int score = 0;
        String text = q.getQuestionText().toLowerCase();
        String keywords = (q.getKeywords() != null) ? q.getKeywords().toLowerCase() : "";
        String action = (q.getRequiredAction() != null) ? q.getRequiredAction().toLowerCase() : "";

        for (String token : tokens) {
            // 1. Action Match (Intent) - Huge Boost
            if (token.equals(action)) score += 50;
            
            // 2. Exact Word Match in Text
            if (text.contains(token)) score += 20;
            
            // 3. Keyword Match (Hidden synonyms)
            if (keywords.contains(token)) score += 15;

            // 4. Fuzzy Match (Typo tolerance)
            // If token is 'cretae' and text has 'create'
            if (fuzzyMatch(token, text)) score += 5;
        }
        return score;
    }

    // Simple Levenshtein check (tolerance of 2 edits for words > 4 chars)
    private boolean fuzzyMatch(String token, String target) {
        if (target.contains(token)) return true;
        // Simplified loop over words in target for performance
        for(String word : target.split(" ")) {
            if (calculateDistance(token, word) <= 2 && token.length() > 3) return true;
        }
        return false;
    }

    // Standard Edit Distance Algo
    private int calculateDistance(String x, String y) {
        int[][] dp = new int[x.length() + 1][y.length() + 1];
        for (int i = 0; i <= x.length(); i++) {
            for (int j = 0; j <= y.length(); j++) {
                if (i == 0) dp[i][j] = j;
                else if (j == 0) dp[i][j] = i;
                else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1] + (x.charAt(i - 1) == y.charAt(j - 1) ? 0 : 1),
                            Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }
        return dp[x.length()][y.length()];
    }

    // =========================================================================
    // CACHING & UTILS
    // =========================================================================

    @Cacheable(value = "help_questions", key = "#screenName")
    public List<HelpQuestionEntity> getQuestionsForScreen(String screenName) {
        return questionRepository.findByScreenNameAndIsActiveOrderByDisplayOrderAsc(screenName, "Y");
    }

    @Cacheable(value = "help_questions_all", key = "'active_global'")
    public List<HelpQuestionEntity> getAllActiveQuestions() {
        return questionRepository.findByIsActive("Y");
    }

    public List<HelpItemDTO> fetchGlobalFaqs() {
        // FAQs can also be cached separately
        return faqRepository.findByIsActiveOrderByDisplayOrderAsc("Y").stream()
                .map(f -> HelpItemDTO.builder().id(f.getFaqId()).text(f.getQuestionText()).answer(f.getAnswerContent()).type("FAQ").build())
                .collect(Collectors.toList());
    }

    private boolean isActionAllowed(HelpQuestionEntity q, List<String> userActions) {
        // If question has no restricted action, it's public for that screen
        if (q.getRequiredAction() == null || q.getRequiredAction().isEmpty()) return true;
        // Super Admin Bypass
        if (userActions.contains("ALL") || userActions.contains("*")) return true;
        // Check List Inclusion
        return userActions.contains(q.getRequiredAction().toUpperCase());
    }

    private HelpItemDTO mapToDTO(HelpQuestionEntity q, String type) {
        return HelpItemDTO.builder()
                .id(q.getQuestionId())
                .text(q.getQuestionText())
                .answer(q.getAnswerContent())
                .actionLink(q.getActionLink())
                .actionLabel(q.getActionLabel())
                .type(type)
                .build();
    }
}

























package com.fincore.HelpService.controller;

import com.fincore.HelpService.dto.HelpDTOs.HelpRequestDTO;
import com.fincore.HelpService.dto.HelpDTOs.HelpResponseDTO;
import com.fincore.HelpService.service.HelpService;
import com.fincore.commonutilities.dto.ApiResponse; // From your common lib
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/help")
@RequiredArgsConstructor
@Slf4j
public class HelpController {

    private final HelpService helpService;

    /**
     * Unified Endpoint for Help.
     * Handles both "Select Screen" and "Search/Type" flows based on payload.
     * * @param request Contains screenName OR searchQuery + userActions
     * @return Filtered list of questions/answers
     */
    @PostMapping("/fetch")
    public ApiResponse<HelpResponseDTO> getHelp(@RequestBody @Valid HelpRequestDTO request) {
        
        long startTime = System.currentTimeMillis();
        try {
            HelpResponseDTO response = helpService.processRequest(request);
            
            log.info("Help processed in {}ms | Context: {} | Results: {}", 
                    (System.currentTimeMillis() - startTime), 
                    response.getContext(), 
                    response.getResults().size());

            return new ApiResponse<>(200, "Success", "Help content retrieved", response);

        } catch (Exception e) {
            log.error("Error processing help request", e);
            return new ApiResponse<>(500, "Error", "Internal Server Error", null);
        }
    }
}

























package com.fincore.HelpService;

import com.fincore.commonutilities.config.RedisConfig;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Import;

@SpringBootApplication
@EnableCaching
@Import(RedisConfig.class) // Ensures Redis Template is loaded from Common Utils
public class HelpServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(HelpServiceApplication.class, args);
    }
}








