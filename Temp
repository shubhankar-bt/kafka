airflow-trigger-service
├── src/main/java
│   └── com.example.airflow
│       ├── AirflowTriggerApplication.java
│       ├── config
│       │   ├── WebClientConfig.java
│       │   └── AirflowProperties.java
│       ├── controller
│       │   └── AirflowController.java
│       ├── service
│       │   ├── AirflowService.java
│       │   └── impl
│       │       └── AirflowServiceImpl.java
│       ├── client
│       │   └── AirflowClient.java
│       ├── dto
│       │   ├── AirflowTriggerRequest.java
│       │   └── AirflowTriggerResponse.java
│       ├── exception
│       │   ├── AirflowException.java
│       │   └── GlobalExceptionHandler.java
│       └── util
│           └── JsonUtil.java
└── src/main/resources
    └── application.yml


















<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.1</version>
        <relativePath/> 
    </parent>
    <groupId>com.example</groupId>
    <artifactId>process-service</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <name>process-service</name>
    <description>Service to trigger Airflow DAGs</description>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.retry</groupId>
            <artifactId>spring-retry</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>



















server:
  port: 8080

spring:
  application:
    name: process-status-service

# Custom Airflow Configuration
airflow:
  # Ensure this points to the API root. For Airflow 2+, usually /api/v1
  base-url: "http://localhost:8080/api/v1"
  username: "airflow-admin" 
  password: "superuser-password" # Inject this via ENV variables in Prod
  # Timeouts in milliseconds
  connect-timeout: 5000
  read-timeout: 10000

logging:
  level:
    com.example.process: DEBUG
    org.springframework.web.reactive.function.client: INFO













package com.example.process.config;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Positive;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.validation.annotation.Validated;

@Data
@Validated
@Configuration
@ConfigurationProperties(prefix = "airflow")
public class AirflowProperties {

    @NotBlank(message = "Airflow Base URL must be configured")
    private String baseUrl;

    @NotBlank(message = "Airflow Username is required")
    private String username;

    @NotBlank(message = "Airflow Password is required")
    private String password;

    @Positive
    private int connectTimeout = 5000;

    @Positive
    private int readTimeout = 10000;
}


















package com.example.process.config;

import io.netty.channel.ChannelOption;
import io.netty.handler.timeout.ReadTimeoutHandler;
import io.netty.handler.timeout.WriteTimeoutHandler;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.netty.http.client.HttpClient;

import java.time.Duration;
import java.util.Base64;
import java.util.concurrent.TimeUnit;

@Slf4j
@Configuration
@RequiredArgsConstructor
public class WebClientConfig {

    private final AirflowProperties properties;

    @Bean
    public WebClient airflowWebClient() {
        log.info("Configuring Airflow WebClient with Base URL: {}", properties.getBaseUrl());

        // Configure timeouts
        HttpClient httpClient = HttpClient.create()
                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, properties.getConnectTimeout())
                .responseTimeout(Duration.ofMillis(properties.getReadTimeout()))
                .doOnConnected(conn -> 
                        conn.addHandlerLast(new ReadTimeoutHandler(properties.getReadTimeout(), TimeUnit.MILLISECONDS))
                            .addHandlerLast(new WriteTimeoutHandler(properties.getReadTimeout(), TimeUnit.MILLISECONDS)));

        // Configure Basic Auth
        String basicAuth = "Basic " + Base64.getEncoder().encodeToString(
                (properties.getUsername() + ":" + properties.getPassword()).getBytes());

        return WebClient.builder()
                .baseUrl(properties.getBaseUrl())
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .defaultHeader(HttpHeaders.AUTHORIZATION, basicAuth)
                .clientConnector(new ReactorClientHttpConnector(httpClient))
                .build();
    }
}




















package com.example.process.model.request;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AirflowTriggerRequest {

    @NotBlank(message = "DAG ID is mandatory")
    @Pattern(regexp = "^[a-zA-Z0-9_\\-\\.]+$", message = "DAG ID contains invalid characters")
    @JsonProperty("dag_id") // Maps frontend JSON "dag_id" to this field
    private String dagId;

    @JsonProperty("dag_run_id")
    private String dagRunId; // Optional: User defined ID

    @JsonProperty("conf")
    private Map<String, Object> payload; // The actual data to pass to Airflow
}

















package com.example.process.model.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;
import lombok.Data;

import java.time.LocalDateTime;

@Data
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class AirflowTriggerResponse {
    
    private String status;
    private String message;
    
    @JsonProperty("dag_run_id")
    private String dagRunId;
    
    @JsonProperty("logical_date")
    private String logicalDate;
    
    @JsonProperty("triggered_at")
    private LocalDateTime triggeredAt;
}


















package com.example.process.exception;

import org.springframework.http.HttpStatusCode;

public class AirflowIntegrationException extends RuntimeException {
    
    private final HttpStatusCode statusCode;

    public AirflowIntegrationException(String message, HttpStatusCode statusCode) {
        super(message);
        this.statusCode = statusCode;
    }

    public HttpStatusCode getStatusCode() {
        return statusCode;
    }
}















package com.example.process.client;

import com.example.process.exception.AirflowIntegrationException;
import com.example.process.model.request.AirflowTriggerRequest;
import com.fasterxml.jackson.databind.JsonNode;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatusCode;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.util.HashMap;
import java.util.Map;

@Slf4j
@Component
@RequiredArgsConstructor
public class AirflowRestClient {

    private final WebClient airflowWebClient;

    /**
     * Calls Airflow REST API: POST /dags/{dag_id}/dagRuns
     */
    public Mono<JsonNode> triggerDagRun(AirflowTriggerRequest request) {
        String uri = String.format("/dags/%s/dagRuns", request.getDagId());
        
        // Construct the body strictly as Airflow expects
        Map<String, Object> body = new HashMap<>();
        if (request.getPayload() != null) {
            body.put("conf", request.getPayload());
        }
        if (request.getDagRunId() != null) {
            body.put("dag_run_id", request.getDagRunId());
        }

        log.debug("Sending request to Airflow URI: {} with payload keys: {}", uri, body.keySet());

        return airflowWebClient.post()
                .uri(uri)
                .bodyValue(body)
                .retrieve()
                .onStatus(HttpStatusCode::is4xxClientError, response -> 
                    response.bodyToMono(String.class).flatMap(errorBody -> {
                        log.error("Airflow Client Error {}: {}", response.statusCode(), errorBody);
                        return Mono.error(new AirflowIntegrationException(
                            "Client Error: " + errorBody, response.statusCode()));
                    })
                )
                .onStatus(HttpStatusCode::is5xxServerError, response -> 
                    response.bodyToMono(String.class).flatMap(errorBody -> {
                        log.error("Airflow Server Error {}: {}", response.statusCode(), errorBody);
                        return Mono.error(new AirflowIntegrationException(
                            "Airflow Server Error", response.statusCode()));
                    })
                )
                .bodyToMono(JsonNode.class)
                .doOnSuccess(json -> log.debug("Successfully triggered DAG. Airflow State: {}", 
                        json.path("state").asText()));
    }
}

















package com.example.process.service.impl;

import com.example.process.client.AirflowRestClient;
import com.example.process.model.request.AirflowTriggerRequest;
import com.example.process.model.response.AirflowTriggerResponse;
import com.example.process.service.AirflowService;
import com.fasterxml.jackson.databind.JsonNode;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;

@Slf4j
@Service
@RequiredArgsConstructor
public class AirflowServiceImpl implements AirflowService {

    private final AirflowRestClient airflowRestClient;

    @Override
    public Mono<AirflowTriggerResponse> triggerWorkflow(AirflowTriggerRequest request) {
        log.info("Processing trigger request for DAG: {}", request.getDagId());

        return airflowRestClient.triggerDagRun(request)
                .map(this::mapToResponse);
    }

    private AirflowTriggerResponse mapToResponse(JsonNode airflowResponse) {
        // Safe parsing of JSON response from Airflow
        String dagRunId = airflowResponse.has("dag_run_id") ? 
                airflowResponse.get("dag_run_id").asText() : "unknown";
        
        String logicalDate = airflowResponse.has("logical_date") ? 
                airflowResponse.get("logical_date").asText() : null;

        String state = airflowResponse.has("state") ? 
                airflowResponse.get("state").asText() : "queued";

        return AirflowTriggerResponse.builder()
                .status(state)
                .message("Successfully triggered DAG run")
                .dagRunId(dagRunId)
                .logicalDate(logicalDate)
                .triggeredAt(LocalDateTime.now())
                .build();
    }
}


















package com.example.process.controller;

import com.example.process.model.request.AirflowTriggerRequest;
import com.example.process.model.response.AirflowTriggerResponse;
import com.example.process.service.AirflowService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

@Slf4j
@RestController
@RequestMapping("/api/v1/airflow")
@RequiredArgsConstructor
public class AirflowController {

    private final AirflowService airflowService;

    @PostMapping("/trigger")
    public Mono<ResponseEntity<AirflowTriggerResponse>> triggerDag(
            @Valid @RequestBody AirflowTriggerRequest request) {
        
        log.info("Received request to trigger DAG: {}", request.getDagId());

        return airflowService.triggerWorkflow(request)
                .map(response -> ResponseEntity.ok(response));
    }
}





















package com.example.process.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AirflowIntegrationException.class)
    public ResponseEntity<Map<String, Object>> handleAirflowException(AirflowIntegrationException ex) {
        log.error("Upstream Airflow Error: {}", ex.getMessage());
        return buildResponse(ex.getStatusCode().value() == 404 ? HttpStatus.NOT_FOUND : HttpStatus.BAD_GATEWAY, 
                ex.getMessage());
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        log.warn("Validation Error: {}", errors);
        
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("errors", errors);
        
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleGeneralException(Exception ex) {
        log.error("Unexpected Error", ex);
        return buildResponse(HttpStatus.INTERNAL_SERVER_ERROR, "Internal System Error");
    }

    private ResponseEntity<Map<String, Object>> buildResponse(HttpStatus status, String message) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", status.value());
        body.put("error", status.getReasonPhrase());
        body.put("message", message);
        return new ResponseEntity<>(body, status);
    }
}

























package com.example.process;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.retry.annotation.EnableRetry;

@EnableRetry
@SpringBootApplication
public class ProcessApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProcessApplication.class, args);
    }
}






{
  "dag_id": "example_bash_operator",
  "conf": {
    "client_name": "Acme Corp",
    "file_id": "12345"
  }
}




