1) Currently when the screen loads, i get the min date in types api call as selectedDate which is already p[resent in the code. But the issue is with thye date picker. In my current code i am allpowing the user to enter the dates and also select dates fropm date picker, in date picker as min date is set to a 
specific date so in date picker prior dates are invalid but while user enters manually any date before the min date then it allows to type the date, proper error is hsowing in the error text that dates can not be prior to min date, 
but in that time if i open the date picker then the fdate types in the text input the date pi9cker opened froom then, like if i type 1999 then in date picker 1999 opened although it is not enabled, still open so much old date which is not allowed,
and also disabled does not make any sense. I want to handle this case very carefully and correctly so that in every cxase it should behavce correctly and no further issues come in it.  
2) dates in the input are MM/DD/YYYY format, i want DD/MM/YYYY formaty also the backspace and enter new date with momnth and year should be working as how the actual system should work. Iijn all cases see all tthe behaviours as per user perdpsective and see what could be done to achive best practices.
3) Once check the full code from first tom last and If any other issue you found in the code, please check and do the needful. 


import { useEffect, useState } from "react";
import {
  Box,
  Typography,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Stack,
  Button,
  Card,
  LinearProgress,
  Grow,
  Fade,
} from "@mui/material";
import { AdapterDayjs } from "@mui/x-date-pickers/AdapterDayjs";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import {
  Summarize,
  CloudDownloadTwoTone,
  LooksOne,
  LooksTwo,
  Looks3,
} from "@mui/icons-material";
import useApi from "../../hooks/useApi";
import dayjs from "dayjs";
import { useSelector } from "react-redux";
import useCustomSnackbar from "../../utils/useCustomSnackbar";
import { useTheme } from "@mui/material/styles";
import CustomChip from "../../utils/CustomChip";
import GlifReportsStyles from "./GlifReportsStyles";
import HybridDatePicker from "./HybridDatePicker";

export default function GlifReports() {
  const { callApi } = useApi();
  const showSnackBar = useCustomSnackbar();
  const user = useSelector((state) => state.auth.user);
  const [dateError, setDateError] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [repTypes, setRepTypes] = useState([]);
  const [selectedReport, setReport] = useState(null);
  const [selectedDate, setDate] = useState(null);
  const [open, setOpen] = useState(null);

  // NEW: streaming progress state
  const [isDownloading, setIsDownloading] = useState(false);
  const [downloadedBytes, setDownloadedBytes] = useState(0);
  const [minDate, setMinDate] = useState("");

  const theme = useTheme();
  const styles = GlifReportsStyles(theme);

  const disableInputs = isLoading || isDownloading;

  const downloadedMB =
    downloadedBytes > 0 ? (downloadedBytes / (1024 * 1024)).toFixed(2) : null;

  //Getting Reports Types list
  useEffect(() => {
    async function fetchData() {
      setIsLoading(true);
      try {
        const data = await callApi(
          "/RS/reports/types",
          { roleId: user.role },
          "POST"
        );
        setRepTypes(data.data || []);
        setMinDate(data.data[0]?.selectedDate || "2025-10-01");
      } catch (error) {
        console.error("Failed to fetch report types:", error);
      }
      setIsLoading(false);
    }
    fetchData();
  }, [callApi, user.role]);

  const handleSelect = (report) => {
    setReport(report);
  };

  const handleFetchReportData = async () => {
    if (!selectedReport?.fileName || !selectedDate) return;

    setIsLoading(true);
    setIsDownloading(true);
    setDownloadedBytes(0);

    const payload = {
      fileName: selectedReport.fileName,
      date: selectedDate.format("YYYY-MM-DD"),
      roleId: user.role,
    };

    try {
      const response = await callApi(
        "/RS/reports/download",
        payload,
        "POST",
        "blob",
        "application/json",
        {
          // axios streaming progress (no total because no Content-Length)
          onDownloadProgress: (event) => {
            setIsDownloading(true);
            if (event && typeof event.loaded === "number") {
              setDownloadedBytes(event.loaded);
            }
          },
        },
        false // get full axios response, not only data
      );

      if (response.data && response.data.size > 22) {
        // axios headers is a plain object, not Headers
        const contentDisposition =
          response.headers["content-disposition"] ||
          response.headers["Content-Disposition"];

        let filename = "report.zip";
        if (
          contentDisposition &&
          contentDisposition.indexOf("attachment") !== -1
        ) {
          const filenameMatch = contentDisposition.match(/filename="(.+?)"/);
          if (filenameMatch && filenameMatch.length > 1) {
            filename = filenameMatch[1];
          }
        }

        const downloadUrl = window.URL.createObjectURL(response.data);
        const a = document.createElement("a");
        a.href = downloadUrl;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(downloadUrl);
        showSnackBar(
          `Reports "${filename}" downloaded successfully`,
          "success"
        );
      } else {
        showSnackBar(
          "No reports found matching your current filter criteria",
          "warning"
        );
      }
    } catch (error) {
      console.log("error", error);

      if (error) {
        // The server sent an error (JSON), but Axios wrapped it in a Blob because of responseType: 'blob'
        // We must read that Blob as text to see the JSON message.
        const errorBlob = error;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const errorJson = JSON.parse(reader.result);
            console.error(errorJson.message);
            // SHOW TOAST / NOTIFICATION HERE
            showSnackBar(
              "No reports found matching your current filter criteria",
              "error"
            );
          } catch (e) {
            console.error(e);
            showSnackBar("Something went wrong, kindly try again.", "error");
          }
        };
        reader.readAsText(errorBlob);
      } else {
        // Network error (Server down, DNS issues)
        showSnackBar("Network Error: Could not connect to server");
      }
    } finally {
      setIsLoading(false);
      setIsDownloading(false);
      setDownloadedBytes(0);
    }
  };

  const getErrorMessage = (error) => {
    switch (error) {
      case "maxDate":
        return "Date cannot be in the future";
      case "minDate":
        return "Date is before the allowed minimum";
      case "invalidDate":
        return "Invalid date format";
      default:
        return "";
    }
  };

  return (
    <>
      <Grow in timeout={500}>
        <Stack spacing={4}>
          <Box sx={styles.rootBox} elevation={10}>
            <Stack
              spacing={3}
              direction={"column"}
              alignItems="center"
              justifyContent="center"
            >
              <Card sx={styles.card}>
                <Box sx={styles.headerContainer}>
                  <Box sx={styles.headerIconWrapper}>
                    <Summarize sx={styles.summaryIcon} />
                  </Box>
                  <Box sx={styles.headerTextBox}>
                    <Typography
                      variant="h5"
                      fontWeight="bold"
                      sx={styles.headerTitle}
                    >
                      Reports Generation
                    </Typography>
                    <Typography variant="body2" sx={styles.headerSubtitle}>
                      Choose a specific required report type and date using the
                      criteria below to download reports
                      {/* on-demand with streaming delivery. */}
                    </Typography>
                  </Box>
                </Box>
                {/* Steps description */}
                <Box sx={styles.noteContainer}>
                  <Typography variant="body2" sx={styles.noteText}>
                    Note: The generated reports cannot be viewed on-screen it
                    can only be downloaded.
                  </Typography>
                  <Stack direction="row" spacing={2} sx={styles.stepsStack}>
                    <CustomChip
                      label="Select a report"
                      variant="outlined"
                      icon={<LooksOne />}
                      color="info"
                      // sx={styles.stepChip}
                    />
                    <CustomChip
                      label="Select the report date for which you would like to download"
                      variant="outlined"
                      icon={<LooksTwo />}
                      color="info"
                      // sx={styles.stepChip}
                    />
                    <CustomChip
                      label="Click Fetch & Download button"
                      variant="outlined"
                      icon={<Looks3 />}
                      color="info"
                      // sx={styles.stepChip}
                    />
                  </Stack>
                </Box>

                <Box sx={styles.inputOuterBox}>
                  <Box sx={styles.inputInnerBox}>
                    {/* Dropdown Menu */}
                    <FormControl sx={styles.formControl}>
                      <InputLabel id="menu-select-label">
                        Select a report
                      </InputLabel>
                      <Select
                        labelId="menu-select-label"
                        id="menu-select"
                        value={selectedReport}
                        label="Select a report"
                        onChange={(row) => handleSelect(row.target.value)}
                        disabled={repTypes.length === 0 || disableInputs}
                      >
                        {repTypes.map((item) => (
                          <MenuItem key={item.fileName} value={item}>
                            {item.reportName}
                          </MenuItem>
                        ))}
                      </Select>
                    </FormControl>

                    {/* Date Picker */}
                    <FormControl sx={styles.formControl}>
                      <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DatePicker
                          label="Select report date"
                          views={["year", "month", "day"]}
                          value={selectedDate}
                          onChange={(newDate) => setDate(newDate)}
                          maxDate={dayjs()}
                          minDate={dayjs(minDate)}
                          onError={(newError) => setDateError(newError)}
                          disabled={repTypes.length === 0 || disableInputs}
                          slotProps={{
                            textField: {
                              helperText: getErrorMessage(dateError),
                              error: !!dateError,
                            },
                          }}
                        />
                      </LocalizationProvider>
                    </FormControl>
                  </Box>
                </Box>

                <Box sx={styles.buttonContainer}>
                  <Button
                    sx={styles.downloadButton}
                    endIcon={<CloudDownloadTwoTone />}
                    variant="contained"
                    onClick={handleFetchReportData}
                    disabled={
                      disableInputs ||
                      !selectedReport ||
                      !selectedDate ||
                      getErrorMessage(dateError)
                    }
                  >
                    {isDownloading ? "Downloading..." : "Fetch & Download"}
                  </Button>

                  {/* Customised progress UI */}
                  <Fade in={isDownloading} unmountOnExit>
                    <Box sx={styles.progressContainer}>
                      {/* Status header */}
                      <Box sx={styles.progressHeader}>
                        <Box sx={styles.progressIconWrapper}>
                          <CloudDownloadTwoTone sx={styles.innerDownloadIcon} />
                        </Box>
                        <Box sx={styles.progressHeaderTextBox}>
                          <Typography variant="body2" fontWeight={600}>
                            Downloading{" "}
                            {selectedReport?.reportName ??
                              "the selected report"}{" "}
                            for the period{" "}
                            {selectedDate?.format("YYYY-MM-DD") ??
                              "an unknown period"}{" "}
                            is in progress.
                          </Typography>

                          <Typography
                            variant="caption"
                            color="text.secondary"
                            sx={styles.progressCaption}
                          >
                            {downloadedMB
                              ? `Streaming report data… ${downloadedMB} MB received`
                              : "Preparing your report stream…"}
                          </Typography>
                        </Box>

                        {downloadedMB && (
                          <CustomChip
                            color="error"
                            label={`${downloadedMB} MB downloaded`}
                            variant="filled"
                          />
                        )}
                      </Box>
                      {/* Fancy progress bar */}
                      <LinearProgress
                        variant="indeterminate"
                        sx={styles.progressBar}
                      />
                    </Box>
                  </Fade>
                </Box>
              </Card>
            </Stack>
          </Box>
        </Stack>
      </Grow>
    </>
  );
}
