import React from "react";
import { Stack, MenuItem, TextField, Autocomplete } from "@mui/material";
import dayjs from "dayjs";
import { TextFieldStyle, TextField1Style } from "./BranchMasterStyle";
import CustomAutoComplete from "./CustomAutoComplete";
import CustomDatePicker from "./CustomDatePicker";
const branchTypeOptions = [
  { value: "A", label: "Automated" },
  { value: "M", label: "Manual" },
];

const emailDomain = "@sbi.co.in";

const BranchForm = ({
  branchData,
  errors,
  circles,
  states,
  mwb,
  mwbLoading,
  mwbInputValue,
  editingId,
  handleChange,
  handleDateChange,
  handleAutoCompleteChange,
  handleMwbInputChange,
}) => {
  // Logic helpers
  const isClosed =
    branchData.status === "InActive" || branchData.status === "Closed";
  const isMerged = !!branchData.mergedWithBranch;
  const canEnabledMergeDate = !!branchData?.mergedWithBranch?.code && !isClosed;

  const startOfCurrentMonth = dayjs().startOf("month");
  const endOfCurrentMonth = dayjs().endOf("month");
  const today = dayjs();

  return (
    <Stack direction={"column"} spacing={2}>
      {/* --- Row 1 --- */}
      <Stack direction={"row"} spacing={1}>
        <TextFieldStyle
          fullWidth
          label="Branch Code *"
          name="code"
          value={branchData.code}
          onChange={handleChange}
          disabled={!!editingId}
          error={!!errors.code}
          helperText={errors.code || "Exactly 5 digits"}
          inputProps={{ maxLength: 5, inputMode: "numeric" }}
        />

        <TextFieldStyle
          fullWidth
          label="Branch Name *"
          name="name"
          value={branchData.name}
          onChange={handleChange}
          error={!!errors.name}
          inputProps={{ maxLength: 50 }}
          helperText={
            errors.name || "Allowed 3-50 letters,numbers,spaces,/&()-,."
          }
        />

        <Autocomplete
          fullWidth
          options={circles}
          getOptionLabel={(option) =>
            `${option.circleCode} - ${option.circleName}`
          }
          value={
            circles.find((c) => c.circleCode === branchData.circleCode) || null
          }
          onChange={(_, value) => {
            handleChange({
              target: {
                name: "circleCode",
                value: value?.circleCode || "",
              },
            });
          }}
          renderInput={(params) => (
            <TextFieldStyle
              {...params}
              label="Circle Code *"
              error={!!errors.circleCode}
              helperText={errors.circleCode || ""}
              inputProps={{
                ...params.inputProps,
                maxLength: 50,
              }}
            />
          )}
        />
      </Stack>

      {/* --- Row 2 --- */}
      <Stack direction={"row"} spacing={1}>
        <Autocomplete
          fullWidth
          options={states}
          getOptionLabel={(option) =>
            // `${option.stateCode} - ${option.stateName}`
            `${option.stateName}`
          }
          value={states.find((s) => s.stateCode === branchData.state) || null}
          onChange={(_, value) => {
            handleChange({
              target: {
                name: "state",
                value: value?.stateCode || "",
              },
            });
          }}
          renderInput={(params) => (
            <TextFieldStyle
              {...params}
              label="State *"
              error={!!errors.state}
              helperText={errors.state}
              inputProps={{
                ...params.inputProps,
                maxLength: 50,
              }}
            />
          )}
        />

        <TextFieldStyle
          fullWidth
          label="City *"
          name="city"
          value={branchData.city}
          onChange={handleChange}
          error={!!errors.city}
          inputProps={{ maxLength: 30 }}
          helperText={
            errors.city || "Allowed 3-30 letters,numbers,spaces,/&()-,."
          }
        />

        <TextFieldStyle
          fullWidth
          label="Pin Code *"
          name="pinCode"
          value={branchData.pinCode}
          onChange={handleChange}
          error={!!errors.pinCode}
          helperText={errors.pinCode || "Exactly 6 digits"}
          inputProps={{ maxLength: 6, inputMode: "numeric" }}
        />
      </Stack>

      {/* --- Row 3 --- */}
      <Stack direction={"row"} spacing={1}>
        <TextField
          fullWidth
          label="Address *"
          name="address"
          value={branchData.address}
          onChange={handleChange}
          error={!!errors.address}
          inputProps={{ maxLength: 50 }}
          helperText={errors.address || "Allowed 5-50 characters"}
          multiline
          maxRows={2}
        />
      </Stack>

      {/* --- Row 4 --- */}
      <Stack direction={"row"} spacing={1}>
        <TextField1Style
          fullWidth
          label="Mobile Number *"
          name="phoneNumber"
          value={branchData.phoneNumber}
          onChange={handleChange}
          error={!!errors.phoneNumber}
          helperText={errors.phoneNumber || "Exactly 10 digits"}
          inputProps={{ maxLength: 10, inputMode: "numeric" }}
        />
        <TextField1Style
          fullWidth
          name="emailId"
          label="Email ID *"
          value={branchData.emailId || emailDomain}
          onChange={handleChange}
          disabled={true}
          error={!!errors.emailId}
          helperText="Auto-generated"
        />
      </Stack>

      {/* --- Row 5 --- */}
      <Stack direction={"row"} spacing={1}>
        <TextFieldStyle
          fullWidth
          name="nmrCode"
          label="N-M-R Code *"
          value={branchData.nmrCode}
          onChange={handleChange}
          onBlur={handleChange}
          error={!!errors.nmrCode}
          helperText={errors.nmrCode || "Exactly 9 digits"}
          inputProps={{ maxLength: 9, inputMode: "numeric" }}
        />

        <TextFieldStyle
          select
          fullWidth
          disabled={!editingId}
          label="Branch Status as per CBS *"
          name="status"
          value={
            !branchData.status || branchData.status === "InActive"
              ? "InActive"
              : "Active"
          }
          onChange={handleChange}
          error={!!errors.status}
          helperText={errors.status}
        >
          <MenuItem value="">Select Branch Status</MenuItem>
          <MenuItem key={"Live"} value={"Active"}>
            Live
          </MenuItem>
          <MenuItem key={"Closed"} value={"InActive"}>
            Closed
          </MenuItem>
        </TextFieldStyle>

        <CustomDatePicker
          label="Open Date *"
          name="openDate"
          value={branchData.openDate}
          onChange={handleDateChange}
          disabled={!!editingId}
          disableFuture
          useStyle1={false}
          minDate={!editingId ? startOfCurrentMonth : undefined}
          maxDate={!editingId ? endOfCurrentMonth : undefined}
          error={errors.openDate}
          helperText={errors.openDate}
        />
      </Stack>

      {/* --- Row 6: Conditional --- */}
      {editingId && (
        <Stack direction={"row"} spacing={1}>
          <CustomDatePicker
            label="Close Date"
            name="closeDate"
            value={branchData.closeDate}
            onChange={handleDateChange}
            disabled={!isClosed} // Logic: Disabled if Active
            disableFuture
            useStyle1={true}
            minDate={
              branchData.openDate ? dayjs(branchData.openDate) : undefined
            }
            maxDate={today}
            error={errors.closeDate}
            helperText={
              errors.closeDate ||
              (isClosed && !branchData.closeDate
                ? "Close Date is required when status is Closed"
                : "")
            }
          />

          <CustomDatePicker
            label="Merge Date"
            name="mergeDate"
            value={branchData.mergeDate}
            onChange={handleDateChange}
            disabled={!canEnabledMergeDate}
            disableFuture
            useStyle1={true}
            minDate={startOfCurrentMonth}
            maxDate={endOfCurrentMonth}
            error={errors.mergeDate}
            helperText={
              errors.mergeDate ||
              (isMerged && !branchData.mergeDate
                ? "Merge Date is required when branch is merged"
                : "")
            }
          />

          <CustomAutoComplete
            key={isClosed ? "mwb-closed" : "mwb-open"}
            options={mwb || []}
            loading={mwbLoading}
            value={isClosed ? null : branchData.mergedWithBranch}
            onChange={handleMwbInputChange}
            inputValue={mwbInputValue}
            // onInputChange={handleMwbInputChange}
            // onInputChange={debounceQuery}
            disabled={isClosed}
            renderOption={(option) => `${option.code} (${option.name})`}
            uniqueElementKey="code"
            label="Merge with Branch"
            name="mergedWithBranch"
            error={errors?.mergedWithBranch}
          />
        </Stack>
      )}

      {/* --- Row 7 --- */}
      <Stack direction={"row"} spacing={1}>
        <TextFieldStyle
          select
          fullWidth
          label="CPC Flag *"
          name="cpcFlag"
          value={branchData.cpcFlag}
          onChange={handleChange}
          error={!!errors.cpcFlag}
        >
          <MenuItem value={true}>Allowed</MenuItem>
          <MenuItem value={false}>Not Allowed</MenuItem>
        </TextFieldStyle>

        <TextFieldStyle
          select
          fullWidth
          label="Food Credit Flag *"
          name="foodCreditFlag"
          value={branchData.foodCreditFlag}
          onChange={handleChange}
          error={!!errors.foodCreditFlag}
        >
          <MenuItem value={true}>Allowed</MenuItem>
          <MenuItem value={false}>Not Allowed</MenuItem>
        </TextFieldStyle>

        <TextFieldStyle
          select
          fullWidth
          label="Currency Chest Flag *"
          name="currChestFlag"
          value={branchData.currChestFlag}
          onChange={handleChange}
          error={!!errors.currChestFlag}
        >
          <MenuItem value={true}>Allowed</MenuItem>
          <MenuItem value={false}>Not Allowed</MenuItem>
        </TextFieldStyle>

        <TextFieldStyle
          select
          fullWidth
          label="Branch Type *"
          name="branchType"
          value={branchData.branchType}
          onChange={handleChange}
          error={!!errors.branchType}
        >
          {branchTypeOptions.map((option) => (
            <MenuItem key={option.value} value={option.value}>
              {option.label}
            </MenuItem>
          ))}
        </TextFieldStyle>
      </Stack>
    </Stack>
  );
};

export default React.memo(BranchForm);



import React, {
  useState,
  useEffect,
  useCallback,
  useRef,
  useMemo,
} from "react";
import {
  Dialog,
  DialogActions,
  DialogContent,
  Button,
  debounce,
} from "@mui/material";
import {
  Add as AddIcon,
  Close as CloseIcon,
  Edit as EditIcon,
} from "@mui/icons-material";
import dayjs from "dayjs";

import { DialogTitleStyle, IconButtonStyle } from "./BranchMasterStyle";
import useApi from "../../hooks/useApi";
import useCustomSnackbar from "../../utils/useCustomSnackbar";
import BranchForm from "./BranchForm";

const reDigits = /^[0-9]*$/;
const reDesc = /^[a-zA-Z0-9\s/&,-.()]*$/;
const eprefix = "sbi.";
const emailDomain = "@sbi.co.in";

export default function BranchDialog({
  open,
  handleClose,
  editingId,
  initialData,
  fetchBranches,
  circles,
  states,
}) {
  const { callApi, cancelAllRequests } = useApi();
  const snackbar = useCustomSnackbar();

  // Throttle Snackbars
  const snackGateRef = useRef(true);
  const notifyOnce = useCallback(
    (msg, variant = "warning") => {
      if (!snackGateRef.current) return;
      snackGateRef.current = false;
      snackbar(msg, variant);
      setTimeout(() => (snackGateRef.current = true), 800);
    },
    [snackbar]
  );

  const [branchData, setBranchData] = useState({});
  const [errors, setErrors] = useState({});
  const [mwb, setMwb] = useState([]);
  const [mwbLoading, setMwbLoading] = useState(false);
  const [mwbInputValue, setMwbInputValue] = useState("");
  const [isDataSame, setIsDataSame] = useState(true);
  const [originalData, setOriginalData] = useState(null);

  // --- Initialization ---
  useEffect(() => {
    if (open) {
      if (editingId && initialData) {
        const init = { ...initialData };
        setBranchData(init);
        setOriginalData(init);
        setIsDataSame(true);
        if (init.mergedWithBranch) {
          setMwb([init.mergedWithBranch]);
        }
      } else {
        setBranchData({
          code: "",
          name: "",
          circleCode: "",
          state: "",
          city: "",
          address: "",
          pinCode: "",
          phoneNumber: "",
          emailId: `${eprefix}${emailDomain}`,
          nmrCode: "",
          status: "Active",
          openDate: dayjs(),
          closeDate: null,
          mergeDate: null,
          mergedWithBranch: null,
          cpcFlag: false,
          foodCreditFlag: false,
          currChestFlag: false,
          branchType: "A",
        });
        setOriginalData(null);
        setIsDataSame(false);
      }
      setErrors({});
      setMwb([]);
    }
  }, [open, editingId, initialData]);

  // --- Change Detection ---
  useEffect(() => {
    if (editingId && originalData) {
      const isSame =
        JSON.stringify(branchData) === JSON.stringify(originalData);
      setIsDataSame(isSame);
    }
  }, [branchData, originalData, editingId]);

  // --- Auto Logic: Branch Type Switching ---
  useEffect(() => {
    if (editingId) {
      const hasManualTriggers =
        branchData.status === "InActive" ||
        !!branchData.closeDate ||
        !!branchData.mergeDate ||
        !!branchData.mergedWithBranch;

      if (hasManualTriggers && branchData.branchType !== "M") {
        setBranchData((prev) => ({ ...prev, branchType: "M" }));
      } else if (!hasManualTriggers && branchData.branchType !== "A") {
        setBranchData((prev) => ({ ...prev, branchType: "A" }));
      }
    }
  }, [
    branchData.status,
    branchData.closeDate,
    branchData.mergeDate,
    branchData.mergedWithBranch,
    editingId,
  ]);

  // --- Auto Logic: Clear Dependent Data ---
  useEffect(() => {
    if (branchData.status === "Active") {
      setBranchData((prev) => {
        // Only update if needed to avoid loops
        if (prev.mergedWithBranch || prev.mergeDate || prev.closeDate) {
          return {
            ...prev,
            mergedWithBranch: null,
            mergeDate: null,
            closeDate: null,
          };
        }
        return prev;
      });
      // Clear errors related to these
      setErrors((prev) => ({
        ...prev,
        closeDate: "",
        mergeDate: "",
        mergedWithBranch: "",
      }));
    }
  }, [branchData.status]);

  // --- Validation ---
  const validateField = (name, value, allData = branchData) => {
    switch (name) {
      case "code":
        if (!value) return "Branch Code is required";
        if (!reDigits.test(value)) return "Only digits allowed";
        if (value.length !== 5) return "Must be 5 digits";
        if (/^0+$/.test(value)) return "All zeros not allowed";
        break;
      case "name":
        if (!value) return "Name required";
        if (!reDesc.test(value)) return "Invalid characters";
        if (value.length < 3) return "Min 3 characters";
        break;
      case "pinCode":
        if (value && !reDigits.test(value)) return "Digits only";
        if (value && value.length !== 6) return "Must be 6 digits";
        if (value && /^0/.test(value)) return "Cannot start with zero";
        break;
      case "phoneNumber":
        if (value && !reDigits.test(value)) return "Digits only";
        if (value && value.length !== 10) return "Must be 10 digits";
        if (value && /^0/.test(value)) return "Cannot start with zero";
        break;
      case "nmrCode":
        if (value && !reDigits.test(value)) return "Digits only";
        if (value && value.length !== 9) return "Must be 9 digits";
        break;

      case "openDate":
        if (!value || !dayjs(value).isValid()) return "Invalid Date";
        break;

      case "closeDate":
        if (value && !dayjs(value).isValid()) return "Invalid Date";
        if (allData.status === "InActive" && !value)
          return "Required when status is Closed";
        if (value && dayjs(value).isValid()) {
          if (
            allData.openDate &&
            dayjs(value).isBefore(dayjs(allData.openDate), "day")
          ) {
            return "Close Date cannot be before Open Date";
          }
          if (dayjs(value).isAfter(dayjs(), "day")) {
            return "Close Date cannot be in future";
          }
        }
        break;

      case "mergeDate":
        if (value && !dayjs(value).isValid()) return "Invalid Date";
        if (allData.mergedWithBranch && !value) return "Required when merged";
        if (value && dayjs(value).isValid()) {
          if (!dayjs(value).isSame(dayjs(), "month"))
            return "Merge Date must be in current month";
          if (dayjs(value).isAfter(dayjs(), "day"))
            return "Merge Date cannot be in future";
        }
        break;
      case "mergedWithBranch":
        if (value?.code === allData.code) return "Cannot merge with itself";
        break;
      default:
        break;
    }
    return "";
  };

  // --- Handlers ---
  const handleChange = useCallback(
    (e) => {
      const { name, value } = e.target;

      // Immediate Validation / Snackbar logic
      if (name === "code" && !reDigits.test(value)) {
        notifyOnce("Digits only");
        return;
      }
      if (name === "code" && value.length > 5) {
        notifyOnce("Max 5 digits");
        return;
      }

      if (
        ["pinCode", "phoneNumber", "nmrCode"].includes(name) &&
        !reDigits.test(value)
      ) {
        notifyOnce("Digits only");
        return;
      }
      if (
        ["name", "city", "address"].includes(name) &&
        value !== "" &&
        !reDesc.test(value)
      ) {
        notifyOnce("Invalid special characters");
        return;
      }

      setBranchData((prev) => {
        const updated = { ...prev, [name]: value };
        if (name === "code")
          updated.emailId = `${eprefix}${value}${emailDomain}`;
        // Logic: Status Logic handled in useEffect, but clear closeDate immediately if made active
        if (name === "status" && value === "Active") updated.closeDate = null;
        return updated;
      });

      if (name === "code" && value.length === 5 && !editingId) {
        checkBranchCodeExists(value);
      }

      setErrors((prev) => ({
        ...prev,
        [name]: validateField(name, value, branchData),
      }));
    },
    [editingId, branchData, notifyOnce]
  );

  const checkBranchCodeExists = async (code) => {
    try {
      const url =
        "/CM/common-master/branches-code-name-only?q=" +
        encodeURIComponent(code);
      const res = await callApi(url, null, "GET");
      if (res?.data?.some((b) => b.code === code)) {
        setErrors((prev) => ({ ...prev, code: "Branch Code already exists" }));
        notifyOnce("Branch Code already exists", "error");
      }
    } catch (e) {
      console.error(e);
    }
  };

  const handleDateChange = useCallback((name, newValue) => {
    setBranchData((prev) => {
      const updated = { ...prev, [name]: newValue };
      const errorMsg = validateField(name, newValue, updated);
      setErrors((prevErr) => ({ ...prevErr, [name]: errorMsg }));
      return updated;
    });
  }, []);

  const handleAutoCompleteChange = useCallback((name, value) => {
    setBranchData((prev) => ({ ...prev, [name]: value }));
    setErrors((prev) => ({ ...prev, [name]: "" }));
  }, []);

  const handleMwbInputChange = useCallback(
    debounce(async (e, val) => {
      setMwbInputValue(val);
      if (!val || val.length < 3) {
        setMwb([]);
        return;
      }
      setMwbLoading(true);
      try {
        const url =
          "/CM/common-master/branches-code-name-only?q=" +
          encodeURIComponent(val);
        const res = await callApi(url, null, "GET");
        setMwb(res?.data || []);
      } catch (e) {
        console.error(e);
      } finally {
        setMwbLoading(false);
      }
    }, 400),
    [callApi]
  );

  // Form Validity Check for Button
  const isFormValid = useMemo(() => {
    // 1. Check for explicit error strings
    const hasErrors = Object.values(errors).some((e) => e);
    if (hasErrors) return false;

    // 2. Check for empty mandatory fields
    const {
      code,
      name,
      circleCode,
      state,
      city,
      address,
      pinCode,
      phoneNumber,
      nmrCode,
      status,
    } = branchData;
    if (
      !code ||
      !name ||
      !circleCode ||
      !state ||
      !city ||
      !address ||
      !pinCode ||
      !phoneNumber ||
      !nmrCode ||
      !status
    )
      return false;

    return true;
  }, [errors, branchData]);

  const handleSubmit = async (e) => {
    e.preventDefault();

    const allErrors = {};
    Object.keys(branchData).forEach((key) => {
      const msg = validateField(key, branchData[key]);
      if (msg) allErrors[key] = msg;
    });

    if (branchData.status === "InActive" && !branchData.closeDate)
      allErrors.closeDate = "Required";
    if (branchData.mergedWithBranch && !branchData.mergeDate)
      allErrors.mergeDate = "Required";

    if (Object.keys(allErrors).length > 0) {
      setErrors(allErrors);
      notifyOnce("Please fix validation errors", "error");
      return;
    }

    if (editingId && isDataSame) {
      notifyOnce("No changes detected", "warning");
      return;
    }

    const payloadData = {
      requestType: "BRANCH",
      changeType: editingId ? "UPDATE" : "ADD",
      targetId: branchData.code,
      payload: {
        code: branchData.code.trim(),
        name: branchData.name.trim(),
        circleCode: branchData.circleCode,
        circleName:
          circles.find((c) => c.circleCode === branchData.circleCode)
            ?.circleName || "",
        state: branchData.state,
        stateName:
          states.find((s) => s.stateCode === branchData.state)?.stateName || "",
        city: branchData.city.trim(),
        address: branchData.address.trim(),
        pinCode: branchData.pinCode,
        phoneNumber: branchData.phoneNumber,
        emailId: branchData.emailId,
        nmrCode: branchData.nmrCode,
        status: branchData.status === "Active",
        cpcFlag: branchData.cpcFlag,
        foodCreditFlag: branchData.foodCreditFlag,
        currChestFlag: branchData.currChestFlag,
        branchType: branchData.branchType,
        openDate: branchData.openDate
          ? dayjs(branchData.openDate).format("DD/MM/YYYY")
          : null,
        ...(editingId && {
          mergedWithBranch: branchData.mergedWithBranch?.code || null,
          closeDate: branchData.closeDate
            ? dayjs(branchData.closeDate).format("DD/MM/YYYY")
            : null,
          mergeDate: branchData.mergeDate
            ? dayjs(branchData.mergeDate).format("DD/MM/YYYY")
            : null,
        }),
      },
    };

    try {
      const response = await callApi("/CR/create-request", payloadData, "POST");
      if (response) {
        snackbar(
          `Request submitted successfully. ID: ${response?.data?.id}`,
          "success"
        );
        handleClose();
        fetchBranches();
      }
    } catch (err) {
      snackbar(err?.message || "Request failed", "error");
    }
  };

  return (
    <Dialog open={open} maxWidth="md" fullWidth onClose={handleClose}>
      <DialogTitleStyle>
        {editingId ? "Edit Branch" : "Add New Branch"}
        <IconButtonStyle onClick={handleClose}>
          <CloseIcon />
        </IconButtonStyle>
      </DialogTitleStyle>

      <DialogContent dividers>
        <BranchForm
          branchData={branchData}
          errors={errors}
          circles={circles}
          states={states}
          mwb={mwb}
          mwbLoading={mwbLoading}
          mwbInputValue={mwbInputValue}
          editingId={editingId}
          handleChange={handleChange}
          handleDateChange={handleDateChange}
          handleAutoCompleteChange={handleAutoCompleteChange}
          handleMwbInputChange={handleMwbInputChange}
        />
      </DialogContent>

      <DialogActions>
        <Button
          onClick={handleSubmit}
          variant="contained"
          startIcon={editingId ? <EditIcon /> : <AddIcon />}
          disabled={!isFormValid || (editingId && isDataSame)}
        >
          {editingId ? "Update" : "Add"}
        </Button>
      </DialogActions>
    </Dialog>
  );
}


import React from "react";
import { Autocomplete, TextField, CircularProgress } from "@mui/material";

const CustomAutoComplete = ({
  options,
  value,
  onChange,
  renderOption,
  uniqueElementKey,
  inputValue,
  onInputChange,
  label,
  name,
  disabled,
  loading,
  error,
}) => {
  const filterOptions = name !== "currency" ? (x) => x : undefined;
  return (
    <Autocomplete
      options={options}
      // defaultValue={value || {}} // resolve 38 no defect
      value={value ?? null}
      inputValue={inputValue || ""}
      onInputChange={onInputChange}
      disabled={disabled}
      getOptionLabel={(option) => renderOption(option)}
      onChange={(_, value) => onChange(value)}
      filterOptions={filterOptions}
      isOptionEqualToValue={(option, value) =>
        option?.[uniqueElementKey] === value?.[uniqueElementKey]
      }
      renderOption={(props, option) => (
        <li {...props} key={option[uniqueElementKey]}>
          {renderOption(option)}
        </li>
      )}
      //noOptionsText={"Exactly 5 digits"} // resolve 38 no defect
      noOptionsText={
        loading
          ? "Loading..."
          : inputValue?.length < 3
          ? "Enter Atleast 3 Characters"
          : options?.length === 0
          ? "No Data for given filter"
          : ""
      }
      renderInput={(params) => (
        <TextField
          {...params}
          label={label}
          name={name}
          disabled={disabled}
          inputProps={{
            ...params.inputProps,
            readOnly: !!disabled,
          }}
          InputProps={{
            ...params.InputProps,
            endAdornment: (
              <>
                {loading ? <CircularProgress size={20} /> : null}
                {params.InputProps.endAdornment}
              </>
            ),
          }}
          error={error}
          helperText={error}
          sx={{ width: 300 }}
        />
      )}
    />
  );
};

export default React.memo(CustomAutoComplete);
