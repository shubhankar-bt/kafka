import React from "react";
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import dayjs from "dayjs";
import { DatePickerStyle, DatePicker1Style } from "./BranchMasterStyle";

const CustomDatePicker = ({
  label,
  name,
  value,
  onChange,
  disabled,
  disableFuture,
  minDate,
  maxDate,
  error,
  helperText,
  useStyle1 = false, // Toggle between DatePickerStyle (false) and DatePicker1Style (true)
  required = false
}) => {
  // Select the styled component based on prop matching your original code structure
  const Component = useStyle1 ? DatePicker1Style : DatePickerStyle;

  return (
    <Component
      label={label}
      format="DD/MM/YYYY"
      name={name}
      disabled={disabled}
      disableFuture={disableFuture}
      value={value} // value is expected to be a Dayjs object or null
      minDate={minDate}
      maxDate={maxDate}
      onChange={(newValue) => {
        // We pass the name back so the parent handler knows which field changed
        onChange(name, newValue);
      }}
      slotProps={{
        textField: {
          fullWidth: true,
          variant: "outlined",
          required: required,
          error: !!error,
          helperText: error || helperText || "",
        },
      }}
    />
  );
};

export default CustomDatePicker;
























import React from "react";
import { Autocomplete, TextField, CircularProgress } from "@mui/material";

const CustomAutoComplete = ({
  options,
  value,
  onChange,
  renderOption,
  uniqueElementKey,
  inputValue,
  onInputChange,
  label,
  name,
  disabled,
  loading,
  error,
}) => {
  const filterOptions = name !== "currency" ? (x) => x : undefined;

  return (
    <Autocomplete
      fullWidth
      options={options || []}
      value={value ?? null}
      inputValue={inputValue || ""}
      onInputChange={onInputChange}
      disabled={disabled}
      getOptionLabel={(option) => {
        if (typeof option === 'string') return option;
        return renderOption ? renderOption(option) : "";
      }}
      onChange={(_, value) => onChange(value)}
      filterOptions={filterOptions}
      isOptionEqualToValue={(option, value) =>
        option?.[uniqueElementKey] === value?.[uniqueElementKey]
      }
      renderOption={(props, option) => (
        <li {...props} key={option[uniqueElementKey]}>
          {renderOption(option)}
        </li>
      )}
      noOptionsText={
        loading
          ? "Loading..."
          : inputValue?.length < 3
          ? "Enter Atleast 3 Characters"
          : options?.length === 0
          ? "No Data for given filter"
          : ""
      }
      renderInput={(params) => (
        <TextField
          {...params}
          label={label}
          name={name}
          disabled={disabled}
          inputProps={{
            ...params.inputProps,
            readOnly: !!disabled,
          }}
          InputProps={{
            ...params.InputProps,
            endAdornment: (
              <>
                {loading ? <CircularProgress size={20} /> : null}
                {params.InputProps.endAdornment}
              </>
            ),
          }}
          error={!!error}
          helperText={error}
          sx={{ width: "100%" }} 
        />
      )}
    />
  );
};

export default CustomAutoComplete;


















import React from "react";
import { Stack, MenuItem, TextField } from "@mui/material";
import dayjs from "dayjs";
import {
  TextFieldStyle,
  TextField1Style,
} from "./BranchMasterStyle";
import CustomAutoComplete from "./CustomAutoComplete";
import CustomDatePicker from "./CustomDatePicker";

const branchTypeOptions = [
  { value: "A", label: "Automated" },
  { value: "M", label: "Manual" },
];

const emailDomain = "@sbi.co.in";

const BranchForm = ({
  branchData,
  errors,
  circles,
  states,
  mwb,
  mwbLoading,
  mwbInputValue,
  editingId,
  handleChange,
  handleDateChange,
  handleAutoCompleteChange,
  handleMwbInputChange,
}) => {
  
  // Logic helpers
  const isClosed = branchData.status === "InActive" || branchData.status === "Closed";
  const isMerged = !!branchData.mergedWithBranch;
  const canEnabledMergeDate = !!branchData?.mergedWithBranch?.code && !isClosed;
  
  // Date Logic
  const startOfCurrentMonth = dayjs().startOf("month");
  const endOfCurrentMonth = dayjs().endOf("month");
  const today = dayjs();

  return (
    <Stack direction={"column"} spacing={2}>
      {/* --- Row 1: Code, Name, Circle --- */}
      <Stack direction={"row"} spacing={1}>
        <TextFieldStyle
          fullWidth
          label="Branch Code *"
          name="code"
          value={branchData.code}
          onChange={handleChange}
          disabled={!!editingId}
          error={!!errors.code}
          helperText={errors.code || "Exactly 5 digits"}
          inputProps={{ maxLength: 5, inputMode: "numeric" }}
        />

        <TextFieldStyle
          fullWidth
          label="Branch Name *"
          name="name"
          value={branchData.name}
          onChange={handleChange}
          error={!!errors.name}
          inputProps={{ maxLength: 50 }}
          helperText={errors.name || "Allowed 3-50 letters,numbers,spaces,/&()-,."}
        />

        <CustomAutoComplete
          label="Circle Code *"
          name="circleCode"
          options={circles}
          value={circles.find((c) => c.circleCode === branchData.circleCode) || null}
          onChange={(val) => handleAutoCompleteChange("circleCode", val?.circleCode)}
          renderOption={(option) => `${option.circleCode} - ${option.circleName}`}
          uniqueElementKey="circleCode"
          error={errors.circleCode}
        />
      </Stack>

      {/* --- Row 2: State, City, Pin --- */}
      <Stack direction={"row"} spacing={1}>
        <CustomAutoComplete
          label="State *"
          name="state"
          options={states}
          value={states.find((s) => s.stateCode === branchData.state) || null}
          onChange={(val) => handleAutoCompleteChange("state", val?.stateCode)}
          renderOption={(option) => `${option.stateName}`}
          uniqueElementKey="stateCode"
          error={errors.state}
        />

        <TextFieldStyle
          fullWidth
          label="City *"
          name="city"
          value={branchData.city}
          onChange={handleChange}
          error={!!errors.city}
          inputProps={{ maxLength: 30 }}
          helperText={errors.city || "Allowed 3-30 letters,numbers,spaces,/&()-,."}
        />

        <TextFieldStyle
          fullWidth
          label="Pin Code *"
          name="pinCode"
          value={branchData.pinCode}
          onChange={handleChange}
          error={!!errors.pinCode}
          helperText={errors.pinCode || "Exactly 6 digits"}
          inputProps={{ maxLength: 6, inputMode: "numeric" }}
        />
      </Stack>

      {/* --- Row 3: Address --- */}
      <Stack direction={"row"} spacing={1}>
        <TextField
          fullWidth
          label="Address *"
          name="address"
          value={branchData.address}
          onChange={handleChange}
          error={!!errors.address}
          inputProps={{ maxLength: 50 }}
          helperText={errors.address || "Allowed 5-50 characters (A-Z, 0-9, spaces, /.&,()-)"}
          multiline
          maxRows={2}
        />
      </Stack>

      {/* --- Row 4: Mobile, Email --- */}
      <Stack direction={"row"} spacing={1}>
        <TextField1Style
          fullWidth
          label="Mobile Number *"
          name="phoneNumber"
          value={branchData.phoneNumber}
          onChange={handleChange}
          error={!!errors.phoneNumber}
          helperText={errors.phoneNumber || "Exactly 10 digits"}
          inputProps={{ maxLength: 10, inputMode: "numeric" }}
        />
        <TextField1Style
          fullWidth
          name="emailId"
          label="Email ID *"
          value={branchData.emailId || emailDomain}
          onChange={handleChange}
          disabled={true}
          error={!!errors.emailId}
          helperText="Auto-generated as sbi.<BranchCode>@sbi.co.in"
        />
      </Stack>

      {/* --- Row 5: NMR, Status, Open Date --- */}
      <Stack direction={"row"} spacing={1}>
        <TextFieldStyle
          fullWidth
          name="nmrCode"
          label="N-M-R Code *"
          value={branchData.nmrCode}
          onChange={handleChange}
          onBlur={handleChange}
          error={!!errors.nmrCode}
          helperText={errors.nmrCode || "Exactly 9 digits"}
          inputProps={{ maxLength: 9, inputMode: "numeric" }}
        />
        
        <TextFieldStyle
          select
          fullWidth
          disabled={!editingId}
          label="Branch Status as per CBS *"
          name="status"
          value={!branchData.status || branchData.status === "InActive" ? "InActive" : "Active"}
          onChange={handleChange}
          error={!!errors.status}
          helperText={errors.status}
        >
          <MenuItem value="">Select Branch Status</MenuItem>
          <MenuItem key={"Live"} value={"Active"}>Live</MenuItem>
          <MenuItem key={"Closed"} value={"InActive"}>Closed</MenuItem>
        </TextFieldStyle>

        <CustomDatePicker
          label="Open Date *"
          name="openDate"
          value={branchData.openDate}
          onChange={handleDateChange}
          disabled={!!editingId}
          disableFuture
          useStyle1={false} // Use DatePickerStyle
          minDate={!editingId ? startOfCurrentMonth : undefined}
          maxDate={!editingId ? endOfCurrentMonth : undefined}
          error={errors.openDate}
          helperText={errors.openDate}
        />
      </Stack>

      {/* --- Row 6: Conditional Date Fields --- */}
      {editingId && (
          <Stack direction={"row"} spacing={1}>
            <CustomDatePicker
              label="Close Date"
              name="closeDate"
              value={branchData.closeDate}
              onChange={handleDateChange}
              disabled={!isClosed}
              disableFuture
              useStyle1={true} // Use DatePicker1Style
              minDate={branchData.openDate ? dayjs(branchData.openDate) : undefined}
              maxDate={today}
              error={errors.closeDate}
              helperText={
                  errors.closeDate || 
                  (isClosed && !branchData.closeDate ? "Close Date is required when status is Closed" : "")
              }
            />

            <CustomDatePicker
              label="Merge Date"
              name="mergeDate"
              value={branchData.mergeDate}
              onChange={handleDateChange}
              disabled={!canEnabledMergeDate}
              disableFuture
              useStyle1={true} // Use DatePicker1Style
              required={isMerged}
              minDate={startOfCurrentMonth}
              maxDate={endOfCurrentMonth}
              error={errors.mergeDate}
              helperText={
                  errors.mergeDate ||
                  (isMerged && !branchData.mergeDate ? "Merge Date is required when branch is merged" : "")
              }
            />

            <CustomAutoComplete
              key={isClosed ? "mwb-closed" : "mwb-open"}
              options={mwb || []}
              loading={mwbLoading}
              value={isClosed ? null : branchData.mergedWithBranch}
              onChange={(val) => handleAutoCompleteChange("mergedWithBranch", val)}
              inputValue={mwbInputValue}
              onInputChange={handleMwbInputChange}
              disabled={isClosed}
              renderOption={(option) => `${option.code} (${option.name})`}
              uniqueElementKey="code"
              label="Merge with Branch"
              name="mergedWithBranch"
              error={errors?.mergedWithBranch}
            />
          </Stack>
      )}

      {/* --- Row 7: Flags & Type --- */}
      <Stack direction={"row"} spacing={1}>
        <TextFieldStyle select fullWidth label="CPC Flag *" name="cpcFlag" value={branchData.cpcFlag} onChange={handleChange} error={!!errors.cpcFlag}>
          <MenuItem value={true}>Allowed</MenuItem>
          <MenuItem value={false}>Not Allowed</MenuItem>
        </TextFieldStyle>

        <TextFieldStyle select fullWidth label="Food Credit Flag *" name="foodCreditFlag" value={branchData.foodCreditFlag} onChange={handleChange} error={!!errors.foodCreditFlag}>
          <MenuItem value={true}>Allowed</MenuItem>
          <MenuItem value={false}>Not Allowed</MenuItem>
        </TextFieldStyle>

        <TextFieldStyle select fullWidth label="Currency Chest Flag *" name="currChestFlag" value={branchData.currChestFlag} onChange={handleChange} error={!!errors.currChestFlag}>
          <MenuItem value={true}>Allowed</MenuItem>
          <MenuItem value={false}>Not Allowed</MenuItem>
        </TextFieldStyle>

        <TextFieldStyle select fullWidth label="Branch Type *" name="branchType" value={branchData.branchType} onChange={handleChange} error={!!errors.branchType}>
          {branchTypeOptions.map((option) => (
            <MenuItem key={option.value} value={option.value}>{option.label}</MenuItem>
          ))}
        </TextFieldStyle>
      </Stack>
    </Stack>
  );
};

export default BranchForm;


























import React, { useState, useEffect, useCallback } from "react";
import {
  Dialog,
  DialogActions,
  DialogContent,
  Button,
  debounce,
} from "@mui/material";
import {
  Add as AddIcon,
  Close as CloseIcon,
  Edit as EditIcon,
} from "@mui/icons-material";
import dayjs from "dayjs";

// Imports from your project structure
import { DialogTitleStyle, IconButtonStyle } from "./BranchMasterStyle";
import useApi from "../../hooks/useApi";
import useCustomSnackbar from "../../utils/useCustomSnackbar";
import BranchForm from "./BranchForm";

const reDigits = /^[0-9]*$/;
const reDesc = /^[a-zA-Z0-9\s/&,-.()]*$/;
const eprefix = "sbi.";
const emailDomain = "@sbi.co.in";

export default function BranchDialog({
  open,
  handleClose,
  editingId,
  initialData,
  fetchBranches,
  circles,
  states,
}) {
  const { callApi, cancelAllRequests } = useApi();
  const snackbar = useCustomSnackbar();

  // State
  const [branchData, setBranchData] = useState({});
  const [errors, setErrors] = useState({});
  const [mwb, setMwb] = useState([]);
  const [mwbLoading, setMwbLoading] = useState(false);
  const [mwbInputValue, setMwbInputValue] = useState("");
  const [isDataSame, setIsDataSame] = useState(true);
  const [originalData, setOriginalData] = useState(null);

  // --- Initialization ---
  useEffect(() => {
    if (open) {
      if (editingId && initialData) {
        // Deep copy
        const init = { ...initialData };
        setBranchData(init);
        setOriginalData(init);
        setIsDataSame(true);
        if (init.mergedWithBranch) {
            setMwb([init.mergedWithBranch]); 
        }
      } else {
        // Add Mode Reset
        setBranchData({
          code: "", name: "", circleCode: "", state: "", city: "", address: "", pinCode: "",
          phoneNumber: "", emailId: `${eprefix}${emailDomain}`, nmrCode: "", status: "Active",
          openDate: dayjs(), closeDate: null, mergeDate: null, mergedWithBranch: null,
          cpcFlag: false, foodCreditFlag: false, currChestFlag: false, branchType: "A",
        });
        setOriginalData(null);
        setIsDataSame(false);
      }
      setErrors({});
      setMwb([]);
    }
  }, [open, editingId, initialData]);

  // --- Change Detection ---
  useEffect(() => {
    if (editingId && originalData) {
      const isSame = JSON.stringify(branchData) === JSON.stringify(originalData);
      setIsDataSame(isSame);
    }
  }, [branchData, originalData, editingId]);

  // --- Auto Logic: Branch Type Switching ---
  useEffect(() => {
    const hasManualTriggers = 
        branchData.status === "InActive" || 
        !!branchData.closeDate || 
        !!branchData.mergeDate || 
        !!branchData.mergedWithBranch;

    if (editingId) {
        if (hasManualTriggers && branchData.branchType !== "M") {
          setBranchData((prev) => ({ ...prev, branchType: "M" }));
        } else if (!hasManualTriggers && branchData.branchType !== "A") {
          setBranchData((prev) => ({ ...prev, branchType: "A" }));
        }
    }
  }, [branchData.status, branchData.closeDate, branchData.mergeDate, branchData.mergedWithBranch, editingId]);

  // --- Auto Logic: Clear Dependent Data ---
  useEffect(() => {
    if (branchData.status === "InActive" || branchData.status === "Closed") {
      setBranchData((prev) => ({
        ...prev,
        mergedWithBranch: null,
        mergeDate: null,
      }));
    }
  }, [branchData.status]);

  useEffect(() => {
      if (!branchData.mergedWithBranch) {
          setBranchData((prev) => ({ ...prev, mergeDate: null }));
      }
  }, [branchData.mergedWithBranch]);

  // --- Validation Logic ---

  const validateField = (name, value, allData = branchData) => {
    switch (name) {
      case "code":
        if (!value) return "Branch Code is required";
        if (!reDigits.test(value)) return "Only digits allowed";
        if (value.length !== 5) return "Must be 5 digits";
        if (/^0+$/.test(value)) return "All zeros not allowed";
        break;
      case "name":
        if (!value) return "Name required";
        if (!reDesc.test(value)) return "Invalid characters";
        if (value.length < 3) return "Min 3 characters";
        break;
      case "pinCode":
        if (value && !reDigits.test(value)) return "Digits only";
        if (value && value.length !== 6) return "Must be 6 digits";
        if (value && /^0/.test(value)) return "Cannot start with zero";
        break;
      case "phoneNumber":
        if (value && !reDigits.test(value)) return "Digits only";
        if (value && value.length !== 10) return "Must be 10 digits";
        if (value && /^0/.test(value)) return "Cannot start with zero";
        break;
      case "nmrCode":
        if (value && !reDigits.test(value)) return "Digits only";
        if (value && value.length !== 9) return "Must be 9 digits";
        break;
      
      // DATE VALIDATIONS
      case "openDate":
        if (!value || !dayjs(value).isValid()) return "Invalid Date";
        break;

      case "closeDate":
        // Check Validity first (catches typing errors like 31/11/2023)
        if (value && !dayjs(value).isValid()) return "Invalid Date";
        
        if (allData.status === "InActive" && !value) return "Required when status is Closed";
        
        if (value && dayjs(value).isValid()) {
             if (allData.openDate && dayjs(value).isBefore(dayjs(allData.openDate), 'day')) {
                 return "Close Date cannot be before Open Date";
             }
             if (dayjs(value).isAfter(dayjs(), 'day')) {
                 return "Close Date cannot be in future";
             }
        }
        break;

      case "mergeDate":
        if (value && !dayjs(value).isValid()) return "Invalid Date";

        if (allData.mergedWithBranch && !value) return "Required when merged";

        if (value && dayjs(value).isValid()) {
             // Logic: Merge date must be current month
             if (!dayjs(value).isSame(dayjs(), 'month')) {
                 return "Merge Date must be in current month";
             }
             if (dayjs(value).isAfter(dayjs(), 'day')) {
                 return "Merge Date cannot be in future";
             }
        }
        break;
      
      case "mergedWithBranch":
        if (value?.code === allData.code) return "Cannot merge with itself";
        break;

      default:
        break;
    }
    return "";
  };

  // --- Handlers ---

  const handleChange = (e) => {
    const { name, value } = e.target;
    
    if (name === "code" && (!reDigits.test(value) || value.length > 5)) return;
    if (name === "pinCode" && (!reDigits.test(value) || value.length > 6)) return;
    if (name === "phoneNumber" && (!reDigits.test(value) || value.length > 10)) return;
    if (name === "nmrCode" && (!reDigits.test(value) || value.length > 9)) return;

    if (["name", "city", "address"].includes(name) && value !== "" && !reDesc.test(value)) return;

    setBranchData((prev) => {
      const updated = { ...prev, [name]: value };
      if (name === "code") updated.emailId = `${eprefix}${value}${emailDomain}`;
      if (name === "status" && value !== "InActive") updated.closeDate = null;
      return updated;
    });

    if (name === "code" && value.length === 5 && !editingId) {
       checkBranchCodeExists(value);
    }

    // Pass the NEW value to validateField for this specific field
    setErrors((prev) => ({ ...prev, [name]: validateField(name, value, branchData) }));
  };

  const checkBranchCodeExists = async (code) => {
    try {
        const url = "/CM/common-master/branches-code-name-only?q=" + encodeURIComponent(code);
        const res = await callApi(url, null, "GET");
        if (res?.data?.some(b => b.code === code)) {
            setErrors(prev => ({ ...prev, code: "Branch Code already exists" }));
            snackbar("Branch Code already exists", "error");
        }
    } catch(e) { console.error(e); }
  };

  const handleDateChange = (name, newValue) => {
    // 1. UPDATE STATE (Allow typing invalid dates)
    setBranchData((prev) => {
        const updated = { ...prev, [name]: newValue };
        // 2. VALIDATE using the UPDATED state
        const errorMsg = validateField(name, newValue, updated);
        setErrors((prevErr) => ({ ...prevErr, [name]: errorMsg }));
        return updated;
    });
  };

  const handleAutoCompleteChange = (name, value) => {
    setBranchData((prev) => ({ ...prev, [name]: value }));
    setErrors((prev) => ({ ...prev, [name]: "" }));
  };

  const handleMwbInputChange = useCallback(
    debounce(async (e, val) => {
        setMwbInputValue(val);
        if (!val || val.length < 3) {
            setMwb([]);
            return;
        }
        setMwbLoading(true);
        try {
            const url = "/CM/common-master/branches-code-name-only?q=" + encodeURIComponent(val);
            const res = await callApi(url, null, "GET");
            setMwb(res?.data || []);
        } catch (e) { console.error(e); }
        finally { setMwbLoading(false); }
    }, 400),
    [callApi]
  );

  const handleSubmit = async (e) => {
    e.preventDefault();

    const allErrors = {};
    Object.keys(branchData).forEach(key => {
        const msg = validateField(key, branchData[key]);
        if(msg) allErrors[key] = msg;
    });

    // Explicit Mandatory Checks
    if (branchData.status === "InActive" && !branchData.closeDate) allErrors.closeDate = "Required";
    if (branchData.mergedWithBranch && !branchData.mergeDate) allErrors.mergeDate = "Required";

    if (Object.keys(allErrors).length > 0) {
        setErrors(allErrors);
        snackbar("Please fix validation errors", "error");
        return;
    }

    if (editingId && isDataSame) {
        snackbar("No changes detected", "warning");
        return;
    }

    // Payload
    const payloadData = {
      requestType: "BRANCH",
      changeType: editingId ? "UPDATE" : "ADD",
      targetId: branchData.code,
      payload: {
        code: branchData.code.trim(),
        name: branchData.name.trim(),
        circleCode: branchData.circleCode,
        circleName: circles.find(c => c.circleCode === branchData.circleCode)?.circleName || "",
        state: branchData.state,
        stateName: states.find(s => s.stateCode === branchData.state)?.stateName || "",
        city: branchData.city.trim(),
        address: branchData.address.trim(),
        pinCode: branchData.pinCode,
        phoneNumber: branchData.phoneNumber,
        emailId: branchData.emailId,
        nmrCode: branchData.nmrCode,
        status: branchData.status === "Active",
        cpcFlag: branchData.cpcFlag,
        foodCreditFlag: branchData.foodCreditFlag,
        currChestFlag: branchData.currChestFlag,
        branchType: branchData.branchType,
        openDate: branchData.openDate ? dayjs(branchData.openDate).format("DD/MM/YYYY") : null,
        ...(editingId && {
            mergedWithBranch: branchData.mergedWithBranch?.code || null,
            closeDate: branchData.closeDate ? dayjs(branchData.closeDate).format("DD/MM/YYYY") : null,
            mergeDate: branchData.mergeDate ? dayjs(branchData.mergeDate).format("DD/MM/YYYY") : null,
        })
      },
    };

    try {
        const response = await callApi("/CR/create-request", payloadData, "POST");
        if (response) {
            snackbar(
                `Branch ${editingId ? "update" : "creation"} request submitted. ID: ${response?.data?.id}`,
                "success"
            );
            handleClose();
            fetchBranches();
        }
    } catch (err) {
        snackbar(err?.message || "Request failed", "error");
    }
  };

  return (
    <Dialog open={open} maxWidth="md" fullWidth onClose={handleClose}>
      <DialogTitleStyle>
        {editingId ? "Edit Branch" : "Add New Branch"}
        <IconButtonStyle onClick={handleClose}>
            <CloseIcon />
        </IconButtonStyle>
      </DialogTitleStyle>
      
      <DialogContent dividers>
        <BranchForm 
            branchData={branchData}
            errors={errors}
            circles={circles}
            states={states}
            mwb={mwb}
            mwbLoading={mwbLoading}
            mwbInputValue={mwbInputValue}
            editingId={editingId}
            handleChange={handleChange}
            handleDateChange={handleDateChange}
            handleAutoCompleteChange={handleAutoCompleteChange}
            handleMwbInputChange={handleMwbInputChange}
        />
      </DialogContent>

      <DialogActions>
        <Button
            onClick={handleSubmit}
            variant="contained"
            startIcon={editingId ? <EditIcon /> : <AddIcon />}
            disabled={(editingId && isDataSame)}
        >
            {editingId ? "Update" : "Add"}
        </Button>
      </DialogActions>
    </Dialog>
  );
}



















import {
  Box,
  Typography,
  Tooltip,
  IconButton,
  styled,
} from "@mui/material";
import {
  Add as AddIcon,
  Edit as EditIcon,
} from "@mui/icons-material";
import { DataGrid } from "@mui/x-data-grid";
import { AdapterDayjs } from "@mui/x-date-pickers/AdapterDayjs";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import dayjs from "dayjs";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

// Existing Imports
import useApi from "../../hooks/useApi";
import { getIconComponent } from "../../utils/IconUtils";
import useCustomSnackbar from "../../utils/useCustomSnackbar";
import ErrorOutlineIcon from "@mui/icons-material/ErrorOutline";
import {
  AddIconStyle,
  Box1Style,
  ChipStyle,
  FabStyle,
  StackStyle,
} from "./BranchMasterStyle";

import BranchDialog from "./BranchDialog";

const OverlayBox = styled(Box)(() => ({
  display: "flex",
  flexDirection: "column",
  height: "100%",
  justifyContent: "center",
  alignItems: "center",
}));

const CustomNoRowsOverlay = () => {
  return (
    <OverlayBox>
      <ErrorOutlineIcon fontSize="large" />
      <Typography variant="h5" fontSize="1.2rem">
        Data is not available
      </Typography>
    </OverlayBox>
  );
};

export default function BranchMasterTab() {
  const [rows, setRows] = useState([]);
  const [rowCount, setRowCount] = useState(0);
  const [loading, setLoading] = useState(false);
  
  const [open, setOpen] = useState(false);
  const [editingId, setEditingId] = useState(null);
  const [editingData, setEditingData] = useState(null);
  
  const [circles, setCircles] = useState([]);
  const [states, setStates] = useState([]);

  // Grid State
  const [paginationModel, setPaginationModel] = useState({ page: 0, pageSize: 20 });
  const [sortModel, setSortModel] = useState([]);
  const [filterModel, setFilterModel] = useState({ items: [] });
  const lastQueryRef = useRef("");

  const { callApi } = useApi();
  const snackbar = useCustomSnackbar();

  // Icons
  const ActiveIcon = useMemo(() => getIconComponent("FiberManualRecord"), []);
  const InActiveIcon = useMemo(() => getIconComponent("FiberManualRecord"), []);

  // --- Fetch ---
  const fetchBranches = useCallback(async () => {
    const sortField = sortModel[0]?.field;
    const sortOrder = sortModel[0]?.sort;

    const filters = filterModel.items
      .filter((f) => f.operator && f.value !== undefined && f.value !== "")
      .map((f) => ({ field: f.field, operator: f.operator, value: f.value }));

    const querySignature = JSON.stringify({
      page: paginationModel.page,
      size: paginationModel.pageSize,
      sortField,
      sortOrder,
      filters,
    });

    if (lastQueryRef.current === querySignature) return;
    lastQueryRef.current = querySignature;

    try {
      setLoading(true);
      const payload = {
        page: paginationModel.page,
        size: paginationModel.pageSize,
        sortField,
        sortOrder,
        filters,
      };
      const resp = await callApi("/CM/common-master/branches-master", payload, "POST");
      setRows(resp?.data?.data || []);
      setRowCount(resp?.data?.totalElements || 0);
    } catch (err) {
      snackbar(err?.message || "Failed to load branches", "error");
      setRows([]);
      setRowCount(0);
    } finally {
      setLoading(false);
    }
  }, [callApi, snackbar, paginationModel, sortModel, filterModel]);

  const fetchLookups = useCallback(async () => {
      try {
        const sRes = await callApi("/CM/common-master/states", null, "GET");
        setStates(sRes?.data ?? []);
        const cRes = await callApi("/CM/common-master/circle-codes", null, "GET");
        setCircles(cRes?.data ?? []);
      } catch (e) {
          console.error(e);
      }
  }, [callApi]);

  useEffect(() => {
    fetchBranches();
  }, [fetchBranches]);

  useEffect(() => {
    fetchLookups();
  }, [fetchLookups]);

  // --- Actions ---
  const handleEdit = useCallback((row) => {
    const nStatus = row.status === false ? "InActive" : "Active";
    
    // Parse strings to Dayjs objects for form
    const initialData = {
      code: String(row.code ?? ""),
      name: String(row.name ?? ""),
      circleCode: String(row.circleCode ?? ""),
      state: String(row.state ?? ""),
      city: String(row.city ?? ""),
      address: String(row.address ?? ""),
      pinCode: String(row.pinCode ?? ""),
      phoneNumber: String(row.phoneNumber ?? ""),
      emailId: row.emailId || `sbi.${row.code}@sbi.co.in`,
      nmrCode: String(row.nmrCode ?? ""),
      status: nStatus,
      cpcFlag: row.cpcFlag,
      currChestFlag: row.currChestFlag,
      foodCreditFlag: row.foodCreditFlag,
      branchType: String(row.branchType ?? ""),
      openDate: row.openDate ? dayjs(row.openDate, "DD/MM/YYYY") : null,
      closeDate: row.closeDate ? dayjs(row.closeDate, "DD/MM/YYYY") : null,
      mergeDate: row.mergeDate ? dayjs(row.mergeDate, "DD/MM/YYYY") : null,
      mergedWithBranch: row.mergedWithBranch || null, 
    };

    setEditingData(initialData);
    setEditingId(row.code);
    setOpen(true);
  }, []);

  const handleAdd = () => {
    setEditingId(null);
    setEditingData(null);
    setOpen(true);
  };

  const handleClose = () => {
      setOpen(false);
  };

  // --- Columns ---
  const columns = useMemo(
    () => [
      { field: "code", headerName: "Branch Code", flex: 2, sortable: true },
      { field: "name", headerName: "Branch Name", flex: 3, sortable: true },
      {
        field: "status",
        headerName: "Status",
        flex: 1,
        sortable: true,
        type: "singleSelect",
        valueOptions: [
          { value: 1, label: "Active" },
          { value: 0, label: "In-Active" },
        ],
        renderCell: (params) => (
          <Box1Style>
            <ChipStyle
              size="small"
              icon={params.row.status ? <ActiveIcon /> : <InActiveIcon />}
              label={params.row.status ? "Active" : "In-Active"}
              color="primary"
              row={params.row}
            />
          </Box1Style>
        ),
      },
      {
        field: "actions",
        headerName: "Actions",
        flex: 1,
        headerAlign: "center",
        align: "center",
        filterable: false,
        sortable: false,
        disableColumnMenu: true,
        renderCell: (params) => (
          <StackStyle direction="row" spacing={1} alignItems="center" justifyContent="center">
            <Tooltip title="Edit">
              <div>
                <IconButton onClick={() => handleEdit(params.row)} color="primary">
                  <EditIcon />
                </IconButton>
              </div>
            </Tooltip>
          </StackStyle>
        ),
      },
    ],
    [handleEdit, ActiveIcon, InActiveIcon]
  );

  return (
    <LocalizationProvider dateAdapter={AdapterDayjs}>
      <Box>
        <Box>
          <FabStyle onClick={handleAdd} color="primary" variant="extended">
            <AddIconStyle />
          </FabStyle>
        </Box>

        <DataGrid
          rows={rows}
          columns={columns}
          getRowId={(row) => row.code}
          loading={loading}
          paginationMode="server"
          sortingMode="server"
          filterMode="server"
          rowCount={rowCount}
          paginationModel={paginationModel}
          onPaginationModelChange={setPaginationModel}
          sortModel={sortModel}
          onSortModelChange={setSortModel}
          filterModel={filterModel}
          onFilterModelChange={setFilterModel}
          pageSizeOptions={[10, 20, 50, 100]}
          disableRowSelectionOnClick
          slots={{ noRowsOverlay: CustomNoRowsOverlay }}
        />

        <BranchDialog 
            open={open}
            handleClose={handleClose}
            editingId={editingId}
            initialData={editingData}
            fetchBranches={fetchBranches}
            circles={circles}
            states={states}
        />
      </Box>
    </LocalizationProvider>
  );
}




