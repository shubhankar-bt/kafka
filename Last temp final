package com.fincore.ReportService.controller;

import java.util.List;
import java.util.Map;

import com.fincore.ReportService.dto.ReportCreationDto;
import com.fincore.commonutilities.jwt.JwtUtil;
import lombok.extern.slf4j.Slf4j;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;

import com.fincore.ReportService.dto.ReportDownloadRequest;
import com.fincore.ReportService.dto.ReportStreamResponse;
import com.fincore.ReportService.dto.ReportTypeDto;
import com.fincore.ReportService.service.ReportService;

@Slf4j
@RestController
@RequestMapping("/api/reports") 
public class ReportController {

    private final ReportService reportService;
    private final JwtUtil jwtUtil;
    
    public ReportController(ReportService reportService, JwtUtil jwtUtil) {
        this.reportService = reportService;
        this.jwtUtil = jwtUtil;
    }

    @PostMapping("/types")
    public List<ReportTypeDto> getReportTypes(@RequestHeader("Authorization") String token) {
        return reportService.getReportTypes(jwtUtil.getUserRoleFromToken(token));
    }

    @PostMapping("/download")
    public ResponseEntity<StreamingResponseBody> downloadReport(
           @RequestHeader("Authorization") String token,
           @RequestBody ReportDownloadRequest request) {
            
       ReportStreamResponse response = reportService.downloadReportStream(
               request.getFileName(),
               request.getDate(),
               jwtUtil.getUserRoleFromToken(token),
               jwtUtil.getUserIdFromToken(token)
       );

       return ResponseEntity.ok()
               .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + response.getDownloadFileName() + "\"")
               .contentType(MediaType.APPLICATION_OCTET_STREAM)
               .body(response.getStreamBody());
    }

    @PostMapping("/create-reports")
    public Map<String,String> createReports (@RequestHeader("Authorization") String token, 
                                             @RequestBody ReportCreationDto requestBody) throws Exception {
           // EXTRACT USER ID FROM TOKEN
           String userId = jwtUtil.getUserIdFromToken(token);
           return reportService.createReports(requestBody, userId);
    }
}






















package com.fincore.ReportService.service;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;

import com.fincore.ReportService.dto.ReportCreationDto;
import com.fincore.ReportService.dto.ReportStreamResponse;
import com.fincore.ReportService.dto.ReportTypeDto;

public interface ReportService {

    List<ReportTypeDto> getReportTypes(int roleId);
    
    ReportStreamResponse downloadReportStream(String fileName, LocalDate date, int userRoleId, String userId);

    // Updated to accept User ID for notifications
    Map<String,String> createReports(ReportCreationDto parameters, String userId) throws Exception;
}
















package com.fincore.ReportService.service;

import com.fincore.ReportService.dto.ReportCreationDto;
import com.fincore.ReportService.dto.ReportStreamResponse;
import com.fincore.ReportService.dto.ReportTypeDto;
import com.fincore.ReportService.dto.TaskProgressDto;
import com.fincore.ReportService.exception.ResourceNotFoundException;
import com.fincore.ReportService.model.AppConfig;
import com.fincore.ReportService.model.JasperReports;
import com.fincore.ReportService.model.ReportType;
import com.fincore.ReportService.repository.AppConfigRepository;
import com.fincore.ReportService.repository.JasperReportTypeRepository;
import com.fincore.ReportService.repository.ReportTypeRepository;
import lombok.extern.slf4j.Slf4j;
import net.sf.jasperreports.engine.*;
import net.sf.jasperreports.engine.export.JRCsvExporter;
import net.sf.jasperreports.engine.export.ooxml.JRXlsxExporter;
import net.sf.jasperreports.export.SimpleCsvExporterConfiguration;
import net.sf.jasperreports.export.SimpleExporterInput;
import net.sf.jasperreports.export.SimpleOutputStreamExporterOutput;
import net.sf.jasperreports.export.SimpleWriterExporterOutput;
import org.apache.catalina.connector.ClientAbortException;
import org.apache.hadoop.fs.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ClassPathResource;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;

import javax.sql.DataSource;
import java.io.*;
import java.nio.file.Paths;
import java.sql.Connection;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.zip.Deflater;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@Service
@Slf4j
public class ReportServiceImpl implements ReportService {

    @Autowired
    private DataSource dataSource;

    @Value("${directory.jasperFileDir:/jasper}")
    private String jasperFileDir;

    @Value("${notification.progress.topic}")
    private String progressTopic;

    private final ReportTypeRepository reportTypeRepository;
    private final JasperReportTypeRepository jasperReportTypeRepository;
    private final String reportsBasePath;
    private final AppConfigRepository appConfigRepository;
    private final NotificationWriterService notificationWriterService;
    private final FileSystem hdfsFileSystem;
    
    // Redis Template for Progress
    private final RedisTemplate<String, TaskProgressDto> redisTemplate;

    private final String REPORTS_START_DATE_KEY = "REPORTS_START_DATE";
    private static final int BUFFER_SIZE = 32 * 1024;
    private static final Set<String> ALREADY_COMPRESSED_EXTS = Set.of("pdf", "xlsx", "xls", "zip", "gz", "png", "jpg", "jpeg");

    public ReportServiceImpl(ReportTypeRepository reportTypeRepository,
                             JasperReportTypeRepository jasperReportTypeRepository,
                             @Value("${glif.reports.base-path}") String basePath,
                             AppConfigRepository appConfigRepository,
                             NotificationWriterService notificationWriterService,
                             FileSystem hdfsFileSystem,
                             @Qualifier("progressRedisTemplate") RedisTemplate<String, TaskProgressDto> redisTemplate) {
        this.reportTypeRepository = reportTypeRepository;
        this.jasperReportTypeRepository = jasperReportTypeRepository;
        this.reportsBasePath = basePath;
        this.appConfigRepository = appConfigRepository;
        this.notificationWriterService = notificationWriterService;
        this.hdfsFileSystem = hdfsFileSystem;
        this.redisTemplate = redisTemplate;
    }

    @Override
    public List<ReportTypeDto> getReportTypes(int roleId) {
        if (roleId <= 0) throw new IllegalArgumentException("Payload structure is not correct.");
        LocalDate startDate = getStartDateFromAppConfig();
        return reportTypeRepository.findByRoleId(roleId).stream()
                .map(rt -> new ReportTypeDto(rt.getReportName(), rt.getFileName(), startDate))
                .collect(Collectors.toList());
    }

    // ----------------------------------------------------------------------------------
    // 1. DOWNLOAD STREAM WITH PROGRESS (Optimized)
    // ----------------------------------------------------------------------------------
    @Transactional(readOnly = true)
    @Override
    public ReportStreamResponse downloadReportStream(String fileName, LocalDate date, int userRoleId, String userId) {
        
        ReportType reportType = reportTypeRepository.findByFileNameAndRoles_roleId(fileName, userRoleId)
                .orElseThrow(() -> {
                    log.warn("Access Denied: User {} -> Report {}", userId, fileName);
                    sendNotification(userId, "Access Denied for report: " + fileName, "/glif-reports", fileName + "_" + date);
                    return new AccessDeniedException("Access Denied for report: " + fileName);
                });

        String reportDisplayName = reportType.getReportName();
        String formattedDate = date.format(DateTimeFormatter.ISO_LOCAL_DATE);
        Path searchDirectory = new Path(reportsBasePath, formattedDate);
        String fileNamePrefix = fileName + "_" + date.format(DateTimeFormatter.ofPattern("ddMMyyyy"));

        try {
            if (!hdfsFileSystem.exists(searchDirectory)) {
                throw new ResourceNotFoundException("Reports directory not found: " + searchDirectory);
            }

            FileStatus[] fileStatuses = hdfsFileSystem.listStatus(searchDirectory);
            List<FileStatus> matchingFiles = new ArrayList<>();
            long totalSizeBytes = 0;

            for (FileStatus status : fileStatuses) {
                if (status.isFile() && status.getPath().getName().startsWith(fileNamePrefix)) {
                    matchingFiles.add(status);
                    totalSizeBytes += status.getLen();
                }
            }

            if (matchingFiles.isEmpty()) {
                throw new ResourceNotFoundException("No report files found matching prefix: " + fileNamePrefix);
            }

            // Task ID for tracking (Internal Use)
            String taskId = "dl_" + System.currentTimeMillis();
            
            long finalTotalSize = totalSizeBytes;
            StreamingResponseBody streamingBody = outputStream -> {
                try {
                    sendProgress(taskId, userId, 0, "Starting download...", "PROCESSING");
                    AtomicLong globalBytesRead = new AtomicLong(0);

                    if (matchingFiles.size() == 1) {
                         streamSingleFile(matchingFiles.get(0), outputStream, finalTotalSize, globalBytesRead, taskId, userId);
                    } else {
                         streamZipBundle(matchingFiles, outputStream, finalTotalSize, globalBytesRead, taskId, userId);
                    }

                    sendProgress(taskId, userId, 100, "Download Complete", "COMPLETED");
                    sendNotification(userId, String.format("%s downloaded successfully.", reportDisplayName), "/glif-reports", fileName + "_" + date);

                } catch (ClientAbortException | java.net.SocketException e) {
                    log.warn("Download aborted by user: {}", userId);
                    // No FAILED status on user abort
                } catch (IOException e) {
                    log.error("Streaming error: {}", e.getMessage());
                    sendProgress(taskId, userId, 0, "Download Failed", "FAILED");
                    sendNotification(userId, "Download failed due to server error.", "/glif-reports", fileName + "_" + date);
                }
            };

            String downloadName = matchingFiles.size() > 1 ? fileName + "_" + formattedDate + ".zip" : matchingFiles.get(0).getPath().getName();
            return new ReportStreamResponse(downloadName, streamingBody);

        } catch (IOException e) {
            log.error("HDFS Metadata Error: {}", e.getMessage());
            throw new RuntimeException("Storage unavailable", e);
        }
    }

    // ----------------------------------------------------------------------------------
    // 2. CREATE REPORT WITH PROGRESS (Optimized & Resilient)
    // ----------------------------------------------------------------------------------
    @Override
    public Map<String, String> createReports(ReportCreationDto parameters, String userId) throws Exception {
        Map<String, String> reportStat = new HashMap<>();
        String taskId = "gen_" + System.currentTimeMillis();

        LocalDate reportDate = LocalDate.parse(parameters.getDate(), DateTimeFormatter.ofPattern("dd/MM/yyyy"));
        String formattedDate = reportDate.format(DateTimeFormatter.ISO_LOCAL_DATE);
        String datePrefix = reportDate.format(DateTimeFormatter.ofPattern("ddMMyyyy"));
        Path reportDir = new Path(reportsBasePath, formattedDate);

        if (!hdfsFileSystem.exists(reportDir)) {
            hdfsFileSystem.mkdirs(reportDir);
        }

        List<JasperReports> reportsDetails = jasperReportTypeRepository.findAll();
        int totalReports = reportsDetails.size();
        int processedCount = 0;

        sendProgress(taskId, userId, 0, "Starting report generation...", "PROCESSING");

        String logoPath = null;
        try {
            logoPath = new ClassPathResource("images/logo.png").getFile().getAbsolutePath();
        } catch (Exception e) {
            log.warn("Logo not found");
        }

        // Use a single connection for the batch, but handle failures gracefully
        try (Connection connection = dataSource.getConnection()) {
            for (JasperReports report : reportsDetails) {
                processedCount++;
                String reportName = report.getType();
                String jasperFileName = report.getFileName();
                
                // Calculate base percentage for this report
                int basePercent = (int) (((double) (processedCount - 1) / totalReports) * 100);
                sendProgress(taskId, userId, basePercent, "Generating " + reportName + "...", "PROCESSING");
                
                StringBuilder status = new StringBuilder();

                try {
                    java.nio.file.Path jasperPath = Paths.get(jasperFileDir, jasperFileName);
                    if (!jasperPath.toFile().exists()) {
                         throw new FileNotFoundException("Jasper file missing: " + jasperFileName);
                    }

                    try (InputStream jasperStream = new FileInputStream(jasperPath.toString())) {
                        Map<String, Object> reportParams = new HashMap<>();
                        reportParams.put("imagePath", logoPath);
                        reportParams.put("date", parameters.getDate());

                        JasperPrint jasperPrint = JasperFillManager.fillReport(jasperStream, reportParams, connection);

                        // --- PDF ---
                        Path pdfPath = new Path(reportDir, reportName + "_" + datePrefix + ".pdf");
                        try (FSDataOutputStream pdfOut = hdfsFileSystem.create(pdfPath, true)) {
                            JasperExportManager.exportReportToPdfStream(jasperPrint, pdfOut);
                            status.append("PDF generated");
                        }

                        // --- EXCEL ---
                        Path xlsxPath = new Path(reportDir, reportName + "_" + datePrefix + ".xlsx");
                        try (FSDataOutputStream xlsxOut = hdfsFileSystem.create(xlsxPath, true)) {
                            JRXlsxExporter xlsxExporter = new JRXlsxExporter();
                            xlsxExporter.setExporterInput(new SimpleExporterInput(jasperPrint));
                            xlsxExporter.setExporterOutput(new SimpleOutputStreamExporterOutput(xlsxOut));
                            xlsxExporter.exportReport();
                            status.append(", Excel generated");
                        }

                        // --- PSV ---
                        Path psvPath = new Path(reportDir, reportName + "_" + datePrefix + ".psv");
                        try (FSDataOutputStream psvOut = hdfsFileSystem.create(psvPath, true)) {
                            JRCsvExporter csvExporter = new JRCsvExporter();
                            csvExporter.setExporterInput(new SimpleExporterInput(jasperPrint));
                            csvExporter.setExporterOutput(new SimpleWriterExporterOutput(psvOut));
                            SimpleCsvExporterConfiguration csvConfig = new SimpleCsvExporterConfiguration();
                            csvConfig.setFieldDelimiter("|");
                            csvExporter.setConfiguration(csvConfig);
                            csvExporter.exportReport();
                            status.append(", PSV generated");
                        }

                        reportStat.put(reportName, status.toString());
                    }
                } catch (Exception e) {
                    log.error("Error generating {}: {}", reportName, e.getMessage());
                    reportStat.put(reportName, "Failed: " + e.getMessage());
                    // Don't stop the loop; try to generate other reports
                }
            }
        }
        
        sendProgress(taskId, userId, 100, "All reports generated.", "COMPLETED");
        return reportStat;
    }


    // ----------------------------------------------------------------------------------
    // HELPER METHODS (Stream Logic + Redis)
    // ----------------------------------------------------------------------------------

    private void streamSingleFile(FileStatus file, OutputStream outputStream, long totalSize, AtomicLong globalBytesRead, String taskId, String userId) throws IOException {
        try (FSDataInputStream hdfsStream = hdfsFileSystem.open(file.getPath(), BUFFER_SIZE)) {
            copyWithProgress(hdfsStream, outputStream, totalSize, globalBytesRead, taskId, userId);
        }
    }

    private void streamZipBundle(List<FileStatus> files, OutputStream outputStream, long totalSize, AtomicLong globalBytesRead, String taskId, String userId) throws IOException {
        try (ZipOutputStream zipOut = new ZipOutputStream(outputStream)) {
            for (FileStatus status : files) {
                String currentFileName = status.getPath().getName();
                ZipEntry zipEntry = new ZipEntry(currentFileName);
                
                if (isAlreadyCompressed(currentFileName)) {
                    zipOut.setLevel(Deflater.NO_COMPRESSION);
                } else {
                    zipOut.setLevel(Deflater.DEFAULT_COMPRESSION);
                }
                
                zipOut.putNextEntry(zipEntry);
                try (FSDataInputStream hdfsStream = hdfsFileSystem.open(status.getPath(), BUFFER_SIZE)) {
                    copyWithProgress(hdfsStream, zipOut, totalSize, globalBytesRead, taskId, userId);
                }
                zipOut.closeEntry();
            }
        }
    }

    private void copyWithProgress(InputStream in, OutputStream out, long totalSize, AtomicLong globalBytesRead, String taskId, String userId) throws IOException {
        byte[] buffer = new byte[BUFFER_SIZE];
        int bytesRead;
        int lastPercent = 0;

        while ((bytesRead = in.read(buffer)) != -1) {
            out.write(buffer, 0, bytesRead);
            long currentTotal = globalBytesRead.addAndGet(bytesRead);
            
            int percent = (int) ((currentTotal * 100) / totalSize);
            percent = Math.min(percent, 99); 

            if (percent >= lastPercent + 5) {
                sendProgress(taskId, userId, percent, "Downloading... " + percent + "%", "PROCESSING");
                lastPercent = percent;
            }
        }
        out.flush();
    }

    private void sendProgress(String taskId, String userId, int percent, String msg, String status) {
        try {
            TaskProgressDto dto = TaskProgressDto.builder()
                    .taskId(taskId)
                    .userId(userId)
                    .percentage(percent)
                    .message(msg)
                    .status(status)
                    .build();
            redisTemplate.convertAndSend(progressTopic, dto);
        } catch (Exception e) {
            log.warn("Redis notification failed: {}", e.getMessage());
        }
    }

    private boolean isAlreadyCompressed(String fileName) {
        int dotIndex = fileName.lastIndexOf('.');
        if (dotIndex == -1) return false;
        String extension = fileName.substring(dotIndex + 1).toLowerCase();
        return ALREADY_COMPRESSED_EXTS.contains(extension);
    }
    
    private void sendNotification(String userId, String message, String url, String aggregateId) {
        try {
            notificationWriterService.createNotification(userId, null, message, url, aggregateId, "ReportService");
        } catch (Exception e) {
            log.warn("Persistent notification failed: {}", e.getMessage());
        }
    }

    private LocalDate getStartDateFromAppConfig() {
        return appConfigRepository.findByConfigKey(REPORTS_START_DATE_KEY)
                .map(AppConfig::getConfigValue)
                .map(LocalDate::parse)
                .orElseThrow(() -> new ResourceNotFoundException("Configuration missing: " + REPORTS_START_DATE_KEY));
    }
}




