package com.fincore.gateway.dto;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class LoginResponseDTO implements UserLoginDTO {

    private String userId;
    private String accessToken;
    private String tokenType;
    private long expiresIn;
    private String sub;
    private String jti;
    private MenuResponse roleData;
    private String error;
    private boolean validCredentials;
    private String userStatus;
    private String passwordLoginStatus;
    
    // --- ADD THIS FIELD ---
    private Integer attemptsLeft; 
}



















    /**
     * UPDATED LOGIC:
     * 1. Increments count on failure.
     * 2. Calculates remaining attempts.
     * 3. Locks account immediately if limit reached.
     */
    @Transactional
    @Override
    public void passwordBasedLogin(String password, LoginAttempt loginAttempt, UserDto userInfo, User user, LoginParam loginParam) {
        log.info("Password-based login for userId={}", user.getUserId());

        int currentFailedCount = user.getUserWrongPasswordCount();
        int maxAllowed = loginParam.getWrongPasswordAttempts();

        // 1. Check if ALREADY locked (Double safety, though verifyUserCredentials checks status earlier)
        if (Constants.INACTIVE.equalsIgnoreCase(user.getPasswordLogin())) {
            loginAttempt.setFailureReason("Account Locked");
            userInfo.setValidCredentials(false);
            userInfo.setMessage("Your account is locked. Please reset password or contact admin.");
            userInfo.setAttemptsLeft(0);
            return;
        }

        // 2. Validate Password
        if (encoder.matches(password, user.getPasswordHash())) {
            // --- SUCCESS CASE ---
            loginAttempt.setSuccess("Y");
            loginAttempt.setFailureReason("Success");
            userInfo.setValidCredentials(true);
            userInfo.setMessage("Login Successful");
            
            // Reset count on success
            user.setUserWrongPasswordCount(0);
            userRepository.save(user);
            return;
        }

        // --- FAILURE CASE ---
        log.warn("Password mismatch for user {}", user.getUserId());
        
        // Increment the count immediately
        int newFailedCount = currentFailedCount + 1;
        user.setUserWrongPasswordCount(newFailedCount);

        loginAttempt.setSuccess("N");
        userInfo.setValidCredentials(false);

        // Check if this specific failure reached or exceeded the limit
        if (newFailedCount >= maxAllowed) {
            // LOCK THE ACCOUNT
            user.setPasswordLogin(Constants.INACTIVE);
            
            // Optional: You might want to set accountStatus to LOCKED as well, depending on your business rule
            // user.setAccountStatus("LOCKED"); 

            loginAttempt.setFailureReason("Account Locked: Max Attempts Reached");
            userInfo.setMessage("Maximum login attempts exceeded. Your account has been locked.");
            userInfo.setPasswordLoginStatus(Constants.INACTIVE);
            userInfo.setAttemptsLeft(0);
        } else {
            // STILL HAS ATTEMPTS LEFT
            int remaining = maxAllowed - newFailedCount;
            loginAttempt.setFailureReason("Wrong Password");
            userInfo.setMessage("Invalid credentials");
            userInfo.setAttemptsLeft(remaining);
        }

        userRepository.save(user);
    }























    /**
     * LOGIN ENDPOINT (Updated)
     * Handles Valid and Invalid credentials with structured responses.
     */
    @PostMapping(value = "/login", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<ApiResponse<LoginResponseDTO>>> login(ServerHttpRequest request, ServerHttpResponse response, @RequestBody @Valid UserDto payload) {
        final String clientIp = LoginUtility.getClientIp(request);
        log.info("Login request for user: {} from IP: {}", payload.getUserId(), clientIp);

        // 1. IP BLOCK CHECK
        if (isIpBlocked(clientIp)) {
            return Mono.just(ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(ApiResponse.error("Access denied: Your IP address is blocked.", "IP_BLOCKED")));
        }

        return Mono.fromCallable(() -> loginService.verifyUserCredentials(payload, clientIp))
                .subscribeOn(Schedulers.boundedElastic())
                .flatMap(user -> {
                    
                    // =========================================================
                    // CASE 1: INVALID CREDENTIALS (Wrong Password / Locked)
                    // =========================================================
                    if (!user.isValidCredentials()) {
                        log.warn("Login Failed for user: {}. Reason: {}", payload.getUserId(), user.getMessage());

                        // Build response to show Attempts Left
                        LoginResponseDTO errorResponse = LoginResponseDTO.builder()
                                .userId(user.getUserId())
                                .validCredentials(false)
                                .userStatus(user.getUserStatus())
                                .passwordLoginStatus(user.getPasswordLoginStatus())
                                .attemptsLeft(user.getAttemptsLeft()) // <--- PASS COUNT TO FRONTEND
                                .error(user.getMessage())
                                .build();

                        // Determine status code: 403 if Locked, 401 if just wrong password
                        HttpStatus status = (user.getAttemptsLeft() == 0 || "INACTIVE".equals(user.getPasswordLoginStatus())) 
                                            ? HttpStatus.FORBIDDEN 
                                            : HttpStatus.UNAUTHORIZED;

                        return Mono.just(ResponseEntity.status(status)
                                .body(ApiResponse.success(errorResponse, user.getMessage())));
                    }

                    // =========================================================
                    // CASE 2: CONFIG ERROR
                    // =========================================================
                    if (hmacSecret == null || hmacSecret.isBlank()) {
                        return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                .body(ApiResponse.error("Server Config Error", "CONFIG_ERROR")));
                    }

                    // =========================================================
                    // CASE 3: SUCCESS
                    // =========================================================
                    @SuppressWarnings("unchecked")
                    Map<String, Object> claimsMap = mapper.convertValue(user.getUser(), Map.class);
                    
                    String accessToken = HmacJwtUtil.generate(hmacSecret, user.getUserId(), accessTokenTtl, claimsMap);

                    Map<String, Object> refreshClaims = Map.of("type", "refresh");
                    String refreshToken = HmacJwtUtil.generate(hmacSecret, user.getUserId(), refreshTokenTtl, refreshClaims);

                    String jti = extractClaims(accessToken).getId();

                    response.addCookie(createRefreshTokenCookie(refreshToken));

                    return validator.registerUserSession(user.getUserId(), jti)
                            .then(Mono.defer(() -> Mono.fromCallable(() -> loginService.fetchRoleWiseData(user.getUserId()))
                                    .subscribeOn(Schedulers.boundedElastic())))
                            .map(roleData -> {
                                LoginResponseDTO loginResponse = LoginResponseDTO.builder()
                                        .userId(user.getUserId())
                                        .validCredentials(true)
                                        .accessToken(accessToken)
                                        .tokenType("Bearer")
                                        .expiresIn(accessTokenTtl)
                                        .sub(user.getUserId())
                                        .jti(jti)
                                        .roleData(roleData)
                                        .userStatus(user.getUserStatus())
                                        .passwordLoginStatus(user.getPasswordLoginStatus())
                                        .attemptsLeft(null) // No need to show attempts on success
                                        .build();

                                return ResponseEntity.ok(ApiResponse.success(loginResponse, "Login successful"));
                            });
                });
    }

