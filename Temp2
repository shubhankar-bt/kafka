import { useEffect, useRef, useState, useCallback, useMemo } from "react";
import axios from "axios";
import { useLocation, useNavigate } from "react-router-dom";
import useCustomSnackbar from "../utils/useCustomSnackbar";
import { useSelector, useDispatch } from "react-redux";
import { resolveConfig } from "../config/EnvironmentConfig";
import { convertToKebabCase } from "../utils/CommonUtilities";
// import { setToken, logout as reduxLogout } from "../store/authSlice"; // Assuming these exist
import { useContext } from "react";
import { AuthContext } from "../context/AuthContext"; // Import your AuthContext

const useApi = () => {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  const navigate = useNavigate();
  const location = useLocation();
  const snackbar = useCustomSnackbar();
  const dispatch = useDispatch();

  // Use AuthContext for logout and dialog trigger
  const { logout, triggerSessionDialog } = useContext(AuthContext); 

  // Assuming token is stored in Redux, but for refresh logic, we might need to update it.
  // Ideally, the token should come from a source that updates immediately after refresh (like Context or Redux).
  const token = useSelector((state) => state.auth.token); 
  const menus = useSelector((s) => s.menus.menus);
  const selectedMenuItem = useSelector((s) => s.menus.selectedMenuItem);

  /** -------------------- Refs -------------------- */
  const activeRequestsRef = useRef(new Set());
  const isRefreshingRef = useRef(false);
  const refreshQueueRef = useRef([]);

  /** -------------------- Cancel Requests -------------------- */
  const cancelAllRequests = () => {
    activeRequestsRef.current.forEach((controller) => {
      if (!controller.signal.aborted) controller.abort();
    });
    activeRequestsRef.current.clear();
    setLoading(false);
  };

  useEffect(() => () => cancelAllRequests(), []);

  /** -------------------- Refresh Token Logic -------------------- */
  const refreshToken = async () => {
    // If a refresh is already in progress, return a promise that resolves when it's done
    if (isRefreshingRef.current) {
      return new Promise((resolve, reject) => {
        refreshQueueRef.current.push({ resolve, reject });
      });
    }

    isRefreshingRef.current = true;

    try {
      // Get the refresh token from storage (Local Storage is standard for persistence)
      const storedRefreshToken = localStorage.getItem("refreshToken");
      
      if (!storedRefreshToken) {
          throw new Error("No refresh token available");
      }

      // Call the backend refresh endpoint
      // Note: Adjust the URL path if your gateway/service structure is different
      const res = await axios.post(
        `${resolveConfig("/LS") ?? ""}/auth/refresh-token`, 
        { refreshToken: storedRefreshToken },
        { 
            headers: { 'Content-Type': 'application/json' },
            withCredentials: true 
        }
      );

      const newAccessToken = res.data?.accessToken;
      const newRefreshToken = res.data?.refreshToken; // If backend rotates refresh tokens

      if (!newAccessToken) throw new Error("No access token received");

      // Update Storage
      localStorage.setItem("accessToken", newAccessToken);
      if (newRefreshToken) {
          localStorage.setItem("refreshToken", newRefreshToken);
      }

      // Update Redux/Context state so the UI reflects the change if needed
      // dispatch(setToken(newAccessToken)); 

      // Process the queue: Resolve all waiting promises with the new token
      refreshQueueRef.current.forEach(p => p.resolve(newAccessToken));
      refreshQueueRef.current = [];

      return newAccessToken;

    } catch (err) {
      // Process the queue: Reject all waiting promises
      refreshQueueRef.current.forEach(p => p.reject(err));
      refreshQueueRef.current = [];
      throw err;
    } finally {
      isRefreshingRef.current = false;
    }
  };

  /** -------------------- Menu Resolver -------------------- */
  const findMenuItem = useCallback((items, route) => {
    if (!items?.length) return null;

    for (const item of items) {
      if (item.route === route) return item;

      if (item.children?.length) {
        if (route.includes("/choose-option/")) {
          const param = route.split("/choose-option/")[1];
          if (param === convertToKebabCase(item.title)) return item;
        }

        const found = findMenuItem(item.children, route);
        if (found) return found;
      }
    }
    return null;
  }, []);

  const currentMenuFromRoute = useMemo(() => {
    return findMenuItem(menus, location.pathname);
  }, [menus, location.pathname, findMenuItem]);

  const xRequestType = useMemo(
    () =>
      currentMenuFromRoute?.requestType ||
      selectedMenuItem?.requestType ||
      "*",
    [currentMenuFromRoute, selectedMenuItem]
  );

  /** -------------------- Main API Caller -------------------- */
  const callApi = useCallback(
    async (
      url,
      payload = null,
      method = "GET",
      responseType = "json",
      contentType = "application/json",
      extraConfig = {},
      returnDataOnly = true
    ) => {
      const parts = url.split("/");
      const service = parts[1];
      parts[1] = resolveConfig(`/${service}`);
      const Final_Url = parts.slice(1).join("/");

      const controller = new AbortController();
      activeRequestsRef.current.add(controller);

      setLoading(true);
      setError(null);

      // Helper to get current token - prefers argument if provided (for retries)
      const getCurrentToken = () => {
          return extraConfig?.headers?.Authorization?.replace('Bearer ', '') || token || localStorage.getItem("accessToken");
      };

      try {
        const config = {
          method,
          url: Final_Url,
          responseType,
          withCredentials: true,
          signal: controller.signal,
          headers: {
            Authorization: `Bearer ${getCurrentToken()}`,
            "Content-Type": contentType,
            "X-Request-Type": xRequestType,
            ...(extraConfig.headers || {}),
          },
          ...extraConfig,
        };

        if (payload) {
          method === "GET"
            ? (config.params = payload)
            : (config.data = payload);
        }

        const response = await axios(config);
        setData(response.data);

        return returnDataOnly ? response.data : response;

      } catch (err) {
        if (axios.isCancel(err)) {
            // Request was cancelled, do nothing
            return;
        }

        const status = err.response?.status;
        const responseData = err.response?.data;
        // Parse error code safely. Backend might send { error: "CODE" } or { code: "CODE" }
        // Adjust based on your actual backend error structure (e.g. LoginResponseDTO error field)
        // Based on AuthController, it sends { error: "Message/Code" }
        // BUT ContextRbacFilter sends { error: "CODE", message: "..." }
        let errorCode = responseData?.error || responseData?.code; 
        
        // Sometimes error is a string message in AuthController, need to check if it's a code
        // Ideally, backend should be consistent. Assuming "TOKEN_EXPIRED" etc are codes.

        /** ----------------------------------------------------
         * CASE 1: Concurrent Login OR Session Expired (Hard Fail)
         * ----------------------------------------------------
         */
        if (status === 401 && (errorCode === "CONCURRENT_LOGIN" || errorCode === "SESSION_EXPIRED")) {
            // Trigger the UI Dialog through AuthContext
            triggerSessionDialog(errorCode);
            setLoading(false);
            return; // Stop execution
        }

        /** ----------------------------------------------------
         * CASE 2: Token Expired (Soft Fail - Silent Refresh)
         * ----------------------------------------------------
         */
        if (
          status === 401 &&
          errorCode === "TOKEN_EXPIRED" &&
          !extraConfig.__isRetry // Prevent infinite loops
        ) {
          try {
            // 1. Attempt Refresh
            const newToken = await refreshToken();

            // 2. Retry Original Request with New Token
            return await callApi(
              url,
              payload,
              method,
              responseType,
              contentType,
              {
                ...extraConfig,
                __isRetry: true, // Mark as retry
                headers: {
                  ...(extraConfig.headers || {}),
                  Authorization: `Bearer ${newToken}`, // Use new token specifically
                },
              },
              returnDataOnly
            );

          } catch (refreshErr) {
            // Refresh failed (e.g., Refresh token expired) -> Hard Logout
            logout(); 
            // Or trigger dialog: triggerSessionDialog('SESSION_EXPIRED');
            setLoading(false);
            return;
          }
        }

        /** ----------------------------------------------------
         * CASE 3: Other Errors (Business Logic, 500, etc.)
         * ----------------------------------------------------
         */
        const msg =
            err.response?.data?.message ||
            err.response?.data?.error || // Fallback to error field
            err.message ||
            "Something went wrong";
            
        snackbar(msg, "error");
        setError(err);
        
        throw err; // Re-throw for component to handle if needed

      } finally {
        activeRequestsRef.current.delete(controller);
        // Only set loading false if not retrying (retry will set it true again)
        // But since retry is a recursive call, this finally block runs for the *failed* call.
        // The recursive call has its own loading state management.
        setLoading(false); 
      }
    },
    [token, xRequestType, navigate, snackbar, logout, triggerSessionDialog, refreshToken] // Dependencies
  );

  return { data, error, loading, callApi, cancelAllRequests };
};

export default useApi;

