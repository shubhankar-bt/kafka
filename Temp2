import React, {
  createContext,
  useEffect,
  useRef,
  useCallback,
  useState,
} from "react";
import { useDispatch, useSelector } from "react-redux";
import axios from "axios";
import { throttle } from "lodash";
import SessionDialog from "../components/SessionDialog";
import SessionWarningDialog from "../components/SessionWarningDialog";
import { logout as reduxLogout } from "../store/slices/authSlice";
import { resolveConfig } from "../config/EnvironmentConfig";

export const AuthContext = createContext();

const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 min
const WARNING_SECONDS = 30;

export const AuthProvider = ({ children }) => {
  const dispatch = useDispatch();
  const token = useSelector((state) => state.auth.token);
  const user = useSelector((state) => state.auth.user);

  const [warningOpen, setWarningOpen] = useState(false);
  const [secondsLeft, setSecondsLeft] = useState(WARNING_SECONDS);
  
  // Dialog State
  const [sessionDialogOpen, setSessionDialogOpen] = useState(false);
  const [sessionReason, setSessionReason] = useState("");

  const inactivityTimerRef = useRef(null);
  const warningTimerRef = useRef(null);
  const countdownRef = useRef(null);

  // --- 1. Helper to Clear Timers ---
  const clearAllTimers = useCallback(() => {
    if (inactivityTimerRef.current) clearTimeout(inactivityTimerRef.current);
    if (warningTimerRef.current) clearTimeout(warningTimerRef.current);
    if (countdownRef.current) clearInterval(countdownRef.current);
  }, []);

  // --- 2. PERFORM LOGOUT (Destructive) ---
  // Called when user clicks "Return to Login" or manually clicks Logout button.
  const performLogout = useCallback(async () => {
    console.log("Initiating Logout Sequence...");
    clearAllTimers();
    setWarningOpen(false);
    setSessionDialogOpen(false); // Close dialog immediately

    try {
      if (token) {
        // Await the response so it appears in Network tab
        const response = await axios.post(
          `${resolveConfig("/LS") ?? ""}/auth/logout`,
          {},
          {
            headers: { Authorization: `Bearer ${token}` },
            withCredentials: true,
          }
        );
        console.log("Logout API Response:", response.data);
      }
    } catch (err) {
      console.warn("Logout API failed or Network Error:", err);
    } finally {
      console.log("Clearing Client State and Redirecting...");
      dispatch(reduxLogout());
      
      // OPTIONAL: Add a small delay (e.g., 500ms) to ensure 
      // the network request is visible in DevTools before the page reloads.
      setTimeout(() => {
          window.location.replace("/");
      }, 500);
    }
  }, [token, dispatch, clearAllTimers]);

  // --- 3. TRIGGER SESSION DIALOG (Safe) ---
  // Called by System Events (Concurrent Login, Timeout).
  // Shows dialog but keeps page/token alive.
  const showSessionDialog = useCallback((reason = "SESSION_EXPIRED") => {
      // Prevent spamming state updates if already open
      setSessionDialogOpen((prev) => {
        if (prev) return true;
        
        clearAllTimers();
        setWarningOpen(false);
        setSessionReason(reason);
        return true;
      });
  }, [clearAllTimers]);

  // --- 4. Inactivity Timer Logic ---
  const startInactivity = useCallback(() => {
    clearAllTimers();
    if (!user) return;

    // Warning Timer
    warningTimerRef.current = setTimeout(() => {
      setWarningOpen(true);
      setSecondsLeft(WARNING_SECONDS);

      let counter = WARNING_SECONDS;
      countdownRef.current = setInterval(() => {
        counter -= 1;
        setSecondsLeft(counter);
        if (counter <= 0) clearInterval(countdownRef.current);
      }, 1000);
    }, INACTIVITY_TIMEOUT - WARNING_SECONDS * 1000);

    // Hard Stop Timer -> Show Dialog
    inactivityTimerRef.current = setTimeout(() => {
      showSessionDialog("SESSION_EXPIRED");
    }, INACTIVITY_TIMEOUT);
  }, [user, clearAllTimers, showSessionDialog]);

  // --- 5. Activity Listener ---
  const onActivity = useCallback(
    throttle(() => {
      if (!user || sessionDialogOpen) return;
      if (warningOpen) setWarningOpen(false);
      startInactivity();
    }, 2000),
    [user, startInactivity, sessionDialogOpen, warningOpen]
  );

  useEffect(() => {
    if (!user) {
      clearAllTimers();
      setWarningOpen(false);
      return;
    }

    startInactivity();
    const events = ["mousemove", "keydown", "click", "scroll", "touchstart"];
    events.forEach((e) => window.addEventListener(e, onActivity));

    return () => {
      events.forEach((e) => window.removeEventListener(e, onActivity));
      onActivity.cancel();
      clearAllTimers();
    };
  }, [user, onActivity, startInactivity, clearAllTimers]);

  return (
    <AuthContext.Provider
      value={{
        logout: performLogout,          // Use for Manual Logout
        triggerSessionDialog: showSessionDialog, // Use for System Events
      }}
    >
      {children}

      <SessionWarningDialog
        open={warningOpen}
        secondsLeft={secondsLeft}
        onContinue={() => {
            setWarningOpen(false);
            startInactivity();
        }}
      />

      {/* When user confirms dialog, execute the destructive logout */}
      <SessionDialog
        open={sessionDialogOpen}
        reason={sessionReason}
        onConfirm={performLogout} 
      />
    </AuthContext.Provider>
  );
};














import {
  useState,
  useRef,
  useCallback,
  useContext,
  useEffect,
  useMemo,
} from "react";
import axios from "axios";
import { useLocation } from "react-router-dom";
import { useDispatch, useSelector } from "react-redux";
import useCustomSnackbar from "../utils/useCustomSnackbar";
import { resolveConfig } from "../config/EnvironmentConfig";
import { convertToKebabCase } from "../utils/CommonUtilities";
import { AuthContext } from "../context/AuthContext";
import { parseJwt } from "../utils/EncryptionUtilities";
import { setToken, setUser } from "../store/slices/authSlice";

const useApi = () => {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  const location = useLocation();
  const snackbar = useCustomSnackbar();
  const dispatch = useDispatch();

  // Get both functions from context
  const { triggerSessionDialog, logout } = useContext(AuthContext);
  
  const token = useSelector((state) => state.auth.token);
  const menus = useSelector((s) => s.menus.menus);
  const selectedMenuItem = useSelector((s) => s.menus.selectedMenuItem);

  const activeRequestsRef = useRef(new Set());
  const isRefreshingRef = useRef(false);
  const refreshQueueRef = useRef([]);
  const sessionInvalidatedRef = useRef(false);

  // Cancel requests helper
  const cancelAllRequests = useCallback(() => {
    activeRequestsRef.current.forEach((controller) => {
      if (!controller.signal.aborted) controller.abort();
    });
    activeRequestsRef.current.clear();
    setLoading(false);
  }, []);

  useEffect(() => cancelAllRequests, [cancelAllRequests]);

  // Handler for hard session failures (Concurrent/Expired)
  const handleSessionInvalid = useCallback(
    (reason) => {
      if (sessionInvalidatedRef.current) return;
      sessionInvalidatedRef.current = true;
      
      cancelAllRequests();
      
      // CRITICAL: Call the SAFE trigger. 
      // Do NOT call logout() here, or the page will vanish before dialog appears.
      triggerSessionDialog(reason);
    },
    [cancelAllRequests, triggerSessionDialog]
  );

  const refreshToken = useCallback(async () => {
    if (isRefreshingRef.current) {
      return new Promise((resolve, reject) => {
        refreshQueueRef.current.push({ resolve, reject });
      });
    }

    isRefreshingRef.current = true;

    try {
      const res = await axios.post(
        `${resolveConfig("/LS") ?? ""}/auth/refresh-token`,
        {},
        { withCredentials: true }
      );

      const { accessToken, refreshToken: newRefreshToken } = res.data || {};
      if (!accessToken) throw new Error("No access token from refresh");

      const user = parseJwt(accessToken);
      dispatch(setToken(accessToken));
      dispatch(setUser(user));

      localStorage.setItem("accessToken", accessToken);
      if (newRefreshToken) {
        localStorage.setItem("refreshToken", newRefreshToken);
      }

      refreshQueueRef.current.forEach((p) => p.resolve(accessToken));
      refreshQueueRef.current = [];

      return accessToken;
    } catch (err) {
      refreshQueueRef.current.forEach((p) => p.reject(err));
      refreshQueueRef.current = [];
      throw err;
    } finally {
      isRefreshingRef.current = false;
    }
  }, [dispatch]);

  // ... Menu logic (unchanged) ...
  const findMenuItem = useCallback((items, route) => {
    if (!items?.length) return null;
    for (const item of items) {
      if (item.route === route) return item;
      if (item.children?.length) {
        if (route.includes("/choose-option/")) {
          const param = route.split("/choose-option/")[1];
          if (param === convertToKebabCase(item.title)) return item;
        }
        const found = findMenuItem(item.children, route);
        if (found) return found;
      }
    }
    return null;
  }, []);

  const currentMenuFromRoute = useMemo(
    () => findMenuItem(menus, location.pathname),
    [menus, location.pathname, findMenuItem]
  );

  const xRequestType = useMemo(
    () => currentMenuFromRoute?.requestType || selectedMenuItem?.requestType || "*",
    [currentMenuFromRoute, selectedMenuItem]
  );

  // Main API Call Logic
  const callApi = useCallback(
    async (
      url,
      payload = null,
      method = "GET",
      responseType = "json",
      contentType = "application/json",
      extraConfig = {},
      returnDataOnly = true
    ) => {
      const parts = url.split("/");
      const service = parts[1];
      parts[1] = resolveConfig(`/${service}`);
      const Final_Url = parts.slice(1).join("/");

      const controller = new AbortController();
      activeRequestsRef.current.add(controller);

      setLoading(true);
      setError(null);

      const getCurrentToken = () =>
        extraConfig?.headers?.Authorization?.replace("Bearer ", "") ||
        localStorage.getItem("accessToken") ||
        token;

      try {
        const config = {
          method,
          url: Final_Url,
          responseType,
          withCredentials: true,
          signal: controller.signal,
          headers: {
            Authorization: `Bearer ${getCurrentToken()}`,
            "Content-Type": contentType,
            "X-Request-Type": xRequestType,
            ...(extraConfig.headers || {}),
          },
          ...extraConfig,
        };

        if (payload) {
          method === "GET"
            ? (config.params = payload)
            : (config.data = payload);
        }

        const response = await axios(config);
        setData(response.data);
        return returnDataOnly ? response.data : response;
      } catch (err) {
        if (axios.isCancel(err)) return;

        const status = err.response?.status;
        const code = err.response?.data?.error || err.response?.data?.code;

        /** HARD FAIL - Shows Dialog */
        if (
          status === 401 &&
          (code === "CONCURRENT_LOGIN" || code === "SESSION_EXPIRED")
        ) {
          handleSessionInvalid(code);
          return; // Stop here, dialog takes over
        }

        /** TOKEN EXPIRED - Retry Logic */
        if (
          status === 401 &&
          code === "TOKEN_EXPIRED" &&
          !extraConfig.__isRetry
        ) {
          try {
            const newToken = await refreshToken();
            return await callApi(
              url,
              payload,
              method,
              responseType,
              contentType,
              {
                ...extraConfig,
                __isRetry: true,
                headers: {
                  ...(extraConfig.headers || {}),
                  Authorization: `Bearer ${newToken}`,
                },
              },
              returnDataOnly
            );
          } catch {
            // If refresh fails, then we do a hard logout
            logout(); 
            return;
          }
        }

        const msg = err.response?.data?.message || err.message || "Error";
        snackbar(msg, "error");
        setError(err);
        throw err;
      } finally {
        activeRequestsRef.current.delete(controller);
        if (!extraConfig.__isRetry) setLoading(false);
      }
    },
    [token, xRequestType, snackbar, logout, handleSessionInvalid, refreshToken]
  );

  return { data, error, loading, callApi, cancelAllRequests };
};

export default useApi;













import React, { useEffect, useContext } from "react";
import { Navigate, Outlet } from "react-router-dom";
import { useSelector } from "react-redux";
import { AuthContext } from "../context/AuthContext";

const PrivateRouter = () => {
  const { token, user } = useSelector((state) => state.auth);
  const tabId = useSelector((state) => state.tab.tabId);
  
  // Use SAFE trigger
  const { triggerSessionDialog } = useContext(AuthContext);

  useEffect(() => {
    if (!user?.userId || !tabId) return;

    const bc = new BroadcastChannel("auth");

    const handleMessage = (event) => {
      const { type, userId: eventUserId, tabId: eventTabId } = event.data || {};

      if (
        type === "USER_LOGGED_IN" &&
        eventUserId === user.userId &&
        eventTabId !== tabId
      ) {
        // Just show dialog. Do NOT redirect.
        triggerSessionDialog("CONCURRENT_LOGIN");
      }
    };

    bc.onmessage = handleMessage;

    return () => {
      bc.close();
    };
  }, [user, tabId, triggerSessionDialog]);

  if (!token) {
    return <Navigate to="/" replace />;
  }

  return <Outlet />;
};

export default PrivateRouter;


