    /**
     * LOGOUT ENDPOINT (ROBUST & VERIFIED)
     * Handles:
     * 1. Valid Tokens -> Standard Logout
     * 2. Expired Tokens -> Manually extracts claims -> Cleans up Redis if JTI matches
     * 3. Concurrent Logins -> Blacklists current token, but PRESERVES the active session in Redis
     * 4. Missing/Malformed Tokens -> Clears cookies and returns success (Idempotent)
     */
    @PostMapping(value = "/logout", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<ApiResponse<LoginResponseDTO>>> logout(JwtAuthenticationToken jwtAuth, ServerHttpRequest request, ServerHttpResponse response) {

        // 1. Always clear the Refresh Token Cookie (Idempotent)
        response.addCookie(createEmptyCookie());

        String tokenString = null;

        // Strategy A: Valid Context
        if (jwtAuth != null && jwtAuth.getToken() != null) {
            tokenString = jwtAuth.getToken().getTokenValue();
        }
        // Strategy B: Manual Header Extraction (Expired Tokens)
        else {
            String header = request.getHeaders().getFirst("Authorization");
            if (header != null && header.startsWith("Bearer ")) {
                tokenString = header.substring(7);
            }
        }

        // 3. Fast Exit: If no token found anywhere, just return success so frontend can clear state
        if (tokenString == null || tokenString.isBlank()) {
            log.warn("Logout called without token. Cleaning up cookies only.");
            return Mono.just(ResponseEntity.ok(
                    ApiResponse.<LoginResponseDTO>success(
                            LoginResponseDTO.builder().userId("anonymous").build(),
                            "Logged out (No Token)"
                    )
            ));
        }

        final String finalToken = tokenString;

        // 4. Processing Chain
        return Mono.fromCallable(() -> {
                    try {
                        // Try standard parsing
                        return extractClaims(finalToken);
                    } catch (ExpiredJwtException e) {
                        // CRITICAL FIX: If token is expired, we STILL want the claims to perform cleanup
                        log.info("Logout: Token is expired. Using claims from exception for cleanup.");
                        return e.getClaims();
                    }
                })
                .subscribeOn(Schedulers.boundedElastic())
                .flatMap(claims -> {
                    String userId = claims.getSubject();
                    String incomingJti = claims.getId();

                    if (userId == null || incomingJti == null) {
                        return Mono.just(ResponseEntity.ok(
                                ApiResponse.<LoginResponseDTO>success(null, "Invalid Token Claims during logout")
                        ));
                    }

                    log.info("Logout Processing for User: {} | JTI: {}", userId, incomingJti);

                    // 5. Blacklist the Token (Always blacklist the incoming token)
                    return validator.blacklistToken(incomingJti)
                            .then(redisTemplate.opsForValue().get(USER_PREFIX + userId))
                            .flatMap(activeJti -> {
                                // 6. Conditional Redis Cleanup
                                if (activeJti != null && activeJti.equals(incomingJti)) {
                                    // SCENARIO: Normal Logout. The session in Redis belongs to THIS token.
                                    // Action: Delete it.
                                    log.info("Session MATCH. Deleting active session for user: {}", userId);
                                    return validator.clearUserSession(userId)
                                            .then(Mono.just(ResponseEntity.ok(
                                                    ApiResponse.<LoginResponseDTO>success(
                                                            LoginResponseDTO.builder().userId(userId).error("Logged out").build(),
                                                            "Logged out successfully"
                                                    )
                                            )));
                                } else {
                                    // SCENARIO: Concurrent Login.
                                    // The session in Redis belongs to a NEWER token (on another device/tab).
                                    // Action: Do NOT delete it. Just let the blacklist happen.
                                    log.warn("Session MISMATCH or ALREADY GONE. Active JTI: {}. Incoming JTI: {}. Preserving Redis Session.", activeJti, incomingJti);
                                    return Mono.just(ResponseEntity.ok(
                                            ApiResponse.<LoginResponseDTO>success(
                                                    LoginResponseDTO.builder().userId(userId).error("Logged out (Concurrent Session Preserved)").build(),
                                                    "Logged out (Concurrent Session Preserved)"
                                            )
                                    ));
                                }
                            })
                            // If key is missing in Redis (Already timed out), return success
                            .switchIfEmpty(Mono.just(ResponseEntity.ok(
                                    ApiResponse.<LoginResponseDTO>success(
                                            LoginResponseDTO.builder().userId(userId).error("Logged out (Session already expired)").build(),
                                            "Logged out (Session already expired)"
                                    )
                            )));
                })
                .onErrorResume(e -> {
                    // Safety Net: If anything explodes (Redis down, etc), allow frontend to logout
                    log.error("Logout Unexpected Error", e);
                    return Mono.just(ResponseEntity.ok(
                            ApiResponse.<LoginResponseDTO>success(null, "Logged out (System Error handled)")
                    ));
                });
    }


