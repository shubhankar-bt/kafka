import React, {
  createContext,
  useEffect,
  useRef,
  useCallback,
  useState,
} from "react";
import { useDispatch, useSelector } from "react-redux";
import axios from "axios";
import { throttle } from "lodash";
import SessionDialog from "../components/SessionDialog";
import SessionWarningDialog from "../components/SessionWarningDialog";
import { logout as reduxLogout } from "../store/slices/authSlice";
import { resolveConfig } from "../config/EnvironmentConfig";

export const AuthContext = createContext();

const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 min
const WARNING_SECONDS = 30;

export const AuthProvider = ({ children }) => {
  const dispatch = useDispatch();
  const token = useSelector((state) => state.auth.token);
  const user = useSelector((state) => state.auth.user);

  const [warningOpen, setWarningOpen] = useState(false);
  const [secondsLeft, setSecondsLeft] = useState(WARNING_SECONDS);
  const [sessionDialogOpen, setSessionDialogOpen] = useState(false);
  const [sessionReason, setSessionReason] = useState("");

  const inactivityTimerRef = useRef(null);
  const warningTimerRef = useRef(null);
  const countdownRef = useRef(null);

  // 1. Helper to Clear Timers
  const clearAllTimers = useCallback(() => {
    if (inactivityTimerRef.current) clearTimeout(inactivityTimerRef.current);
    if (warningTimerRef.current) clearTimeout(warningTimerRef.current);
    if (countdownRef.current) clearInterval(countdownRef.current);
  }, []);

  // 2. Perform Logout (Destructive - Clears State & Redirects)
  // This is called ONLY when the user clicks "Return to Login" or manually logs out.
  const performLogout = useCallback(async () => {
    clearAllTimers();
    setWarningOpen(false);
    setSessionDialogOpen(false);

    try {
      // Call API to clear cookies on server
      // We explicitly pass the token here because we are about to delete it from Redux
      if (token) {
        await axios.post(
          `${resolveConfig("/LS") ?? ""}/auth/logout`,
          {},
          {
            headers: { Authorization: `Bearer ${token}` },
            withCredentials: true,
          }
        );
      }
    } catch (err) {
      console.warn("Logout API failed (ignoring)", err);
    } finally {
      // Clear Redux State -> Triggers PrivateRouter redirect
      dispatch(reduxLogout());
      window.location.replace("/");
    }
  }, [token, dispatch, clearAllTimers]);

  // 3. Show Session Dialog (Safe - Does NOT clear state)
  // This keeps the user on the current screen but blocks them with the dialog.
  const showSessionDialog = useCallback((reason = "SESSION_EXPIRED") => {
      clearAllTimers();
      setWarningOpen(false);
      setSessionReason(reason);
      setSessionDialogOpen(true);
      // NOTE: We do NOT call dispatch(reduxLogout()) here. 
      // This keeps the underlying page rendered so the Dialog can sit on top.
  }, [clearAllTimers]);

  // 4. Inactivity Timer Logic
  const startInactivity = useCallback(() => {
    clearAllTimers();
    if (!user) return;

    // Warning Timer
    warningTimerRef.current = setTimeout(() => {
      setWarningOpen(true);
      setSecondsLeft(WARNING_SECONDS);

      let counter = WARNING_SECONDS;
      countdownRef.current = setInterval(() => {
        counter -= 1;
        setSecondsLeft(counter);
        if (counter <= 0) clearInterval(countdownRef.current);
      }, 1000);
    }, INACTIVITY_TIMEOUT - WARNING_SECONDS * 1000);

    // Hard Stop Timer -> Show Dialog
    inactivityTimerRef.current = setTimeout(() => {
      showSessionDialog("SESSION_EXPIRED");
    }, INACTIVITY_TIMEOUT);
  }, [user, clearAllTimers, showSessionDialog]);

  // 5. Activity Listeners
  const onActivity = useCallback(
    throttle(() => {
      if (!user || sessionDialogOpen) return;
      if (warningOpen) setWarningOpen(false);
      startInactivity();
    }, 2000),
    [user, startInactivity, sessionDialogOpen, warningOpen]
  );

  useEffect(() => {
    if (!user) {
      clearAllTimers();
      setWarningOpen(false);
      return;
    }

    startInactivity();
    const events = ["mousemove", "keydown", "click", "scroll", "touchstart"];
    events.forEach((e) => window.addEventListener(e, onActivity));

    return () => {
      events.forEach((e) => window.removeEventListener(e, onActivity));
      onActivity.cancel();
      clearAllTimers();
    };
  }, [user, onActivity, startInactivity, clearAllTimers]);

  return (
    <AuthContext.Provider
      value={{
        logout: performLogout,          // Manual Action (Clear state)
        triggerSessionDialog: showSessionDialog, // System Event (Show UI only)
      }}
    >
      {children}

      <SessionWarningDialog
        open={warningOpen}
        secondsLeft={secondsLeft}
        onContinue={() => {
            setWarningOpen(false);
            startInactivity();
        }}
      />

      {/* When user confirms the dialog, WE CALL performLogout */}
      <SessionDialog
        open={sessionDialogOpen}
        reason={sessionReason}
        onConfirm={performLogout} 
      />
    </AuthContext.Provider>
  );
};


