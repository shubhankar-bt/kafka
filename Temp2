import React from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Button,
} from "@mui/material";

const SessionDialog = ({ open, reason, onConfirm }) => {
  let title = "Session Expired";
  let message = "Your session has ended due to inactivity. Please log in again.";

  if (reason === "CONCURRENT_LOGIN") {
    title = "Security Alert";
    message = "You have been logged out because this account signed in on another device or tab.";
  }

  return (
    <Dialog 
      open={open} 
      disableEscapeKeyDown={true}
      // Prevent closing by clicking outside
      onClose={() => {}} 
      aria-labelledby="session-dialog-title"
      sx={{ zIndex: 9999 }} // Ensure it sits on top of everything
    >
      <DialogTitle id="session-dialog-title" color="error">
        {title}
      </DialogTitle>
      <DialogContent>
        <DialogContentText>
          {message}
        </DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button 
          onClick={onConfirm} 
          variant="contained" 
          color="primary"
          autoFocus
        >
          Return to Login
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default SessionDialog;










import React, {
  createContext,
  useEffect,
  useRef,
  useCallback,
  useState,
} from "react";
import { useDispatch, useSelector } from "react-redux";
import axios from "axios";
import { throttle } from "lodash";
import SessionDialog from "../components/SessionDialog";
import SessionWarningDialog from "../components/SessionWarningDialog";
import { logout as reduxLogout } from "../store/slices/authSlice";
import { resolveConfig } from "../config/EnvironmentConfig";

export const AuthContext = createContext();

const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 min
const WARNING_SECONDS = 30;

export const AuthProvider = ({ children }) => {
  const dispatch = useDispatch();
  const token = useSelector((state) => state.auth.token);
  const user = useSelector((state) => state.auth.user);

  const [warningOpen, setWarningOpen] = useState(false);
  const [secondsLeft, setSecondsLeft] = useState(WARNING_SECONDS);
  const [sessionDialogOpen, setSessionDialogOpen] = useState(false);
  const [sessionReason, setSessionReason] = useState("");

  const inactivityTimerRef = useRef(null);
  const warningTimerRef = useRef(null);
  const countdownRef = useRef(null);

  /* ---------- 1. Clear Timers Helper ---------- */
  const clearAllTimers = useCallback(() => {
    if (inactivityTimerRef.current) clearTimeout(inactivityTimerRef.current);
    if (warningTimerRef.current) clearTimeout(warningTimerRef.current);
    if (countdownRef.current) clearInterval(countdownRef.current);
  }, []);

  /* ---------- 2. The Final Cleanup (Destructive) ---------- */
  // This is only called when the user CLICKS the button in the dialog
  // OR manually clicks a "Logout" button in the UI.
  const completeLogout = useCallback(async () => {
      clearAllTimers();
      setWarningOpen(false);
      
      try {
        await axios.post(
          `${resolveConfig("/LS") ?? ""}/auth/logout`,
          {},
          {
            headers: { Authorization: `Bearer ${token}` },
            withCredentials: true,
          }
        );
      } catch (err) {
        console.error("Logout API failed (ignoring)", err);
      }

      // CRITICAL: This line triggers the Redirect. We only run it NOW.
      dispatch(reduxLogout());
      setSessionDialogOpen(false);
      window.location.replace("/");
  }, [token, dispatch, clearAllTimers]);


  /* ---------- 3. System Triggered Logout (Non-Destructive UI) ---------- */
  // This is called by Concurrent Login checks or Timeouts.
  // It ONLY shows the dialog. It does NOT clear Redux state yet.
  const triggerSessionDialog = useCallback((reason = "SESSION_EXPIRED") => {
      // If already open, don't spam
      setSessionDialogOpen((prev) => {
        if (prev) return true;
        
        clearAllTimers();
        setWarningOpen(false);
        setSessionReason(reason);
        return true;
      });
  }, [clearAllTimers]);


  /* ---------- 4. Start Inactivity Timers ---------- */
  const startInactivity = useCallback(() => {
    clearAllTimers();
    if (!user) return;

    // Timer 1: Show Warning Dialog
    warningTimerRef.current = setTimeout(() => {
      setWarningOpen(true);
      setSecondsLeft(WARNING_SECONDS);

      let counter = WARNING_SECONDS;
      countdownRef.current = setInterval(() => {
        counter -= 1;
        setSecondsLeft(counter);
        if (counter <= 0) clearInterval(countdownRef.current);
      }, 1000);
    }, INACTIVITY_TIMEOUT - WARNING_SECONDS * 1000);

    // Timer 2: Trigger the Session Ended Dialog (Do NOT auto-redirect yet)
    inactivityTimerRef.current = setTimeout(() => {
      triggerSessionDialog("SESSION_EXPIRED");
    }, INACTIVITY_TIMEOUT);
  }, [user, clearAllTimers, triggerSessionDialog]);

  /* ---------- 5. Activity Handler ---------- */
  const onActivity = useCallback(
    throttle(() => {
      // If dialog is open, stop tracking activity
      if (!user || sessionDialogOpen) return;
      
      // If warning was open, close it and reset
      if (warningOpen) setWarningOpen(false);
      
      startInactivity();
    }, 2000),
    [user, startInactivity, sessionDialogOpen, warningOpen]
  );

  /* ---------- 6. Watch User State ---------- */
  useEffect(() => {
    if (!user) {
      clearAllTimers();
      setWarningOpen(false);
      return;
    }

    startInactivity();

    const events = ["mousemove", "keydown", "click", "scroll", "touchstart"];
    events.forEach((e) => window.addEventListener(e, onActivity));

    return () => {
      events.forEach((e) => window.removeEventListener(e, onActivity));
      onActivity.cancel();
      clearAllTimers();
    };
  }, [user, onActivity, startInactivity, clearAllTimers]);

  return (
    <AuthContext.Provider
      value={{
        logout: completeLogout,          // Manual User Logout (Immediate)
        triggerSessionDialog,            // System Event (Shows Dialog, waits for click)
      }}
    >
      {children}

      <SessionWarningDialog
        open={warningOpen}
        secondsLeft={secondsLeft}
        onContinue={() => {
            setWarningOpen(false);
            startInactivity();
        }}
      />

      {/* The Dialog runs completeLogout when confirmed */}
      <SessionDialog
        open={sessionDialogOpen}
        reason={sessionReason}
        onConfirm={completeLogout} 
      />
    </AuthContext.Provider>
  );
};











import React, { useEffect, useContext } from "react";
import { Navigate, Outlet } from "react-router-dom";
import { useSelector } from "react-redux";
import { AuthContext } from "../context/AuthContext";

const PrivateRouter = () => {
  const { token, user } = useSelector((state) => state.auth);
  const tabId = useSelector((state) => state.tab.tabId);
  
  // Use the context trigger
  const { triggerSessionDialog } = useContext(AuthContext);

  useEffect(() => {
    if (!user?.userId || !tabId) return;

    const bc = new BroadcastChannel("auth");

    const handleMessage = (event) => {
      const { type, userId: eventUserId, tabId: eventTabId } = event.data || {};

      // Concurrent Login Detection (Same User, Different Tab)
      if (
        type === "USER_LOGGED_IN" &&
        eventUserId === user.userId &&
        eventTabId !== tabId
      ) {
        // Trigger the Dialog. 
        // NOTE: This does NOT clear Redux, so <Outlet /> stays rendered below the dialog.
        triggerSessionDialog("CONCURRENT_LOGIN");
      }
    };

    bc.onmessage = handleMessage;

    return () => {
      bc.close();
    };
  }, [user, tabId, triggerSessionDialog]);

  // If token is explicitly null (user manually logged out), redirect.
  // But if concurrent login happened, token is STILL here until they click OK in dialog.
  if (!token) {
    return <Navigate to="/" replace />;
  }

  return <Outlet />;
};

export default PrivateRouter;


