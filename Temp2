import axios from "axios";
import { resolveConfig } from "../config/EnvironmentConfig"; // Ensure this path is correct
import { tokenRefreshed, logoutSuccess } from "../store/slices/authSlice";
import { parseJwt } from "../utils/EncryptionUtilities";

let store; // Will hold the Redux store reference

// Inject store from App.js or index.js to avoid circular dependency
export const injectStore = (_store) => {
  store = _store;
};

// Create a Singleton Axios Instance
const api = axios.create({
  baseURL: resolveConfig("/LS") ?? "", // Base URL
  withCredentials: true, // IMPORTANT: Allows sending/receiving HttpOnly Cookies
  headers: {
    "Content-Type": "application/json",
  },
});

// --- Request Interceptor ---
api.interceptors.request.use(
  (config) => {
    // 1. Get Token from Redux Store
    const state = store?.getState();
    const token = state?.auth?.token;

    // 2. Attach Authorization Header
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    // 3. Attach Context Header (X-Request-Type) if passed in config
    // The hook will pass this in, or defaults to '*'
    if (!config.headers["X-Request-Type"]) {
        config.headers["X-Request-Type"] = "*";
    }

    return config;
  },
  (error) => Promise.reject(error)
);

// --- Response Interceptor ---
let isRefreshing = false;
let failedQueue = [];

const processQueue = (error, token = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });
  failedQueue = [];
};

api.interceptors.response.use(
  (response) => {
    return response;
  },
  async (error) => {
    const originalRequest = error.config;
    
    // Safety check to prevent infinite loops
    if (!originalRequest || originalRequest._retryCount > 2) {
        return Promise.reject(error);
    }

    // Extract Error Details
    const status = error.response?.status;
    const errorCode = error.response?.data?.error || error.response?.data?.code;

    // ---------------------------------------------------------
    // SCENARIO 1: Concurrent Login / Session Invalidated
    // ---------------------------------------------------------
    if (status === 401 && (errorCode === "CONCURRENT_LOGIN" || errorCode === "SESSION_EXPIRED" || errorCode === "INVALID_TOKEN")) {
       // Do NOT attempt refresh. The session is dead.
       // We dispatch a custom event that AuthContext listens to for the Dialog
       window.dispatchEvent(new CustomEvent("auth:session-expired", { detail: { reason: errorCode } }));
       
       // Clear local state immediately
       store.dispatch(logoutSuccess());
       return Promise.reject(error);
    }

    // ---------------------------------------------------------
    // SCENARIO 2: Access Token Expired (Try Refresh)
    // ---------------------------------------------------------
    if (status === 401 && errorCode === "TOKEN_EXPIRED" && !originalRequest._retry) {
      if (isRefreshing) {
        // If already refreshing, queue this request
        return new Promise(function (resolve, reject) {
          failedQueue.push({
            resolve: (token) => {
              originalRequest.headers["Authorization"] = "Bearer " + token;
              resolve(api(originalRequest));
            },
            reject: (err) => {
              reject(err);
            },
          });
        });
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        // Call Backend Refresh Endpoint
        // Note: We don't send the refresh token in body; backend reads the Cookie
        const response = await api.post("/auth/refresh-token");
        
        const { accessToken } = response.data;
        
        if(accessToken) {
             // 1. Update Redux
             const user = parseJwt(accessToken);
             store.dispatch(tokenRefreshed({ token: accessToken, user }));
             
             // 2. Process Queue
             processQueue(null, accessToken);
             
             // 3. Retry Original Request
             originalRequest.headers["Authorization"] = "Bearer " + accessToken;
             return api(originalRequest);
        } else {
            throw new Error("No access token returned");
        }
      } catch (refreshError) {
        processQueue(refreshError, null);
        store.dispatch(logoutSuccess());
        window.dispatchEvent(new CustomEvent("auth:session-expired", { detail: { reason: "SESSION_EXPIRED" } }));
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);

export default api;

import { useState, useCallback, useRef, useEffect } from "react";
import { useSelector } from "react-redux";
import { useLocation } from "react-router-dom";
import api from "../utils/axiosConfig"; // Import the Singleton
import useCustomSnackbar from "../utils/useCustomSnackbar";
import { convertToKebabCase } from "../utils/CommonUtilities";

const useApi = () => {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);
  
  const activeRequests = useRef(new Set());
  const snackbar = useCustomSnackbar();
  const location = useLocation();

  // Get Menus from Redux to calculate X-Request-Type
  const menus = useSelector((state) => state.menus.menus);
  const selectedMenuItem = useSelector((state) => state.menus.selectedMenuItem);

  // --- Helper to find Menu Item based on Route ---
  const findMenuItem = useCallback((items, route) => {
    if (!items?.length) return null;
    for (const item of items) {
      if (item.route === route) return item;
      if (item.children?.length) {
         // Handle dynamic routes if needed
         if (route.includes("/choose-option/")) {
            const param = route.split("/choose-option/")[1];
            if (param === convertToKebabCase(item.title)) return item;
         }
         const found = findMenuItem(item.children, route);
         if (found) return found;
      }
    }
    return null;
  }, []);

  // Calculate X-Request-Type only when location changes
  const xRequestType = (() => {
      const currentMenu = findMenuItem(menus, location.pathname);
      return currentMenu?.requestType || selectedMenuItem?.requestType || "*";
  })();

  const cancelAllRequests = useCallback(() => {
    activeRequests.current.forEach((controller) => {
        controller.abort();
    });
    activeRequests.current.clear();
  }, []);

  // Cleanup on unmount
  useEffect(() => {
      return () => cancelAllRequests();
  }, [cancelAllRequests]);

  const callApi = useCallback(
    async (
      url,
      payload = null,
      method = "GET",
      responseType = "json",
      contentType = "application/json",
      extraConfig = {},
      returnDataOnly = true
    ) => {
      setLoading(true);
      setError(null);
      const controller = new AbortController();
      activeRequests.current.add(controller);

      // Determine the Service URL (e.g. /LS/auth/...)
      // Assuming url comes in as "/LS/auth/login" or similar
      // The logic below adapts your existing split logic
      let finalUrl = url;
      if(url.startsWith("/")) {
          const parts = url.split("/");
          // parts[0] is empty, parts[1] is service name (e.g. LS)
          // Ensure your resolveConfig logic is handled either here or in axiosConfig baseURL
          // If axiosConfig has baseURL, you might just need the relative path
      }

      try {
        const config = {
          method,
          url: finalUrl,
          data: method !== "GET" ? payload : undefined,
          params: method === "GET" ? payload : undefined,
          responseType,
          signal: controller.signal,
          headers: {
            "Content-Type": contentType,
            "X-Request-Type": xRequestType, // Context Header
            ...(extraConfig.headers || {}),
          },
          ...extraConfig,
        };

        // Use the Singleton API instance
        const response = await api(config);

        setData(response.data);
        return returnDataOnly ? response.data : response;
      } catch (err) {
        if (api.isCancel(err)) {
           // Request cancelled, do nothing
           return; 
        }
        setError(err);
        
        // Show Snackbar for generic errors (skip 401s as they are handled by interceptor)
        if(err.response?.status !== 401) {
             const msg = err.response?.data?.message || err.response?.data?.error || "An error occurred";
             snackbar(msg, "error");
        }
        throw err;
      } finally {
        activeRequests.current.delete(controller);
        setLoading(false);
      }
    },
    [xRequestType, snackbar]
  );

  return { data, error, loading, callApi, cancelAllRequests };
};

export default useApi;

import React, {
  createContext,
  useEffect,
  useRef,
  useCallback,
  useState,
} from "react";
import { useDispatch, useSelector } from "react-redux";
import { throttle } from "lodash";
import SessionDialog from "../components/SessionDialog";
import SessionWarningDialog from "../components/SessionWarningDialog";
import { logoutSuccess } from "../store/slices/authSlice";
import api from "../utils/axiosConfig"; // Use the singleton

export const AuthContext = createContext();

const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 min
const WARNING_SECONDS = 30;

export const AuthProvider = ({ children }) => {
  const dispatch = useDispatch();
  const isAuthenticated = useSelector((state) => state.auth.isAuthenticated);
  
  const [warningOpen, setWarningOpen] = useState(false);
  const [secondsLeft, setSecondsLeft] = useState(WARNING_SECONDS);
  
  const [sessionDialogOpen, setSessionDialogOpen] = useState(false);
  const [sessionReason, setSessionReason] = useState("");

  const inactivityTimerRef = useRef(null);
  const warningTimerRef = useRef(null);
  const countdownRef = useRef(null);

  // --- 1. Helper to Clear Timers ---
  const clearAllTimers = useCallback(() => {
    if (inactivityTimerRef.current) clearTimeout(inactivityTimerRef.current);
    if (warningTimerRef.current) clearTimeout(warningTimerRef.current);
    if (countdownRef.current) clearInterval(countdownRef.current);
  }, []);

  // --- 2. Perform Logout ---
  const performLogout = useCallback(async (reason = "USER_INITIATED") => {
      clearAllTimers();
      
      // If triggered by inactivity, show dialog first
      if (reason === "SESSION_EXPIRED" || reason === "CONCURRENT_LOGIN") {
          setSessionReason(reason);
          setSessionDialogOpen(true);
      }
      
      try {
        // Attempt server logout (clears cookie)
        // We use 'api' so headers are attached automatically
        await api.post("/auth/logout");
      } catch (err) {
        console.warn("Server logout failed (likely already expired)", err);
      } finally {
         // Always clear client state
         dispatch(logoutSuccess());
         setWarningOpen(false);
      }
  }, [dispatch, clearAllTimers]);

  // --- 3. Start Timers ---
  const startInactivityTimer = useCallback(() => {
    clearAllTimers();
    if(!isAuthenticated) return;

    // Warning Timer
    warningTimerRef.current = setTimeout(() => {
      setWarningOpen(true);
      setSecondsLeft(WARNING_SECONDS);
      
      let counter = WARNING_SECONDS;
      countdownRef.current = setInterval(() => {
        counter -= 1;
        setSecondsLeft(counter);
        if (counter <= 0) clearInterval(countdownRef.current);
      }, 1000);
      
    }, INACTIVITY_TIMEOUT - (WARNING_SECONDS * 1000));

    // Hard Logout Timer
    inactivityTimerRef.current = setTimeout(() => {
       performLogout("SESSION_EXPIRED");
    }, INACTIVITY_TIMEOUT);
    
  }, [isAuthenticated, clearAllTimers, performLogout]);

  // --- 4. Event Listeners for Activity ---
  const onActivity = useCallback(
    throttle(() => {
      if (!isAuthenticated || sessionDialogOpen) return;
      // If warning is open, close it and reset
      if (warningOpen) setWarningOpen(false);
      startInactivityTimer();
    }, 2000),
    [isAuthenticated, sessionDialogOpen, warningOpen, startInactivityTimer]
  );

  // --- 5. Effect: Monitor Auth State & Global Events ---
  useEffect(() => {
      if (isAuthenticated) {
          startInactivityTimer();
          const events = ["mousemove", "keydown", "click", "scroll", "touchstart"];
          events.forEach((e) => window.addEventListener(e, onActivity));
          
          return () => {
              events.forEach((e) => window.removeEventListener(e, onActivity));
              onActivity.cancel();
              clearAllTimers();
          };
      } else {
          clearAllTimers();
          setWarningOpen(false);
      }
  }, [isAuthenticated, onActivity, startInactivityTimer, clearAllTimers]);

  // --- 6. Effect: Listen for Axios Interceptor Events ---
  useEffect(() => {
      const handleSessionEvent = (e) => {
          const reason = e.detail?.reason || "SESSION_EXPIRED";
          performLogout(reason);
      };
      
      window.addEventListener("auth:session-expired", handleSessionEvent);
      return () => window.removeEventListener("auth:session-expired", handleSessionEvent);
  }, [performLogout]);

  return (
    <AuthContext.Provider
      value={{
        logout: () => performLogout("USER_INITIATED"),
      }}
    >
      {children}

      <SessionWarningDialog
        open={warningOpen}
        secondsLeft={secondsLeft}
        onContinue={() => {
            setWarningOpen(false);
            startInactivityTimer();
        }}
      />

      <SessionDialog
        open={sessionDialogOpen}
        reason={sessionReason}
        onConfirm={() => {
          setSessionDialogOpen(false);
          // Redirect to home/login
          window.location.href = "/"; 
        }}
      />
    </AuthContext.Provider>
  );
};

import React, { useEffect, useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { useNavigate } from "react-router-dom";
import { Box, InputAdornment, IconButton } from "@mui/material";
import LockIcon from "@mui/icons-material/Lock";
import Visibility from "@mui/icons-material/Visibility";
import VisibilityOff from "@mui/icons-material/VisibilityOff";

import api from "../utils/axiosConfig"; // Use Singleton
import { parseJwt } from "../utils/EncryptionUtilities";
import { loginSuccess } from "../store/slices/authSlice";
import { setMenus, setSelectedMenuItem } from "../store/slices/menuSlice";
import { setTabId } from "../store/slices/tabSlice";
import { resolveConfig } from "../config/EnvironmentConfig";

import { loginDialogMessages, loginDialogHeaders } from "./constants";
import { StyledTextField, PrimaryButton, FormTitle, PasswordErrorText } from "./LoginStyles";

const LoginWithPassword = ({ userId, openLoginErrorDialog }) => {
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [passwordInvalidMessage, setPasswordInvalidMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  
  const navigate = useNavigate();
  const dispatch = useDispatch();
  const menus = useSelector((state) => state.menus.menus);

  // Navigate after successful login and menu loading
  useEffect(() => {
    if (menus && menus.length > 0 && menus[0]?.route) {
      navigate(menus[0]?.route);
    }
  }, [menus, navigate]);

  const validateUserCredentials = async () => {
    setIsLoading(true);
    setPasswordInvalidMessage("");
    
    try {
      // 1. Call Login API
      // Using 'api' instance ensures standard headers and settings
      const response = await api.post("/auth/login", {
          userId: userId,
          password: password,
      });

      const result = response.data;

      if (result.validCredentials === true) {
          // 2. Decode Token
          const user = parseJwt(result.accessToken);
          const tabId = crypto.randomUUID();

          // 3. Update Redux (Auth & Menus)
          dispatch(loginSuccess({
              token: result.accessToken,
              user: user
          }));
          
          dispatch(setTabId(tabId));
          dispatch(setMenus(result.roleData.root_menus));
          dispatch(setSelectedMenuItem(result.roleData.root_menus[0]));

          // 4. Broadcast to other tabs (Optional)
          const bc = new BroadcastChannel("auth");
          setTimeout(() => {
            bc.postMessage({
              type: "USER_LOGGED_IN",
              tabId,
              userId: user.userId,
            });
          }, 1000);

      } else {
          // Handle Logic Failure (Account Locked, Bad Pass, etc)
          handleLoginFailure(result);
      }
    } catch (e) {
      console.error("Login Error:", e);
      // Handle Network/Server Error
      // Note: 401s are intercepted, but for Login endpoint specifically, 
      // we usually get 200 OK with validCredentials=false OR 401 Bad Creds.
      // If interceptor catches 401, it might dispatch logout, which is fine.
      
      const msg = e.response?.data?.message || "Failed to log into FinCore, please try again later";
      openLoginErrorDialog("Login Failed", msg);
    } finally {
      setIsLoading(false);
    }
  };

  const handleLoginFailure = (result) => {
      if (result.userStatus === "ACTIVE" && result.loginMethod === "P") {
        if (result.attemptsLeft > 0) {
          setPasswordInvalidMessage(`Invalid password. ${result.attemptsLeft} attempts left.`);
          openLoginErrorDialog("Invalid password", "Password incorrect.");
        } else {
          openLoginErrorDialog("Account locked", "You are out of attempts and your account has been locked");
        }
      } else {
        openLoginErrorDialog(
          loginDialogHeaders[result.userStatus] || "Login Failed",
          loginDialogMessages[result.userStatus] || "Account status issue."
        );
      }
  };

  return (
    <>
      <FormTitle>Sign In</FormTitle>
      <StyledTextField
        fullWidth
        label="Password"
        type={showPassword ? "text" : "password"}
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        variant="outlined"
        error={!!passwordInvalidMessage}
        margin="normal"
        InputProps={{
          startAdornment: (
            <InputAdornment position="start"><LockIcon /></InputAdornment>
          ),
          endAdornment: (
            <InputAdornment position="end">
              <IconButton onClick={() => setShowPassword(!showPassword)} edge="end">
                {showPassword ? <Visibility /> : <VisibilityOff />}
              </IconButton>
            </InputAdornment>
          ),
        }}
      />
      {passwordInvalidMessage && (
        <PasswordErrorText>{passwordInvalidMessage}</PasswordErrorText>
      )}

      <PrimaryButton
        fullWidth
        variant="contained"
        onClick={validateUserCredentials}
        disabled={!userId || isLoading}
      >
        {isLoading ? "Signing in..." : "Sign In"}
      </PrimaryButton>
    </>
  );
};

export default LoginWithPassword;

import React, { useEffect, useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { useNavigate } from "react-router-dom";
import { Box, InputAdornment, IconButton } from "@mui/material";
import LockIcon from "@mui/icons-material/Lock";
import Visibility from "@mui/icons-material/Visibility";
import VisibilityOff from "@mui/icons-material/VisibilityOff";

import api from "../utils/axiosConfig"; // Use Singleton
import { parseJwt } from "../utils/EncryptionUtilities";
import { loginSuccess } from "../store/slices/authSlice";
import { setMenus, setSelectedMenuItem } from "../store/slices/menuSlice";
import { setTabId } from "../store/slices/tabSlice";
import { resolveConfig } from "../config/EnvironmentConfig";

import { loginDialogMessages, loginDialogHeaders } from "./constants";
import { StyledTextField, PrimaryButton, FormTitle, PasswordErrorText } from "./LoginStyles";

const LoginWithPassword = ({ userId, openLoginErrorDialog }) => {
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [passwordInvalidMessage, setPasswordInvalidMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  
  const navigate = useNavigate();
  const dispatch = useDispatch();
  const menus = useSelector((state) => state.menus.menus);

  // Navigate after successful login and menu loading
  useEffect(() => {
    if (menus && menus.length > 0 && menus[0]?.route) {
      navigate(menus[0]?.route);
    }
  }, [menus, navigate]);

  const validateUserCredentials = async () => {
    setIsLoading(true);
    setPasswordInvalidMessage("");
    
    try {
      // 1. Call Login API
      // Using 'api' instance ensures standard headers and settings
      const response = await api.post("/auth/login", {
          userId: userId,
          password: password,
      });

      const result = response.data;

      if (result.validCredentials === true) {
          // 2. Decode Token
          const user = parseJwt(result.accessToken);
          const tabId = crypto.randomUUID();

          // 3. Update Redux (Auth & Menus)
          dispatch(loginSuccess({
              token: result.accessToken,
              user: user
          }));
          
          dispatch(setTabId(tabId));
          dispatch(setMenus(result.roleData.root_menus));
          dispatch(setSelectedMenuItem(result.roleData.root_menus[0]));

          // 4. Broadcast to other tabs (Optional)
          const bc = new BroadcastChannel("auth");
          setTimeout(() => {
            bc.postMessage({
              type: "USER_LOGGED_IN",
              tabId,
              userId: user.userId,
            });
          }, 1000);

      } else {
          // Handle Logic Failure (Account Locked, Bad Pass, etc)
          handleLoginFailure(result);
      }
    } catch (e) {
      console.error("Login Error:", e);
      // Handle Network/Server Error
      // Note: 401s are intercepted, but for Login endpoint specifically, 
      // we usually get 200 OK with validCredentials=false OR 401 Bad Creds.
      // If interceptor catches 401, it might dispatch logout, which is fine.
      
      const msg = e.response?.data?.message || "Failed to log into FinCore, please try again later";
      openLoginErrorDialog("Login Failed", msg);
    } finally {
      setIsLoading(false);
    }
  };

  const handleLoginFailure = (result) => {
      if (result.userStatus === "ACTIVE" && result.loginMethod === "P") {
        if (result.attemptsLeft > 0) {
          setPasswordInvalidMessage(`Invalid password. ${result.attemptsLeft} attempts left.`);
          openLoginErrorDialog("Invalid password", "Password incorrect.");
        } else {
          openLoginErrorDialog("Account locked", "You are out of attempts and your account has been locked");
        }
      } else {
        openLoginErrorDialog(
          loginDialogHeaders[result.userStatus] || "Login Failed",
          loginDialogMessages[result.userStatus] || "Account status issue."
        );
      }
  };

  return (
    <>
      <FormTitle>Sign In</FormTitle>
      <StyledTextField
        fullWidth
        label="Password"
        type={showPassword ? "text" : "password"}
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        variant="outlined"
        error={!!passwordInvalidMessage}
        margin="normal"
        InputProps={{
          startAdornment: (
            <InputAdornment position="start"><LockIcon /></InputAdornment>
          ),
          endAdornment: (
            <InputAdornment position="end">
              <IconButton onClick={() => setShowPassword(!showPassword)} edge="end">
                {showPassword ? <Visibility /> : <VisibilityOff />}
              </IconButton>
            </InputAdornment>
          ),
        }}
      />
      {passwordInvalidMessage && (
        <PasswordErrorText>{passwordInvalidMessage}</PasswordErrorText>
      )}

      <PrimaryButton
        fullWidth
        variant="contained"
        onClick={validateUserCredentials}
        disabled={!userId || isLoading}
      >
        {isLoading ? "Signing in..." : "Sign In"}
      </PrimaryButton>
    </>
  );
};

export default LoginWithPassword;

// In your main index.js or App.js where you create the store
import store from './store'; // Your redux store import
import { injectStore } from './utils/axiosConfig';
import { initializeAuth } from './store/slices/authSlice';

// 1. Inject store into Axios interceptors
injectStore(store);

// 2. Initialize Auth from LocalStorage (if you aren't using redux-persist)
store.dispatch(initializeAuth());

// ... render App

