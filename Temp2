package com.fincore.gateway.Controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.gateway.JwtUtil.HmacJwtUtil;
import com.fincore.gateway.Service.LoginService;
import com.fincore.gateway.Service.TokenSessionValidator;
import com.fincore.gateway.dto.*;
import com.fincore.gateway.model.UserRoles;
import com.fincore.gateway.utility.Constants;
import com.fincore.gateway.utility.LoginUtility;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.ReactiveStringRedisTemplate;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.util.Base64;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {

    private static final String USER_PREFIX = "USR:";

    private final TokenSessionValidator validator;
    private final ReactiveStringRedisTemplate redisTemplate;
    private final LoginService loginService;
    private final ObjectMapper mapper;

    @Value("${security.jwt.mode:hmac}")
    private String mode;

    @Value("${security.jwt.hmac-base64-secret:}")
    private String hmacSecret;

    @Value("${security.jwt.ttl-seconds:900}")
    private long ttlSeconds;

    /**
     * REACTIVE LOGIN
     * 1. Runs DB check on Elastic Thread.
     * 2. Generates Token.
     * 3. Writes Session to Redis (Reactive).
     * 4. Fetches Menus on Elastic Thread.
     */
    @PostMapping(value = "/login", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<LoginResponseDTO> login(ServerHttpRequest request, @RequestBody @Valid UserDto payload) {
        final String clientIp = LoginUtility.getClientIp(request);

        // 1. DB Operation (Blocking -> Elastic Scheduler)
        return Mono.fromCallable(() -> loginService.verifyUserCredentials(payload, clientIp))
                .subscribeOn(Schedulers.boundedElastic())
                .flatMap(user -> {
                    if (!user.isValidCredentials()) {
                        return Mono.just(LoginResponseDTO.builder()
                                .userId(user.getUserId())
                                .validCredentials(false)
                                .userStatus(user.getUserStatus())
                                .passwordLoginStatus(user.getPasswordLoginStatus())
                                .error(user.getMessage() != null ? user.getMessage() : "Invalid credentials")
                                .build());
                    }

                    if (hmacSecret == null || hmacSecret.isBlank()) {
                        return Mono.just(LoginResponseDTO.builder().error("Missing HMAC secret").build());
                    }

                    // 2. Token Generation
                    @SuppressWarnings("unchecked")
                    Map<String, Object> claims = mapper.convertValue(user.getUser(), Map.class);
                    String token = HmacJwtUtil.generate(hmacSecret, user.getUserId(), ttlSeconds, claims);

                    var parser = io.jsonwebtoken.Jwts.parser()
                            .verifyWith(io.jsonwebtoken.security.Keys.hmacShaKeyFor(Base64.getDecoder().decode(hmacSecret)))
                            .build();
                    String jti = parser.parseSignedClaims(token).getPayload().getId();

                    // 3. Redis Write (Non-blocking)
                    return validator.registerUserSession(user.getUserId(), jti)
                            .then(Mono.defer(() -> {
                                // 4. Menu Fetch (Blocking DB -> Elastic Scheduler)
                                return Mono.fromCallable(() -> loginService.fetchRoleWiseData(user.getUserId()))
                                        .subscribeOn(Schedulers.boundedElastic());
                            }))
                            .map(roleData -> LoginResponseDTO.builder()
                                    .userId(user.getUserId())
                                    .validCredentials(true)
                                    .userStatus(user.getUserStatus())
                                    .passwordLoginStatus(user.getPasswordLoginStatus())
                                    .accessToken(token)
                                    .tokenType("Bearer")
                                    .expiresIn(ttlSeconds)
                                    .sub(user.getUserId())
                                    .jti(jti)
                                    .roleData(roleData)
                                    .build());
                })
                .doOnError(e -> log.error("Login Error: ", e));
    }

    /**
     * REACTIVE REFRESH TOKEN
     */
    @PostMapping(value = "/refresh-token", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<LoginResponseDTO> refreshToken(@RequestBody Map<String, String> body) {
        String refreshToken = body.get("refreshToken");

        if (refreshToken == null || refreshToken.isBlank()) {
            return Mono.just(LoginResponseDTO.builder().error("Missing refresh token").build());
        }

        return Mono.fromCallable(() -> {
            var parser = io.jsonwebtoken.Jwts.parser()
                    .verifyWith(io.jsonwebtoken.security.Keys.hmacShaKeyFor(Base64.getDecoder().decode(hmacSecret)))
                    .build();
            return parser.parseSignedClaims(refreshToken).getPayload();
        })
        .subscribeOn(Schedulers.boundedElastic()) // CPU bound but safer on elastic if signature verification is heavy
        .flatMap(claims -> {
            String userId = claims.getSubject();
            String userKey = USER_PREFIX + userId;

            // Check Redis for active session
            return redisTemplate.opsForValue().get(userKey)
                    .flatMap(currentJti -> {
                        // DB Call (Get Role) -> Elastic
                        return Mono.fromCallable(() -> loginService.getUserRole(userId))
                                .subscribeOn(Schedulers.boundedElastic())
                                .flatMap(userRole -> {
                                    Map<String, Object> newClaims = Map.of(
                                            "role", userRole != null ? userRole.getRole() : 0,
                                            "userId", userId
                                    );
                                    
                                    String newAccessToken = HmacJwtUtil.generate(hmacSecret, userId, ttlSeconds, newClaims);
                                    
                                    var parser = io.jsonwebtoken.Jwts.parser()
                                            .verifyWith(io.jsonwebtoken.security.Keys.hmacShaKeyFor(Base64.getDecoder().decode(hmacSecret)))
                                            .build();
                                    String newJti = parser.parseSignedClaims(newAccessToken).getPayload().getId();

                                    // Rotate Session in Redis
                                    return validator.registerUserSession(userId, newJti)
                                            .thenReturn(LoginResponseDTO.builder()
                                                    .accessToken(newAccessToken)
                                                    .refreshToken(refreshToken)
                                                    .userId(userId)
                                                    .jti(newJti)
                                                    .expiresIn(ttlSeconds)
                                                    .validCredentials(true)
                                                    .build());
                                });
                    })
                    .switchIfEmpty(Mono.just(LoginResponseDTO.builder().error("Session expired. Please login again.").build()));
        })
        .onErrorResume(e -> {
            log.error("Refresh Token Failed", e);
            return Mono.just(LoginResponseDTO.builder().error("Invalid refresh token").build());
        });
    }

    /**
     * REACTIVE LOGOUT (CORRECTED)
     * 1. Blacklists the current Token.
     * 2. Checks if Redis Active JTI == Current Token JTI.
     * 3. Only if they match, deletes the Redis Key.
     */
    @PostMapping(value = "/logout", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<LoginResponseDTO> logout(JwtAuthenticationToken jwtAuth) {
        if (jwtAuth == null) {
            return Mono.just(LoginResponseDTO.builder().error("No token").build());
        }
        String username = jwtAuth.getToken().getSubject();
        String jti = jwtAuth.getToken().getId();
        String userKey = USER_PREFIX + username;

        log.info("Logout requested for user={} jti={}", username, jti);

        // 1. Blacklist the specific token (Always happen)
        return validator.blacklistToken(jti)
                .flatMap(blacklisted -> {
                    // 2. Fetch the CURRENT active session from Redis
                    return redisTemplate.opsForValue().get(userKey);
                })
                .flatMap(activeJti -> {
                    // 3. Compare: Is the session in Redis the same one we are logging out?
                    if (activeJti != null && activeJti.equals(jti)) {
                        log.info("Stored JTI matches logout JTI -> clearing session for user={}", username);
                        return validator.clearUserSession(username)
                                .map(cleared -> LoginResponseDTO.builder()
                                        .userId(username)
                                        .jti(jti)
                                        .error("User logged out (revoked token and cleared session)")
                                        .build());
                    } else {
                        // 4. Mismatch: User might be logged in on another device. Don't kill the other session.
                        log.info("Stored JTI ({}) does not match logout JTI ({}) -> keeping session", activeJti, jti);
                        return Mono.just(LoginResponseDTO.builder()
                                .userId(username)
                                .jti(jti)
                                .error("Token revoked. Active session remains (another token is active)")
                                .build());
                    }
                })
                .switchIfEmpty(Mono.just(
                        // Case: Redis key was already empty/expired
                        LoginResponseDTO.builder()
                                .userId(username)
                                .jti(jti)
                                .error("User logged out (session was already expired)")
                                .build()
                ));
    }

    /**
     * REACTIVE CHECK USER
     */
    @PostMapping(value = "/check-user", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<VerifyUserDTO> checkUser(@RequestBody Map<String, String> body) {
        String userId = body.get("userId");
        // DB Call -> Elastic
        return Mono.fromCallable(() -> loginService.checkUser(userId))
                .subscribeOn(Schedulers.boundedElastic());
    }

    /**
     * REACTIVE UPDATE PASSWORD
     */
    @PostMapping(value = "/update-password", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<UpdatePasswordDTO> updatePassword(@RequestBody @Valid UpdatePasswordDTO userCredentials) {
        // DB Call -> Elastic
        return Mono.fromCallable(() -> loginService.updatePassword(userCredentials))
                .subscribeOn(Schedulers.boundedElastic());
    }
}


