package com.fincore.gateway.Service;

import com.fincore.gateway.dto.ChildMenu;
import com.fincore.gateway.dto.MenuResponse;
import com.fincore.gateway.dto.PermissionRow;
import com.fincore.gateway.dto.RootMenu;
import com.fincore.gateway.model.Permissions;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Builds navigational menu structures from permission entities or projections.
 *
 * <p>Responsibilities:</p>
 * <ul>
 *   <li>Group permissions by root menu title</li>
 *   <li>Create root and child menu DTOs</li>
 *   <li>Ensure deterministic ordering (by {@code orderId} / {@code permissionOrder})</li>
 *   <li>Be tolerant to missing/nullable sorting fields</li>
 * </ul>
 *
 * <p><strong>Ordering</strong>: Root menus and child menus are sorted in ascending order using their respective
 * order fields. Null order values are placed last to keep ordering stable.</p>
 */
@Slf4j
@Service
public class MenuService {

    /**
     * Transforms a list of {@link Permissions} entities into a {@link MenuResponse}.
     * <p>Groups by {@code menuTitle}, creates root items, and (when present) child items from
     * entries having a non-null {@code subMenu}.</p>
     *
     * @param permissionsList permissions entities
     * @return menu response with ordered root and child menus
     */
    public MenuResponse transform(List<Permissions> permissionsList) {
        MenuResponse response = new MenuResponse();

        if (permissionsList == null || permissionsList.isEmpty()) {
            response.setRoot_menus(Collections.emptyList());
            return response;
        }

        // Group by root menu title
        Map<String, List<Permissions>> grouped =
                permissionsList.stream().collect(Collectors.groupingBy(Permissions::getMenuTitle));

        List<RootMenu> rootMenus = new ArrayList<>();

        for (Map.Entry<String, List<Permissions>> entry : grouped.entrySet()) {
            List<Permissions> group = entry.getValue();

            // Pick a representative for root fields: prefer the one with the smallest non-null orderId
            Permissions rootPerm = group.stream()
                    .min(Comparator.comparing(MenuService::safeOrderId))
                    .orElse(group.get(0));

            RootMenu rootMenu = buildRootFromPermissions(rootPerm);

            // Build children from items that actually have a sub-menu
            List<ChildMenu> children = group.stream()
                    .filter(p -> p.getSubMenu() != null)
                    .map(this::buildChildFromPermissions)
                    .sorted(Comparator.comparing(MenuService::safeOrderIdChild))
                    .collect(Collectors.toList());

            rootMenu.setHasChildren(!children.isEmpty());
            rootMenu.setChildren(children);
            rootMenus.add(rootMenu);
        }

        // Sort roots by orderId
        rootMenus.sort(Comparator.comparing(MenuService::safeOrderIdRoot));

        response.setRoot_menus(rootMenus);
        return response;
    }

    /**
     * Transforms a list of {@link PermissionRow} projections into a {@link MenuResponse}.
     * <p>Groups by {@code menuTitle}, creates root items, and child items from rows having a non-null {@code subMenu}.</p>
     *
     * @param rows permission projection rows (typically from a custom query join)
     * @return menu response with ordered root and child menus
     */
    public MenuResponse transformFromProjection(List<PermissionRow> rows) {
        MenuResponse response = new MenuResponse();

        if (rows == null || rows.isEmpty()) {
            response.setRoot_menus(Collections.emptyList());
            return response;
        }

        // Group by root menu title
        Map<String, List<PermissionRow>> grouped =
                rows.stream().collect(Collectors.groupingBy(PermissionRow::getMenuTitle));

        List<RootMenu> rootMenus = new ArrayList<>();

        for (Map.Entry<String, List<PermissionRow>> entry : grouped.entrySet()) {
            List<PermissionRow> group = entry.getValue();

            // Representative root row: choose the smallest non-null permissionOrder
            PermissionRow root = group.stream()
                    .min(Comparator.comparing(MenuService::safePermissionOrder))
                    .orElse(group.get(0));

            RootMenu rootMenu = buildRootFromProjection(root);

            // Children (only rows that actually represent a sub-menu), ordered by permissionOrder asc
            List<ChildMenu> children = group.stream()
                    .filter(r -> r.getSubMenu() != null)
                    .map(this::buildChildFromProjection)
                    .sorted(Comparator.comparing(MenuService::safeOrderIdChild))
                    .collect(Collectors.toList());

            rootMenu.setHasChildren(!children.isEmpty());
            rootMenu.setChildren(children);
            rootMenus.add(rootMenu);
        }

        // Order root menus as well
        rootMenus.sort(Comparator.comparing(MenuService::safeOrderIdRoot));

        response.setRoot_menus(rootMenus);
        return response;
    }

    // --------------------------------------------------------------------------------------------
    // Builders
    // --------------------------------------------------------------------------------------------

    private RootMenu buildRootFromPermissions(Permissions p) {
        RootMenu root = new RootMenu();
        root.setId(p.getMenuId());
        root.setTitle(p.getMenuTitle());
        root.setIcon(p.getMenuIcon());
        root.setRoute(p.getMenuUrl());
        root.setComponentPath(p.getComponentPath());
        root.setScreenDescription(p.getMenuDescription());
        root.setOrderId(safeOrderId(p));
        return root;
    }

    private ChildMenu buildChildFromPermissions(Permissions p) {
        ChildMenu child = new ChildMenu();
        child.setId(p.getMenuId());
        child.setTitle(p.getSubMenu());
        child.setIcon(p.getMenuIcon());
        child.setRoute(p.getMenuUrl());
        child.setComponentPath(p.getComponentPath());
        child.setScreenDescription(p.getMenuDescription());
        child.setOrderId(safeOrderId(p));
        return child;
    }

    private RootMenu buildRootFromProjection(PermissionRow r) {
        RootMenu root = new RootMenu();
        root.setId(r.getMenuId());
        root.setTitle(r.getMenuTitle());
        root.setIcon(r.getMenuIcon());
        root.setRoute(r.getMenuUrl());
        root.setMenuAction(r.getMenuAction());
        root.setComponentPath(r.getComponentPath());
        root.setScreenDescription(r.getMenuDescription());
        root.setOrderId(safePermissionOrder(r));
        root.setRequestType(r.getRequestType());
        return root;
    }

    private ChildMenu buildChildFromProjection(PermissionRow r) {
        ChildMenu c = new ChildMenu();
        c.setId(r.getMenuId());
        c.setTitle(r.getSubMenu());
        c.setIcon(r.getMenuIcon());
        c.setRoute(r.getMenuUrl());
        c.setComponentPath(r.getComponentPath());
        c.setScreenDescription(r.getMenuDescription());
        c.setOrderId(safePermissionOrder(r));
        return c;
    }

    // --------------------------------------------------------------------------------------------
    // Null-safe order helpers
    // --------------------------------------------------------------------------------------------

    /**
     * Returns a non-null order for {@link Permissions} (nulls go to the end).
     */
    private static int safeOrderId(Permissions p) {
        Integer v = p.getOrderId();
        return v != null ? v : Integer.MAX_VALUE;
    }

    /**
     * Returns a non-null order for {@link PermissionRow} (nulls go to the end).
     */
    private static int safePermissionOrder(PermissionRow r) {
        Integer v = r.getPermissionOrder();
        return v != null ? v : Integer.MAX_VALUE;
    }

    /**
     * Comparator key extractor for root menus.
     */
    private static int safeOrderIdRoot(RootMenu r) {
        Integer v = r.getOrderId();
        return v != null ? v : Integer.MAX_VALUE;
    }

    /**
     * Comparator key extractor for child menus.
     */
    private static int safeOrderIdChild(ChildMenu c) {
        Integer v = c.getOrderId();
        return v != null ? v : Integer.MAX_VALUE;
    }
}
