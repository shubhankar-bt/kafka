package com.fincore.gateway.Controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.gateway.JwtUtil.HmacJwtUtil;
import com.fincore.gateway.Service.LoginService;
import com.fincore.gateway.Service.TokenSessionValidator;
import com.fincore.gateway.dto.*;
import com.fincore.gateway.utility.LoginUtility;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.ReactiveStringRedisTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseCookie;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import javax.crypto.SecretKey;
import java.time.Duration;
import java.util.Base64;
import java.util.Map;

/**
 * Authentication Controller (Reactive).
 * Handles Login, Logout, and Token Refresh using a distributed Redis session model.
 *
 * Security Features:
 * 1. Dual Token System: Short-lived Access Token (JSON) + Long-lived Refresh Token (HttpOnly Cookie).
 * 2. Token Rotation: A new Refresh Token is issued on every use to detect theft.
 * 3. Session Binding: Access Token JTI is bound to Redis `USR:<userId>`.
 * 4. Concurrency Control: "One Session Per User" enforced via Redis JTI checks.
 * 5. Reactive Non-Blocking: Uses WebFlux Mono/Flux patterns with Elastic Scheduler for DB.
 */
@Slf4j
@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {

    private static final String USER_PREFIX = "USR:";
    private final TokenSessionValidator validator;
    private final ReactiveStringRedisTemplate redisTemplate;
    private final LoginService loginService;
    private final ObjectMapper mapper;

    @Value("${security.jwt.hmac-base64-secret:}")
    private String hmacSecret;

    // Access Token: Short Lived (e.g., 15 mins)
    @Value("${security.jwt.ttl-seconds:900}")
    private long accessTokenTtl;

    // Refresh Token: Long Lived (e.g., 24 hours)
    @Value("${security.jwt.refresh-ttl-seconds:86400}")
    private long refreshTokenTtl;

    /**
     * Creates a secure HttpOnly cookie for the refresh token.
     * Prevents XSS attacks as JavaScript cannot read this cookie.
     *
     * CONFIG NOTE:
     * - secure(false): Allows HTTP (Localhost). Set to true in PROD with HTTPS.
     * - sameSite("Lax"): Allows cross-origin navigation in Localhost dev.
     * - path("/"): Ensures cookie is sent to all auth endpoints.
     */
    private ResponseCookie createRefreshTokenCookie(String token) {
        return ResponseCookie.from("refresh_token", token)
                .httpOnly(true)
                .secure(false) // TODO: Set to true in Production (requires HTTPS)
                .path("/")     // Root path ensures availability to all auth endpoints
                .maxAge(Duration.ofSeconds(refreshTokenTtl))
                .sameSite("Lax") // 'Lax' is safer for localhost dev than 'Strict'
                .build();
    }
    
    /**
     * Creates an empty cookie to clear the refresh token on logout.
     */
    private ResponseCookie createEmptyCookie() {
        return ResponseCookie.from("refresh_token", "")
                .httpOnly(true)
                .path("/")
                .maxAge(0)
                .build();
    }

    /**
     * LOGIN ENDPOINT
     * 1. Validates credentials (Blocking DB call on Elastic Scheduler).
     * 2. Generates Access Token & Refresh Token.
     * 3. Stores Access Token JTI in Redis (Session Start).
     * 4. Returns Access Token in Body, Refresh Token in HttpOnly Cookie.
     */
    @PostMapping(value = "/login", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<LoginResponseDTO> login(ServerHttpRequest request, ServerHttpResponse response, @RequestBody @Valid UserDto payload) {
        final String clientIp = LoginUtility.getClientIp(request);
        log.info("Login request for user: {} from IP: {}", payload.getUserId(), clientIp);

        return Mono.fromCallable(() -> loginService.verifyUserCredentials(payload, clientIp))
                .subscribeOn(Schedulers.boundedElastic()) // Move blocking JDBC call off the event loop
                .flatMap(user -> {
                    if (!user.isValidCredentials()) {
                        log.warn("Invalid credentials for user: {}", payload.getUserId());
                        return Mono.just(LoginResponseDTO.builder()
                                .userId(user.getUserId())
                                .validCredentials(false)
                                .error(user.getMessage() != null ? user.getMessage() : "Invalid credentials")
                                .build());
                    }

                    if (hmacSecret == null || hmacSecret.isBlank()) {
                        log.error("Server Config Error: HMAC secret is missing.");
                        return Mono.error(new IllegalStateException("Missing HMAC secret"));
                    }

                    // 1. Generate Tokens
                    @SuppressWarnings("unchecked")
                    Map<String, Object> claimsMap = mapper.convertValue(user.getUser(), Map.class);
                    // Access Token (Short TTL)
                    String accessToken = HmacJwtUtil.generate(hmacSecret, user.getUserId(), accessTokenTtl, claimsMap);
                    
                    // Refresh Token (Long TTL)
                    Map<String, Object> refreshClaims = Map.of("type", "refresh");
                    String refreshToken = HmacJwtUtil.generate(hmacSecret, user.getUserId(), refreshTokenTtl, refreshClaims);

                    // Extract JTI from Access Token (This is what we track in Redis)
                    String jti = extractClaims(accessToken).getId();

                    // 2. Set Refresh Token in HttpOnly Cookie
                    ResponseCookie cookie = createRefreshTokenCookie(refreshToken);
                    response.addCookie(cookie);
                    log.info("Login Success. Access Token TTL: {}s. Refresh Cookie Set.", accessTokenTtl);

                    // 3. Register Session (JTI) in Redis & Fetch Menus
                    return validator.registerUserSession(user.getUserId(), jti)
                            .then(Mono.defer(() -> Mono.fromCallable(() -> loginService.fetchRoleWiseData(user.getUserId()))
                                    .subscribeOn(Schedulers.boundedElastic())))
                            .map(roleData -> LoginResponseDTO.builder()
                                    .userId(user.getUserId())
                                    .validCredentials(true)
                                    .accessToken(accessToken) // Only Access Token goes to Frontend JS
                                    .tokenType("Bearer")
                                    .expiresIn(accessTokenTtl)
                                    .sub(user.getUserId())
                                    .jti(jti)
                                    .roleData(roleData)
                                    .build());
                })
                .onErrorResume(e -> {
                    log.error("Login System Error for user {}", payload.getUserId(), e);
                    return Mono.just(LoginResponseDTO.builder().error("Login failed: " + e.getMessage()).build());
                });
    }

    /**
     * REFRESH TOKEN ENDPOINT
     * 1. Reads Refresh Token from Cookie.
     * 2. Validates Signature & Expiry.
     * 3. Checks Redis to ensure User Session is still valid/active.
     * 4. Rotates Tokens (New Access Token + New Refresh Cookie).
     */
    @PostMapping(value = "/refresh-token", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<LoginResponseDTO> refreshToken(ServerHttpRequest request, ServerHttpResponse response) {
        
        // 1. Extract Refresh Token from Cookie
        org.springframework.http.HttpCookie cookie = request.getCookies().getFirst("refresh_token");
        String refreshToken = (cookie != null) ? cookie.getValue() : null;

        if (refreshToken == null || refreshToken.isBlank()) {
            log.warn("Refresh failed: No refresh token cookie found. Cookies present: {}", request.getCookies().keySet());
            return Mono.just(LoginResponseDTO.builder().error("Missing refresh token cookie").build());
        }

        return Mono.fromCallable(() -> {
            try {
                // Verify Refresh Token Signature & Expiry
                return extractClaims(refreshToken);
            } catch (ExpiredJwtException e) {
                log.warn("Refresh token expired.");
                throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Refresh token expired");
            } catch (Exception e) {
                log.error("Invalid refresh token signature/format.", e);
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid refresh token");
            }
        })
        .subscribeOn(Schedulers.boundedElastic())
        .flatMap(claims -> {
            String userId = claims.getSubject();
            String userKey = USER_PREFIX + userId;
            
            log.info("Processing refresh for User: {}", userId);
            
            // Check if Session is still active in Redis (Global Logout Check)
            return redisTemplate.opsForValue().get(userKey)
                    .flatMap(currentJti -> {
                         log.info("Session Active. Redis Key Found for User: {}", userId);
                         // Session Found! Proceed to refresh logic.
                         return Mono.fromCallable(() -> loginService.getUserRole(userId))
                            .subscribeOn(Schedulers.boundedElastic())
                            .flatMap(userRole -> {
                                // Generate NEW Access Token
                                Map<String, Object> newClaims = Map.of("role", userRole != null ? userRole.getRole() : 0, "userId", userId);
                                String newAccessToken = HmacJwtUtil.generate(hmacSecret, userId, accessTokenTtl, newClaims);
                                
                                // Generate NEW Refresh Token (Rotation)
                                Map<String, Object> refreshClaims = Map.of("type", "refresh");
                                String newRefreshToken = HmacJwtUtil.generate(hmacSecret, userId, refreshTokenTtl, refreshClaims);

                                String newJti = extractClaims(newAccessToken).getId();

                                // Rotate Cookie (Set new refresh token)
                                response.addCookie(createRefreshTokenCookie(newRefreshToken));

                                // Update Redis Session with NEW Access Token JTI
                                return validator.registerUserSession(userId, newJti)
                                        .thenReturn(LoginResponseDTO.builder()
                                                .accessToken(newAccessToken)
                                                .userId(userId)
                                                .jti(newJti)
                                                .expiresIn(accessTokenTtl)
                                                .validCredentials(true)
                                                .build());
                            });
                    })
                    // If Redis returns Empty, the session has expired (TTL) or was evicted
                    .switchIfEmpty(Mono.defer(() -> {
                        log.warn("Refresh Denied: Session key {} not found in Redis (Expired/Evicted).", userKey);
                        return Mono.just(LoginResponseDTO.builder().error("Session expired. Please login again.").build());
                    }));
        })
        .onErrorResume(e -> {
            if (e instanceof ResponseStatusException) {
                 return Mono.just(LoginResponseDTO.builder().error(e.getMessage()).build());
            }
            log.error("Refresh Token Unexpected Error", e);
            return Mono.just(LoginResponseDTO.builder().error("Invalid refresh token").build());
        });
    }

    /**
     * LOGOUT ENDPOINT
     * 1. Clears Refresh Cookie.
     * 2. Blacklists current Access Token.
     * 3. Clears Redis Session ONLY if JTI matches (Safe against concurrent login).
     */
    @PostMapping(value = "/logout", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<LoginResponseDTO> logout(JwtAuthenticationToken jwtAuth, ServerHttpResponse response) {
        // Clear cookie immediately
        response.addCookie(createEmptyCookie());
        
        if (jwtAuth == null) return Mono.just(LoginResponseDTO.builder().error("No token").build());
        String username = jwtAuth.getToken().getSubject();
        String jti = jwtAuth.getToken().getId();

        log.info("Logout requested for user: {}", username);

        return validator.blacklistToken(jti)
                .flatMap(x -> redisTemplate.opsForValue().get(USER_PREFIX + username))
                .flatMap(activeJti -> {
                    // Only clear session if the token being logged out matches the active session
                    if (activeJti != null && activeJti.equals(jti)) {
                        log.info("Session match. Clearing Redis session for user: {}", username);
                        return validator.clearUserSession(username)
                                .map(c -> LoginResponseDTO.builder().userId(username).error("Logged out").build());
                    } else {
                        log.info("Session mismatch (User logged in elsewhere). Only revoking token for user: {}", username);
                        return Mono.just(LoginResponseDTO.builder().userId(username).error("Token revoked").build());
                    }
                })
                .switchIfEmpty(Mono.just(LoginResponseDTO.builder().userId(username).error("Logged out").build()));
    }
    
    @PostMapping(value = "/check-user")
    public Mono<VerifyUserDTO> checkUser(@RequestBody Map<String, String> body) {
        return Mono.fromCallable(() -> loginService.checkUser(body.get("userId"))).subscribeOn(Schedulers.boundedElastic());
    }

    @PostMapping(value = "/update-password")
    public Mono<UpdatePasswordDTO> updatePassword(@RequestBody @Valid UpdatePasswordDTO dto) {
        return Mono.fromCallable(() -> loginService.updatePassword(dto)).subscribeOn(Schedulers.boundedElastic());
    }

    // Helper to parse token
    private Claims extractClaims(String token) {
        byte[] secretBytes = Base64.getDecoder().decode(hmacSecret);
        return Jwts.parser().verifyWith(Keys.hmacShaKeyFor(secretBytes)).build().parseSignedClaims(token).getPayload();
    }
}


