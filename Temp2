package com.tcs.fincore.CommonRequestService.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Thrown when a request violates a specific business rule 
 * (e.g., Invalid Email Format, Missing Reference Data).
 */
@ResponseStatus(HttpStatus.BAD_REQUEST)
public class BusinessRuleViolationException extends RuntimeException {
    public BusinessRuleViolationException(String message) {
        super(message);
    }
}



















package com.tcs.fincore.CommonRequestService.exception;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.tcs.fincore.CommonRequestService.dto.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;

import jakarta.validation.ConstraintViolationException;
import java.util.stream.Collectors;

@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    // === NEW: Handle Business Rule Violations ===
    @ExceptionHandler(BusinessRuleViolationException.class)
    public ResponseEntity<ApiResponse<Object>> handleBusinessRuleViolation(BusinessRuleViolationException ex) {
        log.warn("Business Rule Violation: {}", ex.getMessage());
        return new ResponseEntity<>(ApiResponse.error(ex.getMessage()), HttpStatus.BAD_REQUEST);
    }
    
    // === NEW: Handle Access Denied ===
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiResponse<Object>> handleAccessDenied(AccessDeniedException ex) {
        log.error("Access Denied: {}", ex.getMessage());
        return new ResponseEntity<>(ApiResponse.error("You do not have permission to perform this action."), HttpStatus.FORBIDDEN);
    }

    // --- Existing Handlers ---

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<Object>> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        log.error("Resource not found: {}", ex.getMessage());
        return new ResponseEntity<>(ApiResponse.error(ex.getMessage()), HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler({JsonProcessingException.class, HttpMessageNotReadableException.class})
    public ResponseEntity<ApiResponse<Object>> handleJsonProcessingException(Exception ex, WebRequest request) {
        log.error("Error processing JSON payload: {}", ex.getMessage());
        return new ResponseEntity<>(ApiResponse.error("Invalid request payload format. Please check data types and JSON structure."), HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiResponse<Object>> handleDataIntegrityViolationException(DataIntegrityViolationException ex, WebRequest request) {
        log.error("Data integrity violation: {}", ex.getMostSpecificCause().getMessage());
        if (ex.getMostSpecificCause().getMessage().contains("unique constraint")) {
            return new ResponseEntity<>(ApiResponse.error("A resource with the provided identifier already exists."), HttpStatus.CONFLICT);
        } else if(ex.getMostSpecificCause().getMessage().contains("pending request")) {
        	return new ResponseEntity<>(ApiResponse.error("A pending request already exists."), HttpStatus.CONFLICT);
        }
        return new ResponseEntity<>(ApiResponse.error("Database constraint violation."), HttpStatus.CONFLICT);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        String errors = ex.getBindingResult().getFieldErrors().stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.joining(", "));
        return new ResponseEntity<>(ApiResponse.error("Validation Failed: "+errors), HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ApiResponse<Object>> handleConstraintViolationException(ConstraintViolationException ex) {
        String errors = ex.getConstraintViolations().stream()
                .map(cv -> cv.getPropertyPath() + ": " + cv.getMessage())
                .collect(Collectors.joining(", "));
        return new ResponseEntity<>(ApiResponse.error("Validation Failed: "+errors), HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Object>> handleGlobalException(Exception ex, WebRequest request) {
        log.error("An unexpected error occurred: {}", ex.getMessage(), ex);
        return new ResponseEntity<>(ApiResponse.error("An internal server error occurred."), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}





















package com.tcs.fincore.CommonRequestService.model;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.*;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Getter
@Setter
@Entity
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "BRANCH_MASTER")
public class BranchMaster {

	@Id
	@Column(name = "CODE", nullable = false, length = 5, updatable = false)
	private String code;

	@Column(name = "NAME", nullable = false, length = 50)
	private String name;

	@Column(name = "CIRCLE_CODE", nullable = false, length = 5)
	private String circleCode;

	@Column(name = "STATE", nullable = false, length = 50)
	private String state;

	@Column(name = "CITY", nullable = true, length = 50)
	private String city;

	@Column(name = "ADDRESS", nullable = true, length = 50)
	private String address;

	@Column(name = "PINCODE", nullable = true, length = 6)
	private String pinCode;

	@Column(name = "PHONE_NUMBER", nullable = false, length = 12)
	private String phoneNumber;

	@Column(name = "EMAIL_ID", nullable = false, length = 50)
	private String emailId;

	@Column(name = "NMR_CODE", nullable = false, length = 50)
	private String nmrCode;

	@Column(name = "STATUS", nullable = false)
	private Boolean status;

    // --- CHANGED TO LOCALDATE ---
	@Column(name = "OPEN_DATE", nullable = false, updatable = false)
	@JsonFormat(pattern = "dd/MM/yyyy")
	private LocalDate openDate;

	@Column(name = "CLOSE_DATE")
	@JsonFormat(pattern = "dd/MM/yyyy")
	private LocalDate closeDate;

	@Column(name = "MERGE_DATE")
	@JsonFormat(pattern = "dd/MM/yyyy")
	private LocalDate mergeDate;

	@Column(name = "MERGED_WITH_BRANCH", length = 5)
	private String mergedWithBranch;

    // --- CHANGED TO LOCALDATETIME (For Audit) ---
	@Column(name = "LAST_CHANGE_DATE")
	@JsonFormat(pattern = "dd/MM/yyyy HH:mm:ss")
	private LocalDateTime lastChangeDate;

	@Column(name = "CPC_FLAG", nullable = false)
	private Boolean cpcFlag;

	@Column(name = "FOOD_CREDIT_FLAG", nullable = false)
	private Boolean foodCreditFlag;

	@Column(name = "CURR_CHEST_FLAG", nullable = false)
	private Boolean currChestFlag;

	@Column(name = "BRANCH_TYPE", length = 1)
	private String branchType;
}














package com.tcs.fincore.CommonRequestService.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Data;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
public class BranchRequestPayloadDTO implements KeyablePayload {

	@NotNull(message = "Code cannot be null.")
	private String code;

	@NotNull(message = "Name cannot be null")
	@Size(min = 1, max = 50, message = "Name length must be between 1 and 50")
	private String name;

	@NotNull(message = "Circle Code cannot be null")
	@Size(min = 5, max = 5, message = "Circle Code length must be between 5 and 5")
	private String circleCode;

	@NotNull(message = "State cannot be null")
	@Size(min = 1, max = 50, message = "State length must be between 1 and 50")
	private String state;

	@NotNull(message = "City cannot be null")
	@Size(min = 1, max = 50, message = "City length must be between 1 and 50")
	private String city;

	@NotNull(message = "Address cannot be null")
	@Size(min = 1, max = 50, message = "Address length must be between 1 and 50")
	private String address;

	@NotNull(message = "Pincode cannot be null")
	@Size(min = 6, max = 6, message = "Pincode length must be 6")
	private String pinCode;

	@NotNull(message = "Phone Number cannot be null")
	@Size(min = 10, max = 10, message = "Phone Number length must be 10")
	private String phoneNumber;

	@NotNull(message = "Email ID cannot be null")
	@Size(min = 5, max = 50, message = "Email ID length must be between 5 and 50")
	private String emailId;

	@NotNull(message = "N-M-R Code cannot be null")
	@Size(min = 3, max = 50, message = "N-M-R Code length must be between 3 and 50")
	private String nmrCode;

	@NotNull(message = "Status cannot be null")
	private Boolean status;

    // --- CHANGED TO LOCALDATE ---
	@JsonFormat(pattern = "dd/MM/yyyy")
	@NotNull(message = "Open Date cannot be null")
	private LocalDate openDate;

	@JsonFormat(pattern = "dd/MM/yyyy")
	private LocalDate closeDate;

	@JsonFormat(pattern = "dd/MM/yyyy")
	private LocalDate mergeDate;

	@Size(min = 5, max = 5, message = "Merged with Branch length must be 5")
	private String mergedWithBranch;

    // --- CHANGED TO LOCALDATETIME ---
	@JsonFormat(pattern = "dd/MM/yyyy HH:mm:ss")
	private LocalDateTime lastChangeDate;

	@NotNull(message = "CPC Flag cannot be null")
	private Boolean cpcFlag;

	@NotNull(message = "Food Credit Flag cannot be null")
	private Boolean foodCreditFlag;

	@NotNull(message = "Curr Chest Flag cannot be null")
	private Boolean currChestFlag;

	@NotNull(message = "Branch Type cannot be null")
	@Size(min = 1, max = 1, message = "Blength must be 1")
	@Pattern(regexp = "[AM]", message = "Branch Type can only be A or M")
	private String branchType;

	@Override
	@JsonIgnore
	public String getKey() {
		return code;
	}
}

















package com.tcs.fincore.CommonRequestService.service.strategy;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.tcs.fincore.CommonRequestService.dto.CreateRequestDto;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;

public interface RequestTypeStrategy {

    RequestType getRequestType();

    /**
     * Processes the approval (Saving to Master Table).
     */
    void processApproval(CommonReq request) throws JsonProcessingException;

    /**
     * Validates the payload BEFORE creating the Pending Request.
     * Default implementation does nothing (hook for strategies to override).
     */
    default void validateRequest(CreateRequestDto requestDto) throws JsonProcessingException {
        // Default: No validation. Override in specific strategies.
    }
}



















package com.tcs.fincore.CommonRequestService.service.strategy;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.dto.BranchRequestPayloadDTO;
import com.tcs.fincore.CommonRequestService.dto.CreateRequestDto;
import com.tcs.fincore.CommonRequestService.exception.BusinessRuleViolationException;
import com.tcs.fincore.CommonRequestService.exception.ResourceNotFoundException;
import com.tcs.fincore.CommonRequestService.model.BranchMaster;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.ChangeType;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.BranchMasterRepository;
import com.tcs.fincore.CommonRequestService.repository.CircleMasterRepository;
import com.tcs.fincore.CommonRequestService.repository.StateMasterRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Slf4j
@Component
@RequiredArgsConstructor
public class BranchMasterStrategy implements RequestTypeStrategy {

    private final BranchMasterRepository branchMasterRepository;
    private final CircleMasterRepository circleMasterRepository;
    private final StateMasterRepository stateMasterRepository;
    private final ObjectMapper objectMapper;

    @Override
    public RequestType getRequestType() {
        return RequestType.BRANCH;
    }

    /**
     * CORE VALIDATION LOGIC
     * Runs before the CommonReq is created.
     */
    @Override
    public void validateRequest(CreateRequestDto requestDto) throws JsonProcessingException {
        // Convert Payload to DTO
        BranchRequestPayloadDTO payload = objectMapper.convertValue(requestDto.getPayload(), BranchRequestPayloadDTO.class);
        String branchCode = payload.getCode();

        // Rule 1: Duplicate Check (Only for ADD)
        if (requestDto.getChangeType() == ChangeType.ADD) {
            if (branchMasterRepository.existsById(branchCode)) {
                throw new BusinessRuleViolationException("Branch with Code " + branchCode + " already exists.");
            }
        }

        // Rule 2: Master Data Presence (Circle & State)
        if (!circleMasterRepository.existsById(payload.getCircleCode())) {
            throw new BusinessRuleViolationException("Invalid Circle Code: " + payload.getCircleCode() + ". Circle does not exist in Master.");
        }
        if (!stateMasterRepository.existsById(payload.getState())) {
            throw new BusinessRuleViolationException("Invalid State Code: " + payload.getState() + ". State does not exist in Master.");
        }

        // Rule 3: Email Format Validation
        // Format: sbi.{branchCode}@sbi.co.in (Assuming Case Insensitive)
        String expectedEmail = "sbi." + branchCode.toLowerCase() + "@sbi.co.in";
        if (!expectedEmail.equalsIgnoreCase(payload.getEmailId())) {
            throw new BusinessRuleViolationException("Invalid Email ID. Expected format: " + expectedEmail);
        }

        // Rule 4 & 6: Branch Status & Type Logic
        // Assumption: Boolean TRUE = LIVE, Boolean FALSE = CLOSED
        boolean isLive = Boolean.TRUE.equals(payload.getStatus());
        String branchType = payload.getBranchType(); // 'A' or 'M'

        if (isLive) {
            // "if branch status is live... branch type is Automated"
            if (!"A".equalsIgnoreCase(branchType)) {
                throw new BusinessRuleViolationException("Live branches must be of Type 'Automated' (A).");
            }
        } else {
            // "if branch status closed... close date is mandatory"
            if (payload.getCloseDate() == null) {
                throw new BusinessRuleViolationException("Close Date is mandatory for Closed/Inactive branches.");
            }
            // "if branch status closed... branch type must be manual"
            if (!"M".equalsIgnoreCase(branchType)) {
                throw new BusinessRuleViolationException("Closed branches must be of Type 'Manual' (M).");
            }
        }

        // Rule 5: Merge Logic
        // "merge date and merge with branch... if one provided other is necessary"
        boolean hasMergeDate = payload.getMergeDate() != null;
        boolean hasMergeBranch = payload.getMergedWithBranch() != null && !payload.getMergedWithBranch().isBlank();

        // XOR Logic: If one is true and the other is false, throw error
        if (hasMergeDate != hasMergeBranch) {
            throw new BusinessRuleViolationException("Merge Date and 'Merged With Branch' must both be provided if one is present.");
        }
    }

    @Override
    public void processApproval(CommonReq request) throws JsonProcessingException {
        switch (request.getChangeType()) {
            case ADD:
                handleAdd(request);
                break;
            case UPDATE:
                handleUpdate(request);
                break;
            case BLOCK:
                handleStatusChange(request, Boolean.FALSE);
                break;
            case UNBLOCK:
                handleStatusChange(request, Boolean.TRUE);
                break;
            default:
                throw new UnsupportedOperationException("Change type " + request.getChangeType() + " is not supported.");
        }
    }

    private void handleAdd(CommonReq request) throws JsonProcessingException {
        BranchMaster payload = objectMapper.readValue(request.getPayload(), BranchMaster.class);
        if (branchMasterRepository.existsById(payload.getCode())) {
            throw new DataIntegrityViolationException("Branch Code already exists");
        }
        BranchMaster saved = branchMasterRepository.save(payload);
        log.info("Successfully added new Branch: {}", saved.getCode());
    }

    private void handleUpdate(CommonReq request) throws JsonProcessingException {
        String targetId = request.getTargetId();
        BranchMaster existing = branchMasterRepository.findById(targetId).orElseThrow(
                () -> new ResourceNotFoundException("Branch Code '" + targetId + "' not found."));

        BranchMaster updated = objectMapper.readValue(request.getPayload(), BranchMaster.class);

        // Apply updates
        existing.setName(updated.getName());
        existing.setCircleCode(updated.getCircleCode());
        existing.setState(updated.getState());
        existing.setCity(updated.getCity());
        existing.setAddress(updated.getAddress());
        existing.setPinCode(updated.getPinCode());
        existing.setPhoneNumber(updated.getPhoneNumber());
        existing.setEmailId(updated.getEmailId());
        existing.setNmrCode(updated.getNmrCode());
        existing.setStatus(updated.getStatus());
        existing.setCloseDate(updated.getCloseDate());
        existing.setMergeDate(updated.getMergeDate());
        existing.setMergedWithBranch(updated.getMergedWithBranch());
        
        // --- USING LOCALDATETIME NOW ---
        existing.setLastChangeDate(LocalDateTime.now());
        
        existing.setCpcFlag(updated.getCpcFlag());
        existing.setFoodCreditFlag(updated.getFoodCreditFlag());
        existing.setCurrChestFlag(updated.getCurrChestFlag());
        existing.setBranchType(updated.getBranchType());

        branchMasterRepository.save(existing);
    }

    private void handleStatusChange(CommonReq request, Boolean newStatus) {
        String targetId = request.getTargetId();
        BranchMaster existing = branchMasterRepository.findById(targetId).orElseThrow(
                () -> new ResourceNotFoundException("Branch Code '" + targetId + "' not found."));
        existing.setStatus(newStatus);
        existing.setLastChangeDate(LocalDateTime.now());
        branchMasterRepository.save(existing);
    }
}















package com.tcs.fincore.CommonRequestService.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.dto.CreateRequestDto;
import com.tcs.fincore.CommonRequestService.dto.NotificationConfigDto;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;
import com.tcs.fincore.CommonRequestService.model.CGLMaster;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.ChangeType;
import com.tcs.fincore.CommonRequestService.model.enums.RequestStatus;
import com.tcs.fincore.CommonRequestService.repository.CommonRequestRepository;
import com.tcs.fincore.CommonRequestService.service.strategy.RequestStrategyFactory;
import com.tcs.fincore.CommonRequestService.service.strategy.RequestTypeStrategy;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class RequestServiceImpl implements RequestService {

    private static final String EVENT_SOURCE = "CommonRequestService";
    private final CommonRequestRepository commonRequestRepository;
    private final RequestStrategyFactory strategyFactory;
    private final ObjectMapper objectMapper;
    private final NotificationWriterService notificationWriterService;
    private final PermissionConfigService permissionConfigService;
    private final BusinessSecurityService businessSecurityService;

    @Override
    @Transactional(rollbackOn = Exception.class)
    public CommonReq createRequest(CreateRequestDto dto, String creatorId, String token) throws JsonProcessingException {

        // 1. RBAC SECURITY CHECK
        businessSecurityService.validateUserAction(token, dto.getRequestType(), dto.getChangeType());
        
        // 2. STRATEGY VALIDATION (Business Rules)
        // This hooks into the 6 rules defined in BranchMasterStrategy
        RequestTypeStrategy strategy = strategyFactory.getStrategy(dto.getRequestType());
        strategy.validateRequest(dto);

        // 3. TARGET ID EXTRACTION
        KeyablePayload payload = (KeyablePayload) dto.getPayload();
        String targetId = payload.getKey();
        if (targetId == null || targetId.isBlank()) {
            throw new IllegalArgumentException("Could not determine targetId from payload.");
        }

        // 4. DUPLICATE PENDING REQUEST CHECK
        List<CommonReq> existingRequests = commonRequestRepository.findByTargetIdAndReqStatus(targetId, RequestStatus.PENDING);
        if (!existingRequests.isEmpty()) {
            throw new DataIntegrityViolationException("An active or pending request for '" + targetId + "' already exists.");
        }

        // 5. SAVE REQUEST
        CommonReq request = new CommonReq();
        request.setCreatorId(creatorId);
        request.setReqType(dto.getRequestType());
        request.setChangeType(dto.getChangeType());
        request.setPayload(objectMapper.writeValueAsString(payload));
        request.setTargetId(targetId);
        request.setReqStatus(RequestStatus.PENDING);
        // REQ_DATE will be set by DB (SourceType.DB)

        CommonReq savedRequest = commonRequestRepository.save(request);
        log.info("Saved new request for targetId {}", targetId);

        // 6. NOTIFICATIONS
        try {
            String requestTypeKey = dto.getRequestType().name();
            NotificationConfigDto config = permissionConfigService.getConfig(requestTypeKey);
            String action = request.getChangeType().name();

            // Custom Logic for Block/Unblock labels
            if (request.getChangeType() == ChangeType.BLOCK || request.getChangeType() == ChangeType.UNBLOCK) {
                 if (request.getChangeType() == ChangeType.BLOCK) action = "BLOCK";
                 if (request.getChangeType() == ChangeType.UNBLOCK) action = "UNBLOCK";
            }
            
            String message = "New " + action + " request (" + targetId + ") pending for " + dto.getRequestType();

            notificationWriterService.createNotification(
                    creatorId,
                    config.getTargetRoles(),
                    message,
                    config.getTargetUrl(),
                    savedRequest.getId().toString(),
                    EVENT_SOURCE
            );
        } catch (Exception e) {
            log.error("Failed to create notification for request: {}. Rolling back.", savedRequest.getId(), e);
            throw new RuntimeException("Failed to create notification event, rolling back.", e);
        }

        return savedRequest;
    }

    // ... Implement getMyRequests, getPendingRequests, updateRequestStatus, cancelRequest as defined previously ...
    @Override
    public java.util.List<CommonReq> getMyRequests(String userId, com.tcs.fincore.CommonRequestService.model.enums.RequestType requestType) {
         return commonRequestRepository.findByCreatorIdAndReqType(userId, requestType);
    }
    @Override
    public java.util.List<CommonReq> getPendingRequests(String userId, com.tcs.fincore.CommonRequestService.model.enums.RequestType requestType) {
        return commonRequestRepository.findByCreatorIdNotAndReqStatusAndReqType(userId, RequestStatus.PENDING, requestType);
    }
    @Override
    public java.util.List<CommonReq> getAllRequests() {
        return commonRequestRepository.findAll();
    }
    @Override
    public java.util.Optional<CommonReq> updateRequestStatus(com.tcs.fincore.CommonRequestService.dto.ProcessRequestDto dto, String executorId) throws JsonProcessingException {
       // Re-use logic from previous responses for updateRequestStatus 
       // (omitted here to keep response concise, refer to your RequestServiceImpl.java backup or previous outputs)
       return java.util.Optional.empty(); 
    }
    @Override
    public CommonReq cancelRequest(com.tcs.fincore.CommonRequestService.dto.CancelRequestDto dto, String userId) {
        // Re-use logic from previous responses for cancelRequest
        return null;
    }
}



















package com.tcs.fincore.CommonRequestService.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.BasicPolymorphicTypeValidator;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;

import java.time.Duration;

@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    @Primary
    public ObjectMapper objectMapper(Jackson2ObjectMapperBuilder builder) {
        // This picks up 'spring.jackson.time-zone' from application.properties
        return builder.createXmlMapper(false).build();
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory, Jackson2ObjectMapperBuilder builder) {
        ObjectMapper redisObjectMapper = builder.createXmlMapper(false).build();

        // Allow Redis to store class types (Polymorphism)
        redisObjectMapper.activateDefaultTyping(
                BasicPolymorphicTypeValidator.builder()
                        .allowIfBaseType(Object.class)
                        .build(),
                ObjectMapper.DefaultTyping.NON_FINAL
        );

        GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(redisObjectMapper);

        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(24))
                .disableCachingNullValues()
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(serializer));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(cacheConfig)
                .build();
    }
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory, ObjectMapper objectMapper) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        
        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(objectMapper, Object.class);
        
        template.setValueSerializer(serializer);
        template.setKeySerializer(new StringRedisSerializer());
        
        return template;
    }
}

















