package com.fincore.JournalService.Aspect;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.JournalService.Dto.BatchRequestDto;
import com.fincore.JournalService.Dto.BulkProcessJournalRequestDto;
import com.fincore.JournalService.Dto.ProcessJournalRequestDto;
import com.fincore.JournalService.Models.JournalLog;
import com.fincore.JournalService.Models.JournalRequest;
import com.fincore.JournalService.Repository.JournalLogRepository;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import java.time.LocalDateTime;

@Aspect
@Component
@Slf4j
@RequiredArgsConstructor
public class JournalActivityLogger {

    private final JournalLogRepository journalLogRepository;
    private final ObjectMapper objectMapper;

    // --- 1. Log Batch Creation (Standard) ---
    @AfterReturning(
            pointcut = "execution(* com.fincore.JournalService.Service.JournalRequestService.createBatchRequest(..)) && args(batchDto, creatorId, creatorRole)",
            returning = "result"
    )
    public void logCreateBatch(JoinPoint joinPoint, BatchRequestDto batchDto, String creatorId, Integer creatorRole, Object result) {
        String summary = "Created Batch with " + (batchDto.getRows() != null ? batchDto.getRows().size() : 0) + " rows.";
        saveLog(creatorId, "CREATE", "BATCH_CREATION", summary, null, null);
    }

    // --- 2. Log Bulk Batch Creation ---
    @AfterReturning(
            pointcut = "execution(* com.fincore.JournalService.Service.JournalRequestService.createBulkBatchRequest(..)) && args(batchDto, creatorId, creatorRole)",
            returning = "batchId"
    )
    public void logBulkCreate(JoinPoint joinPoint, BatchRequestDto batchDto, String creatorId, Integer creatorRole, Object batchId) {
        String summary = "Bulk Upload Created. Batch ID: " + batchId + ". Rows: " + (batchDto.getRows() != null ? batchDto.getRows().size() : 0);
        saveLog(creatorId, "CREATE", "BULK_UPLOAD", summary, null, null);
    }

    // --- 3. Log Status Update (Approve/Reject) ---
    @AfterReturning(
            pointcut = "execution(* com.fincore.JournalService.Service.JournalRequestService.updateRequestStatus(..)) && args(dto, executorId, executorRole)",
            returning = "result"
    )
    public void logStatusUpdate(JoinPoint joinPoint, ProcessJournalRequestDto dto, String executorId, Integer executorRole, Object result) {
        if (result instanceof JournalRequest) {
            JournalRequest req = (JournalRequest) result;
            String newValue = "Status: " + dto.getStatus() + ", Remarks: " + dto.getRemarks();
            saveLog(executorId, dto.getStatus().toString(), "STATUS_UPDATE", newValue, null, req.getId());
        }
    }

    // --- 4. Log Bulk Status Update ---
    @AfterReturning(
            pointcut = "execution(* com.fincore.JournalService.Service.JournalRequestService.processBulkRequests(..)) && args(dto, executorId, executorRole)",
            returning = "result"
    )
    public void logBulkStatusUpdate(JoinPoint joinPoint, BulkProcessJournalRequestDto dto, String executorId, Integer executorRole, Object result) {
        String target = dto.getBatchId() != null ? "Batch ID: " + dto.getBatchId() : "Journals: " + dto.getJournalIdPrefixes();
        String newValue = "Bulk " + dto.getStatus() + " for " + target + ". Remarks: " + dto.getRemarks();
        saveLog(executorId, "BULK_" + dto.getStatus(), "BULK_PROCESS", newValue, null, null);
    }

    // --- 5. Log Cancellations ---
    @AfterReturning(
            pointcut = "execution(* com.fincore.JournalService.Service.JournalRequestService.cancelMyRequest(..)) && args(requestId, userId)"
    )
    public void logCancelRequest(JoinPoint joinPoint, Long requestId, String userId) {
        saveLog(userId, "DELETE", "CANCEL_REQUEST", "User canceled request ID: " + requestId, null, requestId);
    }

    @AfterReturning(
            pointcut = "execution(* com.fincore.JournalService.Service.JournalRequestService.cancelMyRequestsByBatchId(..)) && args(batchId, userId)"
    )
    public void logCancelBatch(JoinPoint joinPoint, String batchId, String userId) {
        saveLog(userId, "DELETE", "CANCEL_BATCH", "User canceled all requests in Batch: " + batchId, null, null);
    }

    // --- Helper ---
    private void saveLog(String userId, String actionType, String changeType, String newValue, String oldValue, Long requestId) {
        try {
            JournalLog logEntry = new JournalLog();
            logEntry.setUserId(userId);
            logEntry.setActionType(actionType);
            logEntry.setChangeType(changeType);
            logEntry.setActionTime(LocalDateTime.now());
            logEntry.setRequestId(requestId);
            logEntry.setIpAddress(getClientIp());

            if (newValue != null && !newValue.getClass().equals(String.class)) {
                newValue = objectMapper.writeValueAsString(newValue);
            }

            logEntry.setNewValue(truncate(newValue, 3900)); // Adjusted to fit DB column
            logEntry.setOldValue(truncate(oldValue, 3900));

            journalLogRepository.save(logEntry);
            log.info("Audit Log Saved: {} performed {} on {}", userId, actionType, (requestId != null ? requestId : "Batch"));

        } catch (Exception e) {
            log.error("Failed to save audit log: {}", e.getMessage());
        }
    }

    private String getClientIp() {
        try {
            HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();
            String xForwardedFor = request.getHeader("X-Forwarded-For");
            if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
                return xForwardedFor.split(",")[0].trim();
            }
            return request.getRemoteAddr();
        } catch (Exception e) {
            return "UNKNOWN";
        }
    }

    private String truncate(String value, int length) {
        if (value != null && value.length() > length) {
            return value.substring(0, length - 3) + "...";
        }
        return value;
    }
}










package com.fincore.JournalService.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
public class AppConfig {

	@Bean
	@Primary
	public ObjectMapper objectMapper() {
		ObjectMapper mapper = new ObjectMapper();

		mapper.registerModule(new JavaTimeModule());

		mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

		return mapper;
	}
}





package com.fincore.JournalService.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import java.util.concurrent.Executor;

@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "bulkExecutor")
    public Executor bulkExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("JournalBulk-");
        executor.initialize();
        return executor;
    }
}





package com.fincore.JournalService.config;


import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public ConcurrentMapCacheManager cacheManager() {
      
        return new ConcurrentMapCacheManager("notification_configs");
    }
}







package com.fincore.JournalService.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;

import javax.sql.DataSource;

/**
 * SECONDARY DATASOURCE CONFIGURATION (Hive/Thrift)
 * * Configures the connection to the Data Lake (Delta Lake).
 * Uses JdbcTemplate for direct SQL execution, suitable for analytics queries.
 */
@Configuration
public class HiveDbConfig {

    @Bean(name = "hiveDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.hive")
    public DataSource hiveDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = "hiveJdbcTemplate")
    public JdbcTemplate hiveJdbcTemplate(@Qualifier("hiveDataSource") DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}



package com.fincore.JournalService.config;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

/**
 * PRIMARY DATASOURCE CONFIGURATION (Oracle)
 * * This class ensures that all existing JPA Repositories and Entities
 * continue to work using the Oracle database.
 * * We mark beans as @Primary so Spring injects this datasource by default
 * into existing services.
 */
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(basePackages = "com.fincore.JournalService.Repository", // Location of existing Repos
        entityManagerFactoryRef = "oracleEntityManagerFactory", transactionManagerRef = "oracleTransactionManager")
public class OracleDbConfig {
    @Primary
    @Bean(name = "oracleDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.oracle")
    public DataSource oracleDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Primary
    @Bean(name = "oracleEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean oracleEntityManagerFactory(
            EntityManagerFactoryBuilder builder,
            @Qualifier("oracleDataSource") DataSource dataSource) {

        Map<String, Object> properties = new HashMap<>();
        properties.put("hibernate.dialect", "org.hibernate.dialect.OracleDialect");
        properties.put("hibernate.hbm2ddl.auto", "update"); // Or 'validate' for prod

        return builder
                .dataSource(dataSource)
                .packages("com.fincore.JournalService.Models") // Location of existing Entities
                .persistenceUnit("oracle")
                .properties(properties)
                .build();
    }

    @Primary
    @Bean(name = "oracleTransactionManager")
    public PlatformTransactionManager oracleTransactionManager(
            @Qualifier("oracleEntityManagerFactory") EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }
    @Primary
    @Bean(name = "oracleJdbcTemplate")
    public JdbcTemplate oracleJdbcTemplate(@Qualifier("oracleDataSource") DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

}






package com.fincore.JournalService.config;

import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;
import com.fincore.JournalService.Models.enums.RequestStatus;
import java.util.stream.Stream;

@Converter(autoApply = true)
public class RequestStatusConverter implements AttributeConverter<RequestStatus, String> {

    @Override
    public String convertToDatabaseColumn(RequestStatus status) {
        if (status == null) {
            return null;
        }
        return status.getCode(); // Writes "P", "A", "R" to DB
    }

    @Override
    public RequestStatus convertToEntityAttribute(String code) {
        if (code == null) {
            return null;
        }
        return Stream.of(RequestStatus.values())
                .filter(c -> c.getCode().equals(code))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("Unknown status code: " + code));
    }
}









package com.fincore.JournalService.config;

import com.fincore.commonutilities.config.CommonSecurityConfig;
import com.fincore.commonutilities.config.RedisConfig;
import com.fincore.commonutilities.jwt.JwtUtil;
import com.fincore.commonutilities.security.ContextRbacFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/**
 * Common Security Configuration.
 * * Aligned with the "Distributed Gateway" architecture.
 * It uses the ContextRbacFilter from Common Utilities to enforce:
 * 1. Token Validity
 * 2. Single Session (Redis check)
 * 3. RBAC Permissions
 */
@Configuration
@EnableWebSecurity
@Import({RedisConfig.class, JwtUtil.class, CommonSecurityConfig.class }) // Import logic from JAR
public class SecurityConfig {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private CommonSecurityConfig commonSecurityConfig; // Wire in the CORS config

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                // 1. Disable CSRF (Stateless API)
                .csrf(csrf -> csrf.disable())

                // 2. Apply Centralized CORS Policy
                .cors(cors -> cors.configurationSource(commonSecurityConfig.corsConfigurationSource()))

                // 3. Stateless Session (No JSESSIONID)
                .sessionManagement(s -> s.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                // 4. Authorization Rules
                .authorizeHttpRequests(authz -> authz
                        // Public Endpoints
                        .requestMatchers("/actuator/**", "/auth/**", "/error").permitAll()
                        // All other endpoints require Authentication (and RBAC filter check)
                        .anyRequest().authenticated()
                )

                // 5. Add the "Distributed Gateway" Filter
                .addFilterBefore(new ContextRbacFilter(redisTemplate, jwtUtil), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}










--***********************************************************************************************
controllers: 
package com.fincore.JournalService.Controllers;

import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.fincore.JournalService.Dto.BranchDto;
import com.fincore.JournalService.Service.BranchService;

import java.util.Collections; 
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/branches-journal")
@RequiredArgsConstructor
public class BranchController {

	private final BranchService branchService;

	@GetMapping("/map")
	public Map<String, String> getBranchMap() {
		return branchService.getBranchCodeAndNameMap();
	}

	@GetMapping("/search")
	public List<BranchDto> searchBranches(@RequestParam String query) {
       
        if (query == null || query.trim().isEmpty()) {
            return Collections.emptyList();
        }
     
		return branchService.searchBranches(query);
	}
}













package com.fincore.JournalService.Controllers;


import com.fincore.JournalService.Dto.CglDto;
import com.fincore.JournalService.Service.CglService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;


@RestController
@RequestMapping("/api/cgl-journal")
@RequiredArgsConstructor
public class CglController {

    private final CglService cglService;

    @GetMapping("/search")
    public ResponseEntity<List<CglDto>> searchCgl(@RequestParam(value = "query", required = false, defaultValue = "") String query) {
        return ResponseEntity.ok(cglService.searchCgls(query));
    }
}















package com.fincore.JournalService.Controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fincore.JournalService.Dto.*;
import com.fincore.JournalService.Exception.ResourceNotFoundException;
import com.fincore.JournalService.Models.JournalRequest;
import com.fincore.JournalService.Service.JournalBulkValidationService;
import com.fincore.JournalService.Service.JournalRequestService;
import com.fincore.commonutilities.jwt.JwtUtil;
// Removed unused import: io.jsonwebtoken.Claims;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/journals")
@RequiredArgsConstructor
@Slf4j
public class JournalRequestController {

    private final JournalRequestService journalRequestService;
    private final JournalBulkValidationService journalBulkValidationService;
    private final JwtUtil jwtUtil;

    // --- 1. NEW: MANUAL BATCH CREATION ---
    @PostMapping("/create-batch")
    public ResponseEntity<List<JournalRequest>> createBatchRequest(
            @Valid @RequestBody BatchRequestDto batchDto,
            @RequestHeader("Authorization") String token) throws JsonProcessingException {

        // Use existing methods from JwtUtil
        String userId = jwtUtil.getUserIdFromToken(token);
        Integer userRole = jwtUtil.getUserRoleFromToken(token);

        log.info("Creating Manual Journal Batch. User: {}, Role: {}", userId, userRole);

        List<JournalRequest> createdRequests = journalRequestService.createBatchRequest(batchDto, userId, userRole);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdRequests);
    }

    // --- 2. EXISTING: BATCH CREATION (FROM FILE CACHE) ---
    @PostMapping("/create-batch-from-cache")
    public ResponseEntity<Map<String, Object>> createBatchFromCache(@RequestBody Map<String, String> payload, @RequestHeader("Authorization") String token) {
        try {
            // Use existing methods here as well
            String userId = jwtUtil.getUserIdFromToken(token);
            Integer userRole = jwtUtil.getUserRoleFromToken(token);

            String batchId = journalRequestService.createBatchFromCache(
                    payload.get("requestId"),
                    payload.get("commonBatchRemarks"),
                    userId,
                    userRole
            );
            return ResponseEntity.ok(Map.of("status", "SUCCESS", "message", "Batch created successfully", "batchId", batchId));
        } catch (ResourceNotFoundException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("status", "ERROR", "message", e.getMessage()));
        } catch (Exception e) {
            log.error("Error", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("status", "ERROR", "message", "System error."));
        }
    }

    @GetMapping("/current-posting-date")
    public String getCurrentPostingDate() {
        LocalDate date = journalRequestService.getCurrentPostingDate();
        return date.format(DateTimeFormatter.ISO_LOCAL_DATE);
    }

    // --- 3. SUMMARIES ---
    @GetMapping("/pending-requests-summary")
    public ResponseEntity<?> getPendingBatchSummaries() {
        try { return ResponseEntity.ok(journalRequestService.getPendingBatchSummaries()); }
        catch (Exception e) { log.error("Error", e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("error", "Unable to load pending requests.")); }
    }

    @GetMapping("/all-requests-summary")
    public ResponseEntity<?> getAllBatchSummaries() {
        try { return ResponseEntity.ok(journalRequestService.getAllBatchSummaries()); }
        catch (Exception e) { log.error("Error", e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("error", "Unable to load requests.")); }
    }

    // --- 4. PAGINATED DETAILS ---
    @GetMapping("/by-batch-paginated/{batchId}")
    public ResponseEntity<?> getRequestsByBatchIdPaginated(@PathVariable String batchId, @RequestParam(defaultValue = "0") int page, @RequestParam(defaultValue = "10") int size) {
        try { return ResponseEntity.ok(journalRequestService.getRequestsByBatchIdPaginated(batchId, PageRequest.of(page, size))); }
        catch (Exception e) { log.error("Error", e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("error", "Unable to load details.")); }
    }

    // --- 5. VALIDATION & DOWNLOAD ---
    @PostMapping(value = "/bulk-validate-init", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> initiateValidation(
            @RequestParam("file") MultipartFile file,
            @RequestParam("postingDate") String date,
            HttpServletRequest request) {

        try {
            log.info(">>> INCOMING UPLOAD REQUEST <<<");
            if (file == null || file.isEmpty()) {
                return ResponseEntity.badRequest().body(Map.of("error", "File is missing or empty"));
            }

            String reqId = journalBulkValidationService.initiateValidation(
                    file.getBytes(),
                    file.getOriginalFilename(),
                    LocalDate.parse(date)
            );

            log.info("Validation Queued. ReqID: {}", reqId);
            return ResponseEntity.ok(Map.of("status", "QUEUED", "requestId", reqId));

        } catch (Exception e) {
            log.error("File Upload Exception", e);
            return ResponseEntity.badRequest().body(Map.of("error", e.getMessage()));
        }
    }

    @GetMapping("/bulk-status/{requestId}")
    public ResponseEntity<BulkUploadStateDto> checkStatus(@PathVariable String requestId) {
        BulkUploadStateDto state = journalBulkValidationService.getState(requestId);
        return state != null ? ResponseEntity.ok(state) : ResponseEntity.notFound().build();
    }

    @GetMapping("/download-bulk-file/{requestId}")
    public ResponseEntity<Resource> downloadFile(@PathVariable String requestId, @RequestParam String type) {
        try {
            byte[] data = journalBulkValidationService.getFileBytes(requestId, type);
            if (data == null) return ResponseEntity.notFound().build();
            String name = type.equals("ERROR") ? "Error_Report.xlsx" : "Success.csv";
            String mime = type.equals("ERROR") ? "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" : "text/csv";
            return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + name + "\"").contentType(MediaType.parseMediaType(mime)).body(new ByteArrayResource(data));
        } catch (Exception e) { return ResponseEntity.internalServerError().build(); }
    }

    @GetMapping("/download-template")
    public ResponseEntity<Resource> downloadTemplate() {
        try {
            byte[] data = journalBulkValidationService.generateTemplateBytes();
            return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"Journal_Upload_Template.xlsx\"").contentType(MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")).body(new ByteArrayResource(data));
        } catch (Exception e) { return ResponseEntity.internalServerError().build(); }
    }

    // --- 6. ACTIONS ---
    @PostMapping("/process-bulk")
    public ResponseEntity<?> processBulkRequests(@RequestHeader("Authorization") String token, @Valid @RequestBody BulkProcessJournalRequestDto dto) {
        try {
            // Use existing methods
            String userId = jwtUtil.getUserIdFromToken(token);
            Integer userRole = jwtUtil.getUserRoleFromToken(token);

            journalRequestService.processBulkRequests(dto, userId, userRole);
            return ResponseEntity.ok(Map.of("status", "SUCCESS"));
        } catch (Exception e) { log.error("Error", e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("status", "ERROR", "message", "Processing failed.")); }
    }

    @DeleteMapping("/my-requests/by-batch/{batchId}")
    public ResponseEntity<?> cancelMyRequestsByBatch(@RequestHeader("Authorization") String token, @PathVariable String batchId) {
        try {
            journalRequestService.cancelMyRequestsByBatchId(batchId, jwtUtil.getUserIdFromToken(token));
            return ResponseEntity.ok(Map.of("status", "SUCCESS"));
        } catch (Exception e) { log.error("Error", e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("status", "ERROR", "message", "Cancel failed.")); }
    }

    @DeleteMapping("/my-requests/by-journal-list")
    public ResponseEntity<?> cancelMyRequestsByJournalPrefixes(@RequestHeader("Authorization") String token, @RequestBody List<String> list) {
        try {
            journalRequestService.cancelMyRequestsByJournalPrefixes(list, jwtUtil.getUserIdFromToken(token));
            return ResponseEntity.ok(Map.of("status", "SUCCESS"));
        } catch (Exception e) { log.error("Error", e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("status", "ERROR", "message", "Cancel failed.")); }
    }

    // --- 7. LEGACY / UTILS ---
    @GetMapping("/by-batch/{batchId}")
    public ResponseEntity<List<JournalRequest>> getRequestsByBatchId(@PathVariable String batchId) { return ResponseEntity.ok(journalRequestService.getRequestsByBatchId(batchId)); }
    @GetMapping("/my-requests")
    public List<JournalRequest> getMyRequests(@RequestHeader("Authorization") String token) { return journalRequestService.getMyRequests(jwtUtil.getUserIdFromToken(token)); }
    @GetMapping("/pending-requests")
    public List<JournalRequest> getPendingRequests(@RequestHeader("Authorization") String token) {
        // Use existing methods
        return journalRequestService.getPendingRequests(jwtUtil.getUserIdFromToken(token), jwtUtil.getUserRoleFromToken(token));
    }
    @PatchMapping("/update-request")
    public JournalRequest updateRequestStatus(@RequestHeader("Authorization") String token, @RequestBody ProcessJournalRequestDto dto) throws JsonProcessingException {
        return journalRequestService.updateRequestStatus(dto, jwtUtil.getUserIdFromToken(token), jwtUtil.getUserRoleFromToken(token)).get();
    }
    @DeleteMapping("/my-request/{requestId}")
    public ResponseEntity<Void> cancelMyRequest(@RequestHeader("Authorization") String token, @PathVariable Long requestId) { journalRequestService.cancelMyRequest(requestId, jwtUtil.getUserIdFromToken(token)); return ResponseEntity.noContent().build(); }
    @GetMapping("/status")
    public ResponseEntity<List<JournalRequestStatusDto>> getJournalStatusList() { return ResponseEntity.ok(journalRequestService.getJournalRequestStatusList()); }
}
***************************************************************************************************
dtos :
package com.fincore.JournalService.Dto;

import com.fincore.JournalService.Models.enums.ChangeType;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.math.BigDecimal;
import java.time.LocalDate;
import lombok.Data;
import java.util.List;

@Data
public class BatchRequestDto {

    @Data
    public static class JournalRequestRow {
        @NotNull
        private ChangeType changeType = ChangeType.ADD;

        private Long masterJournalId;

        private LocalDate csvDate;

        @NotNull @Size(min = 1, max = 50)
        private String branch;

        @NotNull @Size(min = 3, max = 3)
        private String currency;

        @NotNull @Size(min = 1, max = 50)
        private String cgl;

        @NotNull
        private BigDecimal amount;

        @Size(max = 20)
        private String productType;

        @Size(max = 200)
        private String remarks;

        @Size(min = 1, max = 1)
        private String arFlag = "A";

        @Size(min = 1, max = 1)
        private String acClassification;
    }

    @Size(max = 200)
    private String commonBatchRemarks;

    @Valid
    @NotNull
    private List<JournalRequestRow> rows;
}











package com.fincore.JournalService.Dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;


@Data
@NoArgsConstructor
@AllArgsConstructor
public class BranchDto {
    private String code;
    private String name;
    
}












package com.fincore.JournalService.Dto;

import java.util.List;

import com.fincore.JournalService.Models.enums.RequestStatus;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class BulkProcessJournalRequestDto {
     
    private String batchId;
    
    private List<String> journalIdPrefixes;

    @NotNull
    private RequestStatus status; 
    
    @Size(max = 50)
    private String remarks;
}











package com.fincore.JournalService.Dto;

import lombok.Data;
import java.io.Serializable;

@Data
public class BulkUploadStateDto implements Serializable {
    private String requestId;
    private String status; // PROCESSING, SUCCESS, ERROR
    private Integer currentStage; // 1..4
    private Integer totalRows;
    private Long errorCount;
    private String message;
    private String previewDataJson;

    private boolean hasErrorFile;
    private boolean hasSuccessFile;

    private transient String errorFilePath;
    private transient String successFilePath;
}














package com.fincore.JournalService.Dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;


@Data
@NoArgsConstructor
@AllArgsConstructor
public class CglDto {
    private String cglNumber;
    private String description;
}












package com.fincore.JournalService.Dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.math.BigDecimal;
import java.time.LocalDate;

import com.fincore.JournalService.Models.enums.ChangeType;

@Data
@Getter
@Setter
@JsonIgnoreProperties(ignoreUnknown = true)
public class CreateJournalRequestDto {

    @NotNull
    private ChangeType changeType;

    private Long masterJournalId;

    @NotNull
    @JsonProperty("pDate")
    private LocalDate pDate;

    @NotNull @Size(min = 1, max = 50)
    private String branch;

    @NotNull @Size(min = 3, max = 3)
    private String currency;

    @NotNull @Size(min = 1, max = 50)
    private String cgl;

    @NotNull
    private BigDecimal amount;

    @Size(max = 20)
    private String productType;

    @Size(max = 50)
    private String remarks;

    @Size(min = 1, max = 1)
    private String arFlag;

    @Size(min = 1, max = 1)
    private String acClassification;

    @NotNull @Size(min = 1, max = 50)
    private String batchId;

    @NotNull @Size(min = 1, max = 50)
    private String journalId;

    @Size(max = 50)
    private String commonBatchRemarks;

    private Integer transactionCount;

    private String transactionType;
}















package com.fincore.JournalService.Dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class GlAggregatedDataDto {
    private Long id; // Add this field
    private String branch;
    private String currency;
    private String cgl;
    private LocalDate txnDate;
    private BigDecimal rawAmount;
    private BigDecimal convertedAmount;

    // Existing Constructor used in map (id will be null initially)
    public GlAggregatedDataDto(String branch, String currency, String cgl, LocalDate txnDate, BigDecimal rawAmount, BigDecimal convertedAmount) {
        this.branch = branch;
        this.currency = currency;
        this.cgl = cgl;
        this.txnDate = txnDate;
        this.rawAmount = rawAmount;
        this.convertedAmount = convertedAmount;
    }
}












package com.fincore.JournalService.Dto;

import lombok.Data;
import java.time.LocalDateTime;

import com.fincore.JournalService.Models.JournalRequest;
import com.fincore.JournalService.Models.enums.RequestStatus;

@Data
public class JournalRequestStatusDto {

    private RequestStatus requestStatus;
    private LocalDateTime requestDate;
    private String creatorId;
    private String executorId;
    private String executorRemarks;
    private String batchId;
    private String journalId;

    // A helper constructor 
    public JournalRequestStatusDto(JournalRequest request) {
        this.requestStatus = request.getRequestStatus();
        this.requestDate = request.getRequestDate();
        this.creatorId = request.getCreatorId();
        this.executorId = request.getExecutorId();
        this.executorRemarks = request.getExecutorRemarks();
        this.batchId = request.getBatchId();
        this.journalId = request.getJournalId();
    }
}














package com.fincore.JournalService.Dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class NotificationConfigDto {
    private String targetUrl;
    private String targetRoles; // Comma separated string: "51,52,55"
}











package com.fincore.JournalService.Dto;

import com.fincore.JournalService.Models.enums.RequestStatus;

import jakarta.persistence.Column;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

@Data
@Getter
@Setter
public class ProcessJournalRequestDto {
	@Column(nullable = false)
    private Long requestId;
    
    @Column(nullable = false)
    private RequestStatus status; 
    
    @Size(max = 50)
    private String remarks;

}






********************************************************************************************




package com.fincore.JournalService.Exception;


import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}




********************************************************************************************

models:



package com.fincore.JournalService.Models.enums;

import lombok.Getter;

import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;

@Getter
public enum AcClassification {
	  ASSET('A', "Asset"),
	    LIABILITY('L', "Liability"),
	    INCOME('I', "Income"),
	    EXPENSE('E', "Expense"),
	    MEMO('M', "Memo A/c");

	    private final char code;
	    private final String description;

	    AcClassification(char code, String description) {
	        this.code = code;
	        this.description = description;
	    }

	  
	    public static Map<String, String> getClassificationMap() {
	        return Arrays.stream(AcClassification.values())
	                .collect(Collectors.toMap(
	                        ac -> String.valueOf(ac.getCode()), 
	                        AcClassification::getDescription
	                ));
	    }
}







package com.fincore.JournalService.Models.enums;

import lombok.Getter;

@Getter
public enum ChangeType {
	    ADD("A"),
	    UPDATE("U"),
	    DELETE("D");

	    private final String code;

	    ChangeType(String code) {
	        this.code = code;
	    }
}





package com.fincore.JournalService.Models.enums;


import lombok.Getter;

@Getter
public enum RequestStatus {
    PENDING("P"),
    ACCEPTED("A"),
    REJECTED("R");

    private final String code;

    RequestStatus(String code) {
        this.code = code;
    }
}





package com.fincore.JournalService.Models;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;
import java.time.LocalDate;


@Entity
@Table(name = "BRANCH_MASTER")
@Data
public class BranchMaster {

    @Id
    @Column(name = "CODE" )
    private String code;

    @Column(name = "NAME")
    private String name;

    @Column(name = "CIRCLE_CODE")
    private String circleCode;

    @Column(name = "STATE")
    private String state;

    @Column(name = "CITY")
    private String city;

    @Column(name = "ADDRESS")
    private String address;

    @Column(name = "PINCODE")
    private String pincode;

    @Column(name = "PHONE_NUMBER")
    private String phoneNumber;

    @Column(name = "EMAIL_ID")
    private String emailId;

    @Column(name = "NMR_CODE" )
    private String nmrCode;

    @Column(name = "STATUS")
    private Integer status;

    @Column(name = "OPEN_DATE")
    private LocalDate openDate;

    @Column(name = "CLOSE_DATE")
    private LocalDate closeDate;

    @Column(name = "MERGE_DATE")
    private LocalDate mergeDate;

    @Column(name = "MERGED_WITH_BRANCH" )
    private String mergedWithBranch;

    @Column(name = "LAST_CHANGE_DATE")
    private LocalDate lastChangeDate;

    @Column(name = "CPC_FLAG")
    private Boolean cpcFlag;

    @Column(name = "FOOD_CREDIT_FLAG")
    private Boolean foodCreditFlag;

    @Column(name = "CURR_CHEST_FLAG")
    private Boolean currChestFlag;

    @Column(name = "BRANCH_TYPE")
    private String branchType;
}

























tables: 
***************************************************************************************************
journal_requests :

REQ_ID	NUMBER	No		1	
REQ_STATUS	VARCHAR2(10 CHAR)	No	'P' 	2	
CHANGE_TYPE	VARCHAR2(10 CHAR)	No		3	
REQ_DATE	DATE	No	SYSDATE 	4	
CREATOR_ID	VARCHAR2(12 CHAR)	No		5	
EXECUTOR_ID	VARCHAR2(12 CHAR)	Yes		6	
EXECUTION_DATE	DATE	Yes		7	
EXECUTOR_REMARKS	VARCHAR2(50 CHAR)	Yes		8	
PAYLOAD	CLOB	Yes		9	
BATCH_ID	VARCHAR2(50 CHAR)	Yes		10	
JOURNAL_ID	VARCHAR2(50 CHAR)	Yes		11	
COMMON_BATCH_REMARKS	VARCHAR2(50 CHAR)	Yes		12	
CREATOR_ROLE	NUMBER(10,0)	Yes		13	


data :

1404594	A	ADD	31-12-25	3333333	1021253	31-12-25	DAS	{"changeType":"ADD","masterJournalId":null,"pDate":"2025-12-19","branch":"32098","currency":"USD","cgl":"5051501701","amount":-9997.15,"productType":"12345678","remarks":"Balanced_Txn_326_Cr","arFlag":"A","acClassification":"A","batchId":"0001063","journalId":"0004025-006","commonBatchRemarks":"Bulk Upload - 2025-12-17","transactionCount":6}	0001063	0004025-006	Bulk Upload - 2025-12-17	11
1408978	A	ADD	05-01-26	3333333	1021256	05-01-26	ASD	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-02","branch":"32121","currency":"USD","cgl":"1122505001","amount":-10000,"productType":"12345679","remarks":"Normal","arFlag":"A","acClassification":"A","batchId":"0001158","journalId":"0004707-002","commonBatchRemarks":"Bulk Upload - 2025-12-02","transactionCount":2}	0001158	0004707-002	Bulk Upload - 2025-12-02	11
1408977	A	ADD	05-01-26	3333333	1021256	05-01-26	ASD	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-02","branch":"32121","currency":"USD","cgl":"1208505003","amount":10000,"productType":"12345678","remarks":"ewreew","arFlag":"A","acClassification":"A","batchId":"0001158","journalId":"0004707-001","commonBatchRemarks":"Bulk Upload - 2025-12-02","transactionCount":1}	0001158	0004707-001	Bulk Upload - 2025-12-02	11
1408974	A	ADD	05-01-26	3333333	1021256	05-01-26	asd	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-02","branch":"32121","currency":"USD","cgl":"1122505001","amount":-10000,"productType":"12345679","remarks":"Normal","arFlag":"A","acClassification":"A","batchId":"0001156","journalId":"0004705-002","commonBatchRemarks":"Bulk Upload - 2025-12-02","transactionCount":2}	0001156	0004705-002	Bulk Upload - 2025-12-02	11
1408973	A	ADD	05-01-26	3333333	1021256	05-01-26	asd	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-02","branch":"32121","currency":"USD","cgl":"1208505003","amount":10000,"productType":"12345678","remarks":"ewreew","arFlag":"A","acClassification":"A","batchId":"0001156","journalId":"0004705-001","commonBatchRemarks":"Bulk Upload - 2025-12-02","transactionCount":1}	0001156	0004705-001	Bulk Upload - 2025-12-02	11
1408970	A	ADD	05-01-26	3333333	1021256	05-01-26	asd	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-02","branch":"32121","currency":"USD","cgl":"1122505001","amount":-10000,"productType":"12345679","remarks":"Normal","arFlag":"A","acClassification":"A","batchId":"0001154","journalId":"0004703-002","commonBatchRemarks":"Bulk Upload - 2025-12-02","transactionCount":2}	0001154	0004703-002	Bulk Upload - 2025-12-02	11
1408969	A	ADD	05-01-26	3333333	1021256	05-01-26	asd	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-02","branch":"32121","currency":"USD","cgl":"1208505003","amount":10000,"productType":"12345678","remarks":"ewreew","arFlag":"A","acClassification":"A","batchId":"0001154","journalId":"0004703-001","commonBatchRemarks":"Bulk Upload - 2025-12-02","transactionCount":1}	0001154	0004703-001	Bulk Upload - 2025-12-02	11
1406631	A	ADD	05-01-26	3333333	1021256	05-01-26	qwe	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-17","branch":"14443","currency":"USD","cgl":"5051220801","amount":9153.92,"productType":"12345678","remarks":"Balanced_Txn_555_Dr","arFlag":"A","acClassification":"A","batchId":"0001149","journalId":"0004367-005","commonBatchRemarks":"Bulk Upload - 2025-12-17","transactionCount":5}	0001149	0004367-005	Bulk Upload - 2025-12-17	11
1406630	A	ADD	05-01-26	3333333	1021256	05-01-26	qwe	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-17","branch":"14443","currency":"USD","cgl":"2051070601","amount":-3325.87,"productType":"12345678","remarks":"Balanced_Txn_490_Cr","arFlag":"A","acClassification":"A","batchId":"0001149","journalId":"0004367-004","commonBatchRemarks":"Bulk Upload - 2025-12-17","transactionCount":4}	0001149	0004367-004	Bulk Upload - 2025-12-17	11
1406629	A	ADD	05-01-26	3333333	1021256	05-01-26	qwe	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-17","branch":"14443","currency":"USD","cgl":"2051070601","amount":3325.87,"productType":"12345678","remarks":"Balanced_Txn_490_Dr","arFlag":"A","acClassification":"A","batchId":"0001149","journalId":"0004367-003","commonBatchRemarks":"Bulk Upload - 2025-12-17","transactionCount":3}	0001149	0004367-003	Bulk Upload - 2025-12-17	11
1406628	A	ADD	05-01-26	3333333	1021256	05-01-26	qwe	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-17","branch":"14443","currency":"USD","cgl":"5051080630","amount":-1428.23,"productType":"12345678","remarks":"Balanced_Txn_162_Cr","arFlag":"A","acClassification":"A","batchId":"0001149","journalId":"0004367-002","commonBatchRemarks":"Bulk Upload - 2025-12-17","transactionCount":2}	0001149	0004367-002	Bulk Upload - 2025-12-17	11
1406627	A	ADD	05-01-26	3333333	1021256	05-01-26	qwe	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-17","branch":"14443","currency":"USD","cgl":"5051080630","amount":1428.23,"productType":"12345678","remarks":"Balanced_Txn_162_Dr","arFlag":"A","acClassification":"A","batchId":"0001149","journalId":"0004367-001","commonBatchRemarks":"Bulk Upload - 2025-12-17","transactionCount":1}	0001149	0004367-001	Bulk Upload - 2025-12-17	11
1406626	A	ADD	05-01-26	3333333	1021256	05-01-26	qwe	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-17","branch":"31977","currency":"USD","cgl":"5051500130","amount":-9792.25,"productType":"12345678","remarks":"Balanced_Txn_488_Cr","arFlag":"A","acClassification":"A","batchId":"0001149","journalId":"0004366-004","commonBatchRemarks":"Bulk Upload - 2025-12-17","transactionCount":4}	0001149	0004366-004	Bulk Upload - 2025-12-17	11
1406625	A	ADD	05-01-26	3333333	1021256	05-01-26	qwe	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-17","branch":"31977","currency":"USD","cgl":"5051500130","amount":9792.25,"productType":"12345678","remarks":"Balanced_Txn_488_Dr","arFlag":"A","acClassification":"A","batchId":"0001149","journalId":"0004366-003","commonBatchRemarks":"Bulk Upload - 2025-12-17","transactionCount":3}	0001149	0004366-003	Bulk Upload - 2025-12-17	11
1406624	A	ADD	05-01-26	3333333	1021256	05-01-26	qwe	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-17","branch":"31977","currency":"USD","cgl":"7456505002","amount":-8177.29,"productType":"12345678","remarks":"Balanced_Txn_138_Cr","arFlag":"A","acClassification":"A","batchId":"0001149","journalId":"0004366-002","commonBatchRemarks":"Bulk Upload - 2025-12-17","transactionCount":2}	0001149	0004366-002	Bulk Upload - 2025-12-17	11
1406623	A	ADD	05-01-26	3333333	1021256	05-01-26	qwe	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-17","branch":"31977","currency":"USD","cgl":"7456505002","amount":8177.29,"productType":"12345678","remarks":"Balanced_Txn_138_Dr","arFlag":"A","acClassification":"A","batchId":"0001149","journalId":"0004366-001","commonBatchRemarks":"Bulk Upload - 2025-12-17","transactionCount":1}	0001149	0004366-001	Bulk Upload - 2025-12-17	11
1407047	A	ADD	05-01-26	3333333	1021256	05-01-26	qwe	{"changeType":"ADD","masterJournalId":null,"csvDate":"2025-12-17","branch":"14698","currency":"USD","cgl":"2080501103","amount":1590.84,"productType":"12345678","remarks":"Balanced_Txn_130_Dr","arFlag":"A","acClassification":"A","batchId":"0001149","journalId":"0004429-001","commonBatchRemarks":"Bulk Upload - 2025-12-17","transactionCount":1}	0001149	0004429-001	Bulk Upload - 2025-12-17	11


gl_balance : 

ID	NUMBER(19,0)	No	"FINCORE"."GL_BALANCE_SEQ"."NEXTVAL"	1	Id of the balance
BALANCE_DATE	DATE	No	NULL 	2	Date of the balance recorded
BRANCH_CODE	VARCHAR2(5 BYTE)	No		3	branchcodeis the foreign key of the branch_master
CURRENCY	VARCHAR2(3 BYTE)	No		4	currency is foreign key of currency_master
CGL	VARCHAR2(10 BYTE)	No		5	cgl is foreign key of cgl_master
BALANCE	NUMBER(25,4)	No		6	balance recorded for a date
INR_BALANCE	NUMBER(25,2)	Yes		7	Converted to INR Balance

data :
46232234	11-11-25	09298	USD	2248500101	-472.7385	
46232237	11-11-25	09601	USD	2248500101	-539.044	
46232238	11-11-25	09930	USD	2248500101	-13880.5559	
46232239	11-11-25	09995	USD	2248500101	6693.2951	





gl_transactions :
TRANSACTION_ID	NUMBER(20,0)	No	"FINCORE"."GL_TRANSACTIONS_SEQ"."NEXTVAL"	1	
BATCH_ID	VARCHAR2(50 CHAR)	Yes		2	
JOURNAL_ID	VARCHAR2(50 CHAR)	Yes		3	
TRANSACTION_DATE	DATE	Yes	NULL 	4	
POST_DATE	TIMESTAMP(6)	Yes	SYSDATE 	5	
BRANCH_CODE	VARCHAR2(50 CHAR)	Yes		6	
CURRENCY	VARCHAR2(3 BYTE)	Yes		7	
CGL	VARCHAR2(10 BYTE)	Yes		8	
NARRATION	VARCHAR2(40 BYTE)	Yes		9	
DEBIT_AMOUNT	NUMBER(25,4)	Yes		10	
CREDIT_AMOUNT	NUMBER(25,4)	Yes		11	
TRANSACTION_COUNT	NUMBER(10,0)	Yes		12	
SOURCE_FLAG	VARCHAR2(1 BYTE)	Yes		13	

sample data :

316290541	0001170	0004739-485	02-12-25	06-01-26 04:50:26.062668000 PM	32121	USD	1208505003	ewreew	1000	0	485	J
316290542	0001170	0004739-486	02-12-25	06-01-26 04:50:26.062668000 PM	32121	USD	1122505001	Normal	0	1000	486	J
316290543	0001170	0004739-487	02-12-25	06-01-26 04:50:26.062668000 PM	32121	USD	1208505003	ewreew	1000	0	487	J
316290544	0001170	0004739-488	02-12-25	06-01-26 04:50:26.062668000 PM	32121	USD	1122505001	Normal	0	1000	488	J



currency master :

CURRENCY_CODE	VARCHAR2(3 BYTE)	No		1	Currency Code of Currency
CURRENCY_NAME	VARCHAR2(50 BYTE)	No		2	Name of Currency
FLAG	NUMBER(1,0)	No	0	3	Currency Active or Inactive
CURRENCY_RATE	NUMBER(12,6)	Yes		4	Current Rate of Currency
RATE_DATE	DATE	Yes		5	Rate change date 
CREATED_AT	TIMESTAMP(6)	Yes	CURRENT_TIMESTAMP	6	Currency created date
UPDATED_AT	TIMESTAMP(6)	Yes	"CURRENT_TIMESTAMP
   "	7	Currency updated date


data :
VCY	drtvce	0	1.134546		15-12-25 12:21:10.611561000 PM	15-12-25 12:21:10.611561000 PM
RET	hfbdhfadbfhd	0	65.26565		15-12-25 12:52:50.394294000 PM	15-12-25 12:52:50.394294000 PM
MAT	PAMN	0	12.121321		19-12-25 06:34:35.235474000 AM	19-12-25 06:34:35.235477000 AM
GYK	gvkj 	0	1.1		15-12-25 11:39:22.736494000 AM	15-12-25 11:39:22.736494000 AM
GHF	iutyjgtkgjykjhjkgjkggjgjhhghj	0	465564.465454		15-12-25 11:39:42.892401000 AM	15-12-25 11:39:42.892401000 AM
