package com.tcs.dashboard.service;

import com.tcs.dashboard.dto.*;
import com.tcs.dashboard.model.*;
import com.tcs.dashboard.repository.*;
import com.tcs.dashboard.repository.DashboardStatsRepository.TypeCount;
import com.fincore.commonutilities.jwt.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class DashboardServiceImpl {

    // Repos
    private final DashboardStatsRepository statsRepo; // The new Optimized Repo
    private final PermissionRepository permissionRepo;
    private final AnnouncementRepository announcementRepo;
    private final UserLogRepository userLogRepo;
    private final CommonReqRepository commonReqRepo; // Kept for Activity Feed Lists
    private final UserRequestRepository userReqRepo;
    private final RoleRequestRepository roleReqRepo;
    private final JournalRequestRepository journalReqRepo;
    private final JwtUtil jwtUtil;

    @Transactional(readOnly = true)
    public DashboardResponse getDashboardData(String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        int roleIdInt = jwtUtil.getUserRoleFromToken(token);
        String roleIdStr = String.valueOf(roleIdInt);

        log.info("Generating Intelligent Dashboard for User: {}", userId);

        DashboardResponse response = new DashboardResponse();

        // 1. Announcements
        response.setAnnouncements(fetchAnnouncements(roleIdStr));

        // 2. Determine View Type (Logic: Hybrid > Executor > Maker > Viewer)
        List<String> approvalTypes = permissionRepo.findApprovalTypesForRole(roleIdInt);
        int creationPermCount = permissionRepo.countCreationPermissions(roleIdInt);
        boolean canApprove = !approvalTypes.isEmpty();
        boolean canCreate = creationPermCount > 0;

        if (canApprove && canCreate) response.setViewType("HYBRID");
        else if (canApprove) response.setViewType("EXECUTOR");
        else if (canCreate) response.setViewType("MAKER");
        else response.setViewType("VIEWER");

        // 3. Calculate Stats & Intelligence
        StatsDto stats = new StatsDto();
        
        // 3a. Maker Stats (Optimized via DB Aggregation)
        calculateMakerStatsOptimized(stats, userId);
        
        // 3b. Executor Stats (Optimized)
        if (canApprove) {
            calculateExecutorStatsOptimized(stats, approvalTypes);
            // 3c. Apply Bottleneck & Anomaly Intelligence
            applyIntelligenceLayer(stats, userId, approvalTypes);
        }
        
        stats.calculateTotals();
        response.setStats(stats);

        // 4. Smart Quick Actions (Behavioral Algorithm)
        response.setQuickActions(generateSmartQuickActions(roleIdInt, userId));

        // 5. Frequency Stats (Today/Week counts)
        response.setFrequencyStats(calculateFrequencyStats());

        // 6. Unified Activity Feed
        response.setRecentActivity(fetchUnifiedActivity(userId));

        return response;
    }

    // ==================================================================================
    //  ALGORITHM 1: OPTIMIZED STATS (SQL AGGREGATION)
    // ==================================================================================

    private void calculateMakerStatsOptimized(StatsDto stats, String userId) {
        // Maps to hold breakdowns
        Map<String, Integer> pMap = new HashMap<>();
        Map<String, Integer> aMap = new HashMap<>();
        Map<String, Integer> rMap = new HashMap<>();

        // 1. Fetch CRS Stats (Aggregated in DB)
        List<TypeCount> crsStats = statsRepo.getMakerStatsCrs(userId);
        for (TypeCount row : crsStats) {
            bucketStats(pMap, aMap, rMap, row.getType(), row.getStatus(), row.getCount().intValue());
        }

        // 2. Fetch Other Modules (Legacy tables, less volume, fetching list is OK for now)
        // User Mgmt
        List<UserRequest> uReqs = userReqRepo.findByRequestorUserId(userId);
        uReqs.forEach(r -> bucketStats(pMap, aMap, rMap, "USER_MANAGEMENT", r.getRequestStatus(), 1));
        
        // Role Mgmt
        List<RoleRequest> rReqs = roleReqRepo.findByRequestorUserId(userId);
        rReqs.forEach(r -> bucketStats(pMap, aMap, rMap, "ROLE_MANAGEMENT", r.getRequestStatus(), 1));

        // Journal
        List<JournalRequest> jReqs = journalReqRepo.findByCreatorId(userId);
        jReqs.forEach(r -> bucketStats(pMap, aMap, rMap, "JOURNAL_AUTH", r.getReqStatus(), 1));

        // Set Aggregates
        stats.setMyPending(sumMap(pMap));
        stats.setMyApproved(sumMap(aMap));
        stats.setMyRejected(sumMap(rMap));
        
        stats.setMyPendingDetails(pMap);
        stats.setMyApprovedDetails(aMap);
        stats.setMyRejectedDetails(rMap);
    }

    private void calculateExecutorStatsOptimized(StatsDto stats, List<String> allowedTypes) {
        Map<String, Integer> details = new HashMap<>();
        
        // 1. CRS Pending (DB Aggregation)
        List<TypeCount> crsPending = statsRepo.getPendingCountsByTypes(allowedTypes);
        for(TypeCount row : crsPending) {
            details.put(row.getType(), row.getCount().intValue());
        }

        // 2. Other Modules (If permission exists)
        if(allowedTypes.contains("USER_MANAGEMENT")) 
            addIfPositive(details, "USER_MANAGEMENT", userReqRepo.findAllPending().size());
        
        if(allowedTypes.contains("ROLE_MANAGEMENT")) 
            addIfPositive(details, "ROLE_MANAGEMENT", roleReqRepo.findAllPending().size());
            
        if(allowedTypes.contains("JOURNAL_AUTH")) 
            addIfPositive(details, "JOURNAL_AUTH", journalReqRepo.findAllPending().size());

        stats.setPendingForMe(sumMap(details));
        stats.setPendingForMeDetails(details);
    }

    // ==================================================================================
    //  ALGORITHM 2: INTELLIGENCE (BOTTLENECK & ANOMALY)
    // ==================================================================================

    private void applyIntelligenceLayer(StatsDto stats, String userId, List<String> approvalTypes) {
        // 1. BOTTLENECK DETECTION
        // Logic: Query items pending > 48 Hours for this user's specific roles
        int overdueCount = statsRepo.countOverdueItems(approvalTypes);
        stats.setOverduePendingCount(overdueCount);
        
        // Threshold: If more than 5 items are overdue, flag user as Bottleneck
        stats.setIsBottleneck(overdueCount > 5);

        // 2. ANOMALOUS ACTIVITY DETECTION
        // Logic: Query rejections in last 1 hour
        int recentRejections = statsRepo.countRecentRejections(userId);
        
        // Threshold: > 15 rejections in 1 hour is suspicious/high
        if (recentRejections > 15) {
            stats.setAnomalyDetected(true);
            stats.setAnomalyMessage("Warning: High volume of rejections detected (" + recentRejections + " in last hour).");
        }
    }

    // ==================================================================================
    //  ALGORITHM 3: SMART QUICK ACTIONS (BEHAVIORAL FREQUENCY)
    // ==================================================================================

    private List<QuickActionDto> generateSmartQuickActions(int roleId, String userId) {
        // A. Static Permissions
        List<Permission> allPerms = permissionRepo.findAllByRoleId(roleId);
        
        // B. Build Usage Profile (What does this user actually DO?)
        Map<String, Integer> usageMap = new HashMap<>();

        // 1. CRS Usage (CGL, Segment...)
        List<TypeCount> crsUsage = statsRepo.getUserCrsUsageFrequency(userId);
        for(TypeCount row : crsUsage) usageMap.put(row.getType(), row.getCount().intValue());

        // 2. Journal Usage
        int journalUsage = statsRepo.getUserJournalUsageCount(userId);
        if(journalUsage > 0) usageMap.put("JOURNAL", journalUsage);

        // 3. User Mgmt Usage
        int userMgmtUsage = statsRepo.getUserMgmtUsageCount(userId);
        if(userMgmtUsage > 0) usageMap.put("USER_MANAGEMENT", userMgmtUsage);

        List<QuickActionDto> actions = new ArrayList<>();

        for (Permission p : allPerms) {
            if (isApprovalScreen(p)) continue; // Don't show "Approvals" in Quick Actions

            String type = getActionType(p.getMenuAction());
            String mappedType = p.getMappedRequestType();
            int score = 0;

            // --- SCORING ---
            // 1. Interest Boost: If they use it, boost it massively
            if (mappedType != null && usageMap.containsKey(mappedType)) {
                score += (usageMap.get(mappedType) * 2); 
            }
            // Fuzzy match for modules without strict Mapped Type
            if (p.getMenuUrl().contains("journal") && usageMap.containsKey("JOURNAL")) score += 20;
            if (p.getMenuUrl().contains("user") && usageMap.containsKey("USER_MANAGEMENT")) score += 20;

            // 2. Action Type Bias (Uploads/Creates are usually more important than Views)
            if ("UPLOAD".equals(type)) score += 10;
            else if ("CREATE".equals(type)) score += 8;
            else if ("DOWNLOAD".equals(type)) score += 5;
            else score += 1;

            actions.add(new QuickActionDto(
                p.getMenuId(), deriveLabel(type, p.getMenuTitle()), 
                p.getMenuUrl(), p.getMenuIcon(), type, p.getMenuDescription(), score
            ));
        }

        // Sort by Score DESC (Smartest first)
        actions.sort((a, b) -> Integer.compare(b.getScore(), a.getScore()));

        return actions.stream().limit(6).collect(Collectors.toList());
    }

    // ==================================================================================
    //  UNIFIED ACTIVITY FEED (ROBUST PARSING)
    // ==================================================================================

    private List<ActivityLogDto> fetchUnifiedActivity(String userId) {
        List<ActivityLogDto> timeline = new ArrayList<>();

        // 1. USER LOGS (Parsed carefully)
        List<UserLog> userLogs = userLogRepo.findTop20ByUserIdOrderByActionTimeDesc(userId);
        for (UserLog log : userLogs) timeline.add(parseUserLogDetails(log));

        // 2. CRS ACTIVITY
        // Created
        List<CommonReq> created = commonReqRepo.findTop10ByCreatorIdOrderByReqDateDesc(userId);
        for (CommonReq r : created) {
            String msg = String.format("Raised %s Request %s", r.getReqType(), r.getTargetId() != null ? r.getTargetId() : "");
            timeline.add(createLog("Request Raised", toMillis(r.getReqDate()), "COMMON_REQ", msg, normalizeStatus(r.getReqStatus()), r.getCreatorId()));
        }
        // Executed
        List<CommonReq> executed = commonReqRepo.findTop10ByExecutorIdOrderByExecutionDateDesc(userId);
        for (CommonReq r : executed) {
            if(r.getExecutionDate() == null) continue;
            String status = normalizeStatus(r.getReqStatus());
            String msg = String.format("%s request for %s", status, r.getReqType());
            timeline.add(createLog("Request Processed", toMillis(r.getExecutionDate()), "COMMON_REQ", msg, status, r.getExecutorId()));
        }

        // 3. JOURNAL ACTIVITY
        List<JournalRequest> journals = journalReqRepo.findTop10ByCreatorIdOrderByReqDateDesc(userId);
        for (JournalRequest j : journals) {
            String msg = "Uploaded Batch " + j.getBatchId();
            timeline.add(createLog("Journal Upload", toMillis(j.getReqDate()), "JOURNAL", msg, normalizeStatus(j.getReqStatus()), j.getCreatorId()));
        }

        Collections.sort(timeline);
        return timeline.stream().limit(15).collect(Collectors.toList());
    }

    // --- PARSER FOR USER LOGS ---
    private ActivityLogDto parseUserLogDetails(UserLog log) {
        // Raw: {targetUserId=123, requestType=CREATE, ...}
        String raw = log.getNewValue();
        String actionType = log.getActionType() != null ? log.getActionType() : "ACTIVITY";
        
        String reqType = extractRegex(raw, "requestType");
        String target = extractRegex(raw, "targetUserId");
        
        String display = actionType.replace("_", " ");
        String details = log.getChangeType();

        if ("USER_REQUEST".equals(actionType)) {
            display = "User Mgmt";
            details = String.format("Raised %s for User %s", reqType, target);
        } else if (actionType.contains("APPROVAL")) {
            display = "Approval";
            details = String.format("Processed %s for %s", reqType != null ? reqType : "Request", target);
        }

        return createLog(display, log.getActionTime().getTime(), "USER_LOG", details, "COMPLETED", log.getUserId());
    }

    // --- HELPERS ---

    private void bucketStats(Map<String, Integer> p, Map<String, Integer> a, Map<String, Integer> r, String type, String rawStatus, int count) {
        String status = normalizeStatus(rawStatus);
        if ("PENDING".equals(status)) p.merge(type, count, Integer::sum);
        else if ("APPROVED".equals(status)) a.merge(type, count, Integer::sum);
        else if ("REJECTED".equals(status)) r.merge(type, count, Integer::sum);
    }

    private void addIfPositive(Map<String, Integer> map, String key, int count) {
        if(count > 0) map.put(key, count);
    }

    private int sumMap(Map<String, Integer> map) {
        return map.values().stream().mapToInt(Integer::intValue).sum();
    }

    private String normalizeStatus(String s) {
        if (s == null) return "UNKNOWN";
        if (s.startsWith("P")) return "PENDING";
        if (s.startsWith("A") || s.equals("SUCCESS")) return "APPROVED";
        if (s.startsWith("R") || s.startsWith("C")) return "REJECTED";
        return s;
    }

    private String getActionType(String raw) {
        if(raw == null) return "VIEW";
        raw = raw.toLowerCase();
        if(raw.contains("upload")) return "UPLOAD";
        if(raw.contains("create")) return "CREATE";
        if(raw.contains("download")) return "DOWNLOAD";
        return "VIEW";
    }

    private String deriveLabel(String type, String title) {
        if("VIEW".equals(type) && (title.contains("Enquiry") || title.contains("Report"))) return title;
        return type.charAt(0) + type.substring(1).toLowerCase() + " " + title;
    }

    private boolean isApprovalScreen(Permission p) {
        return p.getMenuTitle().contains("Requests") || 
               (p.getMenuAction() != null && p.getMenuAction().contains("approve"));
    }

    private String extractRegex(String source, String key) {
        if (source == null) return "Unknown";
        Pattern p = Pattern.compile(key + "=([^,}]+)");
        Matcher m = p.matcher(source);
        if (m.find()) return m.group(1).trim();
        return "Unknown";
    }

    private ActivityLogDto createLog(String action, long time, String source, String details, String status, String user) {
        ActivityLogDto log = new ActivityLogDto();
        log.setAction(action);
        log.setTimestamp(time);
        log.setDisplayTime(new Timestamp(time).toString());
        log.setSource(source);
        log.setDetails(details);
        log.setStatus(status);
        log.setUser(user);
        return log;
    }

    private long toMillis(LocalDateTime ldt) {
        return ldt == null ? 0 : ldt.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
    }

    // Frequency Stats & Announcements (Unchanged)
    private List<AnnouncementDto> fetchAnnouncements(String roleId) {
        return announcementRepo.findActive(new Timestamp(System.currentTimeMillis()), roleId).stream()
            .map(a -> new AnnouncementDto(a.getId(), a.getTitle(), a.getMessage(), a.getSeverity(), a.getCreatedAt().toString()))
            .collect(Collectors.toList());
    }
    
    private FrequencyStatsDto calculateFrequencyStats() {
        LocalDateTime startOfDay = LocalDate.now().atStartOfDay();
        LocalDateTime endOfDay = LocalDate.now().atTime(LocalTime.MAX);
        return FrequencyStatsDto.builder()
            .createdToday(commonReqRepo.countCreatedBetween(startOfDay, endOfDay))
            .approvedToday(commonReqRepo.countExecutedBetween(startOfDay, endOfDay, "A"))
            .rejectedToday(commonReqRepo.countExecutedBetween(startOfDay, endOfDay, "R"))
            .build();
    }
}
















package com.tcs.dashboard.repository;

import com.tcs.dashboard.model.CommonReq;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

/**
 * OPTIMIZED REPOSITORY
 * Uses Native Queries and Projections to perform heavy aggregations at the Database level.
 * This prevents loading thousands of Entity objects into Java Heap memory.
 */
@Repository
public interface DashboardStatsRepository extends JpaRepository<CommonReq, Long> {

    // --- PROJECTION INTERFACE (Lightweight Data Carrier) ---
    interface TypeCount {
        String getType();   // e.g., "CGL_CODE"
        String getStatus(); // e.g., "P"
        Long getCount();    // e.g., 50
    }

    // ==================================================================================
    // 1. STATS AGGREGATION (MAKER & EXECUTOR)
    // ==================================================================================

    /**
     * MAKER VIEW: Counts requests created by this user, grouped by Type and Status.
     * Efficiently replaces fetching findAllByCreatorId().
     */
    @Query(value = "SELECT REQ_TYPE as type, REQ_STATUS as status, COUNT(*) as count " +
                   "FROM COMMON_REQ WHERE CREATOR_ID = :userId " +
                   "GROUP BY REQ_TYPE, REQ_STATUS", nativeQuery = true)
    List<TypeCount> getMakerStatsCrs(@Param("userId") String userId);

    /**
     * EXECUTOR VIEW: Counts pending requests for specific allowed types.
     * Used to populate 'Pending For Me' details.
     */
    @Query(value = "SELECT REQ_TYPE as type, COUNT(*) as count " +
                   "FROM COMMON_REQ " +
                   "WHERE REQ_STATUS = 'P' AND REQ_TYPE IN :types " +
                   "GROUP BY REQ_TYPE", nativeQuery = true)
    List<TypeCount> getPendingCountsByTypes(@Param("types") List<String> types);

    // ==================================================================================
    // 2. INTELLIGENCE: BOTTLENECK & ANOMALY DETECTION
    // ==================================================================================

    /**
     * BOTTLENECK DETECTION:
     * Counts items pending for more than 48 hours (2 days) for specific types.
     * Oracle Syntax: REQ_DATE < SYSDATE - 2
     */
    @Query(value = "SELECT COUNT(*) FROM COMMON_REQ " +
                   "WHERE REQ_STATUS = 'P' " +
                   "AND REQ_TYPE IN :types " +
                   "AND REQ_DATE < (SYSDATE - 2)", nativeQuery = true)
    int countOverdueItems(@Param("types") List<String> types);

    /**
     * ANOMALY DETECTION:
     * Counts how many items this user REJECTED in the last 1 HOUR.
     * High volume indicates potential error or bulk script usage.
     * Oracle Syntax: SYSDATE - (1/24) means current time minus 1 hour.
     */
    @Query(value = "SELECT COUNT(*) FROM COMMON_REQ " +
                   "WHERE EXECUTOR_ID = :userId " +
                   "AND REQ_STATUS = 'R' " +
                   "AND EXECUTION_DATE > (SYSDATE - (1/24))", nativeQuery = true)
    int countRecentRejections(@Param("userId") String userId);

    // ==================================================================================
    // 3. INTELLIGENCE: BEHAVIORAL ANALYSIS (FOR SMART QUICK ACTIONS)
    // ==================================================================================

    /**
     * FREQUENCY ANALYSIS (CRS):
     * Finds which modules this user interacts with most (Creation).
     */
    @Query(value = "SELECT REQ_TYPE as type, COUNT(*) as count " +
                   "FROM COMMON_REQ WHERE CREATOR_ID = :userId " +
                   "GROUP BY REQ_TYPE", nativeQuery = true)
    List<TypeCount> getUserCrsUsageFrequency(@Param("userId") String userId);

    /**
     * FREQUENCY ANALYSIS (JOURNAL):
     * Checks if user frequently uploads journals.
     */
    @Query(value = "SELECT COUNT(*) FROM JOURNAL_REQUESTS WHERE CREATOR_ID = :userId", nativeQuery = true)
    int getUserJournalUsageCount(@Param("userId") String userId);

    /**
     * FREQUENCY ANALYSIS (USER OPS):
     * Checks if user frequently performs user management.
     */
    @Query(value = "SELECT COUNT(*) FROM USER_LOGS " +
                   "WHERE USER_ID = :userId AND ACTION_TYPE LIKE 'USER_%'", nativeQuery = true)
    int getUserMgmtUsageCount(@Param("userId") String userId);
}











package com.tcs.dashboard.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class StatsDto {
    // --- TOP LEVEL CARDS (Aggregated) ---
    private int totalPending;
    private int totalApproved;
    private int totalRejected;

    // --- EXECUTOR VIEW DATA ---
    private int pendingForMe;
    // Map: "CGL_CODE" -> 5, "BRANCH" -> 2
    private Map<String, Integer> pendingForMeDetails;

    // --- MAKER VIEW DATA ---
    private int myPending;
    private Map<String, Integer> myPendingDetails;

    private int myApproved;
    private Map<String, Integer> myApprovedDetails;

    private int myRejected;
    private Map<String, Integer> myRejectedDetails;

    // --- INTELLIGENT INSIGHTS (New) ---
    // Trigger: If overduePendingCount > 5, Frontend turns card Orange/Red
    private int overduePendingCount; 
    private boolean isBottleneck;    

    // Trigger: If anomalyDetected = true, Frontend shows Toast/Banner
    private boolean anomalyDetected; 
    private String anomalyMessage;

    public void calculateTotals() {
        this.totalPending = myPending; // Simplification: Total usually refers to "My" total in dashboard context
        this.totalApproved = myApproved;
        this.totalRejected = myRejected;
    }
}




