import React, {
  createContext,
  useEffect,
  useRef,
  useCallback,
  useState,
} from "react";
import { useDispatch, useSelector } from "react-redux";
import { throttle } from "lodash";
import SessionDialog from "../components/SessionDialog";
import SessionWarningDialog from "../components/SessionWarningDialog";
import { logoutSuccess } from "../store/slices/authSlice";
import api from "../utils/axiosConfig";

export const AuthContext = createContext();

const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 min
const WARNING_SECONDS = 30;

export const AuthProvider = ({ children }) => {
  const dispatch = useDispatch();
  const isAuthenticated = useSelector((state) => state.auth.isAuthenticated);
  
  const [warningOpen, setWarningOpen] = useState(false);
  const [secondsLeft, setSecondsLeft] = useState(WARNING_SECONDS);
  
  const [sessionDialogOpen, setSessionDialogOpen] = useState(false);
  const [sessionReason, setSessionReason] = useState("");

  const inactivityTimerRef = useRef(null);
  const warningTimerRef = useRef(null);
  const countdownRef = useRef(null);

  // --- 1. Helper to Clear Timers ---
  const clearAllTimers = useCallback(() => {
    if (inactivityTimerRef.current) clearTimeout(inactivityTimerRef.current);
    if (warningTimerRef.current) clearTimeout(warningTimerRef.current);
    if (countdownRef.current) clearInterval(countdownRef.current);
  }, []);

  // --- 2. Perform Logout ---
  // reason can be: "USER_INITIATED", "SESSION_EXPIRED", "CONCURRENT_LOGIN"
  const performLogout = useCallback(async (reason = "USER_INITIATED") => {
      clearAllTimers();
      
      // If triggered by system (not manual button click), show the dialog
      if (reason !== "USER_INITIATED") {
          setSessionReason(reason);
          setSessionDialogOpen(true);
      }
      
      try {
        // Attempt server logout (best effort)
        await api.post("/auth/logout");
      } catch (err) {
        // Ignore errors if token is already dead
      } finally {
         // Always clear client state
         dispatch(logoutSuccess());
         setWarningOpen(false);
      }
  }, [dispatch, clearAllTimers]);

  // --- 3. Start Timers ---
  const startInactivityTimer = useCallback(() => {
    clearAllTimers();
    if(!isAuthenticated) return;

    warningTimerRef.current = setTimeout(() => {
      setWarningOpen(true);
      setSecondsLeft(WARNING_SECONDS);
      
      let counter = WARNING_SECONDS;
      countdownRef.current = setInterval(() => {
        counter -= 1;
        setSecondsLeft(counter);
        if (counter <= 0) clearInterval(countdownRef.current);
      }, 1000);
      
    }, INACTIVITY_TIMEOUT - (WARNING_SECONDS * 1000));

    inactivityTimerRef.current = setTimeout(() => {
       performLogout("SESSION_EXPIRED");
    }, INACTIVITY_TIMEOUT);
    
  }, [isAuthenticated, clearAllTimers, performLogout]);

  // --- 4. Event Listeners ---
  const onActivity = useCallback(
    throttle(() => {
      if (!isAuthenticated || sessionDialogOpen) return;
      if (warningOpen) setWarningOpen(false);
      startInactivityTimer();
    }, 2000),
    [isAuthenticated, sessionDialogOpen, warningOpen, startInactivityTimer]
  );

  useEffect(() => {
      if (isAuthenticated) {
          startInactivityTimer();
          const events = ["mousemove", "keydown", "click", "scroll", "touchstart"];
          events.forEach((e) => window.addEventListener(e, onActivity));
          
          return () => {
              events.forEach((e) => window.removeEventListener(e, onActivity));
              onActivity.cancel();
              clearAllTimers();
          };
      } else {
          clearAllTimers();
          setWarningOpen(false);
      }
  }, [isAuthenticated, onActivity, startInactivityTimer, clearAllTimers]);

  useEffect(() => {
      const handleSessionEvent = (e) => {
          const reason = e.detail?.reason || "SESSION_EXPIRED";
          performLogout(reason);
      };
      
      window.addEventListener("auth:session-expired", handleSessionEvent);
      return () => window.removeEventListener("auth:session-expired", handleSessionEvent);
  }, [performLogout]);

  return (
    <AuthContext.Provider
      value={{
        logout: () => performLogout("USER_INITIATED"),
        // Expose this so PrivateRouter can trigger it
        triggerSessionDialog: (reason) => performLogout(reason)
      }}
    >
      {children}

      <SessionWarningDialog
        open={warningOpen}
        secondsLeft={secondsLeft}
        onContinue={() => {
            setWarningOpen(false);
            startInactivityTimer();
        }}
      />

      {/* The ONE Global Dialog for all session issues */}
      <SessionDialog
        open={sessionDialogOpen}
        reason={sessionReason}
        onConfirm={() => {
          setSessionDialogOpen(false);
          window.location.href = "/"; 
        }}
      />
    </AuthContext.Provider>
  );
};










import React, { useEffect, useContext } from "react";
import { Navigate, Outlet } from "react-router-dom";
import { useSelector } from "react-redux";
import { AuthContext } from "../context/AuthContext";

const PrivateRouter = () => {
  const { token, user } = useSelector((state) => state.auth);
  const tabId = useSelector((state) => state.tab.tabId);
  
  // Use the global context trigger
  const { triggerSessionDialog } = useContext(AuthContext);

  useEffect(() => {
    // Only listen if logged in
    if (!user?.userId || !tabId) return;

    const bc = new BroadcastChannel("auth");

    const handleMessage = (event) => {
      const { type, userId: eventUserId, tabId: eventTabId } = event.data || {};

      // If same user logs in on a different tab
      if (
        type === "USER_LOGGED_IN" &&
        eventUserId === user.userId &&
        eventTabId !== tabId
      ) {
        // Trigger the global dialog with the correct reason
        triggerSessionDialog("CONCURRENT_LOGIN");
      }
    };

    bc.onmessage = handleMessage;

    return () => {
      bc.close();
    };
  }, [user, tabId, triggerSessionDialog]);

  if (!token) {
    return <Navigate to="/" replace />;
  }

  // No local dialogs here! Just the content.
  return <Outlet />;
};

export default PrivateRouter;














import React from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Button,
} from "@mui/material";

const SessionDialog = ({ open, reason, onConfirm }) => {
  let title = "Session Expired";
  let message = "Your session has ended. Please log in again.";

  // Covers both Backend 401s and Frontend BroadcastChannel detections
  if (reason === "CONCURRENT_LOGIN") {
    title = "Security Alert";
    message = "You have been logged out because this account signed in on another device or tab.";
  }

  return (
    <Dialog 
        open={open} 
        disableEscapeKeyDown 
        // Prevent closing by clicking outside
        onClose={() => {}}
    >
      <DialogTitle color="error">{title}</DialogTitle>
      <DialogContent>
        <DialogContentText>{message}</DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button onClick={onConfirm} variant="contained" color="primary">
          Return to Login
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default SessionDialog;













import React from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Button,
} from "@mui/material";

const SessionDialog = ({ open, reason, onConfirm }) => {
  let title = "Session Expired";
  let message = "Your session has ended. Please log in again.";

  // Covers both Backend 401s and Frontend BroadcastChannel detections
  if (reason === "CONCURRENT_LOGIN") {
    title = "Security Alert";
    message = "You have been logged out because this account signed in on another device or tab.";
  }

  return (
    <Dialog 
        open={open} 
        disableEscapeKeyDown 
        // Prevent closing by clicking outside
        onClose={() => {}}
    >
      <DialogTitle color="error">{title}</DialogTitle>
      <DialogContent>
        <DialogContentText>{message}</DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button onClick={onConfirm} variant="contained" color="primary">
          Return to Login
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default SessionDialog;













import React, { useMemo, Suspense } from "react";
import { createBrowserRouter, RouterProvider } from "react-router-dom";
import { useSelector } from "react-redux";
import PrivateRouter from "./PrivateRouter";

// Page Components
import Login from "../features/auth/pages/Login";
import Home from "../pages/Home";
import NotFound from "../pages/NotFound";
import ServerError from "../pages/ServerError";
import CommonLayout from "../layout/CommonLayout";
import FullscreenLayout from "../layout/FullscreenLayout";
import SubmenuSelectionPage from "../pages/SubmenuSelectionPage";

import { generateRouteObjects } from "./RouteGenerator";

const PageLoader = () => (
    <div style={{ display: 'flex', height: '100vh', justifyContent: 'center', alignItems: 'center' }}>
        Loading...
    </div>
);

const DynamicLayout = () => {
  const isComponentFullscreen = useSelector((state) => state.ui.isComponentFullscreen);
  return !isComponentFullscreen ? <CommonLayout /> : <FullscreenLayout />;
};

const AppRouter = () => {
  const menus = useSelector((state) => state.menus.menus);

  const router = useMemo(() => {
    const dynamicRoutes = generateRouteObjects(menus || []);

    const routeConfig = [
      {
        path: "/",
        element: <Login />,
        errorElement: <ServerError />,
      },
      {
        path: "/server-error",
        element: <ServerError />,
      },
      // Protected Routes
      {
        element: <PrivateRouter />,
        children: [
          {
            element: <DynamicLayout />,
            children: [
              { path: "/home", element: <Home /> },
              {
                path: "/choose-option/:mainMenuTitle",
                element: <SubmenuSelectionPage />,
              },
              ...dynamicRoutes,
            ],
          },
        ].filter(Boolean),
      },
      {
        path: "*",
        element: <NotFound />,
      },
    ];

    return createBrowserRouter(routeConfig);
  }, [menus]);

  return (
    <Suspense fallback={<PageLoader />}>
      <RouterProvider router={router} />
    </Suspense>
  );
};

export default AppRouter;


