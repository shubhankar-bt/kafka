    /**
     * LOGOUT ENDPOINT (ROBUST & VERIFIED)
     * Handles:
     * 1. Valid Tokens -> Standard Logout
     * 2. Expired Tokens -> Manually extracts claims -> Cleans up Redis if JTI matches
     * 3. Concurrent Logins -> Blacklists current token, but PRESERVES the active session in Redis
     * 4. Missing/Malformed Tokens -> Clears cookies and returns success (Idempotent)
     */
    @PostMapping(value = "/logout", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<LoginResponseDTO>> logout(JwtAuthenticationToken jwtAuth, ServerHttpRequest request, ServerHttpResponse response) {
        
        // 1. Always clear the Refresh Token Cookie (Idempotent)
        response.addCookie(createEmptyCookie());

        // 2. Resolve Token Strategy
        String tokenString = null;
        
        // Strategy A: Spring Security Context (Valid Tokens)
        if (jwtAuth != null && jwtAuth.getToken() != null) {
            tokenString = jwtAuth.getToken().getTokenValue();
        } 
        // Strategy B: Manual Header Extraction (Expired Tokens)
        else {
            String header = request.getHeaders().getFirst("Authorization");
            if (header != null && header.startsWith("Bearer ")) {
                tokenString = header.substring(7);
            }
        }

        // 3. Fast Exit: If no token found anywhere, just return success so frontend can clear state
        if (tokenString == null || tokenString.isBlank()) {
            log.warn("Logout called without token. Cleaning up cookies only.");
            return Mono.just(ResponseEntity.ok(
                LoginResponseDTO.builder().userId("anonymous").error("Logged out (No Token)").build()
            ));
        }

        final String finalToken = tokenString;

        // 4. Processing Chain
        return Mono.fromCallable(() -> {
            try {
                // Try standard parsing
                return extractClaims(finalToken);
            } catch (ExpiredJwtException e) {
                // CRITICAL FIX: If token is expired, we STILL want the claims to perform cleanup
                log.info("Logout: Token is expired. Using claims from exception for cleanup.");
                return e.getClaims();
            }
        })
        .subscribeOn(Schedulers.boundedElastic())
        .flatMap(claims -> {
            String userId = claims.getSubject();
            String incomingJti = claims.getId();

            if (userId == null || incomingJti == null) {
                return Mono.just(ResponseEntity.ok(
                    LoginResponseDTO.builder().error("Invalid Token Claims").build()
                ));
            }

            log.info("Logout Processing for User: {} | JTI: {}", userId, incomingJti);

            // 5. Blacklist the Token (Always blacklist the incoming token)
            return validator.blacklistToken(incomingJti)
                    .then(redisTemplate.opsForValue().get(USER_PREFIX + userId))
                    .flatMap(activeJti -> {
                        // 6. Conditional Redis Cleanup
                        if (activeJti != null && activeJti.equals(incomingJti)) {
                            // SCENARIO: Normal Logout. The session in Redis belongs to THIS token.
                            // Action: Delete it.
                            log.info("Session MATCH. Deleting active session for user: {}", userId);
                            return validator.clearUserSession(userId)
                                    .then(Mono.just(ResponseEntity.ok(
                                        LoginResponseDTO.builder().userId(userId).error("Logged out successfully").build()
                                    )));
                        } else {
                            // SCENARIO: Concurrent Login.
                            // The session in Redis belongs to a NEWER token (on another device/tab).
                            // Action: Do NOT delete it. Just let the blacklist happen.
                            log.warn("Session MISMATCH or ALREADY GONE. Active JTI: {}. Incoming JTI: {}. Preserving Redis Session.", activeJti, incomingJti);
                            return Mono.just(ResponseEntity.ok(
                                LoginResponseDTO.builder().userId(userId).error("Logged out (Concurrent Session Preserved)").build()
                            ));
                        }
                    })
                    // If key is missing in Redis (Already timed out), return success
                    .switchIfEmpty(Mono.just(ResponseEntity.ok(
                        LoginResponseDTO.builder().userId(userId).error("Logged out (Session already expired)").build()
                    )));
        })
        .onErrorResume(e -> {
            // Safety Net: If anything explodes (Redis down, etc), allow frontend to logout
            log.error("Logout Unexpected Error", e);
            return Mono.just(ResponseEntity.ok(
                LoginResponseDTO.builder().error("Logged out (System Error handled)").build()
            ));
        });
    }





























import React, {
  createContext,
  useEffect,
  useRef,
  useCallback,
  useState,
} from "react";
import { useDispatch, useSelector } from "react-redux";
import axios from "axios";
import { throttle } from "lodash";
import SessionDialog from "../components/SessionDialog";
import SessionWarningDialog from "../components/SessionWarningDialog";
import { logout as reduxLogout } from "../store/slices/authSlice";
import { resolveConfig } from "../config/EnvironmentConfig";

export const AuthContext = createContext();

const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 min
const WARNING_SECONDS = 30;

export const AuthProvider = ({ children }) => {
  const dispatch = useDispatch();
  const token = useSelector((state) => state.auth.token);
  const user = useSelector((state) => state.auth.user);

  const [warningOpen, setWarningOpen] = useState(false);
  const [secondsLeft, setSecondsLeft] = useState(WARNING_SECONDS);
  const [sessionDialogOpen, setSessionDialogOpen] = useState(false);
  const [sessionReason, setSessionReason] = useState("");

  const inactivityTimerRef = useRef(null);
  const warningTimerRef = useRef(null);
  const countdownRef = useRef(null);

  const clearAllTimers = useCallback(() => {
    if (inactivityTimerRef.current) clearTimeout(inactivityTimerRef.current);
    if (warningTimerRef.current) clearTimeout(warningTimerRef.current);
    if (countdownRef.current) clearInterval(countdownRef.current);
  }, []);

  /**
   * PERFORM LOGOUT (Destructive)
   * This handles the API call and Redux cleanup.
   */
  const performLogout = useCallback(async () => {
    console.log("Initiating Logout Sequence...");
    clearAllTimers();
    setWarningOpen(false);
    setSessionDialogOpen(false);

    try {
      if (token) {
        // We await the response so the Network tab captures it
        const response = await axios.post(
          `${resolveConfig("/LS") ?? ""}/auth/logout`,
          {},
          {
            headers: { Authorization: `Bearer ${token}` },
            withCredentials: true,
          }
        );
        console.log("Logout API Response:", response.data);
      }
    } catch (err) {
      console.warn("Logout API failed or Network Error:", err);
    } finally {
      console.log("Clearing Client State and Redirecting...");
      dispatch(reduxLogout());
      
      // Optional: Small delay to allow logs/network to flush before unload
      setTimeout(() => {
          window.location.replace("/");
      }, 100);
    }
  }, [token, dispatch, clearAllTimers]);

  /**
   * SHOW DIALOG (Safe)
   * This is triggered by Concurrent Login / Timeout.
   * It does NOT clear the token, so the background stays visible.
   */
  const showSessionDialog = useCallback((reason = "SESSION_EXPIRED") => {
      // Prevent double-opening
      setSessionDialogOpen(prev => {
          if(prev) return true;
          clearAllTimers();
          setWarningOpen(false);
          setSessionReason(reason);
          return true;
      });
  }, [clearAllTimers]);

  // --- Inactivity Logic ---
  const startInactivity = useCallback(() => {
    clearAllTimers();
    if (!user) return;

    warningTimerRef.current = setTimeout(() => {
      setWarningOpen(true);
      setSecondsLeft(WARNING_SECONDS);

      let counter = WARNING_SECONDS;
      countdownRef.current = setInterval(() => {
        counter -= 1;
        setSecondsLeft(counter);
        if (counter <= 0) clearInterval(countdownRef.current);
      }, 1000);
    }, INACTIVITY_TIMEOUT - WARNING_SECONDS * 1000);

    inactivityTimerRef.current = setTimeout(() => {
      showSessionDialog("SESSION_EXPIRED");
    }, INACTIVITY_TIMEOUT);
  }, [user, clearAllTimers, showSessionDialog]);

  const onActivity = useCallback(
    throttle(() => {
      if (!user || sessionDialogOpen) return;
      if (warningOpen) setWarningOpen(false);
      startInactivity();
    }, 2000),
    [user, startInactivity, sessionDialogOpen, warningOpen]
  );

  useEffect(() => {
    if (!user) {
      clearAllTimers();
      setWarningOpen(false);
      return;
    }
    startInactivity();
    const events = ["mousemove", "keydown", "click", "scroll", "touchstart"];
    events.forEach((e) => window.addEventListener(e, onActivity));
    return () => {
      events.forEach((e) => window.removeEventListener(e, onActivity));
      onActivity.cancel();
      clearAllTimers();
    };
  }, [user, onActivity, startInactivity, clearAllTimers]);

  return (
    <AuthContext.Provider
      value={{
        logout: performLogout,
        triggerSessionDialog: showSessionDialog,
      }}
    >
      {children}

      <SessionWarningDialog
        open={warningOpen}
        secondsLeft={secondsLeft}
        onContinue={() => {
            setWarningOpen(false);
            startInactivity();
        }}
      />

      <SessionDialog
        open={sessionDialogOpen}
        reason={sessionReason}
        onConfirm={performLogout} 
      />
    </AuthContext.Provider>
  );
};


