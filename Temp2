package com.tcs.userservice.repository;

import com.tcs.userservice.model.Permissions;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Set;

@Repository
public interface PermissionsRepository extends JpaRepository<Permissions, Integer> {

    // Existing method
    @Query(value = "select REQUEST_TYPE from PERMISSIONS where MENU_ID in :ids", nativeQuery = true)
    List<String> findMappedRequestTypeByMenuId(@Param("ids") Set<Integer> ids);

    // --- NEW OPTIMIZED METHOD ---
    // Efficiently fetches all permissions EXCEPT the specific title passed
    // Uses Lowercase for case-insensitive safety
    @Query("SELECT p FROM Permissions p WHERE LOWER(p.menuTitle) <> LOWER(:title)")
    List<Permissions> findAllExceptTitle(@Param("title") String title);
}
















package com.tcs.userservice.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.userservice.ResponseVO;
import com.tcs.userservice.dto.*;
import com.tcs.userservice.model.*;
import com.tcs.userservice.repository.*;
import com.tcs.userservice.utility.ClobUtil;
import com.tcs.userservice.utility.Constant;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class RoleRequestServiceImpl implements RoleRequestService {

    private static final String EVENT_SOURCE = "USER_SERVICE";
    private static final String REQUEST_TYPE_KEY = "ROLE_MANAGEMENT";
    
    // --- CONFIGURATION CONSTANTS ---
    // Defined here for easy maintenance. 
    // If these change in the future, you only edit these lines.
    private static final String HIDDEN_ROLE_NAME = "F1/Bog";
    private static final String RESTRICTED_PERMISSION_TITLE = "Role Management";

    private final RoleRequestRepository roleRequestRepository;
    private final RoleRepository roleRepository;
    private final ObjectMapper objectMapper;
    private final RoleService roleService;
    private final PermissionsRepository permissionsRepository;
    private final RolePermissionsRepository rolePermissionsRepository;
    private final CacheManager cacheManager;
    private final PermissionConfigService permissionConfigService;
    private final NotificationWriterService notificationWriterService;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<RoleRequest>> createNewRoleRequest(RoleRequestCreateDto dto, String userId) {
        
        RoleRequest roleRequest = new RoleRequest();
        roleRequest.setRequestType(dto.getRequestType());
        roleRequest.setTargetRoleId(dto.getTargetRoleId());
        roleRequest.setRequestorUserId(userId);
        roleRequest.setRequestStatus(Constant.PENDING);
        roleRequest.setRequestDate(new Timestamp(System.currentTimeMillis()));
        
        String finalJsonPayload;
        Map<String, Object> payloadMap;
        try {
            if (dto.getRequestPayload() instanceof String) {
                finalJsonPayload = (String) dto.getRequestPayload();
                payloadMap = objectMapper.readValue(finalJsonPayload, Map.class);
            } else {
                payloadMap = (Map<String, Object>) dto.getRequestPayload();
                finalJsonPayload = objectMapper.writeValueAsString(payloadMap);
            }
            roleRequest.setRequestPayload(finalJsonPayload);
        } catch (Exception e) {
            throw new IllegalArgumentException("Invalid JSON payload structure", e);
        }

        boolean isCreate = Constant.CREATE.equalsIgnoreCase(dto.getRequestType());
        String roleName = (String) payloadMap.get("roleName");

        validateRequest(isCreate, dto.getTargetRoleId(), roleName);

        if (isCreate) {
            roleRequest.setTargetRoleId(roleRequestRepository.getNewRoleIdOnCreation());
        }

        RoleRequest saved = roleRequestRepository.save(roleRequest);

        String notifMsg = String.format("New Role Request (ID: %s) for Role %s (%s) is pending approval.",
                saved.getRequestId(), saved.getTargetRoleId(), saved.getRequestType());
        
        createNotification(null, notifMsg, String.valueOf(saved.getRequestId()));

        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ResponseVO.<RoleRequest>builder()
                        .statusCode(HttpStatus.CREATED)
                        .message("Request Created")
                        .result(saved)
                        .build());
    }

    private void validateRequest(boolean isCreate, int roleId, String roleName) {
        if (isCreate) {
             Role existingRole = roleRepository.findRoleByRoleId(roleId);
             if(existingRole != null) throw new IllegalArgumentException("Role ID already exists");
             
             if(roleName != null && roleRequestRepository.countPendingRoleRequestsByRoleName(roleName.toLowerCase()) > 0) {
                 throw new IllegalArgumentException("Creation request for this Role Name already pending");
             }
        } else {
            if(roleRequestRepository.countPendingRoleRequests(roleId) > 0) {
                throw new IllegalArgumentException("Pending request already exists for this Role ID");
            }
        }
    }

    @Override
    @Transactional(readOnly = true)
    public ResponseEntity<ResponseVO<Map<String, Object>>> getPendingRoleRequests(String userId) {
        List<UserRequestProjection> rawList = roleRequestRepository.findPendingRoleRequests(userId);
        return processProjectionList(rawList, "pendingRequests");
    }

    @Override
    @Transactional(readOnly = true)
    public ResponseEntity<ResponseVO<Map<String, Object>>> getMyRoleRequests(String userId) {
        List<UserRequestProjection> rawList = roleRequestRepository.findMyPendingRoleRequests(userId);
        return processProjectionList(rawList, "myRequests");
    }

    private ResponseEntity<ResponseVO<Map<String, Object>>> processProjectionList(List<UserRequestProjection> rawList, String keyName) {
        List<Map<String, Object>> processedList = rawList.stream().map(req -> {
            Map<String, Object> map = new HashMap<>();
            map.put("requestId", req.getRequestId());
            map.put("requestType", req.getRequestType());
            map.put("requestorUserId", req.getRequestorUserId());
            map.put("targetRoleId", req.getTargetRoleId());
            map.put("requestStatus", req.getRequestStatus());
            map.put("requestDate", req.getRequestDate());
            map.put("requestPayload", ClobUtil.clobToString(req.getRequestPayload()));
            map.put("reasonForRejection", req.getReasonForRejection());
            map.put("executionDetails", ClobUtil.clobToString(req.getExecutionDetails()));
            return map;
        }).collect(Collectors.toList());

        Map<String, Object> result = new HashMap<>();
        result.put(keyName, processedList);
        result.put("count", processedList.size());

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .message("Fetched " + processedList.size() + " requests")
                .result(result)
                .build());
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> acceptOrRejectRoleRequest(Map<String, Object> request, String userId) {
        String actionFlag = (String) request.get("actionFlag");
        int requestId = Integer.parseInt(String.valueOf(request.get("requestId")));
        
        RoleRequest roleRequest = roleRequestRepository.findRoleRequestByRequestId(requestId);
        roleRequest.setApproverUserId(userId);
        roleRequest.setApprovalDate(new Timestamp(System.currentTimeMillis()));

        Map<String, Object> result = new HashMap<>();
        boolean isApproved = Constant.ACCEPT.equalsIgnoreCase(actionFlag);
        
        performUpdateOperation(result, actionFlag, roleRequest);
        
        String status = isApproved ? "ACCEPTED" : "REJECTED";
        String notifMsg = String.format("Your Role Request (ID: %s) for Role %s has been %s.", 
                roleRequest.getRequestId(), roleRequest.getTargetRoleId(), status);

        if (!isApproved) {
            notifMsg += " Reason: " + roleRequest.getReasonForRejection();
        }

        createNotification(roleRequest.getRequestorUserId(), notifMsg, String.valueOf(roleRequest.getRequestId()));

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .message((String) result.get(Constant.MESSAGE))
                .result(result)
                .build());
    }

    private void performUpdateOperation(Map<String, Object> result, String actionFlag, RoleRequest roleRequest) {
        if (actionFlag.equalsIgnoreCase(Constant.ACCEPT)) {
            try {
                String jsonPayload = ClobUtil.clobToString(roleRequest.getRequestPayload());
                RoleRequestPayload payload = objectMapper.readValue(jsonPayload, RoleRequestPayload.class);
                int roleId = roleRequest.getTargetRoleId();

                Role role = roleRepository.findRoleByRoleId(roleId);
                boolean isCreate = Constant.CREATE.equalsIgnoreCase(roleRequest.getRequestType());

                if (isCreate) role = new Role();
                if (role == null) {
                    result.put(Constant.STATUS, false);
                    result.put(Constant.MESSAGE, "Role not found");
                    return;
                }

                role.setRoleId(roleId);
                role.setRoleName(payload.getRoleName());
                role.setDescription(payload.getDescription());
                role.setStatus(Constant.ACTIVE);
                roleRepository.save(role);

                savePermissions(payload, roleId);
                
                evictPermissionCache(payload.getPermissions());

                roleRequest.setRequestStatus(Constant.ACCEPTED);
                roleRequestRepository.save(roleRequest);

                result.put(Constant.STATUS, true);
                result.put(Constant.MESSAGE, isCreate ? "Role Created" : "Role Updated");

            } catch (Exception e) {
                log.error("Error updating role", e);
                throw new RuntimeException("Update failed", e);
            }
        } else {
            roleRequest.setRequestStatus(Constant.REJECTED);
            roleRequest.setReasonForRejection("Rejected by approver");
            roleRequestRepository.save(roleRequest);
            result.put(Constant.STATUS, true);
            result.put(Constant.MESSAGE, "Request Rejected");
        }
    }
    
    private void evictPermissionCache(List<PermissionList> permissions) {
        if(permissions == null) return;
        try {
            Set<Integer> ids = permissions.stream().map(PermissionList::getId).collect(Collectors.toSet());
            List<String> keys = permissionsRepository.findMappedRequestTypeByMenuId(ids);
            Cache cache = cacheManager.getCache("notification_configs");
            if (cache != null && keys != null) {
                keys.forEach(cache::evict);
            }
        } catch (Exception e) {
            log.warn("Cache eviction failed", e);
        }
    }

    private void savePermissions(RoleRequestPayload payload, int roleId) {
        List<PermissionList> newPerms = payload.getPermissions();
        if (newPerms == null) return;

        List<RolePermissions> current = rolePermissionsRepository.findByIdRoleId(roleId);
        rolePermissionsRepository.deleteAll(current);
        rolePermissionsRepository.flush();

        List<RolePermissions> toSave = newPerms.stream().map(p -> {
            RolePermissions rp = new RolePermissions();
            rp.setId(new RolePermissionId(roleId, p.getId()));
            rp.setPermissionOrder(p.getOrder());
            return rp;
        }).collect(Collectors.toList());

        rolePermissionsRepository.saveAll(toSave);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> cancelRoleRequest(Map<String, Object> request, String userId) {
        int requestId = Integer.parseInt(String.valueOf(request.get("requestId")));
        RoleRequest roleRequest = roleRequestRepository.getRoleRequestByRequestId(requestId);

        if(!roleRequest.getRequestorUserId().equals(userId)) {
             return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }
        
        roleRequest.setRequestStatus(Constant.CANCEL);
        roleRequestRepository.save(roleRequest);
        
        createNotification(roleRequest.getRequestorUserId(), 
                "Role Request (ID: " + requestId + ") has been cancelled.", 
                String.valueOf(requestId));

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .message("Cancelled")
                .result(Map.of("status", true))
                .build());
    }

    private void createNotification(String targetUser, String msg, String refId) {
        try {
            NotificationConfigDto config = permissionConfigService.getConfig(REQUEST_TYPE_KEY);
            String targetRoles = (targetUser == null) ? config.getTargetRoles() : null;
            
            notificationWriterService.createNotification(targetUser, targetRoles, msg, 
                                                         config.getTargetUrl(), 
                                                         refId, EVENT_SOURCE);
        } catch (Exception e) {
             throw new RuntimeException("Notification failed", e);
        }
    }
    
    @Override
	public ResponseEntity<ResponseVO<Map<String, Object>>> getAllRoles(Map<String, Object> request) {
        boolean includePermissions = Boolean.parseBoolean(String.valueOf(request.get("permissions")));
        List<RoleDto> roles = roleService.getAllRolesWithPermissions(includePermissions);
        
        // --- JAVA FILTERING (Best Practice for this specific case) ---
        // Reason: 'getAllRolesWithPermissions' performs complex Join logic.
        // Duplicating that logic in SQL just to filter one row is risky.
        // Since roles are < 100, Java filtering is safe and performant here.
        if(roles != null) {
            roles = roles.stream()
                .filter(r -> r.getRoleName() != null && !r.getRoleName().equalsIgnoreCase(HIDDEN_ROLE_NAME))
                .collect(Collectors.toList());
        }

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .result(Map.of("roles", roles))
                .build());
    }

    @Override
    public ResponseEntity<ResponseVO<List<PermissionDto>>> getAllPermissions() {
        
        // --- DB FILTERING (Best Practice) ---
        // Reason: Permissions can be large (100s or 1000s). 
        // We use the Repository to fetch ONLY what we need.
        List<Permissions> permissions = permissionsRepository.findAllExceptTitle(RESTRICTED_PERMISSION_TITLE);
        
        List<PermissionDto> dtos = permissions.stream()
                .map(p -> PermissionDto.builder()
                    .id(p.getMenuId())
                    .title(p.getMenuTitle())
                    .icon(p.getMenuIcon())
                    .menuSubmenu(p.getMenuSubmenu())
                    .description(p.getMenuDescription())
                    .build())
                .collect(Collectors.toList());
        
        return ResponseEntity.ok(ResponseVO.<List<PermissionDto>>builder()
                .statusCode(HttpStatus.OK)
                .result(dtos)
                .build());
    }

    @Override
    public ResponseEntity<?> savePermissionOrder(PermissionOrderDto payload) {
        // Implementation as per previous code
        return null; 
    }
}



