package com.fincore.gateway.Controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.gateway.JwtUtil.HmacJwtUtil;
import com.fincore.gateway.Service.LoginService;
import com.fincore.gateway.Service.TokenSessionValidator;
import com.fincore.gateway.dto.*;
import com.fincore.gateway.model.UserRoles;
import com.fincore.gateway.utility.Constants;
import com.fincore.gateway.utility.LoginUtility;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.ReactiveStringRedisTemplate;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.util.Base64;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {

    private static final String USER_PREFIX = "USR:";

    private final TokenSessionValidator validator;
    private final ReactiveStringRedisTemplate redisTemplate;
    private final LoginService loginService;
    private final ObjectMapper mapper;

    @Value("${security.jwt.hmac-base64-secret:}")
    private String hmacSecret;

    @Value("${security.jwt.ttl-seconds:900}")
    private long ttlSeconds;

    /**
     * REACTIVE LOGIN ENDPOINT
     * Wraps blocking DB calls in boundedElastic scheduler and chains Redis calls.
     */
    @PostMapping(value = "/login", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<LoginResponseDTO> login(ServerHttpRequest request, @RequestBody @Valid UserDto payload) {
        
        final String clientIp = LoginUtility.getClientIp(request);

        // 1. Wrap Blocking DB Call (verifyUserCredentials) in Elastic Scheduler
        return Mono.fromCallable(() -> loginService.verifyUserCredentials(payload, clientIp))
                .subscribeOn(Schedulers.boundedElastic()) 
                .flatMap(user -> {
                    // 2. Process Logic
                    if (!user.isValidCredentials()) {
                        return Mono.just(LoginResponseDTO.builder()
                                .userId(user.getUserId())
                                .validCredentials(false)
                                .userStatus(user.getUserStatus())
                                .passwordLoginStatus(user.getPasswordLoginStatus())
                                .error(user.getMessage() != null ? user.getMessage() : "Invalid credentials")
                                .build());
                    }

                    if (hmacSecret == null || hmacSecret.isBlank()) {
                        return Mono.just(LoginResponseDTO.builder().error("Missing HMAC secret").build());
                    }

                    // 3. Generate Token (CPU bound, fast enough to run on current thread)
                    @SuppressWarnings("unchecked")
                    Map<String, Object> claims = mapper.convertValue(user.getUser(), Map.class);
                    String token = HmacJwtUtil.generate(hmacSecret, user.getUserId(), ttlSeconds, claims);

                    // Extract JTI
                    var parser = io.jsonwebtoken.Jwts.parser()
                            .verifyWith(io.jsonwebtoken.security.Keys.hmacShaKeyFor(Base64.getDecoder().decode(hmacSecret)))
                            .build();
                    String jti = parser.parseSignedClaims(token).getPayload().getId();

                    // 4. Chain Reactive Redis Call (Non-Blocking)
                    return validator.registerUserSession(user.getUserId(), jti)
                            .then(Mono.defer(() -> {
                                // 5. Fetch Menu Data (Blocking DB call) -> Wrap in Elastic
                                return Mono.fromCallable(() -> loginService.fetchRoleWiseData(user.getUserId()))
                                        .subscribeOn(Schedulers.boundedElastic());
                            }))
                            .map(roleData -> {
                                // 6. Build Final Response
                                return LoginResponseDTO.builder()
                                        .userId(user.getUserId())
                                        .validCredentials(true)
                                        .userStatus(user.getUserStatus())
                                        .passwordLoginStatus(user.getPasswordLoginStatus())
                                        .accessToken(token)
                                        .tokenType("Bearer")
                                        .expiresIn(ttlSeconds)
                                        .sub(user.getUserId())
                                        .jti(jti)
                                        .roleData(roleData)
                                        .build();
                            });
                })
                .doOnError(e -> log.error("Login Error: ", e));
    }

    /**
     * REACTIVE REFRESH TOKEN ENDPOINT
     */
    @PostMapping(value = "/refresh-token", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<LoginResponseDTO> refreshToken(@RequestBody Map<String, String> body) {
        String refreshToken = body.get("refreshToken");

        if (refreshToken == null || refreshToken.isBlank()) {
            return Mono.just(LoginResponseDTO.builder().error("Missing refresh token").build());
        }

        return Mono.fromCallable(() -> {
            // 1. Parse Token (CPU Bound)
            var parser = io.jsonwebtoken.Jwts.parser()
                    .verifyWith(io.jsonwebtoken.security.Keys.hmacShaKeyFor(Base64.getDecoder().decode(hmacSecret)))
                    .build();
            return parser.parseSignedClaims(refreshToken).getPayload();
        })
        .subscribeOn(Schedulers.boundedElastic())
        .flatMap(claims -> {
            String userId = claims.getSubject();
            String userKey = USER_PREFIX + userId;

            // 2. Check Redis (Reactive)
            return redisTemplate.opsForValue().get(userKey)
                    .flatMap(currentJti -> {
                        // 3. Wrap Blocking DB Call (getUserRole)
                        return Mono.fromCallable(() -> loginService.getUserRole(userId))
                                .subscribeOn(Schedulers.boundedElastic())
                                .flatMap(userRole -> {
                                    // 4. Generate New Token
                                    Map<String, Object> newClaims = Map.of(
                                            "role", userRole != null ? userRole.getRole() : 0,
                                            "userId", userId
                                    );
                                    
                                    String newAccessToken = HmacJwtUtil.generate(hmacSecret, userId, ttlSeconds, newClaims);
                                    
                                    // Extract New JTI
                                    var parser = io.jsonwebtoken.Jwts.parser()
                                            .verifyWith(io.jsonwebtoken.security.Keys.hmacShaKeyFor(Base64.getDecoder().decode(hmacSecret)))
                                            .build();
                                    String newJti = parser.parseSignedClaims(newAccessToken).getPayload().getId();

                                    // 5. Update Redis
                                    return validator.registerUserSession(userId, newJti)
                                            .thenReturn(LoginResponseDTO.builder()
                                                    .accessToken(newAccessToken)
                                                    .refreshToken(refreshToken)
                                                    .userId(userId)
                                                    .jti(newJti)
                                                    .expiresIn(ttlSeconds)
                                                    .validCredentials(true)
                                                    .build());
                                });
                    })
                    .switchIfEmpty(Mono.just(LoginResponseDTO.builder().error("Session expired. Please login again.").build()));
        })
        .onErrorResume(e -> {
            log.error("Refresh Token Failed", e);
            return Mono.just(LoginResponseDTO.builder().error("Invalid refresh token").build());
        });
    }

    /**
     * REACTIVE LOGOUT
     */
    @PostMapping(value = "/logout", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<LoginResponseDTO> logout(JwtAuthenticationToken jwtAuth) {
        if (jwtAuth == null) {
            return Mono.just(LoginResponseDTO.builder().error("No token").build());
        }
        String username = jwtAuth.getToken().getSubject();
        String jti = jwtAuth.getToken().getId();

        return validator.blacklistToken(jti)
                .then(validator.clearUserSession(username))
                .thenReturn(LoginResponseDTO.builder()
                        .userId(username)
                        .error("Logged out")
                        .build());
    }

    /**
     * REACTIVE CHECK USER
     */
    @PostMapping(value = "/check-user", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<VerifyUserDTO> checkUser(@RequestBody Map<String, String> body) {
        String userId = body.get("userId");
        // Wrap blocking DB call
        return Mono.fromCallable(() -> loginService.checkUser(userId))
                .subscribeOn(Schedulers.boundedElastic());
    }

    /**
     * REACTIVE UPDATE PASSWORD
     */
    @PostMapping(value = "/update-password", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<UpdatePasswordDTO> updatePassword(@RequestBody @Valid UpdatePasswordDTO userCredentials) {
        // Wrap blocking DB call
        return Mono.fromCallable(() -> loginService.updatePassword(userCredentials))
                .subscribeOn(Schedulers.boundedElastic());
    }
}


