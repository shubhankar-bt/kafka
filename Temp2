import { useEffect, useRef, useState, useCallback, useMemo, useContext } from "react";
import axios from "axios";
import { useLocation, useNavigate } from "react-router-dom";
import useCustomSnackbar from "../utils/useCustomSnackbar";
import { useSelector } from "react-redux";
import { resolveConfig } from "../config/EnvironmentConfig";
import { convertToKebabCase } from "../utils/CommonUtilities";
import { AuthContext } from "../context/AuthContext";

const useApi = () => {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  const navigate = useNavigate();
  const location = useLocation();
  const snackbar = useCustomSnackbar();

  // Access AuthContext for global session management
  const { logout, triggerSessionDialog } = useContext(AuthContext);

  // Redux selectors for token (initial state) and menus
  const token = useSelector((state) => state.auth.token);
  const menus = useSelector((s) => s.menus.menus);
  const selectedMenuItem = useSelector((s) => s.menus.selectedMenuItem);

  // Refs for tracking active requests and refresh state
  const activeRequestsRef = useRef(new Set());
  const isRefreshingRef = useRef(false);
  const refreshQueueRef = useRef([]);

  /** -------------------- Cancel Requests on Unmount -------------------- */
  const cancelAllRequests = useCallback(() => {
    activeRequestsRef.current.forEach((controller) => {
      if (!controller.signal.aborted) controller.abort();
    });
    activeRequestsRef.current.clear();
    setLoading(false);
  }, []);

  useEffect(() => {
    return () => cancelAllRequests();
  }, [cancelAllRequests]);

  /** -------------------- Refresh Token Logic -------------------- */
  const refreshToken = async () => {
    // Queue concurrent refresh requests
    if (isRefreshingRef.current) {
      return new Promise((resolve, reject) => {
        refreshQueueRef.current.push({ resolve, reject });
      });
    }

    isRefreshingRef.current = true;

    try {
      const storedRefreshToken = localStorage.getItem("refreshToken");

      if (!storedRefreshToken) {
        throw new Error("No refresh token available");
      }

      // Call Backend Refresh Endpoint
      const res = await axios.post(
        `${resolveConfig("/LS") ?? ""}/auth/refresh-token`,
        { refreshToken: storedRefreshToken },
        {
          headers: { "Content-Type": "application/json" },
          withCredentials: true,
        }
      );

      const newAccessToken = res.data?.accessToken;
      const newRefreshToken = res.data?.refreshToken; // If backend rotates refresh tokens

      if (!newAccessToken) {
        throw new Error("No access token received");
      }

      // Update Local Storage
      localStorage.setItem("accessToken", newAccessToken);
      if (newRefreshToken) {
        localStorage.setItem("refreshToken", newRefreshToken);
      }

      // Resolve all queued promises with the new token
      refreshQueueRef.current.forEach((p) => p.resolve(newAccessToken));
      refreshQueueRef.current = [];

      return newAccessToken;
    } catch (err) {
      // Reject all queued promises
      refreshQueueRef.current.forEach((p) => p.reject(err));
      refreshQueueRef.current = [];
      throw err;
    } finally {
      isRefreshingRef.current = false;
    }
  };

  /** -------------------- Menu Resolver -------------------- */
  const findMenuItem = useCallback((items, route) => {
    if (!items?.length) return null;

    for (const item of items) {
      if (item.route === route) return item;

      if (item.children?.length) {
        if (route.includes("/choose-option/")) {
          const param = route.split("/choose-option/")[1];
          if (param === convertToKebabCase(item.title)) return item;
        }

        const found = findMenuItem(item.children, route);
        if (found) return found;
      }
    }
    return null;
  }, []);

  const currentMenuFromRoute = useMemo(() => {
    return findMenuItem(menus, location.pathname);
  }, [menus, location.pathname, findMenuItem]);

  const xRequestType = useMemo(
    () =>
      currentMenuFromRoute?.requestType ||
      selectedMenuItem?.requestType ||
      "*",
    [currentMenuFromRoute, selectedMenuItem]
  );

  /** -------------------- Main API Caller -------------------- */
  const callApi = useCallback(
    async (
      url,
      payload = null,
      method = "GET",
      responseType = "json",
      contentType = "application/json",
      extraConfig = {},
      returnDataOnly = true
    ) => {
      // URL Resolution Logic
      const parts = url.split("/");
      const service = parts[1];
      parts[1] = resolveConfig(`/${service}`);
      const Final_Url = parts.slice(1).join("/");

      const controller = new AbortController();
      activeRequestsRef.current.add(controller);

      setLoading(true);
      setError(null);

      // Helper to prioritize the freshest token (e.g. from retry config or storage)
      const getCurrentToken = () => {
        return (
          extraConfig?.headers?.Authorization?.replace("Bearer ", "") ||
          localStorage.getItem("accessToken") ||
          token
        );
      };

      try {
        const config = {
          method,
          url: Final_Url,
          responseType,
          withCredentials: true,
          signal: controller.signal,
          headers: {
            Authorization: `Bearer ${getCurrentToken()}`,
            "Content-Type": contentType,
            "X-Request-Type": xRequestType,
            ...(extraConfig.headers || {}),
          },
          ...extraConfig,
        };

        if (payload) {
          method === "GET"
            ? (config.params = payload)
            : (config.data = payload);
        }

        const response = await axios(config);
        setData(response.data);

        return returnDataOnly ? response.data : response;
      } catch (err) {
        if (axios.isCancel(err)) {
          return; // Request cancelled, do nothing
        }

        const status = err.response?.status;
        const responseData = err.response?.data;
        // Backend can send { error: "CODE" } or { code: "CODE" }
        const errorCode = responseData?.error || responseData?.code;

        // 1. HARD FAIL: Concurrent Login or Session Expired
        if (
          status === 401 &&
          (errorCode === "CONCURRENT_LOGIN" || errorCode === "SESSION_EXPIRED")
        ) {
          triggerSessionDialog(errorCode);
          setLoading(false);
          return; // Stop execution, user must log in again
        }

        // 2. SOFT FAIL: Token Expired (Silent Refresh)
        if (
          status === 401 &&
          errorCode === "TOKEN_EXPIRED" &&
          !extraConfig.__isRetry
        ) {
          try {
            // Attempt Refresh
            const newToken = await refreshToken();

            // Retry Original Request with New Token
            return await callApi(
              url,
              payload,
              method,
              responseType,
              contentType,
              {
                ...extraConfig,
                __isRetry: true, // Mark as retry to prevent loops
                headers: {
                  ...(extraConfig.headers || {}),
                  Authorization: `Bearer ${newToken}`,
                },
              },
              returnDataOnly
            );
          } catch (refreshErr) {
            // Refresh Failed (e.g., refresh token expired) -> Force Logout
            logout();
            setLoading(false);
            return;
          }
        }

        // 3. OTHER ERRORS (Business Logic, 500s, etc.)
        const msg =
          err.response?.data?.message ||
          err.response?.data?.error ||
          err.message ||
          "Something went wrong";

        snackbar(msg, "error");
        setError(err);
        throw err;
      } finally {
        activeRequestsRef.current.delete(controller);
        // Ensure loading is set to false only if we aren't in a retry loop
        // (Though the retry call handles its own loading state)
        setLoading(false);
      }
    },
    [
      token,
      xRequestType,
      navigate,
      snackbar,
      logout,
      triggerSessionDialog,
      // refreshToken - stable function inside component scope or useRef approach
      // findMenuItem - stable via useCallback
    ]
  );

  return { data, error, loading, callApi, cancelAllRequests };
};

export default useApi;















import React from 'react';
import { Dialog, DialogTitle, DialogContent, DialogContentText, DialogActions, Button } from '@mui/material';

const SessionDialog = ({ open, reason, onConfirm }) => {
  let title = "Session Expired";
  let message = "Your session has timed out. Please log in again.";

  if (reason === "CONCURRENT_LOGIN") {
    title = "Security Alert";
    message = "You have been logged out because this account signed in on another device.";
  }

  return (
    <Dialog open={open} disableEscapeKeyDown onClose={(e, r) => { if (r !== 'backdropClick') onConfirm(); }}>
      <DialogTitle color="error">{title}</DialogTitle>
      <DialogContent><DialogContentText>{message}</DialogContentText></DialogContent>
      <DialogActions><Button onClick={onConfirm} variant="contained" color="primary">Return to Login</Button></DialogActions>
    </Dialog>
  );
};

export default SessionDialog;












import React, { createContext, useState, useEffect } from 'react';
import SessionDialog from '../components/SessionDialog';

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [sessionError, setSessionError] = useState('');

  useEffect(() => {
    const savedUser = localStorage.getItem('user');
    if(savedUser) setUser(JSON.parse(savedUser));
  }, []);

  const login = (userData, tokens) => {
    localStorage.setItem('accessToken', tokens.accessToken);
    localStorage.setItem('refreshToken', tokens.refreshToken);
    localStorage.setItem('user', JSON.stringify(userData));
    setUser(userData);
  };

  const logout = () => {
    localStorage.clear();
    setUser(null);
    setDialogOpen(false);
    window.location.href = '/login'; 
  };

  const triggerSessionDialog = (reason) => {
    setSessionError(reason);
    setDialogOpen(true);
  };

  return (
    <AuthContext.Provider value={{ user, login, logout, triggerSessionDialog }}>
      {children}
      <SessionDialog open={dialogOpen} reason={sessionError} onConfirm={logout} />
    </AuthContext.Provider>
  );
};


