-- =========================================================
-- 1. ANNOUNCEMENTS TABLE (For CommonMasterService)
-- =========================================================
CREATE TABLE FINCORE.ANNOUNCEMENTS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    TITLE VARCHAR2(100 CHAR) NOT NULL,
    MESSAGE VARCHAR2(4000 CHAR) NOT NULL,
    SEVERITY VARCHAR2(20 CHAR) DEFAULT 'INFO', -- INFO, WARN, CRITICAL
    TARGET_ROLE VARCHAR2(50 CHAR) DEFAULT 'ALL', -- 'ALL' or '51', '55'
    START_DATE TIMESTAMP DEFAULT SYSTIMESTAMP,
    EXPIRY_DATE TIMESTAMP,
    IS_ACTIVE CHAR(1) DEFAULT 'Y',
    CREATED_BY VARCHAR2(50 CHAR),
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Index for fast lookup on login
CREATE INDEX FINCORE.IDX_ANNC_LOOKUP ON FINCORE.ANNOUNCEMENTS(IS_ACTIVE, EXPIRY_DATE, TARGET_ROLE);

-- Sample Data
INSERT INTO FINCORE.ANNOUNCEMENTS (TITLE, MESSAGE, SEVERITY, TARGET_ROLE, EXPIRY_DATE) 
VALUES ('System Update', 'Scheduled maintenance this Saturday at 10 PM.', 'INFO', 'ALL', SYSTIMESTAMP + 7);

INSERT INTO FINCORE.ANNOUNCEMENTS (TITLE, MESSAGE, SEVERITY, TARGET_ROLE, EXPIRY_DATE) 
VALUES ('Pending Approvals', 'Year-end closing is approaching. Please clear pending CGL requests.', 'WARN', '55', SYSTIMESTAMP + 30);

COMMIT;























// =================================================================
// 1. ENTITY: Announcement.java
// Package: com.tcs.fincore.CommonMasterService.model
// =================================================================
package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.*;
import lombok.Data;
import java.time.LocalDateTime;

@Entity
@Table(name = "ANNOUNCEMENTS")
@Data
public class Announcement {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String title;

    @Lob
    @Column(nullable = false)
    private String message; 

    @Column(length = 20)
    private String severity; // INFO, WARN, CRITICAL

    @Column(name = "TARGET_ROLE", length = 50)
    private String targetRole; // "ALL" or specific Role ID

    private LocalDateTime startDate;
    private LocalDateTime expiryDate;
    
    @Column(name = "IS_ACTIVE", length = 1)
    private String isActive; // 'Y' or 'N'
    
    private String createdBy;
    private LocalDateTime createdAt;
}

// =================================================================
// 2. REPOSITORY: AnnouncementRepository.java
// Package: com.tcs.fincore.CommonMasterService.repository
// =================================================================
package com.tcs.fincore.CommonMasterService.repository;

import com.tcs.fincore.CommonMasterService.model.Announcement;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface AnnouncementRepository extends JpaRepository<Announcement, Long> {

    @Query("SELECT a FROM Announcement a WHERE a.isActive = 'Y' " +
           "AND a.startDate <= CURRENT_TIMESTAMP " +
           "AND (a.expiryDate IS NULL OR a.expiryDate >= CURRENT_TIMESTAMP) " +
           "AND (a.targetRole = 'ALL' OR a.targetRole = :roleId) " +
           "ORDER BY a.createdAt DESC")
    List<Announcement> findActiveAnnouncements(@Param("roleId") String roleId);
}

// =================================================================
// 3. CONTROLLER: DashboardController.java
// Package: com.tcs.fincore.CommonMasterService.controller
// =================================================================
package com.tcs.fincore.CommonMasterService.controller;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.fincore.CommonMasterService.model.Announcement;
import com.tcs.fincore.CommonMasterService.repository.AnnouncementRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/dashboard")
@RequiredArgsConstructor
public class DashboardController {

    private final AnnouncementRepository announcementRepository;
    private final JwtUtil jwtUtil;

    @GetMapping("/announcements")
    public ResponseEntity<?> getAnnouncements(@RequestHeader("Authorization") String token) {
        // Extract Role ID from Token
        // NOTE: Ensure your JwtUtil returns String for Role, otherwise convert int to String
        int roleIdInt = jwtUtil.getUserRoleFromToken(token);
        String roleId = String.valueOf(roleIdInt);
        
        List<Announcement> list = announcementRepository.findActiveAnnouncements(roleId);
        
        return ResponseEntity.ok(Map.of(
            "success", true, 
            "data", list, 
            "timestamp", java.time.LocalDateTime.now()
        ));
    }
}

















// =================================================================
// 1. DTO: DashboardStatsDto.java
// Package: com.tcs.fincore.CommonRequestService.dto
// =================================================================
package com.tcs.fincore.CommonRequestService.dto;

import lombok.Builder;
import lombok.Data;
import java.time.LocalDateTime;
import java.util.Map;

@Data
@Builder
public class DashboardStatsDto {
    private long totalPending;
    private long totalApproved; 
    private long totalRejected; 
    private Map<String, Long> pendingByType; // { "CGL_CODE": 5, "BRANCH": 2 }
}

// =================================================================
// 2. DTO: ActivityLogDto.java
// Package: com.tcs.fincore.CommonRequestService.dto
// =================================================================
package com.tcs.fincore.CommonRequestService.dto;

import lombok.Builder;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@Builder
public class ActivityLogDto {
    private String title;       // e.g. "CGL_CODE Creation"
    private String description; // e.g. "Request for Target ID 1001"
    private String status;      // PENDING, ACCEPTED
    private LocalDateTime timestamp;
    private String type;        // "BUSINESS"
}

// =================================================================
// 3. REPOSITORY UPDATE: CommonRequestRepository.java
// Package: com.tcs.fincore.CommonRequestService.repository
// =================================================================
// Add these methods to your interface

// Count My Requests (For Makers)
@Query("SELECT c.reqStatus, COUNT(c) FROM CommonReq c " +
       "WHERE c.creatorId = :userId GROUP BY c.reqStatus")
List<Object[]> countMyRequestStatus(@Param("userId") String userId);

// Count Pending Queue (For Checkers) - Excluding own requests
@Query("SELECT c.reqType, COUNT(c) FROM CommonReq c " +
       "WHERE c.reqStatus = 'PENDING' AND c.creatorId != :userId " +
       "GROUP BY c.reqType")
List<Object[]> countPendingByType(@Param("userId") String userId);

// Recent Activity Log
@Query("SELECT c FROM CommonReq c WHERE c.creatorId = :userId ORDER BY c.reqDate DESC")
List<CommonReq> findRecentActivity(@Param("userId") String userId, Pageable pageable);


// =================================================================
// 4. CONTROLLER: DashboardController.java
// Package: com.tcs.fincore.CommonRequestService.controller
// =================================================================
package com.tcs.fincore.CommonRequestService.controller;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.fincore.CommonRequestService.dto.ActivityLogDto;
import com.tcs.fincore.CommonRequestService.dto.DashboardStatsDto;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.repository.CommonRequestRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/dashboard")
@RequiredArgsConstructor
public class DashboardController {

    private final CommonRequestRepository requestRepository;
    private final JwtUtil jwtUtil;

    @GetMapping("/stats")
    public ResponseEntity<DashboardStatsDto> getStats(@RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);

        // 1. Maker Stats (My Requests)
        List<Object[]> myStats = requestRepository.countMyRequestStatus(userId);
        long myPending = 0, myApproved = 0, myRejected = 0;
        
        for (Object[] row : myStats) {
            String status = row[0].toString(); 
            long count = (long) row[1];
            if ("PENDING".equals(status) || "P".equals(status)) myPending = count;
            else if ("ACCEPTED".equals(status) || "A".equals(status)) myApproved = count;
            else if ("REJECTED".equals(status) || "R".equals(status)) myRejected = count;
        }

        // 2. Checker Stats (Work Queue)
        List<Object[]> pendingRows = requestRepository.countPendingByType(userId);
        Map<String, Long> pendingMap = new HashMap<>();
        for (Object[] row : pendingRows) {
            pendingMap.put(row[0].toString(), (long) row[1]);
        }

        DashboardStatsDto stats = DashboardStatsDto.builder()
                .totalPending(myPending)
                .totalApproved(myApproved)
                .totalRejected(myRejected)
                .pendingByType(pendingMap)
                .build();

        return ResponseEntity.ok(stats);
    }

    @GetMapping("/recent-activity")
    public ResponseEntity<List<ActivityLogDto>> getRecentActivity(@RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        
        // Fetch Top 5
        List<CommonReq> requests = requestRepository.findRecentActivity(userId, PageRequest.of(0, 5));

        List<ActivityLogDto> dtos = requests.stream().map(req -> ActivityLogDto.builder()
                .title(req.getReqType() + " Request")
                .description(req.getChangeType() + " operation for ID: " + req.getTargetId())
                .status(req.getReqStatus().toString())
                .timestamp(req.getReqDate()) // Ensure getReqDate returns LocalDateTime
                .type("BUSINESS")
                .build()
        ).collect(Collectors.toList());

        return ResponseEntity.ok(dtos);
    }
}


















// =================================================================
// 1. CONTROLLER UPDATE: UserRequestController.java
// Package: com.tcs.userservice.controller
// =================================================================

// Add this endpoint to your existing Controller
@GetMapping("/dashboard/recent-activity")
public ResponseEntity<List<UserLogsDto>> getDashboardActivity(@RequestHeader("Authorization") String token) {
    String userId = jwtUtil.getUserIdFromToken(token);
    
    // NOTE: Ensure your UserLogsRepository handles the String vs Int conversion
    // If your User_Logs table uses Integer for UserID:
    // Integer uid = Integer.parseInt(userId);
    // List<UserLogs> logs = userLogsRepository.findTop5ByUserIdOrderByActionTimeDesc(uid);
    
    // For now, assuming you added the method to the Repository:
    List<UserLogs> logs = userLogsService.getRecentLogs(userId); // You need to implement this in Service
    
    List<UserLogsDto> dtos = logs.stream()
        .map(UserLogsMapper::toDto)
        .collect(Collectors.toList());
        
    return ResponseEntity.ok(dtos);
}

Phase 5: Frontend Strategy (Quick Actions)
You asked for Quick Actions. We do not need backend changes for this.
The Frontend will:
 * Read the roleData.root_menus from the Login Response.
 * Iterate through the menus.
 * Identify "Important" actions.
Frontend Logic (Concept):
// Quick Actions Widget Logic
const quickActions = [];

root_menus.forEach(menu => {
    // If user can CREATE, add a "New [Title]" shortcut
    if (menu.menuAction.includes('create')) {
        quickActions.push({
            label: `New ${menu.title}`,
            icon: 'plus',
            link: menu.route,
            color: 'blue'
        });
    }
    // If user can APPROVE, add a "Pending [Title]" shortcut
    if (menu.menuAction.includes('approve')) {
        quickActions.push({
            label: `Review ${menu.title}`,
            icon: 'check',
            link: menu.route + '/pending', // Assuming frontend route convention
            color: 'green'
        });
    }
});



