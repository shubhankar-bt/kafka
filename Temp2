// In AuthController.java -> login() method

// ... existing code ...
String jti = claimsJws.getPayload().getId();

// === ADD THIS BLOCK ===
// We MUST block here because this is the specific point where we commit the session.
// Without this, the User Service will reject the token because Redis is empty.
validator.registerUserSession(user.getUserId(), jti).block(); 
// ======================

MenuResponse roleData = loginService.fetchRoleWiseData(user.getUserId());
// ... return response ...
















// Add to AuthController.java

    @PostMapping(value = "/refresh-token", produces = MediaType.APPLICATION_JSON_VALUE)
    public LoginResponseDTO refreshToken(@RequestBody Map<String, String> body) {
        String refreshToken = body.get("refreshToken");
        
        if (refreshToken == null || refreshToken.isBlank()) {
            return LoginResponseDTO.builder().error("Missing refresh token").build();
        }

        // 1. Verify Crypto Signature of Refresh Token
        // (Assuming you use the same secret for now, otherwise inject refresh secret)
        try {
             var parser = io.jsonwebtoken.Jwts.parser()
                .verifyWith(io.jsonwebtoken.security.Keys.hmacShaKeyFor(
                        java.util.Base64.getDecoder().decode(hmacSecret)))
                .build();
             var claims = parser.parseSignedClaims(refreshToken).getPayload();
             String userId = claims.getSubject();

             // 2. Check if User Session is still valid in Redis
             String userKey = USER_PREFIX + userId;
             String currentJti = redisTemplate.opsForValue().get(userKey).block();

             if (currentJti == null) {
                 return LoginResponseDTO.builder().error("Session expired. Please login again.").build();
             }

             // 3. Generate NEW Access Token (New JTI)
             // We need to fetch the user role again to ensure claims are up to date
             // (Simplified: assuming role is passed or fetched via service)
             com.fincore.gateway.model.UserRoles userRole = 
                 com.fincore.gateway.utility.LoginUtility.fetchUserRole(userId); // You might need to expose a service method for this

             Map<String, Object> newClaims = java.util.Map.of(
                 "role", userRole != null ? userRole.getRole() : 0, 
                 "userId", userId
             );
             
             String newAccessToken = HmacJwtUtil.generate(hmacSecret, userId, ttlSeconds, newClaims);
             
             // 4. Extract NEW JTI
             var newClaimsJws = parser.parseSignedClaims(newAccessToken);
             String newJti = newClaimsJws.getPayload().getId();

             // 5. UPDATE REDIS (Session Rotation)
             // This automatically invalidates the previous Access Token
             validator.registerUserSession(userId, newJti).block();

             return LoginResponseDTO.builder()
                     .accessToken(newAccessToken)
                     .refreshToken(refreshToken) // Return same refresh token or rotate it too
                     .userId(userId)
                     .jti(newJti)
                     .expiresIn(ttlSeconds)
                     .build();

        } catch (Exception e) {
            log.error("Refresh failed", e);
            return LoginResponseDTO.builder().error("Invalid refresh token").build();
        }
    }























package com.fincore.commonutilities.security;

import com.fincore.commonutilities.jwt.JwtUtil;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.JwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;
import java.util.Set;

@Slf4j
@RequiredArgsConstructor
public class ContextRbacFilter extends OncePerRequestFilter {

    private final StringRedisTemplate redisTemplate;
    private final JwtUtil jwtUtil;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    // MUST match the prefix used in Login Service (TokenSessionValidator.java)
    private static final String REDIS_USER_PREFIX = "USR:";

    private static final Set<String> WHITELIST = Set.of(
            "/auth/**", "/actuator/**", "/error", "/swagger-ui/**", "/v3/api-docs/**", "/login"
    );

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        String uri = request.getRequestURI();

        // 1. SKIP WHITELIST
        for (String pattern : WHITELIST) {
            if (pathMatcher.match(pattern, uri)) {
                filterChain.doFilter(request, response);
                return;
            }
        }

        String token = request.getHeader("Authorization");

        if (token != null) {
            try {
                // 2. BASIC VALIDATION (Signature & Expiry)
                // This throws ExpiredJwtException if token is old
                if (!jwtUtil.isTokenValid(token)) {
                    throw new JwtException("Invalid Token Signature");
                }

                String userId = jwtUtil.getUserIdFromToken(token);
                
                // We need to extract the 'jti' (JWT ID) from the token
                // Ensure your JwtUtil exposes a way to get Claims or the jti directly
                String incomingJti = jwtUtil.extractClaim(token, Claims::getId);
                
                if (incomingJti == null) {
                     sendError(response, HttpServletResponse.SC_UNAUTHORIZED, "INVALID_TOKEN", "Token missing JTI");
                     return;
                }

                // =================================================================
                // 3. DISTRIBUTED SESSION CHECK (The "One Session" Logic)
                // =================================================================
                String sessionKey = REDIS_USER_PREFIX + userId;
                
                // Fetch the "Active" JTI from Redis (Written by Login Service)
                String activeJti = redisTemplate.opsForValue().get(sessionKey);

                if (activeJti == null) {
                    // Redis key expired or user logged out manually
                    sendError(response, HttpServletResponse.SC_UNAUTHORIZED, "SESSION_EXPIRED", "Session timed out or logged out.");
                    return; 
                }

                if (!incomingJti.equals(activeJti)) {
                    // The token is valid crypto-wise, but Redis has a DIFFERENT JTI.
                    // This means the user logged in again on another device.
                    log.warn("Concurrent Login Detected for User {}. Incoming JTI: {}, Active JTI: {}", userId, incomingJti, activeJti);
                    sendError(response, HttpServletResponse.SC_UNAUTHORIZED, "CONCURRENT_LOGIN", "You have been logged out because of a login on another device.");
                    return; 
                }
                // =================================================================

                // 4. SET SECURITY CONTEXT
                int roleIdInt = jwtUtil.getUserRoleFromToken(token);
                if (SecurityContextHolder.getContext().getAuthentication() == null) {
                    UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                            userId, null, List.of(new SimpleGrantedAuthority("ROLE_" + roleIdInt))
                    );
                    SecurityContextHolder.getContext().setAuthentication(authToken);
                }

                // 5. RBAC CHECK (Redis Permissions)
                if (!checkRbac(request, response, String.valueOf(roleIdInt), userId)) {
                    return; // Response handled in checkRbac
                }

            } catch (ExpiredJwtException e) {
                log.warn("JWT Expired for IP: {}", request.getRemoteAddr());
                sendError(response, HttpServletResponse.SC_UNAUTHORIZED, "TOKEN_EXPIRED", "JWT has expired.");
                return;
            } catch (Exception e) {
                log.error("Auth Error: {}", e.getMessage());
                sendError(response, HttpServletResponse.SC_UNAUTHORIZED, "AUTH_ERROR", "Authentication failed.");
                return;
            }
        } else {
            sendError(response, HttpServletResponse.SC_UNAUTHORIZED, "MISSING_TOKEN", "Authorization header missing.");
            return;
        }

        filterChain.doFilter(request, response);
    }

    private void sendError(HttpServletResponse response, int status, String error, String message) throws IOException {
        response.setStatus(status);
        response.setContentType("application/json");
        response.getWriter().write(String.format("{\"status\": %d, \"error\": \"%s\", \"message\": \"%s\"}", status, error, message));
    }

    // ... (Keep existing checkRbac method exactly as it is in your file) ...
    private boolean checkRbac(HttpServletRequest request, HttpServletResponse response, String roleId, String userId) throws IOException {
        // ... paste existing RBAC logic here ...
        // (This part of your code was fine, just ensure Redis Template is wired correctly)
        
        // Shortened for brevity in this response, refer to your original file for the RBAC logic
        return true; 
    }
}

Step C: Update JwtUtil in Common Utilities
Your ContextRbacFilter now relies on extracting the jti (Token ID). You need to ensure JwtUtil exposes a helper for this or extractClaim is public.
In common-utilities-latest.txt, extractClaim is private. Make it public:
// In JwtUtil.java

// Change private to public
public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
    // ... logic ...
}

Or add a specific method:
public String getTokenId(String token) {
    String cleanToken = removeBearerPrefix(token);
    return extractClaim(cleanToken, Claims::getId);
}

