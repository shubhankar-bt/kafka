package com.fincore.helpservice.entity;

import jakarta.persistence.*;
import lombok.Data;
import java.io.Serializable;

// --- 1. User Roles (To get Role ID) ---
@Data
@Entity
@Table(name = "USER_ROLES")
public class UserRoleEntity {
    @Id
    @Column(name = "USER_ID")
    private String userId;

    @Column(name = "ROLE_ID")
    private Integer roleId;
}

// --- 2. Role Permissions (To get Permission IDs) ---
@Data
@Entity
@Table(name = "ROLE_PERMISSIONS")
@IdClass(RolePermissionId.class)
public class RolePermissionEntity {
    @Id
    @Column(name = "ROLE_ID")
    private Integer roleId;

    @Id
    @Column(name = "PERMISSION_ID")
    private Integer permissionId;
}

@Data
class RolePermissionId implements Serializable {
    private Integer roleId;
    private Integer permissionId;
}

// --- 3. Permissions (To get Screen Name & Actions) ---
@Data
@Entity
@Table(name = "PERMISSIONS")
public class PermissionEntity {
    @Id
    @Column(name = "MENU_ID")
    private Integer menuId;

    @Column(name = "MENU_TITLE") // e.g. "CGL Management"
    private String menuTitle;

    @Column(name = "MENU_ACTION") // e.g. "view|create|modify"
    private String menuAction;
}
















package com.fincore.helpservice.repository;

import com.fincore.helpservice.entity.PermissionEntity;
import com.fincore.helpservice.entity.RolePermissionEntity;
import com.fincore.helpservice.entity.UserRoleEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface UserRoleRepository extends JpaRepository<UserRoleEntity, String> {}

@Repository
public interface RolePermissionRepository extends JpaRepository<RolePermissionEntity, Integer> {
    List<RolePermissionEntity> findByRoleId(Integer roleId);
}

@Repository
public interface PermissionRepository extends JpaRepository<PermissionEntity, Integer> {
    
    // Complex Query: Get Actions for a specific User and Screen
    @Query(value = """
        SELECT p.MENU_ACTION 
        FROM PERMISSIONS p
        JOIN ROLE_PERMISSIONS rp ON p.MENU_ID = rp.PERMISSION_ID
        JOIN USER_ROLES ur ON rp.ROLE_ID = ur.ROLE_ID
        WHERE ur.USER_ID = :userId 
        AND UPPER(p.MENU_TITLE) = UPPER(:screenName)
    """, nativeQuery = true)
    String findActionForUserAndScreen(@Param("userId") String userId, @Param("screenName") String screenName);
}














package com.fincore.helpservice.service;

import com.fincore.helpservice.repository.PermissionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class PermissionService {

    private final PermissionRepository permissionRepository;

    /**
     * Fetches the list of allowed actions (CREATE, APPROVE, etc.) for a user on a specific screen.
     */
    public List<String> getUserActions(String userId, String screenName) {
        if (screenName == null) return Collections.emptyList();

        String actionString = permissionRepository.findActionForUserAndScreen(userId, screenName);
        
        if (actionString == null || actionString.isBlank()) {
            return Collections.emptyList();
        }

        // Split "view|create|modify" -> ["VIEW", "CREATE", "MODIFY"]
        return Arrays.stream(actionString.split("\\|"))
                .map(String::trim)
                .map(String::toUpperCase)
                .collect(Collectors.toList());
    }

    /**
     * Generates a polite "Access Denied" message based on the missing action.
     */
    public String getAccessDeniedMessage(String requiredAction, String screenName) {
        String module = (screenName != null) ? screenName : "this module";
        requiredAction = (requiredAction != null) ? requiredAction.toLowerCase() : "perform this action";

        return switch (requiredAction.toUpperCase()) {
            case "CREATE" -> 
                "You do not have rights to create entries in " + module + ". Users with creation rights can perform this. Please contact your administrator.";
            case "APPROVE" -> 
                "You do not have approval rights for " + module + ". Please wait for an executor to process requests, or check 'My Requests' to view status.";
            case "MODIFY" -> 
                "You do not have permission to modify records in " + module + ".";
            case "DELETE" -> 
                "Deletion is restricted. You do not have the required permissions.";
            default -> 
                "You do not have the required permissions (" + requiredAction + ") to perform this action.";
        };
    }
}























package com.fincore.helpservice.service;

import com.fincore.helpservice.dto.HelpItemDTO;
import com.fincore.helpservice.dto.HelpRequestDTO;
import com.fincore.helpservice.dto.HelpResponseDTO;
import com.fincore.helpservice.entity.HelpFaqEntity;
import com.fincore.helpservice.entity.HelpQuestionEntity;
import com.fincore.helpservice.repository.HelpFaqRepository;
import com.fincore.helpservice.repository.HelpQuestionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
@RequiredArgsConstructor
@Slf4j
public class HelpService {

    private final HelpQuestionRepository questionRepository;
    private final HelpFaqRepository faqRepository;
    private final HelpAnalyticsService analyticsService;
    private final PermissionService permissionService;

    // Tuning Thresholds
    private static final int SCORE_THRESHOLD_HIGH = 65; // Lowered slightly for better responsiveness
    private static final int SCORE_THRESHOLD_LOW = 25;

    // --- SYNONYM MAP (The Smart Dictionary) ---
    private static final Map<String, List<String>> SYNONYMS = new HashMap<>();
    static {
        SYNONYMS.put("create", List.of("add", "new", "generate", "make", "raise"));
        SYNONYMS.put("modify", List.of("edit", "update", "change", "correct"));
        SYNONYMS.put("approve", List.of("authorize", "pass", "accept", "sign"));
        SYNONYMS.put("view", List.of("show", "see", "check", "display", "list"));
        SYNONYMS.put("delete", List.of("remove", "cancel", "trash"));
        SYNONYMS.put("logout", List.of("sign out", "log out", "exit"));
    }

    public HelpResponseDTO processRequest(HelpRequestDTO request) {
        String userId = getUserIdFromContext();
        String type = request.getRequestType();

        // Server-Side RBAC: Fetch actions based on User ID & Screen
        // We do this inside specific handlers now to be context-aware
        
        switch (type) {
            case "MODULE_QUESTIONS":
                return handleModuleFetch(userId, request.getScreenName());
            case "FAQ_LIST":
                return handleFaqFetch();
            case "GET_ANSWER":
                return handleGetAnswer(request.getQuestionId());
            case "CHAT":
                return handleChat(userId, request.getChatMessage(), request.getScreenName());
            default:
                throw new IllegalArgumentException("Invalid Request Type");
        }
    }

    // --- HANDLER 1: MODULE QUESTIONS ---
    private HelpResponseDTO handleModuleFetch(String userId, String screenName) {
        if (!StringUtils.hasText(screenName)) throw new IllegalArgumentException("Screen Name is required");

        // Fetch User Permissions
        List<String> userActions = permissionService.getUserActions(userId, screenName);

        List<HelpItemDTO> items = getQuestionsForScreen(screenName).stream()
                // Only show relevant questions in the list (Hide restricted ones here to avoid clutter)
                .filter(q -> isActionAllowed(q, userActions)) 
                .map(q -> HelpItemDTO.builder().id(q.getQuestionId()).text(q.getQuestionText()).type("QUESTION").build())
                .collect(Collectors.toList());

        return HelpResponseDTO.builder().responseType("LIST_SELECTION").botReply("Topics for " + screenName + ":").items(items).build();
    }

    // --- HANDLER 2: FAQ FETCH ---
    private HelpResponseDTO handleFaqFetch() {
        return HelpResponseDTO.builder()
                .responseType("LIST_SELECTION")
                .botReply("Frequently Asked Questions:")
                .items(fetchGlobalFaqs())
                .build();
    }

    // --- HANDLER 3: GET ANSWER (Direct Click) ---
    private HelpResponseDTO handleGetAnswer(String questionId) {
        return questionRepository.findById(questionId)
                .map(q -> HelpResponseDTO.builder().responseType("TEXT_REPLY").botReply(q.getAnswerContent()).build())
                .orElse(HelpResponseDTO.builder().responseType("NO_MATCH").botReply("Content not found.").build());
    }

    // --- HANDLER 4: SMART CHAT ---
    private HelpResponseDTO handleChat(String userId, String message, String clientScreenName) {
        if (!StringUtils.hasText(message)) return HelpResponseDTO.builder().responseType("NO_MATCH").botReply("Please type a message.").build();

        // 1. Infer Context (If user types "CGL" but is on Home screen)
        String inferredScreen = inferScreenFromQuery(message);
        String activeScreen = (inferredScreen != null) ? inferredScreen : clientScreenName;

        // 2. Perform Search (Includes FAQs & Questions)
        List<HelpItemDTO> matches = performSmartSearch(message, activeScreen);

        if (matches.isEmpty()) {
            analyticsService.logChatInteraction(userId, activeScreen, message, "NO_MATCH", 0);
            return HelpResponseDTO.builder().responseType("NO_MATCH").botReply("Sorry, I couldn't find anything related to that. Try rephrasing?").build();
        }

        HelpItemDTO bestMatch = matches.get(0);
        int score = (int) bestMatch.getSearchScore();

        // 3. Permission Check (The "Polite Rejection" Logic)
        if (score >= SCORE_THRESHOLD_HIGH) {
            
            // Check if it's a Restricted Question
            if ("QUESTION".equals(bestMatch.getType()) && bestMatch.getRequiredAction() != null) {
                List<String> userActions = permissionService.getUserActions(userId, bestMatch.getScreenName());
                
                // If user LACKS permission
                if (!userActions.contains(bestMatch.getRequiredAction())) {
                    String deniedMsg = permissionService.getAccessDeniedMessage(bestMatch.getRequiredAction(), bestMatch.getScreenName());
                    
                    analyticsService.logChatInteraction(userId, activeScreen, message, "ACCESS_DENIED", score);
                    return HelpResponseDTO.builder().responseType("TEXT_REPLY").botReply(deniedMsg).build();
                }
            }
            
            // Access Granted or Public FAQ
            analyticsService.logChatInteraction(userId, activeScreen, message, "ANSWERED", score);
            return HelpResponseDTO.builder().responseType("TEXT_REPLY").botReply(bestMatch.getAnswer()).build();
        } 
        
        // 4. Suggestions (Ambiguous)
        else if (score >= SCORE_THRESHOLD_LOW) {
            analyticsService.logChatInteraction(userId, activeScreen, message, "SUGGESTION", score);
            return HelpResponseDTO.builder()
                    .responseType("SUGGESTION")
                    .botReply("I'm not sure, but did you mean one of these?")
                    .items(matches.stream().limit(3).collect(Collectors.toList()))
                    .build();
        }

        // 5. No Match
        analyticsService.logChatInteraction(userId, activeScreen, message, "NO_MATCH_LOW", score);
        return HelpResponseDTO.builder().responseType("NO_MATCH").botReply("I didn't quite get that. Could you be more specific?").build();
    }

    // =========================================================================
    // SEARCH ENGINE
    // =========================================================================

    private List<HelpItemDTO> performSmartSearch(String query, String activeScreen) {
        String normalizedQuery = query.toLowerCase().trim();
        List<String> tokens = tokenize(normalizedQuery);

        // 1. Process Questions
        Stream<HelpItemDTO> questions = getAllActiveQuestions().stream()
                .map(q -> {
                    int score = calculateScore(q.getQuestionText(), q.getKeywords(), q.getScreenName(), normalizedQuery, tokens, activeScreen);
                    // Add Action Bonus (If query is "Create" and Question Action is "CREATE")
                    if(q.getRequiredAction() != null && isActionMatch(normalizedQuery, q.getRequiredAction())) {
                        score += 30; // Huge Intent Bonus
                    }
                    return HelpItemDTO.builder()
                            .id(q.getQuestionId()).text(q.getQuestionText()).answer(q.getAnswerContent())
                            .type("QUESTION").requiredAction(q.getRequiredAction()).screenName(q.getScreenName())
                            .searchScore(score).build();
                });

        // 2. Process FAQs (Now included!)
        Stream<HelpItemDTO> faqs = fetchGlobalFaqsEntity().stream()
                .map(f -> {
                    int score = calculateScore(f.getQuestionText(), null, "FAQ", normalizedQuery, tokens, null);
                    return HelpItemDTO.builder()
                            .id(f.getFaqId()).text(f.getQuestionText()).answer(f.getAnswerContent())
                            .type("FAQ").searchScore(score).build();
                });

        // 3. Merge & Sort
        return Stream.concat(questions, faqs)
                .filter(item -> item.getSearchScore() > 0)
                .sorted((a, b) -> Double.compare(b.getSearchScore(), a.getSearchScore()))
                .limit(5)
                .collect(Collectors.toList());
    }

    private int calculateScore(String text, String keywords, String screenName, String fullQuery, List<String> tokens, String activeScreen) {
        double score = 0;
        String lowerText = text.toLowerCase();
        String lowerKeywords = (keywords != null) ? keywords.toLowerCase() : "";

        // A. Exact Match
        if (lowerText.equals(fullQuery)) return 100;
        if (lowerText.contains(fullQuery)) score += 50;

        // B. Token Match with Synonyms
        int matches = 0;
        for (String token : tokens) {
            if (STOP_WORDS.contains(token)) continue;

            boolean tokenMatched = false;
            // Direct Contain
            if (lowerText.contains(token) || lowerKeywords.contains(token)) {
                score += 15;
                tokenMatched = true;
            } 
            // Synonym Check
            else if (matchesSynonym(token, lowerText)) {
                score += 12; // Slightly less than exact word
                tokenMatched = true;
            }
            // Fuzzy Check (Typo)
            else if (fuzzyMatch(token, lowerText)) {
                score += 5;
                tokenMatched = true;
            }

            if (tokenMatched) matches++;
        }

        if (matches > 1) score += (matches * 5); // Combo bonus

        // C. Context Boost
        if (activeScreen != null && activeScreen.equalsIgnoreCase(screenName)) {
            score = score * 2.5;
        }

        return (int) Math.min(score, 100);
    }

    // --- HELPERS ---

    private boolean isActionMatch(String query, String action) {
        // Check exact action
        if (query.contains(action.toLowerCase())) return true;
        // Check synonyms (e.g., "Add" matches "CREATE")
        List<String> synonyms = SYNONYMS.getOrDefault(action.toLowerCase(), Collections.emptyList());
        for(String syn : synonyms) {
            if (query.contains(syn)) return true;
        }
        return false;
    }

    private boolean matchesSynonym(String token, String text) {
        for (List<String> synonymList : SYNONYMS.values()) {
            if (synonymList.contains(token)) {
                for (String syn : synonymList) {
                    if (text.contains(syn)) return true;
                }
            }
        }
        return false;
    }

    private String inferScreenFromQuery(String query) {
        String lower = query.toLowerCase();
        if (lower.contains("cgl")) return "CGL Management";
        if (lower.contains("segment")) return "Segment Management";
        if (lower.contains("branch")) return "Branch Management";
        if (lower.contains("user")) return "User Management";
        return null;
    }

    private String getUserIdFromContext() {
        try {
            return SecurityContextHolder.getContext().getAuthentication().getName();
        } catch (Exception e) { return "ANONYMOUS"; }
    }

    // Standard getters/cache/utils...
    private List<String> tokenize(String query) { return Arrays.asList(query.split("\\W+")); }
    
    @Cacheable(value = "help_questions_all")
    public List<HelpQuestionEntity> getAllActiveQuestions() { return questionRepository.findByIsActive("Y"); }
    
    @Cacheable(value = "help_faqs_all")
    public List<HelpFaqEntity> fetchGlobalFaqsEntity() { return faqRepository.findByIsActiveOrderByDisplayOrderAsc("Y"); }

    private static final Set<String> STOP_WORDS = Set.of("how", "to", "i", "can", "do", "a", "the", "in", "on", "what", "is");
    
    // Levenshtein Implementation (Same as before)
    private boolean fuzzyMatch(String token, String target) {
        if(token.length() < 3) return false;
        for(String w : target.split("\\W+")) if(calculateDistance(token, w) <= 1) return true;
        return false;
    }
    private int calculateDistance(String x, String y) { /* ... same as before ... */ return 0; }
    
    // List Filter (Used for Module Fetch only)
    private boolean isActionAllowed(HelpQuestionEntity q, List<String> actions) {
        if (q.getRequiredAction() == null) return true;
        if (actions.contains("ALL")) return true;
        return actions.contains(q.getRequiredAction().toUpperCase());
    }
    
    // Helper for FAQ Fetch Handler
    private List<HelpItemDTO> fetchGlobalFaqs() {
        return fetchGlobalFaqsEntity().stream().map(f -> HelpItemDTO.builder().id(f.getFaqId()).text(f.getQuestionText()).type("FAQ").build()).collect(Collectors.toList());
    }
}





















package com.fincore.helpservice.dto;

import lombok.Builder;
import lombok.Data;
import java.io.Serializable;

@Data
@Builder
public class HelpItemDTO implements Serializable {

    private String id;
    private String text;       // The Question
    private String answer;     // The Answer (HTML/Text)
    private String actionLink; // Deep Link
    private String actionLabel;// Button Text
    private String type;       // QUESTION, FAQ, SEARCH_RESULT
    private double searchScore; 
    
    // New Fields for Internal Logic
    private String requiredAction;
    private String screenName;
}












