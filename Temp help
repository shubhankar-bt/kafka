<!-- Apache OpenNLP for POS Tagging & Tokenization -->
<dependency>
    <groupId>org.apache.opennlp</groupId>
    <artifactId>opennlp-tools</artifactId>
    <version>2.3.0</version>
</dependency>

<!-- Apache Commons Lang for optimized Levenshtein Distance -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
</dependency>











package com.fincore.helpservice.service;

import com.fincore.helpservice.model.PermissionEntity;
import com.fincore.helpservice.repository.PermissionRepository;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import opennlp.tools.postag.POSModel;
import opennlp.tools.postag.POSTaggerME;
import opennlp.tools.tokenize.TokenizerME;
import opennlp.tools.tokenize.TokenizerModel;
import org.springframework.core.io.ClassPathResource;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.io.InputStream;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * THE SMART BRAIN (Powered by Apache OpenNLP).
 * Uses Part-of-Speech (POS) tagging to accurately distinguish
 * Actions (Verbs) from Modules (Nouns).
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class NLPEngine {

    private final AdaptiveSearchService adaptiveService;
    private final PermissionRepository permissionRepository;

    // OpenNLP Tools
    private TokenizerME tokenizer;
    private POSTaggerME posTagger;

    private final Map<String, String> KNOWN_SCREENS = new ConcurrentHashMap<>();
    private final Map<String, String> SCREEN_URLS = new ConcurrentHashMap<>();

    private static final Set<String> KNOWN_ACTIONS = Set.of("CREATE", "MODIFY", "APPROVE", "VIEW", "DELETE", "DOWNLOAD");
    
    // Regex fallbacks for specific commands
    private static final Pattern ERROR_CODE_PATTERN = Pattern.compile("\\b[A-Z]{3,4}-\\d{3,5}\\b");
    private static final Pattern NAV_PATTERN = Pattern.compile("\\b(go to|open|take me to|navigate to|launch)\\b", Pattern.CASE_INSENSITIVE);
    private static final Pattern CAPABILITY_PATTERN = Pattern.compile("\\b(what can i do|my rights|my permissions|access do i have)\\b", Pattern.CASE_INSENSITIVE);
    private static final Pattern RESET_PATTERN = Pattern.compile("\\b(stop|cancel|wrong|start over|reset)\\b", Pattern.CASE_INSENSITIVE);
    private static final Pattern PRONOUN_PATTERN = Pattern.compile("\\b(it|this|that)\\b", Pattern.CASE_INSENSITIVE);
    private static final Pattern TROUBLE_PATTERN = Pattern.compile("\\b(cant|cannot|fail|error|issue|problem|broken)\\b", Pattern.CASE_INSENSITIVE);

    @PostConstruct
    public void initOpenNLP() {
        try {
            // Load Tokenizer Model
            InputStream tokenStream = new ClassPathResource("models/en-token.bin").getInputStream();
            TokenizerModel tokenModel = new TokenizerModel(tokenStream);
            tokenizer = new TokenizerME(tokenModel);

            // Load POS Tagger Model
            InputStream posStream = new ClassPathResource("models/en-pos-maxent.bin").getInputStream();
            POSModel posModel = new POSModel(posStream);
            posTagger = new POSTaggerME(posModel);

            log.info("NLPEngine: Apache OpenNLP Models loaded successfully.");
            loadScreenKnowledge();
        } catch (Exception e) {
            log.error("NLPEngine: CRITICAL - Failed to load OpenNLP models. Ensure .bin files are in src/main/resources/models/", e);
        }
    }

    @Scheduled(fixedRate = 3600000)
    public void loadScreenKnowledge() {
        try {
            List<PermissionEntity> allPermissions = permissionRepository.findAll();
            KNOWN_SCREENS.clear();
            SCREEN_URLS.clear();
            for (PermissionEntity p : allPermissions) {
                if (p.getMenuTitle() != null) {
                    String upperTitle = p.getMenuTitle().toUpperCase().trim();
                    KNOWN_SCREENS.put(upperTitle, p.getMenuTitle().trim());
                    if (p.getMenuUrl() != null) SCREEN_URLS.put(upperTitle, p.getMenuUrl());
                }
            }
        } catch (Exception e) {
            log.error("NLPEngine: Failed to load screens.", e);
        }
    }

    public String getScreenUrl(String screenName) {
        return screenName == null ? null : SCREEN_URLS.get(screenName.toUpperCase().trim());
    }

    /**
     * EXTRACT NORMALIZED INTENT USING OPENNLP TOKENIZER
     */
    public String extractNormalizedIntent(String sentence) {
        if (sentence == null || tokenizer == null) return "";
        
        // Use OpenNLP for precise tokenization (handles punctuation beautifully)
        String[] tokens = tokenizer.tokenize(sentence.toLowerCase());
        StringBuilder normalized = new StringBuilder();

        for (String word : tokens) {
            if (word.matches("\\p{Punct}")) continue; // Skip raw punctuation
            String root = adaptiveService.getRootFromSynonym(word);
            normalized.append(root).append(" ");
        }
        return normalized.toString().trim();
    }

    /**
     * SMART ACTION DETECTION: Only looks at Verbs (VB, VBD, VBG, VBN, VBP, VBZ)
     */
    public String detectAction(String originalSentence) {
        if (originalSentence == null || posTagger == null) return null;

        String[] tokens = tokenizer.tokenize(originalSentence);
        String[] tags = posTagger.tag(tokens);

        for (int i = 0; i < tokens.length; i++) {
            // Check if the word is grammatically a Verb
            if (tags[i].startsWith("VB")) {
                String verb = tokens[i].toLowerCase();
                String root = adaptiveService.getRootFromSynonym(verb);
                if (KNOWN_ACTIONS.contains(root.toUpperCase())) {
                    return root.toUpperCase();
                }
            }
        }
        
        // Fallback: If OpenNLP misses it, do a basic scan
        return fallbackActionDetection(originalSentence);
    }

    private String fallbackActionDetection(String sentence) {
         for (String word : sentence.split("\\s+")) {
            String root = adaptiveService.getRootFromSynonym(word.toLowerCase());
            if (KNOWN_ACTIONS.contains(root.toUpperCase())) return root.toUpperCase();
        }
        return null;
    }

    /**
     * SMART SCREEN DETECTION: Looks primarily at Nouns (NN, NNS, NNP, NNPS)
     */
    public String detectScreen(String originalSentence) {
        if (originalSentence == null) return null;
        
        // 1. Exact phrase match first (highest priority for things like "CGL Management")
        String upperSentence = originalSentence.toUpperCase();
        for (String dbScreenUpper : KNOWN_SCREENS.keySet()) {
            if (upperSentence.contains(dbScreenUpper)) {
                return KNOWN_SCREENS.get(dbScreenUpper);
            }
        }

        // 2. OpenNLP Noun Extraction
        if (posTagger != null) {
            String[] tokens = tokenizer.tokenize(originalSentence);
            String[] tags = posTagger.tag(tokens);

            for (int i = 0; i < tokens.length; i++) {
                // If it's a Noun
                if (tags[i].startsWith("NN")) {
                    String noun = tokens[i].toLowerCase();
                    String root = adaptiveService.getRootFromSynonym(noun);
                    if (KNOWN_SCREENS.containsKey(root.toUpperCase().trim())) {
                        return KNOWN_SCREENS.get(root.toUpperCase().trim());
                    }
                }
            }
        }
        return null;
    }

    public boolean containsPronoun(String t) { return t != null && PRONOUN_PATTERN.matcher(t).find(); }
    public String resolveAnaphora(String t, String topic) { return PRONOUN_PATTERN.matcher(t).replaceAll(topic); }
    public boolean isTrouble(String t) { return t != null && TROUBLE_PATTERN.matcher(t).find(); }
    public String extractErrorCode(String text) { Matcher m = ERROR_CODE_PATTERN.matcher(text.toUpperCase()); return m.find() ? m.group() : null; }
    public boolean isNavigationCommand(String text) { return text != null && NAV_PATTERN.matcher(text).find(); }
    public boolean isCapabilityRequest(String text) { return text != null && CAPABILITY_PATTERN.matcher(text).find(); }
    public boolean isDefinitionRequest(String text) { return text != null && text.toLowerCase().startsWith("what is"); }
    public boolean isResetRequest(String text) { return text != null && RESET_PATTERN.matcher(text).find(); }
}





















    // =========================================================================
    // ENHANCED FUZZY MATCHING
    // =========================================================================

    /**
     * Uses Dynamic Tolerance based on word length.
     */
    private boolean fuzzyMatch(String token, String target) {
        if (target.contains(token)) return true;
        
        // Don't fuzzy match tiny words (too many false positives)
        if (token.length() <= 3) return false;

        // Dynamic Tolerance: 
        // 4-5 chars -> 1 edit allowed
        // 6+ chars -> 2 edits allowed
        int allowedEdits = (token.length() <= 5) ? 1 : 2;

        for (String word : target.split("\\W+")) {
            // Optimization: Skip checking if length difference is greater than allowed edits
            if (Math.abs(token.length() - word.length()) > allowedEdits) {
                continue;
            }

            // Using Apache Commons Lang for highly optimized C-style DP calculation
            int distance = org.apache.commons.lang3.StringUtils.getLevenshteinDistance(token, word);
            
            if (distance <= allowedEdits) {
                return true;
            }
        }
        return false;
    }

### **Summary of what we just achieved:**
1. **Punctuation Immunity:** `TokenizerME` cleanly separates words from punctuation. "CGL." is now cleanly read as "CGL".
2. **Contextual Awareness:** `POSTaggerME` knows if the user is using "view" as a verb (action) or "view" as a noun (the name of a screen).
3. **Optimized Search:** Replaced your manual `calculateDistance` array with Apache's optimized StringUtils, reducing CPU load during chat interactions, and added dynamic tolerance to eliminate false positives on short words. 

This completes points 1, 2, 3, and 4 of your master plan!
