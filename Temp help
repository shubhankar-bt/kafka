// ... imports
import org.springframework.security.core.context.SecurityContextHolder;

// ... inside HelpService class ...

    // --- HANDLER 4: CHAT (The Smart Part with Context Boosting) ---
    private HelpResponseDTO handleChat(String message, List<String> userActions, String currentScreenName) {
        // 1. Validation
        if (!StringUtils.hasText(message)) {
            return HelpResponseDTO.builder().responseType("NO_MATCH").botReply("Please type a message.").build();
        }

        // 2. Extract Current User ID from JWT Context
        String userId = "ANONYMOUS";
        try {
            userId = SecurityContextHolder.getContext().getAuthentication().getName();
        } catch (Exception e) {
            log.warn("Could not retrieve User ID from Security Context", e);
        }

        // 3. Run Search Algorithm (With Context Boosting)
        List<HelpItemDTO> matches = performSmartSearch(message, userActions, currentScreenName);

        // 4. Analyze Scores & Decision Tree
        if (matches.isEmpty()) {
            analyticsService.logChatInteraction(userId, currentScreenName, message, "NO_MATCH", 0);
            return HelpResponseDTO.builder()
                    .responseType("NO_MATCH")
                    .botReply("Sorry, I don't have information about that. Please try rephrasing or check the FAQ.")
                    .build();
        }

        HelpItemDTO bestMatch = matches.get(0);
        int bestScore = (int) bestMatch.getSearchScore();

        if (bestScore >= SCORE_THRESHOLD_HIGH) {
            // Case A: High Confidence -> Direct Answer
            analyticsService.logChatInteraction(userId, currentScreenName, message, "ANSWERED", bestScore);
            return HelpResponseDTO.builder()
                    .responseType("TEXT_REPLY")
                    .botReply(bestMatch.getAnswer())
                    .build();

        } else if (bestScore >= SCORE_THRESHOLD_LOW) {
            // Case B: Medium Confidence -> Suggestions
            analyticsService.logChatInteraction(userId, currentScreenName, message, "SUGGESTION", bestScore);
            return HelpResponseDTO.builder()
                    .responseType("SUGGESTION")
                    .botReply("I'm not sure, but did you mean one of these?")
                    // Return top 3 suggestions
                    .items(matches.stream().limit(3).collect(Collectors.toList()))
                    .build();

        } else {
            // Case C: Low Confidence -> Treat as No Match
            analyticsService.logChatInteraction(userId, currentScreenName, message, "NO_MATCH_LOW_SCORE", bestScore);
            return HelpResponseDTO.builder()
                    .responseType("NO_MATCH")
                    .botReply("Sorry, I didn't understand that. Could you try rephrasing?")
                    .build();
        }
    }

    // =========================================================================
    // SEARCH ALGORITHM (Updated with Context Boosting)
    // =========================================================================

    private List<HelpItemDTO> performSmartSearch(String query, List<String> userActions, String currentScreenName) {
        List<HelpQuestionEntity> allQuestions = getAllActiveQuestions();
        String normalizedQuery = query.toLowerCase().trim();
        List<String> tokens = Arrays.asList(normalizedQuery.split("\\W+"));

        return allQuestions.stream()
                // 1. RBAC Filter
                .filter(q -> isActionAllowed(q, userActions))
                // 2. Score Calculation
                .map(q -> {
                    int score = calculateScore(q, normalizedQuery, tokens, currentScreenName);
                    return new AbstractMap.SimpleEntry<>(q, score);
                })
                // 3. Filter Zero Scores
                .filter(entry -> entry.getValue() > 0)
                // 4. Sort Descending
                .sorted((e1, e2) -> Integer.compare(e2.getValue(), e1.getValue()))
                // 5. Limit Results
                .limit(5)
                // 6. Map to DTO
                .map(entry -> HelpItemDTO.builder()
                        .id(entry.getKey().getQuestionId())
                        .text(entry.getKey().getQuestionText())
                        .answer(entry.getKey().getAnswerContent())
                        .searchScore(entry.getValue())
                        .type("SEARCH_RESULT")
                        .build())
                .collect(Collectors.toList());
    }

    private int calculateScore(HelpQuestionEntity q, String fullQuery, List<String> tokens, String currentScreenName) {
        double score = 0;
        String qText = q.getQuestionText().toLowerCase();

        // --- Core Matching Logic ---

        // 1. Exact Phrase Match (Highest Priority)
        if (qText.equals(fullQuery)) score = 100;
        else if (qText.contains(fullQuery)) score += 60;

        // 2. Token Matching
        int tokenMatches = 0;
        for (String token : tokens) {
            if (STOP_WORDS.contains(token)) continue;

            if (qText.contains(token)) {
                score += 15;
                tokenMatches++;
            } else if (q.getKeywords() != null && q.getKeywords().toLowerCase().contains(token)) {
                score += 10; // Hidden keyword match
                tokenMatches++;
            } else if (fuzzyMatch(token, qText)) {
                score += 5; // Typo match
            }
        }

        // Bonus for matching multiple tokens (Context)
        if (tokenMatches > 1) score += (tokenMatches * 5);

        // --- CONTEXT BOOSTING ---
        // If the question belongs to the screen the user is currently viewing, boost the score.
        if (currentScreenName != null && currentScreenName.equalsIgnoreCase(q.getScreenName())) {
            score = score * 2.5; // 250% Boost
        }

        // Cap at 100 to keep semantics clean (though higher internal scores help sorting)
        return (int) Math.min(score, 100);
    }


