package com.fincore.helpservice.service;

import com.fincore.helpservice.dto.HelpItemDTO;
import com.fincore.helpservice.dto.HelpRequestDTO;
import com.fincore.helpservice.dto.HelpResponseDTO;
import com.fincore.helpservice.model.HelpFaqEntity;
import com.fincore.helpservice.model.HelpQuestionEntity;
import com.fincore.helpservice.repository.HelpFaqRepository;
import com.fincore.helpservice.repository.HelpQuestionRepository;
import com.fincore.helpservice.repository.HelpScreenRepository;
import com.fincore.helpservice.repository.PermissionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
@RequiredArgsConstructor
@Slf4j
public class HelpService {
    // Thresholds
    private static final int SCORE_THRESHOLD_HIGH = 60; // Above this -> Direct Answer
    private static final int SCORE_THRESHOLD_LOW = 20; // Between 30-75 -> Suggestions
    // SYNONYM MAP Smart Dictionary
    private static final Map<String, List<String>> SYNONYMS = new HashMap<>();
    // Words to ignore in search to improve relevance
    private static final Set<String> STOP_WORDS = Set.of("how", "to", "i", "can", "do", "a", "the", "in", "on", "what", "is");

    static {
        SYNONYMS.put("create", List.of("add", "new", "generate", "make", "raise"));
        SYNONYMS.put("modify", List.of("edit", "update", "change", "correct"));
        SYNONYMS.put("approve", List.of("authorize", "pass", "accept", "sign"));
        SYNONYMS.put("view", List.of("show", "see", "check", "display", "list"));
        SYNONYMS.put("delete", List.of("remove", "cancel", "trash"));
        SYNONYMS.put("logout", List.of("sign out", "log out", "exit"));
    }

    // CORE REPOS
    private final HelpQuestionRepository questionRepository;
    private final HelpFaqRepository faqRepository;
    private final HelpScreenRepository screenRepository;
    private final PermissionRepository permissionRepository; // Source of Truth for Screens

    // SERVICES
    private final HelpAnalyticsService analyticsService;
    private final PermissionService permissionService;
    private final NLPEngine nlpEngine;
    private final SmallTalkService smallTalkService;
    private final SmartResponseGenerator responseGenerator;
    private final SystemHealthService healthService;
    private final ContentInjectorService contentInjector;
    private final SupportRoutingService routingService;
    private final AdaptiveSearchService adaptiveService;


    // BRAIN MODULES
    private final ChatSessionService sessionService;
    private final SentimentAnalyzer sentimentAnalyzer;

    /**
     * MAIN PROCESSOR: Routes based on Intent (Request Type)
     */
    public HelpResponseDTO processRequest(HelpRequestDTO request, String userId, String roleId) {

        String type = request.getRequestType();

        switch (type) {
            case "MODULE_QUESTIONS":
                return handleModuleFetch(request.getScreenName(), roleId);

            case "FAQ_LIST":
                return handleFaqFetch();

            case "GET_ANSWER":
                return handleGetAnswer(request.getQuestionId());

            case "CHAT":
                return handleChat(userId, request.getChatMessage(), request.getScreenName(), roleId);

            default:
                throw new IllegalArgumentException("Invalid Request Type: " + type);
        }
    }


    // =========================================================================
    // HANDLER 1: MODULE QUESTIONS
    // =========================================================================

    private HelpResponseDTO handleModuleFetch(String screenName, String roleId) {
        if (!StringUtils.hasText(screenName)) throw new IllegalArgumentException("Screen Name is required");

        // Fetch User Permissions
        List<String> userActions = permissionService.getUserActions(roleId, screenName);

        List<HelpItemDTO> items = getQuestionsForScreen(screenName).stream()
                .filter(q -> isActionAllowed(q, userActions))
                .map(q -> HelpItemDTO.builder()
                        .id(q.getQuestionId())
                        .text(q.getQuestionText())
                        .type("QUESTION")
                        .build()) // Note: We do NOT send the full answer content here to keep it light
                .collect(Collectors.toList());

        return HelpResponseDTO.builder()
                .responseType("LIST_SELECTION")
                .botReply("Here are the topics for " + screenName + ":")
                .items(items)
                .build();
    }

    // =========================================================================
    // HANDLER 2: FAQ FETCH
    // =========================================================================
    private HelpResponseDTO handleFaqFetch() {
        List<HelpItemDTO> faqs = fetchGlobalFaqs();
        return HelpResponseDTO.builder()
                .responseType("LIST_SELECTION")
                .botReply("Here are the frequently asked questions:")
                .items(faqs)
                .build();
    }

    // =========================================================================
    // HANDLER 3: DIRECT ANSWER
    // =========================================================================
    private HelpResponseDTO handleGetAnswer(String questionId) {
        return questionRepository.findById(questionId)
                .map(q -> HelpResponseDTO.builder()
                        .responseType("TEXT_REPLY")
                        .botReply(q.getAnswerContent())
                        .navigationLink(q.getActionLink())
                        .navigationLabel(q.getActionLabel())
                        .build())
                .orElse(HelpResponseDTO.builder().responseType("NO_MATCH").botReply("Content not found.").build());
    }

    // =========================================================================
    // THE ULTIMATE SMART CHAT HANDLER
    // =========================================================================
    private HelpResponseDTO handleChat(String userId, String rawMessage, String clientScreenName, String roleId) {
        if (!StringUtils.hasText(rawMessage))
            return HelpResponseDTO.builder().responseType("NO_MATCH").botReply("Please type a message.").build();

        StringBuilder botPrefix = new StringBuilder();

        // 0. RESET
        if (nlpEngine.isResetRequest(rawMessage)) {
            sessionService.clearSession(userId);
            return HelpResponseDTO.builder().responseType("TEXT_REPLY").botReply("Conversation cleared.").build();
        }

        // 1. SENTIMENT ANALYSIS
        SentimentAnalyzer.Sentiment sentiment = sentimentAnalyzer.analyze(rawMessage);
        if (sentiment != SentimentAnalyzer.Sentiment.NEUTRAL) {
            botPrefix.append(sentimentAnalyzer.getDeEscalationMessage(sentiment)).append("<br/><br/>");
        }

        // 2. SMALL TALK
        if (sentiment == SentimentAnalyzer.Sentiment.NEUTRAL) {
            String smallTalk = smallTalkService.getSmallTalkResponse(rawMessage);
            if (smallTalk != null)
                return HelpResponseDTO.builder().responseType("TEXT_REPLY").botReply(smallTalk).build();
        }

        // 3. NLP & CONTEXT RESOLUTION
        String normalizedIntent = nlpEngine.extractNormalizedIntent(rawMessage);
        String detectedAction = nlpEngine.detectAction(normalizedIntent);
        String detectedScreenName = nlpEngine.detectScreen(rawMessage); // Returns String Name

        // -- MEMORY & ANAPHORA --
        ChatSessionService.UserSession session = sessionService.getSession(userId);

        // Resolve "it/this"
        if (nlpEngine.containsPronoun(rawMessage) && session != null && session.getLastTopic() != null) {
            String resolvedMsg = nlpEngine.resolveAnaphora(rawMessage, session.getLastTopic());
            normalizedIntent = nlpEngine.extractNormalizedIntent(resolvedMsg);
            botPrefix.append("*(Context: ").append(session.getLastTopic()).append(")*<br/>");
        }

        // Merge Action from History
        if (detectedAction == null && detectedScreenName != null && session != null && session.getLastAction() != null) {
            detectedAction = session.getLastAction();
            normalizedIntent = detectedAction + " " + normalizedIntent;
        }

        // Merge Screen from History/Client
        if (detectedScreenName == null) {
            if (session != null && session.getLastScreen() != null) detectedScreenName = session.getLastScreen();
            else if (clientScreenName != null) detectedScreenName = clientScreenName;
        }

        // Resolve Screen Name to ID for Database Query
        Integer activePermissionId = resolveScreenToId(detectedScreenName);
        String activeScreenName = detectedScreenName; // Keep string for UI/Text

        // 4. DISAMBIGUATION (If Action found but Screen is null)
        if (detectedAction != null && activePermissionId == null) {
            List<String> validScreens = findScreensForAction(roleId, detectedAction);
            if (validScreens.size() > 1) {
                sessionService.updateSession(userId, detectedAction, null, null);
                return HelpResponseDTO.builder()
                        .responseType("LIST_SELECTION")
                        .botReply(botPrefix + "I see you want to **" + detectedAction + "**. Which module?")
                        .items(validScreens.stream().map(s -> HelpItemDTO.builder().text(s).id("CTX_" + s).type("CONTEXT_SUGGESTION").build()).collect(Collectors.toList()))
                        .build();
            } else if (validScreens.size() == 1) {
                activeScreenName = validScreens.get(0);
                activePermissionId = resolveScreenToId(activeScreenName);
            }
        }

        // Update Memory
        sessionService.updateSession(userId, detectedAction, activeScreenName, activeScreenName);

        // 5. PERMISSION CHECK
        if (detectedAction != null && activeScreenName != null) {
            List<String> allowedActions = permissionService.getUserActions(roleId, activeScreenName);
            boolean isAllowed = allowedActions.contains(detectedAction);

            if (!isAllowed && !nlpEngine.isTrouble(rawMessage)) { // Don't deny if they are troubleshooting
                String reply = responseGenerator.generatePermissionResponse(false, detectedAction, activeScreenName, userId);
                analyticsService.logChatInteraction(userId, activeScreenName, rawMessage, "ACCESS_DENIED", 100);
                return HelpResponseDTO.builder().responseType("TEXT_REPLY").botReply(botPrefix + reply).build();
            }
        }

        // 6. PERFORM SEARCH
        boolean isDef = nlpEngine.isDefinitionRequest(rawMessage);
        List<HelpItemDTO> matches = performSmartSearch(normalizedIntent, rawMessage, activePermissionId, isDef);

        // --- FALLBACK ROUTING ---
        if (matches.isEmpty()) {
            analyticsService.logChatInteraction(userId, activeScreenName, rawMessage, "NO_MATCH", 0);
            String contact = routingService.getSupportContact(rawMessage);
            return HelpResponseDTO.builder().responseType("NO_MATCH")
                    .botReply(botPrefix + "I couldn't find a document for that. For complex queries, please contact **" + contact + "**.").build();
        }

        HelpItemDTO bestMatch = matches.get(0);
        int score = (int) bestMatch.getSearchScore();

        if (score >= SCORE_THRESHOLD_HIGH) {
            // Permission check on result
            if (bestMatch.getRequiredAction() != null) {
                List<String> allowedActions = permissionService.getUserActions(roleId, bestMatch.getScreenName());
                if (!allowedActions.contains(bestMatch.getRequiredAction())) {
                    String deniedMsg = responseGenerator.generatePermissionResponse(false, bestMatch.getRequiredAction(), bestMatch.getScreenName(), userId);
                    return HelpResponseDTO.builder().responseType("TEXT_REPLY").botReply(botPrefix + deniedMsg).build();
                }
            }

            String logId = analyticsService.logChatInteraction(userId, activeScreenName, rawMessage, "ANSWERED", score);

            // Dynamic Reply Construction
            StringBuilder finalReply = new StringBuilder();
            if (detectedAction != null && activeScreenName != null) {
                finalReply.append(responseGenerator.generatePermissionResponse(true, detectedAction, activeScreenName, userId)).append("<br/><br/>");
            } else {
                finalReply.append(responseGenerator.generateSearchIntro(score)).append("<br/>");
            }
            finalReply.append(bestMatch.getAnswer());

            if (bestMatch.getProTip() != null) {
                finalReply.append("<br/><br/>ðŸ’¡ <b>Pro Tip:</b> ").append(bestMatch.getProTip());
            }

            return HelpResponseDTO.builder()
                    .responseType("TEXT_REPLY")
                    .botReply(botPrefix + finalReply.toString())
                    .logId(logId)
                    .navigationLink(bestMatch.getActionLink())
                    .navigationLabel(bestMatch.getActionLabel())
                    .uiElementSelector(bestMatch.getUiSelector()) // UI HIGHLIGHT
                    .build();
        } else {
            String logId = analyticsService.logChatInteraction(userId, activeScreenName, rawMessage, "SUGGESTION", score);
            return HelpResponseDTO.builder().responseType("SUGGESTION")
                    .botReply(botPrefix + responseGenerator.generateSuggestionResponse())
                    .items(matches.stream().limit(3).collect(Collectors.toList())).logId(logId).build();
        }
    }


    // =========================================================================
    // SEARCH ALGORITHM
    // =========================================================================
    private List<HelpItemDTO> performSmartSearch(String normalizedQuery, String rawQuery, Integer activePermissionId, boolean isDefinition) {
        List<String> tokens = Arrays.asList(normalizedQuery.split("\\s+"));

        Stream<HelpItemDTO> questions = getAllActiveQuestions().stream().map(q -> {
            int score = calculateScore(q, normalizedQuery, rawQuery, tokens, activePermissionId, isDefinition);
            // Hive Mind Boost
            score += adaptiveService.getBehavioralBoost(normalizedQuery, q.getQuestionId());

            return mapToDTO(q, score);
        });

        Stream<HelpItemDTO> faqs = fetchGlobalFaqsEntity().stream().map(f -> {
            int score = calculateScore(f.getQuestionText(), null, null, normalizedQuery, rawQuery, tokens, null, false);
            return HelpItemDTO.builder().id(f.getFaqId()).text(f.getQuestionText()).answer(f.getAnswerContent()).type("FAQ").searchScore(score).build();
        });

        return Stream.concat(questions, faqs).filter(i -> i.getSearchScore() > 0)
                .sorted((a, b) -> Double.compare(b.getSearchScore(), a.getSearchScore())).limit(5).collect(Collectors.toList());
    }

    // =========================================================================
    // PREDICTIVE WORKFLOW ENGINE
    // =========================================================================

    @Cacheable("screen_name_to_id")
    public Integer resolveScreenToId(String screenName) {
        if (screenName == null) return null;
        // In real app, cache this map. Here querying DB.
        return permissionRepository.findIdByTitle(screenName);
    }


    private HelpItemDTO mapToDTO(HelpQuestionEntity q) {
        return mapToDTO(q, 0);
    }

    private HelpItemDTO mapToDTO(HelpQuestionEntity q, int score) {
        return HelpItemDTO.builder()
                .id(q.getQuestionId())
                .text(q.getQuestionText())
                .answer(q.getAnswerContent())
                .type("QUESTION")
                .requiredAction(q.getRequiredAction())
                .screenName(q.getScreenName()) // Still need string for UI
                .permissionId(q.getPermissionId())
                .actionLink(q.getActionLink())
                .actionLabel(q.getActionLabel())
                .proTip(q.getProTip())
                .uiSelector(q.getUiSelector())
                .searchScore(score)
                .build();
    }

    // =============================== Helper =================================
    private List<String> findScreensForAction(String roleId, String action) {
        // Fetch all permissions for role and filter by action
        // This logic mimics finding distinct screens where action is allowed
        return permissionRepository.findScreensByRoleAndAction(roleId, action);
    }


    private int calculateScore(HelpQuestionEntity q, String normalizedQuery, String rawQuery, List<String> tokens,
                               Integer activePermissionId, boolean isDefinition) {

        return calculateScore(q.getQuestionText(), q.getKeywords(), q.getPermissionId(), normalizedQuery, rawQuery,
                tokens, activePermissionId, isDefinition);
    }

    private int calculateScore(String text, String keywords, Integer qPermId, String normalizedQuery, String rawQuery,
                               List<String> tokens, Integer activePermId, boolean isDefinition) {
        double score = 0;
        String lowerText = text.toLowerCase();

        if (lowerText.equals(rawQuery.toLowerCase())) return 100;
        if (lowerText.contains(rawQuery.toLowerCase())) score += 50;

        int matches = 0;
        for (String token : tokens) {
            if (lowerText.contains(token) || (keywords != null && keywords.toLowerCase().contains(token))) {
                score += 15;
                matches++;
            } else if (fuzzyMatch(token, lowerText)) {
                score += 10;
                matches++;
            }
        }
        if (matches > 1) score += (matches * 5);

        if (activePermId != null && activePermId.equals(qPermId)) score = score * 2.5;

        if (isDefinition && text.toLowerCase().startsWith("what is")) score += 20;

        return (int) Math.min(score, 100);
    }


    // Levenshtein check (tolerance of 2 edits for words > 3 chars)
    private boolean fuzzyMatch(String token, String target) {
        if (target.contains(token)) return true;
        if (token.length() < 3) return false;

        // Check against each word in target to avoid matching across word boundaries
        for (String word : target.split("\\W+")) {
            if (calculateDistance(token, word) <= 1) return true;
        }
        return false;
    }

    private boolean isActionMatchFuzzy(String query, String action) {
        String actionLower = action.toLowerCase();
        // Check direct presence
        if (query.contains(actionLower)) return true;
        // Check fuzzy on tokens
        for (String token : tokenize(query)) {
            if (fuzzyMatch(token, actionLower)) return true;
        }
        // Check synonyms
        List<String> synonyms = SYNONYMS.getOrDefault(actionLower, Collections.emptyList());
        for (String syn : synonyms) {
            if (query.contains(syn)) return true;
        }
        return false;
    }

    // Standard Edit Distance Algo
    private int calculateDistance(String x, String y) {
        int[][] dp = new int[x.length() + 1][y.length() + 1];
        for (int i = 0; i <= x.length(); i++) {
            for (int j = 0; j <= y.length(); j++) {
                if (i == 0) dp[i][j] = j;
                else if (j == 0) dp[i][j] = i;
                else dp[i][j] = Math.min(dp[i - 1][j - 1] + (x.charAt(i - 1) == y.charAt(j - 1) ? 0 : 1),
                            Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
            }
        }
        return dp[x.length()][y.length()];
    }

    // =========================================================================
    // CACHING & UTILS
    // =========================================================================

    @Cacheable(value = "help_questions", key = "#screenName")
    public List<HelpQuestionEntity> getQuestionsForScreen(String screenName) {
        return questionRepository.findByScreenNameAndIsActiveOrderByDisplayOrderAsc(screenName, "Y");
    }

    @Cacheable(value = "help_questions_all", key = "'active_global'")
    public List<HelpQuestionEntity> getAllActiveQuestions() {
        return questionRepository.findByIsActive("Y");
    }

    @Cacheable(value = "help_faqs_all")
    public List<HelpFaqEntity> fetchGlobalFaqsEntity() {
        return faqRepository.findByIsActiveOrderByDisplayOrderAsc("Y");
    }

    public List<HelpItemDTO> fetchGlobalFaqs() {
        return faqRepository.findByIsActiveOrderByDisplayOrderAsc("Y").stream()
                .map(f -> HelpItemDTO.builder().id(f.getFaqId()).text(f.getQuestionText()).type("FAQ").build())
                .collect(Collectors.toList());
    }

    private boolean isActionAllowed(HelpQuestionEntity q, List<String> userActions) {
        // If question has no restricted action, it's public for that screen
        if (q.getRequiredAction() == null || q.getRequiredAction().trim().isEmpty()) return true;

        // Super Admin Bypass
        if (userActions.contains("ALL") || userActions.contains("*")) return true;

        // Check List Inclusion
        return userActions.contains(q.getRequiredAction().toUpperCase());
    }

    private List<String> normalizeActions(List<String> actions) {
        return actions == null ? Collections.emptyList() : actions.stream().map(String::toUpperCase).collect(Collectors.toList());
    }

    private boolean isActionMatch(String query, String action) {
        // Check exact action
        if (query.contains(action.toLowerCase())) return true;
        // Check synonyms (e.g., "Add" matches "CREATE")
        List<String> synonyms = SYNONYMS.getOrDefault(action.toLowerCase(), Collections.emptyList());
        for (String syn : synonyms) {
            if (query.contains(syn)) return true;
        }
        return false;
    }

    private boolean matchesSynonym(String token, String text) {
        for (List<String> synonymList : SYNONYMS.values()) {
            if (synonymList.contains(token)) {
                for (String syn : synonymList) {
                    if (text.contains(syn)) return true;
                }
            }
        }
        return false;
    }

    private String inferScreenFromQuery(String query) {
        String lower = query.toLowerCase();
        if (lower.contains("cgl")) return "CGL Management";
        if (lower.contains("segment")) return "Segment Management";
        if (lower.contains("branch")) return "Branch Management";
        if (lower.contains("user")) return "User Management";
        return null;
    }

    private List<String> tokenize(String query) {
        return Arrays.asList(query.split("\\W+"));
    }


}





















package com.fincore.helpservice.service;

import com.fincore.helpservice.model.HelpSynonymEntity;
import com.fincore.helpservice.repository.HelpSynonymRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class AdaptiveSearchService {
    private final HelpSynonymRepository synonymRepository;
    private final Map<String, String> synonymCache = new ConcurrentHashMap<>();

    public AdaptiveSearchService(HelpSynonymRepository synonymRepository) {
        this.synonymRepository = synonymRepository;
    }

    @PostConstruct
    @Scheduled(fixedRate = 1800000)
    public void refreshKnowledge() {
        List<HelpSynonymEntity> synonyms = synonymRepository.findByIsActive("Y");
        synonymCache.clear();
        for (HelpSynonymEntity syn : synonyms) {
            synonymCache.put(syn.getTerm().toLowerCase(), syn.getRootIntent().toUpperCase());
        }
    }

    public String getRootFromSynonym(String word) {
        return synonymCache.getOrDefault(word.toLowerCase(), word);
    }

    public int getBehavioralBoost(String query, String qId) {
        // Implementation of logic described in previous turns (Analytics lookup)
        return 0; // Stub
    }
}










package com.fincore.helpservice.service;

import lombok.Data;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Manages Short-Term Conversational Memory.
 * Allows the bot to understand follow-up questions like "What about Segment?"
 */
@Service
public class ChatSessionService {

    //todo In a real prod env, use Redis. For now, ConcurrentMap is perfect for single instance.
    private final Map<String, UserSession> sessions = new ConcurrentHashMap<>();

    @Data
    public static class UserSession {
        private String lastAction;      // e.g. "CREATE"
        private String lastScreen;      // e.g. "CGL Management"
        private String lastTopic;       // NEW: e.g. "CGL", "Segment", "User"
        private LocalDateTime lastInteraction;
    }

    public void updateSession(String userId, String action, String screen, String topic) {
        if (userId == null) return;

        UserSession session = sessions.getOrDefault(userId, new UserSession());

        if (action != null) session.setLastAction(action);
        if (screen != null) session.setLastScreen(screen);
        if (topic != null) session.setLastTopic(topic); // Store the noun

        session.setLastInteraction(LocalDateTime.now());
        sessions.put(userId, session);
    }

    public UserSession getSession(String userId) {
        UserSession session = sessions.get(userId);
        if (session == null) return null;

        // Session Timeout (e.g., 5 minutes)
        if (session.getLastInteraction().plusMinutes(5).isBefore(LocalDateTime.now())) {
            sessions.remove(userId);
            return null;
        }
        return session;
    }

    public void clearSession(String userId) {
        sessions.remove(userId);
    }
}








package com.fincore.helpservice.service;

import org.springframework.stereotype.Service;
import java.util.Map;

@Service
public class ContentInjectorService {

    // In a real app, inject your ConfigurationService here
    private final Map<String, String> LIVE_CONFIGS = Map.of(
            "{CUTOFF_TIME}", "3:30 PM",
            "{SUPPORT_EMAIL}", "fincore-support@bank.com",
            "{CURRENT_VERSION}", "v2.5.1",
            "{FOREX_RATE_SOURCE}", "Reuters API"
    );

    public String injectDynamicContent(String rawContent) {
        if (rawContent == null) return null;
        String processed = rawContent;

        for (Map.Entry<String, String> entry : LIVE_CONFIGS.entrySet()) {
            if (processed.contains(entry.getKey())) {
                processed = processed.replace(entry.getKey(), entry.getValue());
            }
        }
        return processed;
    }
}










package com.fincore.helpservice.service;

import com.fincore.helpservice.dto.FeedbackRequestDTO;
import com.fincore.helpservice.model.HelpSearchAnalyticsEntity;
import com.fincore.helpservice.model.HelpUnansweredEntity;
import com.fincore.helpservice.repository.HelpAnalyticsRepository;
import com.fincore.helpservice.repository.HelpUnansweredRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class HelpAnalyticsService {
    private final HelpAnalyticsRepository analyticsRepository;
    private final HelpUnansweredRepository unansweredRepository;

    // Log returns ID immediately (Synchronous save for simplicity to ensure ID availability)
    @Transactional
    public String logChatInteraction(String userId, String screenContext, String query, String status, int score) {
        try {
            HelpSearchAnalyticsEntity entity = new HelpSearchAnalyticsEntity();
            entity.generateId();
            entity.setUserId(userId != null ? userId : "ANONYMOUS");
            entity.setScreenContext(screenContext);
            entity.setSearchQuery(query);
            entity.setResultStatus(status);
            entity.setConfidenceScore(score);
            analyticsRepository.save(entity);
            return entity.getLogId();
        } catch (Exception e) {
            log.error("Failed to log analytics", e);
            return null;
        }
    }

    @Async
    public void logUnansweredQuery(String userId, String query) {
        HelpUnansweredEntity entity = new HelpUnansweredEntity();
        entity.setUserId(userId);
        entity.setUserQuery(query);
        unansweredRepository.save(entity);
    }

    @Transactional
    public void submitFeedback(FeedbackRequestDTO request) {
        analyticsRepository.findById(request.getLogId()).ifPresent(log -> {
            log.setClickedQuestionId(request.getClickedQuestionId());
            analyticsRepository.save(log);
        });
    }
}










package com.fincore.helpservice.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * THE BRAIN.
 * Responsible for understanding English grammar, identifying intents,
 * and normalizing complex sentences into executable commands.
 */
@Service
public class NLPEngine {
    private static final Set<String> NEGATION_WORDS = Set.of(
            "not", "cant", "cannot", "unable", "fail", "failed", "failing", "error", "issue", "problem", "broken", "wont"
    );
    // REGEX PATTERNS
    private static final Pattern ERROR_CODE_PATTERN = Pattern.compile("\\b[A-Z]{3,4}-\\d{3,5}\\b"); // Matches FIN-101, ORA-9000
    private static final Pattern NAV_PATTERN = Pattern.compile("\\b(go to|open|take me to|navigate to)\\b");
    private static final Pattern CAPABILITY_PATTERN = Pattern.compile("\\b(what can i do|my rights|my permissions|access do i have)\\b");
    private static final Pattern DEFINITION_PATTERN = Pattern.compile("\\b(what is|define|meaning of)\\b");
    private static final Pattern RESET_PATTERN = Pattern.compile("\\b(stop|cancel|wrong|start over|reset)\\b");
    private static final Pattern PRONOUN_PATTERN = Pattern.compile("\\b(it|this|that)\\b", Pattern.CASE_INSENSITIVE);
    private static final Pattern TROUBLE_PATTERN = Pattern.compile("\\b(cant|cannot|fail|error|issue)\\b", Pattern.CASE_INSENSITIVE);
    private static final Pattern DEF_PATTERN = Pattern.compile("\\b(what is|define)\\b", Pattern.CASE_INSENSITIVE);
    // Noise words that don't add meaning to our specific domain
    private static final Set<String> STOP_WORDS = Set.of(
            "i", "me", "my", "myself", "we", "our", "ours", "ourselves", "you", "your", "yours",
            "yourself", "yourselves", "he", "him", "his", "himself", "she", "her", "hers",
            "herself", "it", "its", "itself", "they", "them", "their", "theirs", "themselves",
            "what", "which", "who", "whom", "this", "that", "these", "those", "am", "is", "are",
            "was", "were", "be", "been", "being", "have", "has", "had", "having", "do", "does",
            "did", "doing", "a", "an", "the", "and", "but", "if", "or", "because", "as", "until",
            "while", "of", "at", "by", "for", "with", "about", "against", "between", "into",
            "through", "during", "before", "after", "above", "below", "to", "from", "up", "down",
            "in", "out", "on", "off", "over", "under", "again", "further", "then", "once", "here",
            "there", "when", "where", "why", "how", "all", "any", "both", "each", "few", "more",
            "most", "other", "some", "such", "no", "nor", "not", "only", "own", "same", "so",
            "than", "too", "very", "s", "t", "can", "will", "just", "don", "should", "now", "please", "kindly", "help"
    );
    // ACTION MAPPING - Maps various English variations to a Core Action
    private static final Map<String, String> ACTION_ROOTS = new HashMap<>();

    static {
        // CREATE roots
        List.of("create", "creation", "creating", "created", "add", "adding", "addition", "new", "generate", "generation", "make", "making", "raise", "raising")
                .forEach(w -> ACTION_ROOTS.put(w, "CREATE"));

        // MODIFY roots
        List.of("modify", "modification", "modifying", "edit", "editing", "edits", "update", "updating", "change", "changing", "correction", "correct")
                .forEach(w -> ACTION_ROOTS.put(w, "MODIFY"));

        // APPROVE roots
        List.of("approve", "approval", "approving", "approved", "accept", "accepting", "accepted", "authorize", "authorization", "sign", "pass", "passing")
                .forEach(w -> ACTION_ROOTS.put(w, "APPROVE"));

        // VIEW roots
        List.of("view", "viewing", "show", "showing", "see", "seeing", "check", "checking", "display", "list", "listing", "fetch", "get")
                .forEach(w -> ACTION_ROOTS.put(w, "VIEW"));

        // DELETE roots
        List.of("delete", "deletion", "deleting", "remove", "removing", "removal", "cancel", "cancelling", "trash", "drop")
                .forEach(w -> ACTION_ROOTS.put(w, "DELETE"));

        // DOWNLOAD roots
        List.of("download", "export", "save", "print")
                .forEach(w -> ACTION_ROOTS.put(w, "DOWNLOAD"));
    }

    @Autowired
    private AdaptiveSearchService adaptiveService;

    private boolean isKnownAction(String word) {
        return Set.of("CREATE", "MODIFY", "APPROVE", "VIEW", "DELETE", "DOWNLOAD").contains(word);
    }

    /**
     * Input: "Can I please creating a new CGL?"
     * Output: "create cgl"
     */
    public String extractNormalizedIntent(String sentence) {
        if (sentence == null) return "";
        String clean = sentence.toLowerCase().replaceAll("[^a-z0-9\\s]", " ");
        StringBuilder normalized = new StringBuilder();

        for (String word : clean.split("\\s+")) {
            if (word.isEmpty()) continue;
            if (STOP_WORDS.contains(word)) continue;

            // DYNAMIC LOOKUP from DB/Cache
            String root = adaptiveService.getRootFromSynonym(word);
            normalized.append(root).append(" ");
        }
        return normalized.toString().trim();
    }

    /**
     * Identifies the ACTION verb from the sentence.
     */
    public String detectAction(String normalizedSentence) {
        // Simplified detection logic checking if words are known Actions
        for (String word : normalizedSentence.split(" ")) {
            String root = adaptiveService.getRootFromSynonym(word);
            if (isKnownAction(root)) return root;
        }
        return null;
    }

    /**
     * Identifies the MODULE/CONTEXT from the sentence based on known screens.
     */
    public String detectScreen(String sentence) {
        String lower = sentence.toLowerCase();
        // Specific checks for multi-word screens
        if (lower.contains("cgl")) return "CGL Management";
        if (lower.contains("segment")) return "Segment Management";
        if (lower.contains("branch")) return "Branch Management";
        if (lower.contains("user")) return "User Management";
        if (lower.contains("role")) return "Role Management";
        if (lower.contains("calendar")) return "Calendar Configuration";
        if (lower.contains("state")) return "State Management";
        if (lower.contains("currency") && lower.contains("rate")) return "Currency Rate Management";
        if (lower.contains("currency")) return "Currency Management";
        if (lower.contains("journal")) return "Journal Management";
        if (lower.contains("report")) return "Reports";

        return null;
    }

    /**
     * Detects if the user is expressing inability to perform an action.
     * "I cannot create" -> true
     */
    public boolean isNegatedOrTrouble(String sentence) {
        if (sentence == null) return false;
        String lower = sentence.toLowerCase();

        for (String neg : NEGATION_WORDS) {
            // Check word boundaries so "note" doesn't trigger "not"
            if (java.util.regex.Pattern.compile("\\b" + neg + "\\b").matcher(lower).find()) {
                return true;
            }
        }
        return false;
    }

    public boolean containsPronoun(String t) {
        return t != null && PRONOUN_PATTERN.matcher(t).find();
    }

    public String resolveAnaphora(String t, String topic) {
        return PRONOUN_PATTERN.matcher(t).replaceAll(topic);
    }

    public boolean isTrouble(String t) {
        return t != null && TROUBLE_PATTERN.matcher(t).find();
    }

    /**
     * Extracts an error code like "FIN-909" from the text.
     */
    public String extractErrorCode(String text) {
        if (text == null) return null;
        Matcher m = ERROR_CODE_PATTERN.matcher(text.toUpperCase());
        if (m.find()) {
            return m.group();
        }
        return null;
    }

    public boolean isNavigationCommand(String text) {
        return text != null && NAV_PATTERN.matcher(text.toLowerCase()).find();
    }

    public boolean isCapabilityRequest(String text) {
        return text != null && CAPABILITY_PATTERN.matcher(text.toLowerCase()).find();
    }

    public boolean isDefinitionRequest(String text) {
        return text != null && DEFINITION_PATTERN.matcher(text.toLowerCase()).find();
    }

    public boolean isResetRequest(String text) {
        return text != null && RESET_PATTERN.matcher(text.toLowerCase()).find();
    }

}













package com.fincore.helpservice.service;

import com.fincore.helpservice.repository.PermissionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class PermissionService {

    private final PermissionRepository permissionRepository;

    /**
     * CACHED: Roles/Permissions rarely change mid-session.
     * Cache for 10-15 mins (configured in app.properties).
     */
    @Cacheable(value = "user_actions_cache", key = "#roleId + '_' + #screenName")
    public List<String> getUserActions(String roleId, String screenName) {
        if (screenName == null) return Collections.emptyList();

        List<String> actionStrings = permissionRepository.findActionForUserAndScreen(roleId, screenName);

        if (actionStrings == null || actionStrings.isEmpty()) {
            return Collections.emptyList();
        }

        return actionStrings.stream()
                .filter(Objects::nonNull)
                .flatMap(s -> Arrays.stream(s.split("\\|")))
                .map(String::trim)
                .map(String::toUpperCase)
                .distinct()
                .collect(Collectors.toList());
    }

    /**
     * Generates a polite "Access Denied" message based on the missing action.
     */
    public String getAccessDeniedMessage(String requiredAction, String screenName) {
        String module = (screenName != null) ? screenName : "this module";
        requiredAction = (requiredAction != null) ? requiredAction.toLowerCase() : "perform this action";

        return switch (requiredAction.toUpperCase()) {
            case "CREATE" ->
                    "You do not have rights to create entries in " + module + ". Users with creation rights can perform this. Please contact support.";
            case "APPROVE" ->
                    "You do not have approval rights for " + module + ". Please wait for an executor to process requests, or check 'My Requests' to view status.";
            case "MODIFY" ->
                    "You do not have permission to modify records in " + module + ".";
            case "DELETE" ->
                    "Deletion is restricted. You do not have the required permissions.";
            default ->
                    "You do not have the required permissions (" + requiredAction + ") to perform this action.";
        };
    }
}


















package com.fincore.helpservice.service;

import org.springframework.stereotype.Service;
import java.util.Set;

@Service
public class SentimentAnalyzer {

    private static final Set<String> NEGATIVE_WORDS = Set.of(
            "stupid", "useless", "bad", "hate", "broken", "fail", "idiot", "worst", "garbage", "nonsense"
    );

    public enum Sentiment {
        NEUTRAL, FRUSTRATED, ANGRY
    }

    public Sentiment analyze(String text) {
        if (text == null || text.trim().isEmpty()) return Sentiment.NEUTRAL;

        String clean = text.trim();

        // 1. CAPS LOCK DETECTION (If > 60% of chars are uppercase and length > 5)
        long upperCount = clean.chars().filter(Character::isUpperCase).count();
        long letterCount = clean.chars().filter(Character::isLetter).count();

        if (letterCount > 5 && ((double) upperCount / letterCount) > 0.6) {
            return Sentiment.ANGRY;
        }

        // 2. KEYWORD DETECTION
        String lower = clean.toLowerCase();
        for (String badWord : NEGATIVE_WORDS) {
            if (lower.contains(badWord)) return Sentiment.FRUSTRATED;
        }

        return Sentiment.NEUTRAL;
    }

    public String getDeEscalationMessage(Sentiment sentiment) {
        if (sentiment == Sentiment.ANGRY) {
            return "I notice you seem upset. I apologize if I haven't been helpful. Let's try to solve this step-by-step.";
        } else if (sentiment == Sentiment.FRUSTRATED) {
            return "I understand this might be frustrating. I'm doing my best to find the right information for you.";
        }
        return "";
    }
}






















package com.fincore.helpservice.service;

import org.springframework.stereotype.Service;
import java.util.*;
import java.util.regex.Pattern;

@Service
public class SmallTalkService {

    private static final Map<List<String>, List<String>> CONVERSATIONS = new HashMap<>();

    static {
        // Greetings
        CONVERSATIONS.put(List.of("hi", "hello", "hey", "greetings", "good morning", "good afternoon", "good evening"),
                List.of("Hello! How can I help you today?", "Hi there! What can I do for you?", "Greetings! Need help with FinCore?"));

        // Status
        CONVERSATIONS.put(List.of("how are you", "how are you doing", "what's up"),
                List.of("I'm doing great, thanks for asking! How about you?", "I am fully operational and ready to help."));

        // Gratitude
        CONVERSATIONS.put(List.of("thank", "thanks", "thank you", "thx", "cool", "awesome"),
                List.of("You're welcome!", "Glad I could help.", "Anytime!"));

        // Identity
        CONVERSATIONS.put(List.of("who are you", "what are you", "your name"),
                List.of("I am the FinCore Smart Assistant.", "I'm a bot designed to help you navigate FinCore."));

        // Frustration (Handling negative sentiment)
        CONVERSATIONS.put(List.of("stupid", "useless", "dumb", "hate", "idiot"),
                List.of("I'm sorry if I wasn't helpful. I'm still learning.", "Apologies. Could you try rephrasing your question?"));
    }

    public String getSmallTalkResponse(String userMessage) {
        String lower = userMessage.toLowerCase().replaceAll("[^a-z\\s]", "");

        for (Map.Entry<List<String>, List<String>> entry : CONVERSATIONS.entrySet()) {
            for (String keyPhrase : entry.getKey()) {
                // STRICT MATCH: Use Regex \b to ensure whole word match
                // Matches "hi" but not "high"
                if (Pattern.compile("\\b" + Pattern.quote(keyPhrase) + "\\b").matcher(lower).find()) {
                    List<String> responses = entry.getValue();
                    return responses.get(new Random().nextInt(responses.size()));
                }
            }
        }
        return null; // Not small talk
    }
}















package com.fincore.helpservice.service;

import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Random;

@Service
public class SmartResponseGenerator {

    private final Random random = new Random();

    // --- HIGH CONFIDENCE PHRASES (90-100%) ---
    private final List<String> HIGH_CONFIDENCE_INTROS = List.of(
            "I found exactly what you're looking for:",
            "Here is the answer:",
            "Check this out:",
            "According to the documentation, here is the procedure:",
            "I can help with that. Here are the details:"
    );

    // --- MEDIUM CONFIDENCE PHRASES (60-89%) ---
    private final List<String> MED_CONFIDENCE_INTROS = List.of(
            "I think this is what you need:",
            "This looks like the right topic:",
            "I believe this answers your question:",
            "Here is the most relevant information I found:"
    );

    // --- LOW CONFIDENCE PHRASES (<60%) ---
    private final List<String> LOW_CONFIDENCE_INTROS = List.of(
            "I'm not 100% sure, but this might help:",
            "This is the closest match I could find:",
            "I couldn't find an exact match, but take a look at this:"
    );

    // --- PERMISSION PHRASES ---
    private final List<String> PERMISSION_GRANTED_INTROS = List.of(
            "Good news, %s. You have the required permissions.",
            "Yes, %s, your profile allows this action.",
            "You are authorized to proceed, %s."
    );

    public String generateSearchIntro(int score) {
        if (score >= 90) return getRandom(HIGH_CONFIDENCE_INTROS);
        if (score >= 60) return getRandom(MED_CONFIDENCE_INTROS);
        return getRandom(LOW_CONFIDENCE_INTROS);
    }

    public String generatePermissionResponse(boolean isAllowed, String action, String module, String user) {
        String userName = (user != null) ? user : "there";

        if (isAllowed) {
            String template = getRandom(PERMISSION_GRANTED_INTROS);
            return String.format(template + " You can **%s** in **%s**.", userName, action, module);
        } else {
            return switch (action) {
                case "CREATE" ->
                        String.format("I checked your profile, %s. Unfortunately, you **do not** have rights to create entries in **%s**.", userName, module);
                case "APPROVE" ->
                        String.format("No, %s. Approval in **%s** is restricted. You need 'APPROVER' rights for this.", userName, module);
                case "DELETE" ->
                        String.format("Sorry %s, deletion is a sensitive action in **%s** and you don't have permissions.", userName, module);
                default ->
                        String.format("No, %s. You are not authorized to perform **%s** in **%s**.", userName, module, action);
            };
        }
    }

    public String generateSuggestionResponse() {
        List<String> intros = List.of(
                "I'm not entirely sure, but did you mean one of these?",
                "I found a few similar topics:",
                "Here are a few options that might match:"
        );
        return getRandom(intros);
    }

    private String getRandom(List<String> options) {
        return options.get(random.nextInt(options.size()));
    }
}














package com.fincore.helpservice.service;

import org.springframework.stereotype.Service;
import java.util.HashMap;
import java.util.Map;

@Service
public class SupportRoutingService {

    private static final Map<String, String> DEPARTMENT_MAP = new HashMap<>();

    static {
        DEPARTMENT_MAP.put("TAX", "Taxation Team (tax-ops@fincore.com)");
        DEPARTMENT_MAP.put("GST", "Taxation Team (tax-ops@fincore.com)");
        DEPARTMENT_MAP.put("VAT", "Taxation Team (tax-ops@fincore.com)");
        DEPARTMENT_MAP.put("SERVER", "IT Operations (support@fincore.com)");
        DEPARTMENT_MAP.put("SLOW", "IT Operations (support@fincore.com)");
        DEPARTMENT_MAP.put("ERROR", "IT Operations (support@fincore.com)");
        DEPARTMENT_MAP.put("LEDGER", "GL Ops Team (gl-support@fincore.com)");
        DEPARTMENT_MAP.put("BALANCE", "GL Ops Team (gl-support@fincore.com)");
        DEPARTMENT_MAP.put("USER", "Security Admin (security@fincore.com)");
        DEPARTMENT_MAP.put("PASSWORD", "Security Admin (security@fincore.com)");
    }

    public String getSupportContact(String query) {
        String upperQuery = query.toUpperCase();
        for (Map.Entry<String, String> entry : DEPARTMENT_MAP.entrySet()) {
            if (upperQuery.contains(entry.getKey())) {
                return entry.getValue();
            }
        }
        return "the IT Helpdesk (helpdesk@fincore.com)"; // Default
    }
}
















package com.fincore.helpservice.service;

import org.springframework.stereotype.Service;
import java.time.LocalTime;

@Service
public class SystemHealthService {

    /**
     * Checks if there are known system issues/maintenance.
     * In a real app, this would query your Job Scheduler or Health Actuator.
     */
    public String getSystemStatusMessage() {
        // Simulation: "EOD Batch" runs between 11 PM and 1 AM
        LocalTime now = LocalTime.now();
        if (now.isAfter(LocalTime.of(23, 0)) || now.isBefore(LocalTime.of(1, 0))) {
            return "âš ï¸ **System Alert:** The End-of-Day (EOD) Batch Process is currently active. You may experience slower response times or read-only access in the Ledger modules.";
        }

        // Simulation: Random "Database Maintenance" check
        // return "âš ï¸ **Maintenance:** Scheduled database maintenance is in progress.";

        return null; // System is healthy
    }
}









package com.fincore.helpservice.service;

import com.fincore.helpservice.repository.HelpAnalyticsRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

import java.awt.print.Pageable;
import java.util.List;

@Service
@RequiredArgsConstructor
public class UserProfileService {

    private final HelpAnalyticsRepository analyticsRepository;

    /**
     * Generates a personalized greeting based on history.
     */
    public String getSmartWelcomeMessage(String userId, String userName) {
        // Fetch top 1 most frequent search
        List<String> topSearches = analyticsRepository.findTopSearchesByUser(userId, (Pageable) PageRequest.of(0, 1));

        if (topSearches.isEmpty()) {
            return "Hello " + userName + "! How can I help you navigate FinCore today?";
        }

        String favoriteTopic = topSearches.get(0);
        return String.format("Welcome back, %s! picking up where you left off with **%s**? Or need help with something else?",
                userName, favoriteTopic);
    }
}











package com.fincore.helpservice.repository;

import com.fincore.helpservice.model.HelpSearchAnalyticsEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.awt.print.Pageable;
import java.util.List;

@Repository
public interface HelpAnalyticsRepository extends JpaRepository<HelpSearchAnalyticsEntity, String> {

    // Find top 3 most searched phrases for a specific user
    @Query("SELECT h.searchQuery FROM HelpSearchAnalyticsEntity h " +
            "WHERE h.userId = :userId " +
            "GROUP BY h.searchQuery " +
            "ORDER BY COUNT(h) DESC")
    List<String> findTopSearchesByUser(@Param("userId") String userId, Pageable pageable);
}








package com.fincore.helpservice.repository;


import com.fincore.helpservice.model.HelpFaqEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface HelpFaqRepository extends JpaRepository<HelpFaqEntity, String> {

    // Global FAQs
    List<HelpFaqEntity> findByIsActiveOrderByDisplayOrderAsc(String isActive);
}










package com.fincore.helpservice.repository;


import com.fincore.helpservice.model.HelpQuestionEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface HelpQuestionRepository extends JpaRepository<HelpQuestionEntity, String> {

    // For Context Mode: Select Module
    List<HelpQuestionEntity> findByScreenNameAndIsActiveOrderByDisplayOrderAsc(String screenName, String isActive);

    // For Search Mode: Fetch All Active
    List<HelpQuestionEntity> findByIsActive(String isActive);
}











package com.fincore.helpservice.repository;

import com.fincore.helpservice.model.HelpScreenEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface HelpScreenRepository extends JpaRepository<HelpScreenEntity, String> {
}











package com.fincore.helpservice.repository;

import com.fincore.helpservice.model.HelpSynonymEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface HelpSynonymRepository extends JpaRepository<HelpSynonymEntity, Integer> {
    List<HelpSynonymEntity> findByIsActive(String isActive);
}









package com.fincore.helpservice.repository;

import com.fincore.helpservice.model.HelpScreenEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface HelpScreenRepository extends JpaRepository<HelpScreenEntity, String> {
}








package com.fincore.helpservice.repository;


import com.fincore.helpservice.model.HelpQuestionEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface HelpQuestionRepository extends JpaRepository<HelpQuestionEntity, String> {

    // For Context Mode: Select Module
    List<HelpQuestionEntity> findByScreenNameAndIsActiveOrderByDisplayOrderAsc(String screenName, String isActive);

    // For Search Mode: Fetch All Active
    List<HelpQuestionEntity> findByIsActive(String isActive);
}











package com.fincore.helpservice.repository;


import com.fincore.helpservice.model.HelpFaqEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface HelpFaqRepository extends JpaRepository<HelpFaqEntity, String> {

    // Global FAQs
    List<HelpFaqEntity> findByIsActiveOrderByDisplayOrderAsc(String isActive);
}








package com.fincore.helpservice.repository;

import com.fincore.helpservice.model.HelpSearchAnalyticsEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.awt.print.Pageable;
import java.util.List;

@Repository
public interface HelpAnalyticsRepository extends JpaRepository<HelpSearchAnalyticsEntity, String> {

    // Find top 3 most searched phrases for a specific user
    @Query("SELECT h.searchQuery FROM HelpSearchAnalyticsEntity h " +
            "WHERE h.userId = :userId " +
            "GROUP BY h.searchQuery " +
            "ORDER BY COUNT(h) DESC")
    List<String> findTopSearchesByUser(@Param("userId") String userId, Pageable pageable);
}









package com.fincore.helpservice.model;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.UUID;


/**
 * ENTITY: HELP_FAQ_MASTER
 * Global FAQs.
 */
@Data
@Entity
@Table(name = "HELP_FAQ_MASTER")
public class HelpFaqEntity implements Serializable {

    @Id
    @Column(name = "FAQ_ID", length = 50)
    private String faqId;

    @Column(name = "QUESTION_TEXT", length = 500)
    private String questionText;

    @Lob
    @Column(name = "ANSWER_CONTENT")
    private String answerContent;

    @Column(name = "DISPLAY_ORDER")
    private Integer displayOrder;

    @Column(name = "IS_ACTIVE")
    private String isActive;

    @PrePersist
    public void prePersist() {
        if (this.faqId == null || this.faqId.isEmpty()) {
            this.faqId = UUID.randomUUID().toString();
        }
    }
}






package com.fincore.helpservice.model;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.UUID;


/**
 * ENTITY: HELP_QUESTION_MASTER
 * Represents individual help items.
 * Includes logic for auto-generating UUIDs if not provided.
 */

@Data
@Entity
@Table(name = "HELP_QUESTION_MASTER")
public class HelpQuestionEntity {
    @Id
    @Column(name = "QUESTION_ID")
    private String questionId;

    @Column(name = "QUESTION_TEXT")
    private String questionText;

    @Lob
    @Column(name = "ANSWER_CONTENT")
    private String answerContent;

    @Column(name = "KEYWORDS")
    private String keywords;

    @Column(name = "IS_ACTIVE")
    private String isActive;

    @Column(name = "SCREEN_NAME")
    private String screenName; // For UI display

    @Column(name = "PERMISSION_ID")
    private Integer permissionId; // For robust linking

    @Column(name = "REQUIRED_ACTION")
    private String requiredAction;

    @Column(name = "ACTION_LINK")
    private String actionLink;

    @Column(name = "ACTION_LABEL")
    private String actionLabel;

    @Column(name = "PRO_TIP")
    private String proTip;       // The Wisdom

    @Column(name = "UI_SELECTOR")
    private String uiSelector;   // The Guide

    @Column(name = "RELATED_QUESTION_IDS")
    private String relatedQuestionIds;

    @Column(name = "DISPLAY_ORDER")
    private Integer displayOrder;


    // Auto-generate UUID if missing
    @PrePersist
    public void prePersist() {
        if (this.questionId == null || this.questionId.isEmpty()) {
            this.questionId = UUID.randomUUID().toString().replace("-", "").substring(0, 32);
        }
    }
}






package com.fincore.helpservice.model;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import java.io.Serializable;
import java.time.LocalDateTime;


/**
 * ENTITY: HELP_SCREEN_MASTER
 * Represents a functional module in the application (e.g., "CGL Management").
 */
@Data
@Entity
@Table(name = "HELP_SCREEN_MASTER")
public class HelpScreenEntity implements Serializable {

    @Id
    @Column(name = "SCREEN_NAME", length = 100)
    private String screenName;

    @Column(name = "SCREEN_LABEL", length = 100)
    private String screenLabel;

    @Column(name = "IS_ACTIVE", length = 1)
    private String isActive;

    @CreationTimestamp
    @Column(name = "CREATED_AT", updatable = false)
    private LocalDateTime createdAt;
}





package com.fincore.helpservice.model;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Entity: HELP_SEARCH_ANALYTICS
 * Purpose: Logs every chat interaction for future analysis.
 */
@Data
@Entity
@Table(name = "HELP_SEARCH_ANALYTICS")
public class HelpSearchAnalyticsEntity {

    @Id
    @Column(name = "LOG_ID", length = 50)
    private String logId;

    @Column(name = "USER_ID", length = 50)
    private String userId;

    @Column(name = "SEARCH_QUERY", length = 500)
    private String searchQuery;

    @Column(name = "SCREEN_CONTEXT", length = 100)
    private String screenContext;

    // Enum values: "ANSWERED", "SUGGESTION", "NO_MATCH"
    @Column(name = "RESULT_STATUS", length = 20)
    private String resultStatus;

    // 0-100
    @Column(name = "CONFIDENCE_SCORE")
    private Integer confidenceScore;

    // Populated later if user clicks a suggestion
    @Column(name = "CLICKED_Q_ID", length = 50)
    private String clickedQuestionId;

    @CreationTimestamp
    @Column(name = "SEARCH_TIMESTAMP", updatable = false)
    private LocalDateTime searchTimestamp;

    @PrePersist
    public void generateId() {
        if (this.logId == null || this.logId.isEmpty()) {
            this.logId = UUID.randomUUID().toString();
        }
    }
}







package com.fincore.helpservice.model;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
@Table(name = "HELP_SYNONYMS")
public class HelpSynonymEntity {

    @Id
    @Column(name = "SYNONYM_ID")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer synonymId;

    @Column(name = "TERM", unique = true)
    private String term; // e.g., "bucks", "glc", "add"

    @Column(name = "ROOT_INTENT")
    private String rootIntent; // e.g., "CURRENCY", "CGL", "CREATE"

    @Column(name = "IS_ACTIVE")
    private String isActive; // "Y" or "N"
}








package com.fincore.helpservice.model;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "HELP_UNANSWERED")
public class HelpUnansweredEntity {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String userQuery;
    private String userId;

    @CreationTimestamp
    private LocalDateTime timestamp;
}










package com.fincore.helpservice.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

@Data
@Entity
@Table(name = "PERMISSIONS")
public class PermissionEntity {

    @Id
    @Column(name = "MENU_ID")
    private Integer menuId;

    @Column(name = "MENU_TITLE") // e.g. "CGL Management"
    private String menuTitle;

    @Column(name = "MENU_ACTION") // e.g. "view|create|modify"
    private String menuAction;

}











package com.fincore.helpservice.model;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
@Table(name = "ROLE_PERMISSIONS")
@IdClass(RolePermissionId.class)
public class RolePermissionEntity {
    @Id
    @Column(name = "ROLE_ID")
    private Integer roleId;

    @Id
    @Column(name = "PERMISSION_ID")
    private Integer permissionId;
}












package com.fincore.helpservice.model;


import lombok.Data;

import java.io.Serializable;

@Data
class RolePermissionId implements Serializable {
    private Integer roleId;
    private Integer permissionId;
}









package com.fincore.helpservice.dto;

import lombok.Data;

@Data
public class FeedbackRequestDTO {
    private String logId;
    private String clickedQuestionId;
}




package com.fincore.helpservice.dto;

import lombok.Builder;
import lombok.Data;
import java.io.Serializable;

@Data
@Builder
public class HelpItemDTO implements Serializable {

    private String id;
    private String text;       // The Question
    private String answer;     // The Answer (HTML/Text)
    private String actionLink; // Deep Link
    private String actionLabel;// Button Text
    private String type;       // QUESTION, FAQ, SEARCH_RESULT
    private double searchScore;
    private Integer permissionId;
    private String uiSelector;

    // New Fields for Internal Logic
    private String requiredAction;
    private String screenName;
    private String proTip;
}








package com.fincore.helpservice.dto;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class HelpRequestDTO {

    /**
     * The intent of the user.
     * Values: MODULE_QUESTIONS, FAQ_LIST, GET_ANSWER, CHAT
     */
    @NotNull(message = "Request Type is mandatory")
    private String requestType;

    // --- Conditional Fields (based on requestType) ---

    // For MODULE_QUESTIONS
    private String screenName;

    // For GET_ANSWER (When user clicks a specific question)
    private String questionId;

    // For CHAT (When user types)
    private String chatMessage;

    // RBAC: User's Allowed Actions (from Login Token)
//    @NotNull(message = "User actions cannot be null")
    private List<String> userActions;
}









package com.fincore.helpservice.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Builder;
import lombok.Data;

import java.util.List;

@Data
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class HelpResponseDTO {

    /**
     * Tells the Client how to render the response.
     * - "TEXT_REPLY": Show a bot bubble with text.
     * - "LIST_SELECTION": Show a list of clickable options (Questions).
     * - "SUGGESTION": Show "Did you mean?" with options.
     * - "NO_MATCH": Show apology.
     */
    private String responseType;

    // The main text content (Answer or Apology)
    private String botReply;

    // List of items (Questions for Module, Suggestions, or FAQs)
    private List<HelpItemDTO> items;

    private String logId;

    // If the bot finds a direct link (e.g., "Take me to Create CGL"), send it here.
    private String navigationLink;  // e.g. "/cgl-management/create"

    private String navigationLabel; // e.g. "Go to Create Screen"

    private HelpItemDTO nextBestAction;

    private String uiElementSelector;
}










package com.fincore.helpservice.controller;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.fincore.helpservice.dto.ApiResponse;
import com.fincore.helpservice.dto.FeedbackRequestDTO;
import com.fincore.helpservice.dto.HelpRequestDTO;
import com.fincore.helpservice.dto.HelpResponseDTO;
import com.fincore.helpservice.service.HelpAnalyticsService;
import com.fincore.helpservice.service.HelpService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/help")
@RequiredArgsConstructor
@Slf4j
public class HelpController {

    private final HelpService helpService;
    private final JwtUtil jwtUtil;
    private final HelpAnalyticsService analyticsService;

    /**
     * Unified Help Endpoint.
     */
    @PostMapping("/fetch")
    public ResponseEntity<ApiResponse<HelpResponseDTO>> getHelp(@RequestHeader("Authorization") String token, @RequestBody @Valid HelpRequestDTO request) {

        log.info("Received Help Bot Request for Type: {}", request.getRequestType());

        // Delegate business logic to Service
        HelpResponseDTO result = helpService.processRequest(request, jwtUtil.getUserIdFromToken(token), String.valueOf(jwtUtil.getUserRoleFromToken(token)));

        // Return clean success response
        return ResponseEntity.ok(ApiResponse.success(result));
    }

    @PostMapping("/feedback")
    public ResponseEntity<Void> submitFeedback(@RequestBody FeedbackRequestDTO request) {
        analyticsService.submitFeedback(request);
        return ResponseEntity.ok().build();
    }
}









db tables after so many updates :
help_question_master : 
QUESTION_ID	VARCHAR2(50 CHAR)	No		1	
SCREEN_NAME	VARCHAR2(100 CHAR)	No		2	
QUESTION_TEXT	VARCHAR2(500 CHAR)	No		3	
ANSWER_CONTENT	CLOB	Yes		4	
ACTION_LINK	VARCHAR2(255 CHAR)	Yes		5	
ACTION_LABEL	VARCHAR2(50 CHAR)	Yes		6	
REQUIRED_ACTION	VARCHAR2(50 CHAR)	Yes		7	
KEYWORDS	VARCHAR2(1000 CHAR)	Yes		8	Synonyms used by the Java Fuzzy Search logic to improve relevance.
DISPLAY_ORDER	NUMBER(5,0)	Yes	0	9	
IS_ACTIVE	VARCHAR2(1 CHAR)	No	'Y' 	10	
CREATED_AT	TIMESTAMP(6)	Yes	SYSTIMESTAMP	11	
UPDATED_AT	TIMESTAMP(6)	Yes	SYSTIMESTAMP	12	
PERMISSION_ID	NUMBER(10,0)	Yes		13	
PRO_TIP	VARCHAR2(500 CHAR)	Yes		14	
UI_SELECTOR	VARCHAR2(100 CHAR)	Yes		15	
RELATED_QUESTION_IDS	VARCHAR2(200 CHAR)	Yes		16	


sammple data : 

Q_CGL_001	CGL Management	What is a CGL Code?	CGL (Central General Ledger) codes are used for financial tracking...				definition, meaning, what is	1	Y	22-01-26 05:35:14.163355000 PM	22-01-26 05:35:14.163355000 PM				
Q_CGL_002	CGL Management	How do I create a new CGL?	Click the "Add CGL" button in the top right corner.	/cgl-management/create	Go to Create	CREATE	add, new, insert, make, generate	2	Y	22-01-26 05:35:14.254842000 PM	22-01-26 05:35:14.254842000 PM				
Q_CGL_003	CGL Management	How to approve CGL requests?	Navigate to the "CGL Requests" tab and select "Approve" on the ballot.	/cgl-requests	View Requests	APPROVE	authorize, sign off, check, accept	3	Y	22-01-26 05:35:14.345141000 PM	22-01-26 05:35:14.345141000 PM				
Q_CGL_004	CGL Management	How to edit a CGL description?	Select the CGL from the list and click the Pencil icon.			MODIFY	edit, update, change, correct	4	Y	22-01-26 05:35:14.437519000 PM	22-01-26 05:35:14.437519000 PM				
Q_SEG_001	Segment Management	How to add a new Segment?	Use the Segment Master screen to add entries.			CREATE	add, new, create	0	Y	22-01-26 05:35:14.528850000 PM	22-01-26 05:35:14.528850000 PM				
Q_CGL_01	CGL Management	How to create a new CGL?	To create a CGL: 1. Navigate to CGL Management. 2. Click "Add". 3. Fill in the GL Code and Description. 4. Select the Account Type. 5. Click Save.			CREATE	add cgl new gl code	1	Y	11-02-26 02:26:32.364887000 PM	11-02-26 02:26:32.364887000 PM	10	Ensure the GL Code is unique. Once used in a transaction, it cannot be deleted.	#btn-add-cgl	Q_CGL_03,Q_DEF_01
Q_CGL_02	CGL Management	How to modify a CGL?	Locate the CGL in the grid, click the "Edit" (Pencil) icon, make your changes, and click Update.			MODIFY	edit update change cgl	2	Y	11-02-26 02:26:32.437705000 PM	11-02-26 02:26:32.437705000 PM	10	You cannot change the GL Code itself, only the description and status.		
Q_CGL_03	CGL Management	How to approve a CGL request?	Go to CGL Management > Pending Approvals tab. Select the record and click "Approve".			APPROVE	authorize sign pass	3	Y	11-02-26 02:26:32.482313000 PM	11-02-26 02:26:32.482313000 PM	10	Always verify the GL Type before approving to prevent reporting errors.		
Q_USER_01	User Management	How to add a new User?	Click the "Create User" button. Enter the Employee ID, Name, and assign a Role. The system will generate a temporary password.			CREATE	create staff member employee	1	Y	11-02-26 02:26:32.562436000 PM	11-02-26 02:26:32.562436000 PM	54		#btn-create-user	
Q_USER_02	User Management	How to reset a user password?	Find the user, select "Reset Password" from the action menu. An OTP will be sent to their registered email.			MODIFY	forgot password login unlock	2	Y	11-02-26 02:26:32.608554000 PM	11-02-26 02:26:32.608554000 PM	54	Users must change their password immediately after the first login.		
Q_SEG_01	Segment Management	How to create a Segment?	Navigate to Segment Master. Click Add. Define the Segment Hierarchy and Save.			CREATE	add segment structure	1	Y	11-02-26 02:26:32.683897000 PM	11-02-26 02:26:32.683897000 PM	60			
Q_DEF_01	CGL Management	What is CGL?	CGL stands for Central General Ledger. It is the master list of all accounts used to record financial transactions.				definition meaning what is	99	Y	11-02-26 02:26:32.761486000 PM	11-02-26 02:26:32.761486000 PM	10			
Q_BR_01	Branch Management	How to add a Branch?	Go to Branch Management > Add. Fill in the location and sol ID.			CREATE	location office	0	Y	11-02-26 02:48:48.841447000 PM	11-02-26 02:48:48.841447000 PM	58			




