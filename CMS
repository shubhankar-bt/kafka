package com.tcs.fincore.CommonMasterService.advice;

import com.tcs.fincore.CommonMasterService.dto.ApiResponse;
import org.springframework.core.MethodParameter;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

/**
 * This ControllerAdvice intercepts successful responses from any @RestController
 * and wraps them in a standard ApiResponse format.
 */
@ControllerAdvice
public class ApiResponseWrapper implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        // This advice applies to any method in a class annotated with @RestController
        // that is not already returning a ResponseEntity (which gives manual control).
        return AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), RestController.class) && !returnType.getParameterType().equals(ResponseEntity.class);
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class<? extends HttpMessageConverter<?>> selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {

        // If the controller has already manually wrapped the response, do nothing.
        if (body instanceof ApiResponse<?>) {
            return body;
        }

        // Wrap the successful response body in the standard ApiResponse structure.
        return ApiResponse.success(body);
    }
}












// config

package com.tcs.fincore.CommonMasterService.config;

import com.fincore.commonutilities.config.CommonSecurityConfig;
import com.fincore.commonutilities.config.RedisConfig;
import com.fincore.commonutilities.jwt.JwtUtil;
import com.fincore.commonutilities.security.ContextRbacFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/**
 * Common Security Configuration.
 * * Aligned with the "Distributed Gateway" architecture.
 * It uses the ContextRbacFilter from Common Utilities to enforce:
 * 1. Token Validity
 * 2. Single Session (Redis check)
 * 3. RBAC Permissions
 */
@Configuration
@EnableWebSecurity
@Import({RedisConfig.class, JwtUtil.class, CommonSecurityConfig.class}) // Import logic from JAR
public class SecurityConfig {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private CommonSecurityConfig commonSecurityConfig; // Wire in the CORS config

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                // 1. Disable CSRF (Stateless API)
                .csrf(csrf -> csrf.disable())

                // 2. Apply Centralized CORS Policy
                .cors(cors -> cors.configurationSource(commonSecurityConfig.corsConfigurationSource()))

                // 3. Stateless Session (No JSESSIONID)
                .sessionManagement(s -> s.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                // 4. Authorization Rules
                .authorizeHttpRequests(authz -> authz
                        // Public Endpoints
                        .requestMatchers("/actuator/**", "/auth/**", "/error").permitAll()
                        // All other endpoints require Authentication (and RBAC filter check)
                        .anyRequest().authenticated()
                )

                // 5. Add the "Distributed Gateway" Filter
                .addFilterBefore(new ContextRbacFilter(redisTemplate, jwtUtil), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}










// controller
package com.tcs.fincore.CommonMasterService.Controller;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.fincore.CommonMasterService.dto.AnnouncementDto;
import com.tcs.fincore.CommonMasterService.service.AnnouncementService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;


/**
 * AnnouncementController :-
 *
 * This controller handles API requests related to Announcement Screen.
 * It provides endpoints for Admin Management Screen: For creating, editing, and toggling announcements
 *
 * @author Shubhankar [v1018405]
 * @version 1.0
 * @since 2025-12-11
 */
@RestController
@RequestMapping("/announcements")
@RequiredArgsConstructor
public class AnnouncementController {
    private final AnnouncementService service;
    private final JwtUtil jwtUtil;

    /**
     * 1. CREATE ANNOUNCEMENT
     */
    @PostMapping
    public ResponseEntity<AnnouncementDto> create(
            @RequestHeader("Authorization") String token,
            @Valid @RequestBody AnnouncementDto dto) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return ResponseEntity.ok(service.createAnnouncement(dto, userId));
    }

    /**
     * 2. UPDATE ANNOUNCEMENT
     */
    @PutMapping("/{id}")
    public ResponseEntity<AnnouncementDto> update(
            @RequestHeader("Authorization") String token,
            @PathVariable Long id,
            @Valid @RequestBody AnnouncementDto dto) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return ResponseEntity.ok(service.updateAnnouncement(id, dto, userId));
    }

    /**
     * 3. LIST ALL
     * Used for the Management Grid.
     */
    @GetMapping("/list")
    public ResponseEntity<List<AnnouncementDto>> listAll() {
        return ResponseEntity.ok(service.getAllAnnouncements());
    }

    /**
     * 4. TOGGLE STATUS
     * Returns the updated DTO so UI can reflect the new Status immediately.
     */
    @PatchMapping("/{id}/toggle")
    public ResponseEntity<AnnouncementDto> toggle(@PathVariable Long id) {
        // No Token needed for toggle if we don't track "Who toggled it",
        // otherwise add @RequestHeader("Authorization") and pass userId to service.
        return ResponseEntity.ok(service.toggleStatus(id));
    }
}








package com.tcs.fincore.CommonMasterService.Controller;

import com.tcs.fincore.CommonMasterService.dto.ApiResponse;
import com.tcs.fincore.CommonMasterService.dto.BalanceRequestDTO;
import com.tcs.fincore.CommonMasterService.dto.BalanceResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.PaginatedResponseDto;
import com.tcs.fincore.CommonMasterService.service.CommonMasterService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/balance-enquiry")
@RequiredArgsConstructor
public class BalanceController {

    private final CommonMasterService service;

    @PostMapping("/enquires")
    public ResponseEntity<ApiResponse<PaginatedResponseDto<BalanceResponseDTO>>> getBalance(
            @RequestBody BalanceRequestDTO request) {

        PaginatedResponseDto<BalanceResponseDTO> result = service.getBalanceDetails(request);
        return ResponseEntity.ok(ApiResponse.success(result, "Balance records fetched Successfully"));
    }

    @PostMapping("/export")
    public ResponseEntity<byte[]> exportBalance(@RequestBody BalanceRequestDTO request) {
        byte[] bytes = service.exportBalanceToExcel(request);
        return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, "atttachmet; filename=balance_enquiry.xlsx")
                .contentType(
                        MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"))
                .body(bytes);
    }

}








package com.tcs.fincore.CommonMasterService.Controller;

import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.tcs.fincore.CommonMasterService.dto.ApiResponse;
import com.tcs.fincore.CommonMasterService.dto.BranchStateCircleResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CGLSegmentResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CglSearchRequest;
import com.tcs.fincore.CommonMasterService.dto.PaginatedResponseDto;
import com.tcs.fincore.CommonMasterService.model.BranchCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.BranchMaster;
import com.tcs.fincore.CommonMasterService.model.CGLCodeDescriptionOnly;
import com.tcs.fincore.CommonMasterService.model.CGLMaster;
import com.tcs.fincore.CommonMasterService.model.CalenderConfigModel;
import com.tcs.fincore.CommonMasterService.model.CircleMaster;
import com.tcs.fincore.CommonMasterService.model.CurrencyCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.CurrencyMasterModel;
import com.tcs.fincore.CommonMasterService.model.CurrencyRateChange;
import com.tcs.fincore.CommonMasterService.model.SegmentCodeMaster;
import com.tcs.fincore.CommonMasterService.model.StateMaster;
import com.tcs.fincore.CommonMasterService.model.ZoneMaster;
import com.tcs.fincore.CommonMasterService.repository.BranchMasterWithStateCircleRepository;
import com.tcs.fincore.CommonMasterService.service.CommonMasterService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@RestController
public class CommonMasterController {

	private final CommonMasterService service;

	@GetMapping("/segment-codes")
	public List<SegmentCodeMaster> getSegmentCodes(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getSegmentCodes();
	}

	@PostMapping("/cgls")
	public PaginatedResponseDto<CGLMaster> getCGLs(
			@RequestHeader("Authorization") String authorizationHeader,
			@RequestBody CglSearchRequest request) {
		return service.getCGLs(request);
	}

	@GetMapping("/cgl-code-description-only")
	public List<CGLCodeDescriptionOnly> getCGLsCodeDescriptionOnly(@RequestParam String q) {
		return service.getCGLsCodeDescriptionOnly(q);
	}

	@GetMapping("/cgl-codes")
	public List<String> getCGLCodes(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCGLCodes();
	}

	@GetMapping("/states")
	public List<StateMaster> getStateList(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getStateList();
	}

	@GetMapping("/branches")
	public List<BranchMaster> getBranches(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getBranches();
	}

	@GetMapping("/branches-code-name-only")
	public List<BranchCodeNameOnly> getBranchesCodeNameOnly(@RequestParam String q) {
		return service.getBranchesCodeNameOnly(q);
	}

	@GetMapping("/zone-codes")
	public List<ZoneMaster> getZoneCodes() {
		return service.getZoneCodes();
	}

	@GetMapping("/circle-codes")
	public List<CircleMaster> getCircleList() {
		return service.getCircleList();
	}

	@GetMapping("/currency-master")
	public List<CurrencyMasterModel> getCurrency(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCurrency();
	}

	@GetMapping("/currency-code-name-only")
	public List<CurrencyCodeNameOnly> getCurrencyCodeNameOnly(
			@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCurrencyCodeNameOnly();
	}

	@GetMapping("/currency")
	public List<String> getCurrencys(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCurrencys();
	}

	@GetMapping("/calendar-configuration")
	public CalenderConfigModel getCalenderConfig(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCalenderConfig();
	}

	@GetMapping("/currency-rate-change")
	public List<CurrencyRateChange> getRateChange(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getRateChange();
	}

	@GetMapping("/branchesNewAPI")
	public Page<BranchMaster> getBranchNames(Pageable pageable) {
		return service.getBranchNames(pageable);
	}

	@GetMapping("/viewCgl")
	public ResponseEntity<ApiResponse<PaginatedResponseDto<CGLSegmentResponseDTO>>> searchCglWithSegment(
			@RequestParam String cglCodeOrDesc, @RequestParam(required = false) Integer page,
			@RequestParam(required = false) Integer size) {

		PaginatedResponseDto<CGLSegmentResponseDTO> result = service.searchCglWithSegment(cglCodeOrDesc, page, size);

		return ResponseEntity.ok(ApiResponse.success(result, "CGL Details fetched Successfully"));
	}

	
	@GetMapping("/viewBranch")
	public ResponseEntity<ApiResponse<List<BranchStateCircleResponseDTO>>> searchByBranchNameORCode(
			@RequestParam String branchCodeOrName) {
		List<BranchStateCircleResponseDTO> result = service.searchByBranchNameORCode(branchCodeOrName);
		return ResponseEntity.ok(ApiResponse.success(result, "Branch Details Feched Successfully"));
	}

}








// DTO

package com.tcs.fincore.CommonMasterService.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AnnouncementDto {

    private Long id;

    @NotBlank(message = "Title is required")
    private String title;

    @NotBlank(message = "Message content is required")
    private String message;

    private String severity; // INFO, WARN, CRITICAL

    private List<String> targetRoles; // e.g. ["51", "55"] or ["ALL"]

    // Used for Request (Post/Edit)
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startDate;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Future(message = "Expiry date must be in the future")
    private LocalDateTime expiryDate;

    private String isActive; // 'Y' or 'N'

    // Derived Status for UI (e.g. "ACTIVE", "EXPIRED", "SCHEDULED", "DISABLED")
    private String displayStatus;

    // Read-only fields
    private String createdBy;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createdAt;
}






package com.tcs.fincore.CommonMasterService.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Getter;

import java.time.Instant;

@Getter
@JsonInclude(JsonInclude.Include.NON_NULL) // Don't include null fields in the JSON response
public class ApiResponse<T> {

    private final boolean success;
    private final String message;
    private final T data;
    private final Instant timestamp;

    private ApiResponse(boolean success, String message, T data) {
        this.success = success;
        this.message = message;
        this.data = data;
        this.timestamp = Instant.now();
    }

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, message, data);
    }

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, "Operation completed successfully.", data);
    }

    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(false, message, null);
    }
}








package com.tcs.fincore.CommonMasterService.dto;

import java.util.Date;

import com.fasterxml.jackson.annotation.JsonFormat;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class BalanceRequestDTO {

    @NotNull(message = "Branch is required")
    private String branch;

    @NotNull(message = "CGL is required")
    private String cgl;

    @NotNull(message = "Currency is required")
    private String currency;

    @NotNull(message = "End date is required")
    @JsonFormat(pattern = "dd-MM-yyyy")
    private Date endDate;

    @NotNull(message = "Start date is required")
    @JsonFormat(pattern = "dd-MM-yyyy")
    private Date startDate;

    private Integer page;

    private Integer size;

    private String sortIn;

}










package com.tcs.fincore.CommonMasterService.dto;

import java.util.Date;

import com.fasterxml.jackson.annotation.JsonFormat;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class BalanceResponseDTO {
    
    private Integer id;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd-MM-yyyy")
    private Date date;

    private String branch;

    private String cgl;

    private String currency;

    private Double balance;

}








package com.tcs.fincore.CommonMasterService.dto;

import java.util.Date;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BranchStateCircleResponseDTO {

    private String branchCode;
    private String branchName;
    private String branchCity;

    private String circleCode;
    private String circleName;

    private String stateCode;
    private String stateName;

    private String address;
    private String pinCode;
    private String phoneNumber;
    private String emailId;
    private String nmrCode;
    private Boolean status;
    private Date openDate;
    private Date closeDate;
    private Date mergeDate;
    private String mergedWithBranch;
    private Date lastChangeDate;
    private Boolean cpcFlag;
    private Boolean foodCreditFlag;
    private Boolean currChestFlag;
    private String branchType;

}










package com.tcs.fincore.CommonMasterService.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class CglFilterRequest {
    private String field;
    private String operator;
    private String value;
}









package com.tcs.fincore.CommonMasterService.dto;

import lombok.Getter;
import lombok.Setter;
import java.util.List;

@Getter
@Setter
public class CglSearchRequest {
    private String requestType;
    private int page;
    private int size;
    private List<CglFilterRequest> filters;
}






package com.tcs.fincore.CommonMasterService.dto;

import java.time.LocalDate;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CGLSegmentResponseDTO {
    
    private String cglNumber;
    private String description;

    private String comp1;
    private String comp2;
    private String acClassification;
    
    private String segmentCode;
    private String segmentDescription;

    private Integer balFwd;
    private String defValType;
    private Integer status;
    private LocalDate openDate;
    private LocalDate closeDate;
    private Integer balcompare;
    private Integer manualPosting;

    
}






package com.tcs.fincore.CommonMasterService.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class PaginatedResponseDto<T> {

    private int currentPage;
    private int totalPages;
    private int pageSize;
    private long totalElements;
    private String sortIn;
    private List<T> data;
    
    

}







package com.tcs.fincore.CommonMasterService.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.tcs.fincore.CommonMasterService.dto.ApiResponse;

import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NoDataFoundException.class)
    public ResponseEntity<ApiResponse<?>> handleNoData(NoDataFoundException e) {
        return ResponseEntity.ok(ApiResponse.error(e.getMessage()));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<?>> handleValidationErrors(MethodArgumentNotValidException e) {
        String errorMsg = e.getBindingResult().getFieldError().getDefaultMessage();
        return ResponseEntity.badRequest().body(ApiResponse.error(errorMsg));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<?>> handleGeneralException(Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("Spmething went wrong: " + e.getMessage()));
    }

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<Map<String, String>> handleIllegalState(IllegalStateException ex) {
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(Map.of("error", "Validation Error", "message", ex.getMessage()));
    }

}








package com.tcs.fincore.CommonMasterService.exception;

public class NoDataFoundException extends RuntimeException{

    public NoDataFoundException(String message){
        super(message);
    }

}







package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.*;
import lombok.Data;

import java.time.LocalDateTime;
import java.util.Date;

@Entity
@Table(name = "ANNOUNCEMENTS")
@Data
public class Announcements {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID")
    private Long id;

    @Column(name = "TITLE")
    private String title;

    @Column(name = "MESSAGE")
    private String message;

    @Column(name = "SEVERITY")
    private String severity;

    @Column(name = "TARGET_ROLE", length = 255)
    private String targetRole; // Stored as "51,55,53" or "ALL"

    @Column(name = "START_DATE")
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime startDate;

    @Column(name = "EXPIRY_DATE")
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime expiryDate;

    @Column(name = "IS_ACTIVE")
    private String isActive;  

    @Column(name = "CREATED_BY")
    private String createdBy;

    @Column(name = "CREATED_AT")
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime createdAt;
}










package com.tcs.fincore.CommonMasterService.model;

import java.util.Date;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Table(name = "GL_BALANCE")
@Entity
public class BalanceRecord {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID")
    private Integer id;

    @Column(name = "BRANCH_CODE", nullable = false)
    private String branch;

    @Column(name = "CGL", nullable = false)
    private String cgl;

    @Column(name = "CURRENCY", nullable = false)
    private String currency;

    @Column(name = "BALANCE", nullable = false)
    private double balance;

    @Temporal(TemporalType.DATE)
    @Column(name = "BALANCE_DATE", nullable = false)
    private Date date;

}








package com.tcs.fincore.CommonMasterService.model;

public interface BranchCodeNameOnly {
	String getCode();

	String getName();
}




package com.tcs.fincore.CommonMasterService.model;

import java.util.Date;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Entity
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "BRANCH_MASTER")
public class BranchMaster {
	@Id
	@Column(name = "CODE", nullable = false, length = 5, updatable = false)
	private String code;

	@Column(name = "NAME", nullable = false, length = 50)
	private String name;

	@Column(name = "CIRCLE_CODE", nullable = false, length = 5)
	private String circleCode;

	@Column(name = "STATE", nullable = false, length = 50)
	private String state;

	@Column(name = "CITY", nullable = true, length = 50)
	private String city;

	@Column(name = "ADDRESS", nullable = true, length = 50)
	private String address;

	@Column(name = "PINCODE", nullable = true, length = 6)
	private String pinCode;

	@Column(name = "PHONE_NUMBER", nullable = false, length = 12)
	private String phoneNumber;

	@Column(name = "EMAIL_ID", nullable = false, length = 50)
	private String emailId;

	@Column(name = "NMR_CODE", nullable = false, length = 50)
	private String nmrCode;

	@Column(name = "STATUS", nullable = false)
	private Boolean status;

	@Column(name = "OPEN_DATE", nullable = false, updatable = false)
	private Date openDate;

	@Column(name = "CLOSE_DATE")
	private Date closeDate;

	@Column(name = "MERGE_DATE")
	private Date mergeDate;

	@Column(name = "MERGED_WITH_BRANCH", length = 5)
	private String mergedWithBranch;

	@Column(name = "LAST_CHANGE_DATE")
	private Date lastChangeDate;

	@Column(name = "CPC_FLAG", nullable = false)
	private Boolean cpcFlag;

	@Column(name = "FOOD_CREDIT_FLAG", nullable = false)
	private Boolean foodCreditFlag;

	@Column(name = "CURR_CHEST_FLAG", nullable = false)
	private Boolean currChestFlag;

	@Column(name = "BRANCH_TYPE", length = 1)
	private String branchType;
}









package com.tcs.fincore.CommonMasterService.model;

import java.util.Date;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Entity
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "BRANCH_MASTER")
public class BranchMasterWithCircleState {
    @Id
    @Column(name = "CODE", nullable = false, length = 5, updatable = false)
    private String code;

    @Column(name = "NAME", nullable = false, length = 50)
    private String name;

    @Column(name = "CIRCLE_CODE", nullable = false, length = 5)
    private String circleCode;

    @Column(name = "STATE", nullable = false, length = 50)
    private String stateCode;

    @Column(name = "CITY", nullable = true, length = 50)
    private String city;

    @Column(name = "ADDRESS", nullable = true, length = 50)
    private String address;

    @Column(name = "PINCODE", nullable = true, length = 6)
    private String pinCode;

    @Column(name = "PHONE_NUMBER", nullable = false, length = 12)
    private String phoneNumber;

    @Column(name = "EMAIL_ID", nullable = false, length = 50)
    private String emailId;

    @Column(name = "NMR_CODE", nullable = false, length = 50)
    private String nmrCode;

    @Column(name = "STATUS", nullable = false)
    private Boolean status;

    @Column(name = "OPEN_DATE", nullable = false, updatable = false)
    private Date openDate;

    @Column(name = "CLOSE_DATE")
    private Date closeDate;

    @Column(name = "MERGE_DATE")
    private Date mergeDate;

    @Column(name = "MERGED_WITH_BRANCH", length = 5)
    private String mergedWithBranch;

    @Column(name = "LAST_CHANGE_DATE")
    private Date lastChangeDate;

    @Column(name = "CPC_FLAG", nullable = false)
    private Boolean cpcFlag;

    @Column(name = "FOOD_CREDIT_FLAG", nullable = false)
    private Boolean foodCreditFlag;

    @Column(name = "CURR_CHEST_FLAG", nullable = false)
    private Boolean currChestFlag;

    @Column(name = "BRANCH_TYPE", length = 1)
    private String branchType;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "STATE", referencedColumnName = "STATE_CODE", insertable = false, updatable = false)
    private StateMaster state;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "CIRCLE_CODE", referencedColumnName = "CIRCLE_CODE", insertable = false, updatable = false)
    private CircleMaster circle;

}











package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.*;
import lombok.Data;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "CALENDER_CONFIG")
@Data
public class CalenderConfigModel {

    @Id
    @Column(name = "ID")
    private Long id;

    @Column(name = "YEAR_START_DATE", nullable = false)
    private LocalDate yearStartDate;

    @Column(name = "YEAR_END_DATE", nullable = false)
    private LocalDate yearEndDate;

    @Column(name = "REMARKS", nullable = false, length = 255)
    private String remarks;

    @Column(name = "APPROVEDAT")
    private LocalDateTime approvedAt;

    @Column(name = "APPROVEDBY", length = 50)
    private String approvedBy;

    @Column(name = "REQUESTEDAT")
    private LocalDateTime requestedAt;

    @Column(name = "REQUESTEDBY", length = 50)
    private String requestedBy;

}









package com.tcs.fincore.CommonMasterService.model;

public interface CGLCodeDescriptionOnly {
	String getCglNumber();

	String getDescription();
}







package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;
import org.hibernate.annotations.Generated;
import org.hibernate.generator.EventType;

import java.time.LocalDate;

@Getter
@Setter
@Entity
@Table(name = "CGL_MASTER")
public class CGLMaster {
    @Id
    @Generated(event = EventType.INSERT)
    @Column(name = "CGL_NUMBER", insertable = false, updatable = false)
    private String cglNumber;

    @Column(name = "COMP_1", nullable = false)
    private String comp1;

    @Column(name = "SEGMENT_CODE", nullable = false)
    private String segmentCode;

    @Column(name = "COMP_2", nullable = false)
    private String comp2;

    @Column(name = "DESCRIPTION", nullable = false, length = 100)
    private String description;

    @Column(name = "AC_CLASSIFICATION", nullable = false, length = 1)
    private String acClassification;

    @Column(name = "BAL_FWD", nullable = false)
    private Integer balFwd = 0;

    @Column(name = "DEF_BAL_TYPE", nullable = false, length = 1)
    private String defBalType;

    @Column(name = "STATUS", nullable = false)
    private Integer status;

    @ColumnDefault("SYSDATE")
    @Generated(event = EventType.INSERT)
    @Column(name = "OPEN_DATE", nullable = false, insertable = false, updatable = false)
    private LocalDate openDate;

    @Column(name = "CLOSE_DATE")
    private LocalDate closeDate;

    @Column(name = "BAL_COMPARE", nullable = false)
    private Integer balCompare = 0;

    @Column(name = "MANUAL_POSTING", nullable = false)
    private Integer manualPosting = 0;
}










package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;
import org.hibernate.annotations.Generated;
import org.hibernate.generator.EventType;

import java.time.LocalDate;

@Getter
@Setter
@Entity
@Table(name = "CGL_MASTER")
public class CGLMasterWithSegment {
    @Id
    // @Generated(event = EventType.INSERT)
    @Column(name = "CGL_NUMBER", insertable = false, updatable = false)
    private String cglNumber;

    @Column(name = "COMP_1", nullable = false)
    private String comp1;

    @Column(name = "SEGMENT_CODE", nullable = false)
    private String segmentCode;

    @Column(name = "COMP_2", nullable = false)
    private String comp2;

    @Column(name = "DESCRIPTION", nullable = false, length = 100)
    private String description;

    @Column(name = "AC_CLASSIFICATION", nullable = false, length = 1)
    private String acClassification;

    @Column(name = "BAL_FWD", nullable = false)
    private Integer balFwd = 0;

    @Column(name = "DEF_BAL_TYPE", nullable = false, length = 1)
    private String defBalType;

    @Column(name = "STATUS", nullable = false)
    private Integer status;

    @ColumnDefault("SYSDATE")
    @Generated(event = EventType.INSERT)
    @Column(name = "OPEN_DATE", nullable = false, insertable = false, updatable = false)
    private LocalDate openDate;

    @Column(name = "CLOSE_DATE")
    private LocalDate closeDate;

    @Column(name = "BAL_COMPARE", nullable = false)
    private Integer balCompare = 0;

    @Column(name = "MANUAL_POSTING", nullable = false)
    private Integer manualPosting = 0;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "SEGMENT_CODE", referencedColumnName = "SEGMENT_CODE", insertable = false,updatable =false)
    private SegmentCodeMaster segment;

}














package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;
import java.util.Date;

@Entity
@Getter
@Setter
@Table(name="CIRCLE_MASTER")
public class CircleMaster{
	
	@Id 
	@Column(name="CIRCLE_CODE" , nullable = false , length = 3)
	public String circleCode;
	
	@Column(name="CIRCLE_NAME", nullable = false , length = 150)
	public String circleName;
	
	@Column(name="ZONE_CODE", nullable = false , length = 3)
	public String zoneCode;
	
	@Column(name="CREATED_DATE", insertable = false )
	public Date createdDate;
	
	
}







package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Data
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "CURRENCY_RATE_CHANGE")
public class Currency_Rate_Change_Model {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "currency_code", nullable = false, length = 3)
    private String currencyCode;

    @Column(name = "currency_rate", nullable = false, precision = 19, scale = 9)
    private BigDecimal currencyRate;

    @Column(name = "rate_change_date")
    private LocalDateTime rateChangeDate;


    @PreUpdate
    public void onPreUpdate() {
        this.rateChangeDate = LocalDateTime.now();
    }

 
    @PrePersist
    public void onPrePersist() {
        this.rateChangeDate = LocalDateTime.now();
    }
}











package com.tcs.fincore.CommonMasterService.model;

public interface CurrencyCodeNameOnly {
	String getCurrencyCode();

	String getCurrencyName();
}








package com.tcs.fincore.CommonMasterService.model;


import java.time.LocalDateTime;
import java.util.Date;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "CURRENCY_MASTER")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor

public class CurrencyMasterModel {
 
     @Id
     @Column(name = "CURRENCY_CODE", nullable = false, unique = true, length = 3)
     private String currencyCode;

     @Column(name = "CURRENCY_NAME", nullable = false, length = 50)
     private String currencyName;

     @Column(name = "FLAG", nullable = false)
     private Integer flag;

     @Column(name = "CURRENCY_RATE")
     private BigDecimal currencyRate;

     @Column(name = "RATE_DATE")
     private Date rateDate;

     @Column(name = "CREATED_AT", updatable = false)
     private LocalDateTime createdAt;

     @Column(name = "UPDATED_AT")
     private LocalDateTime updatedAt;

     @PrePersist
     
     protected void onCreate() {
         this.createdAt = LocalDateTime.now();
         this.updatedAt = LocalDateTime.now();
     }

     @PreUpdate
     protected void onUpdate() {
         this.updatedAt = LocalDateTime.now();
     }
 
 
 
}











package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Data
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "CURRENCY_RATE_CHANGE")
public class CurrencyRateChange {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "currency_code", nullable = false, length = 3)
    private String currencyCode;

    @Column(name = "currency_rate", nullable = false, precision = 19, scale = 9)
    private BigDecimal currencyRate;

    @Column(name = "rate_change_date")
    private LocalDateTime rateChangeDate;


    @PreUpdate
    public void onPreUpdate() {
        this.rateChangeDate = LocalDateTime.now();
    }

 
    @PrePersist
    public void onPrePersist() {
        this.rateChangeDate = LocalDateTime.now();
    }
}








package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp; // Import this
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.io.Serializable;
import java.time.Instant; // This is the correct type
import java.util.Objects;
import java.util.UUID;

/**
 * Represents an event in the outbox system, intended for notification purposes.
 * This entity maps to the {@code notification_table} in the database. It captures all necessary details
 * for a notification to be processed and displayed to a user or a group of users (via roles).
 * <p>
 * The {@code @CreationTimestamp} annotation ensures that the {@code eventTimestamp} is automatically
 * populated upon entity creation, providing an accurate record of when the event occurred.
 * </p>
 */
@Entity
@Table(name = "notifications")
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class NotificationTable implements Serializable {

    /**
     * Unique primary key for the outbox event.
     * Uses a generated {@link UUID} strategy, which is suitable for Oracle's SYS_GUID() or RAW(16) columns.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "EVENT_ID", updatable = false, nullable = false)
    private UUID eventId;

    /**
     * The ID of the user who should receive this notification (for 1-to-1 notifications).
     * This field is used when targeting a specific user.
     */
    @Column(name = "USER_ID", length = 255)
    private String userId;

    /**
     * The human-readable message to be displayed in the UI.
     * This is the main content of the notification.
     */
    @Column(name = "MESSAGE", length = 1024, nullable = false)
    private String message;

    /**
     * The relative URL the user should be taken to when clicking the notification.
     * Provides a direct link to the relevant business object or view.
     */
    @Column(name = "LINK_URL", length = 1024)
    private String linkUrl;

    /**
     * The microservice that generated this event.
     * Helps in tracing the origin of the notification within a microservice architecture.
     */
    @Column(name = "EVENT_SOURCE", length = 100)
    private String eventSource;

    /**
     * The primary key of the related business object (e.g., the Common Request ID).
     * Used to link the notification back to the original business data.
     */
    @Column(name = "AGGREGATE_ID", length = 255)
    private String aggregateId;

    /**
     * The timestamp when the event was created.
     * Automatically populated using {@link CreationTimestamp} and stored as an {@link Instant}.
     * The column is both non-nullable and non-updatable after creation.
     */
    @CreationTimestamp
    @Column(name = "EVENT_TIMESTAMP", nullable = false, updatable = false)
    private Instant eventTimestamp;

    /**
     * For 1-to-Many notifications. If {@code userId} is null, this role is used to determine the recipients.
     * Enables broadcasting notifications to all users within a specific role.
     */
    @Column(name = "TARGET_ROLE", length = 100)
    private String targetRole;


    /**
     * Compares this NotificationTable entity with another object for equality based solely on the {@code eventId}.
     *
     * @param o The object to compare with.
     * @return true if the objects are equal (have the same eventId), false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        NotificationTable that = (NotificationTable) o;
        return Objects.equals(eventId, that.eventId);
    }

    /**
     * Generates a hash code for the NotificationTable entity based solely on the {@code eventId}.
     *
     * @return The hash code.
     */
    @Override
    public int hashCode() {
        return Objects.hash(eventId);
    }


    /**
     * Provides a string representation of the NotificationTable entity, primarily for logging and debugging purposes.
     *
     * @return A string containing key fields of the entity.
     */
    @Override
    public String toString() {
        return "NotificationTable{" +
                "eventId='" + eventId + '\'' +
                ", userId='" + userId + '\'' +
                ", targetRole='" + targetRole + '\'' +
                ", eventSource='" + eventSource + '\'' +
                ", aggregateId='" + aggregateId + '\'' +
                ", eventTimestamp=" + eventTimestamp +
                '}';
    }
}












package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "SEGMENT_CODE_MASTER")
public class SegmentCodeMaster {
    @Id
    @Column(name = "SEGMENT_CODE", nullable = false, length = 4)
    private String segmentCode;

    @Column(name = "DESCRIPTION", nullable = false, length = 100)
    private String description;
}








package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "STATE_MASTER")
public class StateMaster {

    @Id
    @Column(name = "STATE_CODE", nullable = false, length = 4)
    private String StateCode;

    @Column(name = "NAME", nullable = false, length = 20)
    private String stateName;
}







package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "ZONE_MASTER")
public class ZoneMaster {
	
	@Id
    @Column(name = "ID")
    private String id;

    @Column(name = "ZONE_DESC")
    private String description;
	
}










// repo

package com.tcs.fincore.CommonMasterService.repository;

import com.tcs.fincore.CommonMasterService.model.Announcements;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AnnouncementsRepository extends JpaRepository<Announcements, Long> {

    // For Admin Screen (List View with Filters)
    // If status is 'ALL', ignore the isActive check.
    @Query("SELECT a FROM Announcements a WHERE " +
            "(:status IS NULL OR a.isActive = :status) " +
            "ORDER BY a.createdAt DESC")
    List<Announcements> findAllByFilter(@Param("status") String status);

    // ADMIN QUERY: Fetch all (filtering is done in Service or via simple WHERE)
    @Query("SELECT a FROM Announcements a ORDER BY a.createdAt DESC")
    List<Announcements> findAllByOrderByCreatedAtDesc();

}






package com.tcs.fincore.CommonMasterService.repository;

import java.util.Date;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

import com.tcs.fincore.CommonMasterService.model.BalanceRecord;

public interface BalanceRecordRepository extends JpaRepository<BalanceRecord, Integer> {

    Page<BalanceRecord> findByBranchAndCglAndCurrencyAndDateBetween(String branch, String cgl, String currency,
            Date startDate, Date endDate, Pageable pageable);


}






package com.tcs.fincore.CommonMasterService.repository;

import java.util.List;


import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.CrudRepository;

import com.tcs.fincore.CommonMasterService.model.BranchCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.BranchMaster;

public interface BranchMasterRepository extends CrudRepository<BranchMaster, String> {

    List<BranchCodeNameOnly> findTop100ByCodeContainingIgnoreCaseOrNameContainingIgnoreCase(
            String code,
            String name
    );

	
	 Page<BranchMaster> findAll(Pageable pageable);
}






package com.tcs.fincore.CommonMasterService.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import com.tcs.fincore.CommonMasterService.model.BranchMasterWithCircleState;

public interface BranchMasterWithStateCircleRepository extends JpaRepository<BranchMasterWithCircleState,String>{

    List<BranchMasterWithCircleState> findByCodeContainingIgnoreCaseOrNameContainingIgnoreCase(String name,String code);
    
}











package com.tcs.fincore.CommonMasterService.repository;

import com.tcs.fincore.CommonMasterService.model.CalenderConfigModel;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface CalenderConfigRepository extends CrudRepository<CalenderConfigModel, Long> {
    CalenderConfigModel findFirstByOrderByIdDesc();
}









package com.tcs.fincore.CommonMasterService.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;

import com.tcs.fincore.CommonMasterService.model.CGLCodeDescriptionOnly;
import com.tcs.fincore.CommonMasterService.model.CGLMaster;

public interface CGLMasterRepository extends JpaRepository<CGLMaster, String>, JpaSpecificationExecutor<CGLMaster> {

	@Query(nativeQuery = true, value = """
			SELECT CGL_NUMBER FROM CGL_MASTER
			""")
	List<String> findAllCGLNumbers();

	List<CGLCodeDescriptionOnly> findBycglNumberContainingIgnoreCaseOrDescriptionContainingIgnoreCase(
			String cglNumber,
			String description);

}








package com.tcs.fincore.CommonMasterService.repository;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.tcs.fincore.CommonMasterService.model.CGLMasterWithSegment;

@Repository
public interface CGLMasterWithSegmentRepository extends JpaRepository<CGLMasterWithSegment, String> {

    // @Query(value = "SELECT c FROM CGLMasterWithSegment c JOIN FETCH c.segment s"
    // + "WHERE LOWER(c.cglNumber) LIKE LOWER(CONCAT('%', :text, '%'))"
    // + "OR LOWER(c.description) LIKE LOWER(CONCAT('%', :text , '%'))", countQuery
    // = "SELECT COUNT(c) FROM CGLMasterWithSegment c"
    // + "WHERE LOWER(c.cglNumber) LIKE LOWER(CONCAT('%', :text, '%'))"
    // + "OR LOWER(c.description) LIKE LOWER(CONCAT('%', :text , '%'))")
    // Page<CGLMasterWithSegment> searchAlongWithSegment(@Param("text") String text,
    // Pageable pageable);

    Page<CGLMasterWithSegment> findByCglNumberContainingIgnoreCaseOrDescriptionContainingIgnoreCase(
            @Param("text") String text, String Description, Pageable pageable);

}











package com.tcs.fincore.CommonMasterService.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.tcs.fincore.CommonMasterService.model.CircleMaster;

@Repository
public interface CircleMasterRepository extends JpaRepository<CircleMaster,String>{
	
}










package com.tcs.fincore.CommonMasterService.repository;

import java.util.List;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;

import com.tcs.fincore.CommonMasterService.model.CurrencyCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.CurrencyMasterModel;

public interface CurrencyMasterRepository extends CrudRepository<CurrencyMasterModel, String> {

	@Query(nativeQuery = true, value = """
			SELECT CURRENCY_CODE FROM CURRENCY_MASTER
			""")
	List<String> findAllCurrency();

	List<CurrencyCodeNameOnly> findAllBy();
}











package com.tcs.fincore.CommonMasterService.repository;

import java.awt.List;

import org.springframework.data.repository.CrudRepository;

import com.tcs.fincore.CommonMasterService.model.CurrencyRateChange;


public interface CurrencyRateChangeRepo extends CrudRepository<CurrencyRateChange, Long> {
	
	
	
}











package com.tcs.fincore.CommonMasterService.repository;

import com.tcs.fincore.CommonMasterService.model.NotificationTable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface NotificationOutboxRepository extends JpaRepository<NotificationTable, UUID> {
}






package com.tcs.fincore.CommonMasterService.repository;

import com.tcs.fincore.CommonMasterService.model.SegmentCodeMaster;
import org.springframework.data.repository.CrudRepository;

public interface SegmentCodeMasterRepository extends CrudRepository<SegmentCodeMaster, String> {
}







package com.tcs.fincore.CommonMasterService.repository;

import org.springframework.stereotype.Repository;
import com.tcs.fincore.CommonMasterService.model.StateMaster;
import org.springframework.data.repository.CrudRepository;


@Repository
public interface StateMasterRepository extends CrudRepository<StateMaster, String> {
    
}







package com.tcs.fincore.CommonMasterService.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.tcs.fincore.CommonMasterService.model.ZoneMaster;


@Repository
public interface ZoneMasterRepository extends JpaRepository<ZoneMaster,String>{
		
}






// service
package com.tcs.fincore.CommonMasterService.service;

import com.tcs.fincore.CommonMasterService.model.Announcements;
import com.tcs.fincore.CommonMasterService.model.NotificationTable;
import com.tcs.fincore.CommonMasterService.repository.NotificationOutboxRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Slf4j
public class AnnouncementNotificationService {

    private final NotificationOutboxRepository notificationRepository;

    @Transactional(propagation = Propagation.MANDATORY)
    public void broadcastAnnouncement(Announcements announcement) {

        String targetRole = announcement.getTargetRole();

        if ("ALL".equalsIgnoreCase(targetRole) || targetRole == null) {
            targetRole = "ALL_USERS";
        }

        String message = buildNotificationMessage(announcement);
        String link = "/dashboard";

        // Build Entity using Builder Pattern
        NotificationTable notification = NotificationTable.builder()
                .message(message)
                .linkUrl(link)
                .targetRole(targetRole)
                .aggregateId(String.valueOf(announcement.getId()))
                .eventSource("CommonMasterService")
                .userId(null) // It's a role broadcast, so user is null
                .build();

        // Save using JPA
        notificationRepository.save(notification);

        log.info(" Queued Notification for Targets: {}", targetRole);
    }

    private String buildNotificationMessage(Announcements a) {
        String prefix = switch (a.getSeverity()) {
            case "CRITICAL" -> " URGENT: ";
            case "WARN" -> " Attention: ";
            default -> " ";
        };
        return prefix + a.getTitle() + " : "+a.getMessage();
    }
}






package com.tcs.fincore.CommonMasterService.service;

import com.tcs.fincore.CommonMasterService.dto.AnnouncementDto;
import jakarta.validation.Valid;

import java.util.List;

public interface AnnouncementService {

    AnnouncementDto createAnnouncement(@Valid AnnouncementDto dto, String userId);

    AnnouncementDto updateAnnouncement(Long id, @Valid AnnouncementDto dto, String userId);

    List<AnnouncementDto> getAllAnnouncements();

    AnnouncementDto toggleStatus(Long id);
}










package com.tcs.fincore.CommonMasterService.service;

import com.tcs.fincore.CommonMasterService.dto.AnnouncementDto;
import com.tcs.fincore.CommonMasterService.model.Announcements;
import com.tcs.fincore.CommonMasterService.repository.AnnouncementsRepository;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class AnnouncementServiceImpl implements AnnouncementService {

    private final AnnouncementsRepository repository;
    private final AnnouncementNotificationService notificationService;

    // --- 1. CREATE ---
    @Transactional
    public AnnouncementDto createAnnouncement(AnnouncementDto dto, String userId) {
        Announcements entity = new Announcements();
        log.info("dto : {}", dto);
        mapDtoToEntity(dto, entity);

        // Defaults
        entity.setCreatedBy(userId);
        entity.setCreatedAt(LocalDateTime.now());

        if (entity.getStartDate() == null) entity.setStartDate(LocalDateTime.now());
        if (entity.getIsActive() == null) entity.setIsActive("Y");
        entity = repository.save(entity);

        // TRIGGER NOTIFICATION
        // Only if Active ('Y') AND Started (Not Future)
        if ("Y".equals(entity.getIsActive()) && !isFuture(entity.getStartDate())) {
            notificationService.broadcastAnnouncement(entity);
        }

        log.info("Announcement created with ID: {}", entity.getId());
        return mapEntityToDto(entity);
    }

    // --- 2. UPDATE ---
    @Transactional
    public AnnouncementDto updateAnnouncement(Long id, AnnouncementDto dto, String userId) {
        Announcements entity = repository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Announcement not found: " + id));

        // Update fields
        mapDtoToEntity(dto, entity);

        // Audit update (Optional: Add updatedBy/updatedAt columns if needed)
        log.info("Announcement {} updated by {}", id, userId);
        entity = repository.save(entity);

        return mapEntityToDto(entity);
    }

    // --- 3. LIST (Return all) ---
    public List<AnnouncementDto> getAllAnnouncements() {
        return repository.findAllByOrderByCreatedAtDesc().stream()
                .map(this::mapEntityToDto)
                .collect(Collectors.toList());
    }

    // --- 4. TOGGLE STATUS (Quick Action) ---
    @Transactional
    public AnnouncementDto toggleStatus(Long id) {
        Announcements entity = repository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Announcement not found"));
        String current = entity.getIsActive();
        LocalDateTime now = LocalDateTime.now();

        // LOGIC: If currently Inactive ('N'), and user wants to Activate ('Y')
        if ("N".equals(current)) {
            // Check Expiry
            if (entity.getExpiryDate() != null && entity.getExpiryDate().isBefore(now)) {
                // BLOCK THE ACTION
                throw new IllegalStateException("Cannot activate an expired announcement. Please edit the announcement and extend the expiry date first.");
            }
            entity.setIsActive("Y");
        } else {
            // Deactivating is always allowed
            entity.setIsActive("N");
        }
        repository.save(entity);

        // TRIGGER NOTIFICATION
        // Only if toggled to 'Y'
        if ("N".equals(current)) {
            notificationService.broadcastAnnouncement(entity);
        }

        return mapEntityToDto(entity);
    }

    // --- Helpers ---
    private AnnouncementDto mapEntityToDto(Announcements entity) {

        AnnouncementDto dto = AnnouncementDto.builder()
                .id(entity.getId())
                .title(entity.getTitle())
                .message(entity.getMessage())
                .severity(entity.getSeverity())
                .startDate(entity.getStartDate())
                .expiryDate(entity.getExpiryDate())
                .isActive(entity.getIsActive())
                .createdBy(entity.getCreatedBy())
                .createdAt(entity.getCreatedAt())
                .build();

        if (entity.getTargetRole() != null) {
            dto.setTargetRoles(List.of(entity.getTargetRole().split(",")));
        } else {
            dto.setTargetRoles(List.of("ALL"));
        }


        // --- COMPUTED STATUS LOGIC ---
        LocalDateTime now = LocalDateTime.now();
        String displayStatus;

        if ("N".equals(entity.getIsActive())) {
            displayStatus = "DISABLED"; // Manually turned off
        } else if (entity.getExpiryDate() != null && entity.getExpiryDate().isBefore(now)) {
            displayStatus = "EXPIRED"; // Active='Y' but Time is up
        } else if (entity.getStartDate().isAfter(now)) {
            displayStatus = "SCHEDULED"; // Active='Y' but Time hasn't started
        } else {
            displayStatus = "ACTIVE"; // Live on Dashboard
        }
        dto.setDisplayStatus(displayStatus);
        return dto;
    }

    private void mapDtoToEntity(AnnouncementDto dto, Announcements entity) {
        entity.setTitle(dto.getTitle());
        entity.setMessage(dto.getMessage());
        entity.setSeverity(dto.getSeverity());

        // CONVERT LIST ["51", "55"] -> STRING "51,55"
        if (dto.getTargetRoles() != null && !dto.getTargetRoles().isEmpty()) {
            entity.setTargetRole(String.join(",", dto.getTargetRoles()));
        } else {
            entity.setTargetRole("ALL"); // Default
        }

        entity.setStartDate(dto.getStartDate());
        entity.setExpiryDate(dto.getExpiryDate());
        // Only update status if provided (otherwise keep existing)
        if (dto.getIsActive() != null) entity.setIsActive(dto.getIsActive());
    }

    private boolean isFuture(LocalDateTime date) {
        return date != null && date.isAfter(LocalDateTime.now());
    }

}











package com.tcs.fincore.CommonMasterService.service;

import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import com.tcs.fincore.CommonMasterService.dto.BalanceRequestDTO;
import com.tcs.fincore.CommonMasterService.dto.BalanceResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.BranchStateCircleResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CGLSegmentResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CglSearchRequest;
import com.tcs.fincore.CommonMasterService.dto.PaginatedResponseDto;
import com.tcs.fincore.CommonMasterService.model.BranchCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.BranchMaster;
import com.tcs.fincore.CommonMasterService.model.BranchMasterWithCircleState;
import com.tcs.fincore.CommonMasterService.model.CGLCodeDescriptionOnly;
import com.tcs.fincore.CommonMasterService.model.CGLMaster;
import com.tcs.fincore.CommonMasterService.model.CGLMasterWithSegment;
import com.tcs.fincore.CommonMasterService.model.CalenderConfigModel;
import com.tcs.fincore.CommonMasterService.model.CircleMaster;
import com.tcs.fincore.CommonMasterService.model.CurrencyCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.CurrencyMasterModel;
import com.tcs.fincore.CommonMasterService.model.CurrencyRateChange;
import com.tcs.fincore.CommonMasterService.model.SegmentCodeMaster;
import com.tcs.fincore.CommonMasterService.model.StateMaster;
import com.tcs.fincore.CommonMasterService.model.ZoneMaster;

public interface CommonMasterService {

	List<SegmentCodeMaster> getSegmentCodes();

	PaginatedResponseDto<CGLMaster> getCGLs(CglSearchRequest request);

	List<CGLCodeDescriptionOnly> getCGLsCodeDescriptionOnly(String query);

	List<String> getCGLCodes();

	List<StateMaster> getStateList();

	List<BranchMaster> getBranches();

	List<BranchCodeNameOnly> getBranchesCodeNameOnly(String query);

	List<ZoneMaster> getZoneCodes();

	List<CircleMaster> getCircleList();

	List<CurrencyMasterModel> getCurrency();

	List<CurrencyCodeNameOnly> getCurrencyCodeNameOnly();

	List<CurrencyRateChange> getRateChange();

	List<String> getCurrencys();

	CalenderConfigModel getCalenderConfig();

	PaginatedResponseDto<BalanceResponseDTO> getBalanceDetails(BalanceRequestDTO request);

	byte[] exportBalanceToExcel(BalanceRequestDTO request);

	Page<BranchMaster> getBranchNames(Pageable pageable);

	PaginatedResponseDto<CGLSegmentResponseDTO> searchCglWithSegment(String text, Integer page, Integer size);

	CGLSegmentResponseDTO toCGLDto(CGLMasterWithSegment c);

	List<BranchStateCircleResponseDTO> searchByBranchNameORCode(String name);

	BranchStateCircleResponseDTO toBranchDto(BranchMasterWithCircleState b);

}








package com.tcs.fincore.CommonMasterService.service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.fincore.CommonMasterService.Specification.CglSpecification;
import com.tcs.fincore.CommonMasterService.dto.BalanceRequestDTO;
import com.tcs.fincore.CommonMasterService.dto.BalanceResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.BranchStateCircleResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CGLSegmentResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CglSearchRequest;
import com.tcs.fincore.CommonMasterService.dto.PaginatedResponseDto;
import com.tcs.fincore.CommonMasterService.exception.NoDataFoundException;
import com.tcs.fincore.CommonMasterService.model.BalanceRecord;
import com.tcs.fincore.CommonMasterService.model.BranchCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.BranchMaster;
import com.tcs.fincore.CommonMasterService.model.BranchMasterWithCircleState;
import com.tcs.fincore.CommonMasterService.model.CGLCodeDescriptionOnly;
import com.tcs.fincore.CommonMasterService.model.CGLMaster;
import com.tcs.fincore.CommonMasterService.model.CGLMasterWithSegment;
import com.tcs.fincore.CommonMasterService.model.CalenderConfigModel;
import com.tcs.fincore.CommonMasterService.model.CircleMaster;
import com.tcs.fincore.CommonMasterService.model.CurrencyCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.CurrencyMasterModel;
import com.tcs.fincore.CommonMasterService.model.CurrencyRateChange;
import com.tcs.fincore.CommonMasterService.model.SegmentCodeMaster;
import com.tcs.fincore.CommonMasterService.model.StateMaster;
import com.tcs.fincore.CommonMasterService.model.ZoneMaster;
import com.tcs.fincore.CommonMasterService.repository.AnnouncementsRepository;
import com.tcs.fincore.CommonMasterService.repository.BalanceRecordRepository;
import com.tcs.fincore.CommonMasterService.repository.BranchMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.BranchMasterWithStateCircleRepository;
import com.tcs.fincore.CommonMasterService.repository.CGLMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.CGLMasterWithSegmentRepository;
import com.tcs.fincore.CommonMasterService.repository.CalenderConfigRepository;
import com.tcs.fincore.CommonMasterService.repository.CircleMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.CurrencyMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.CurrencyRateChangeRepo;
import com.tcs.fincore.CommonMasterService.repository.SegmentCodeMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.StateMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.ZoneMasterRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class CommonMasterServiceImpl implements CommonMasterService {

	private final SegmentCodeMasterRepository repository;
	private final CGLMasterRepository cglMasterRepository;
	private final StateMasterRepository stateMasterRepository;
	private final BranchMasterRepository branchMasterRepository;
	private final ZoneMasterRepository zoneMasterRepository;
	private final CircleMasterRepository circleMatserRepository;
	private final CurrencyMasterRepository currencyMasterRepo;
	private final CalenderConfigRepository calenderConfigRepository;
	private final CurrencyRateChangeRepo currencyRateChangeRepo;
	private final BalanceRecordRepository balanceRecordRepository;
	private final AnnouncementsRepository announcementsRepository;
	private final CGLMasterWithSegmentRepository cglWithSegmentRepository;
	private final BranchMasterWithStateCircleRepository branchMasterWithStateCircleRepository;
	private final JwtUtil jwtUtil;

	private static final int EXPORT_CHUNK_SIZE = 500;

	@Override
	public List<SegmentCodeMaster> getSegmentCodes() {
		return (List<SegmentCodeMaster>) repository.findAll();
	}

	@Override
	public PaginatedResponseDto<CGLMaster> getCGLs(CglSearchRequest request) {

		PageRequest pageRequest = PageRequest.of(request.getPage(), request.getSize());

		Page<CGLMaster> pageResult;

		if (request.getFilters() == null || request.getFilters().isEmpty()) {
			pageResult = cglMasterRepository.findAll(pageRequest);
		} else {
			pageResult = cglMasterRepository.findAll(
					CglSpecification.build(request.getFilters()),
					pageRequest);
		}

		PaginatedResponseDto<CGLMaster> response = new PaginatedResponseDto<>();

		response.setData(pageResult.getContent());
		response.setTotalElements(pageResult.getTotalElements());
		response.setTotalPages(pageResult.getTotalPages());
		response.setPageSize(pageResult.getSize());
		response.setCurrentPage(pageResult.getNumber());

		return response;
	}

	@Override
	public List<CGLCodeDescriptionOnly> getCGLsCodeDescriptionOnly(String query) {
		return cglMasterRepository.findBycglNumberContainingIgnoreCaseOrDescriptionContainingIgnoreCase(query, query);
	}

	@Override
	public List<String> getCGLCodes() {
		return cglMasterRepository.findAllCGLNumbers();
	}

	@Override
	public List<String> getCurrencys() {
		return currencyMasterRepo.findAllCurrency();
	}

	@Override
	public List<StateMaster> getStateList() {
		return (List<StateMaster>) stateMasterRepository.findAll();
	}

	@Override
	public List<BranchMaster> getBranches() {
		return (List<BranchMaster>) branchMasterRepository.findAll();
	}

	@Override
	public List<BranchCodeNameOnly> getBranchesCodeNameOnly(String query) {
		return branchMasterRepository.findTop100ByCodeContainingIgnoreCaseOrNameContainingIgnoreCase(query, query);
	}

	@Override
	public List<ZoneMaster> getZoneCodes() {
		return zoneMasterRepository.findAll();
	}

	@Override
	public List<CircleMaster> getCircleList() {
		return circleMatserRepository.findAll();
	}

	@Override
	public List<CurrencyMasterModel> getCurrency() {
		return (List<CurrencyMasterModel>) currencyMasterRepo.findAll();
	}

	@Override
	public List<CurrencyCodeNameOnly> getCurrencyCodeNameOnly() {
		return currencyMasterRepo.findAllBy();
	}

	@Override
	public CalenderConfigModel getCalenderConfig() {
		return calenderConfigRepository.findFirstByOrderByIdDesc();
	}

	@Override
	public List<CurrencyRateChange> getRateChange() {
		return (List<CurrencyRateChange>) currencyRateChangeRepo.findAll();
	}

	@Override
	public PaginatedResponseDto<BalanceResponseDTO> getBalanceDetails(BalanceRequestDTO request) {
		if (request.getEndDate().before(request.getStartDate())) {
			throw new IllegalArgumentException("End date must be after start date");
		}

		int page = (request.getPage() != null && request.getPage() >= 0) ? request.getPage() : 0;

		int size = (request.getSize() != null && request.getSize() >= 0) ? request.getSize() : 10;

		String sortIn = (request.getSortIn() != null && !request.getSortIn().isBlank())
				? request.getSortIn().toUpperCase()
				: "ASC";

		Sort sort = sortIn.equals("DESC") ? Sort.by("date").descending() : Sort.by("date").ascending();

		PageRequest pageRequest = PageRequest.of(page, size, sort);

		Page<BalanceRecord> records = balanceRecordRepository.findByBranchAndCglAndCurrencyAndDateBetween(
				request.getBranch(), request.getCgl(), request.getCurrency(), request.getStartDate(),
				request.getEndDate(), pageRequest);

		if (records.isEmpty()) {
			throw new NoDataFoundException("No records found for given filters");
		}

		List<BalanceResponseDTO> list = records.stream()
				.map(
						r -> new BalanceResponseDTO(
								r.getId(), r.getDate(), r.getBranch(), r.getCgl(), r.getCurrency(), r.getBalance()))
				.toList();

		String actualSort = records.getSort().stream().findFirst().map(order -> order.getDirection().name())
				.orElse("UNSORTED");

		return new PaginatedResponseDto<>(
				records.getNumber(), records.getTotalPages(), records.getSize(), records.getTotalElements(), actualSort,
				list);

	}

	@Override
	public byte[] exportBalanceToExcel(BalanceRequestDTO request) {

		if (request.getEndDate().before(request.getStartDate())) {
			throw new IllegalArgumentException("End date must be after start date");
		}
		int chunkSize = EXPORT_CHUNK_SIZE;
		try (Workbook workbook = new XSSFWorkbook();
				ByteArrayOutputStream out = new ByteArrayOutputStream()) {
			Sheet sheet = workbook.createSheet("Balance Enquiry");

			CellStyle headerStyle = workbook.createCellStyle();
			Font headereFont = workbook.createFont();
			headereFont.setBold(true);
			headerStyle.setFont(headereFont);

			CellStyle dateStyle = workbook.createCellStyle();
			CreationHelper creationHelper = workbook.getCreationHelper();
			short dateFormat = creationHelper.createDataFormat().getFormat("dd-MM-yyyy");
			dateStyle.setDataFormat(dateFormat);

			CellStyle balanceStyle = workbook.createCellStyle();
			short balanceFormat = creationHelper.createDataFormat().getFormat("#,##0.00");
			balanceStyle.setDataFormat(balanceFormat);

			String[] columns = { "ID", "Date", "Branch", "CGL", "Currency", "Balance" };
			Row header = sheet.createRow(0);
			for (int i = 0; i < columns.length; i++) {
				Cell cell = header.createCell(i);
				cell.setCellValue(columns[i]);
				cell.setCellStyle(headerStyle);
			}

			int rowIdx = 1;
			int page = 0;
			Page<BalanceRecord> recordsPage;

			do {
				Pageable pageable = PageRequest.of(page, chunkSize, Sort.by("date").ascending());

				recordsPage = balanceRecordRepository.findByBranchAndCglAndCurrencyAndDateBetween(request.getBranch(),
						request.getCgl(), request.getCurrency(), request.getStartDate(), request.getEndDate(),
						pageable);

				if (page == 0 && recordsPage.isEmpty()) {
					workbook.write(out);
					return out.toByteArray();
				}
				for (BalanceRecord r : recordsPage.getContent()) {
					Row row = sheet.createRow(rowIdx++);
					if (r.getId() != null) {
						row.createCell(0).setCellValue(r.getId());
					} else {
						row.createCell(0).setCellValue("");
					}
					Cell dateCell = row.createCell(1);
					if (r.getDate() != null) {
						dateCell.setCellValue(r.getDate());
						dateCell.setCellStyle(dateStyle);
					} else {
						dateCell.setCellValue("");
					}

					row.createCell(2).setCellValue(r.getBranch() != null ? r.getBranch() : "");
					row.createCell(3).setCellValue(r.getCgl() != null ? r.getCgl() : "");
					row.createCell(4).setCellValue(r.getCurrency() != null ? r.getCurrency() : "");
					Cell balanceCell = row.createCell(5);
					balanceCell.setCellValue(r.getBalance());
					balanceCell.setCellStyle(balanceStyle);
				}
				page++;
			} while (!recordsPage.isLast());

			for (int i = 0; i < columns.length; i++) {
				sheet.autoSizeColumn(i);
			}
			workbook.write(out);
			return out.toByteArray();

		} catch (IOException e) {
			throw new RuntimeException("Failed to generate Excel file", e);
		}
	}

	@Override
	public Page<BranchMaster> getBranchNames(Pageable pageable) {

		return branchMasterRepository.findAll(pageable);
	}

	@Override
	@Transactional
	public PaginatedResponseDto<CGLSegmentResponseDTO> searchCglWithSegment(String text, Integer page, Integer size) {
		int pageNo = (page == null || page < 0) ? 0 : page;
		int pageSize = (size == null || size <= 0) ? 10 : size;

		Pageable pageable = PageRequest.of(pageNo, pageSize);

		Page<CGLMasterWithSegment> pageResult = cglWithSegmentRepository
				.findByCglNumberContainingIgnoreCaseOrDescriptionContainingIgnoreCase(text.trim(), text.trim(),
						pageable);

		List<CGLSegmentResponseDTO> list = pageResult.getContent().stream().map(this::toCGLDto).toList();
		if (list.isEmpty()) {
			throw new NoDataFoundException("No records found for " + text + " !!");
		}
		return new PaginatedResponseDto<>(pageResult.getNumber(), pageResult.getTotalPages(), pageResult.getSize(),
				pageResult.getTotalElements(), null, list);

	}

	// Helper Class for searchCglWithSegment to convert entity to DTO
	public CGLSegmentResponseDTO toCGLDto(CGLMasterWithSegment c) {
		return new CGLSegmentResponseDTO(c.getCglNumber(), c.getDescription(), c.getComp1(), c.getComp2(),
				c.getAcClassification(), c.getSegmentCode(),
				(c.getSegment() != null ? c.getSegment().getDescription() : null), c.getBalFwd(), c.getDefBalType(),
				c.getStatus(), c.getOpenDate(), c.getCloseDate(), c.getBalCompare(), c.getManualPosting());
	}

	public List<BranchStateCircleResponseDTO> searchByBranchNameORCode(String name) {

		List<BranchMasterWithCircleState> branches = branchMasterWithStateCircleRepository
				.findByCodeContainingIgnoreCaseOrNameContainingIgnoreCase(name.trim(), name.trim());

		if (branches.isEmpty()) {
			throw new NoDataFoundException("No branches found for " + name + " !!");
		}

		return branches.stream().map(this::toBranchDto).toList();

	}

	// Helper Class for searchByBranchNameORCode to convert entity to DTO
	public BranchStateCircleResponseDTO toBranchDto(BranchMasterWithCircleState b) {
		return new BranchStateCircleResponseDTO(b.getCode(), b.getName(), b.getCity(), b.getCircleCode(),
				(b.getCircle() != null ? b.getCircle().getCircleName() : null), b.getStateCode(),
				(b.getState() != null ? b.getState().getStateName() : null), b.getAddress(), b.getPinCode(),
				b.getPhoneNumber(), b.getEmailId(), b.getNmrCode(), b.getStatus(), b.getOpenDate(), b.getCloseDate(),
				b.getMergeDate(), b.getMergedWithBranch(), b.getLastChangeDate(), b.getCpcFlag(), b.getFoodCreditFlag(),
				b.getCurrChestFlag(), b.getBranchType());
	}
}















// specification

package com.tcs.fincore.CommonMasterService.Specification;

import com.tcs.fincore.CommonMasterService.dto.CglFilterRequest;
import com.tcs.fincore.CommonMasterService.model.CGLMaster;

import org.springframework.data.jpa.domain.Specification;

import jakarta.persistence.criteria.Predicate;
import java.util.ArrayList;
import java.util.List;

public class CglSpecification {

    public static Specification<CGLMaster> build(List<CglFilterRequest> filters) {

        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            for (CglFilterRequest filter : filters) {

                String field = filter.getField();
                String operator = filter.getOperator();
                String value = filter.getValue();

                if (value == null || value.isBlank()) {
                    continue;
                }

                if ("contains".equalsIgnoreCase(operator)) {
                    predicates.add(
                            cb.like(
                                    cb.lower(root.get(field)),
                                    "%" + value.toLowerCase() + "%"));
                } else if ("equals".equalsIgnoreCase(operator)) {
                    predicates.add(
                            cb.equal(root.get(field), value));
                }
            }

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}







package com.tcs.fincore.CommonMasterService;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CommonMasterServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(CommonMasterServiceApplication.class, args);
    }

}







spring.application.name=CommonMasterService
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.profiles.active=dev
server.port=2000

#todo Expose all actuator endpoints over HTTP.
management.endpoints.web.exposure.include=*

# Always show full details on the health endpoint (e.g., database connection status)
management.endpoint.health.show-details=always

# Add some custom info to the /info endpoint
info.app.name=CommonMasterService
info.app.description=Service for managing Different Screen requests. [ex: SegmentRequest, CGL etc]
info.app.version=1.0.0

spring.jackson.date-format=dd/MM/yyyy
spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.time-zone= Asia/Kolkata




# Use Red Hat UBI with OpenJDK 17 (if accessible internally)
FROM alpine/java:22-jdk

# Set working directory inside container
#WORKDIR /app

ARG JAR_FILE=target/*.jar
# Set environment variable (optional)
ENV SPRING_PROFILES_ACTIVE=dev
ENV SERVER_PORT=2000

# Copy JAR file into the container
COPY ${JAR_FILE} app.jar

EXPOSE 2000

# Run your Spring Boot app
CMD ["java", "-jar", "app.jar"]



 



