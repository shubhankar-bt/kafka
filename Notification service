package com.fincore.NotificationService.service;

import com.fincore.NotificationService.config.RedisConfig;
import com.fincore.NotificationService.dto.DebeziumEvent;
import com.fincore.NotificationService.dto.NotificationOutboxEvent;
import com.fincore.NotificationService.model.Notification;
import com.fincore.NotificationService.repository.NotificationRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class EventProcessorService {

    private static final Logger log = LoggerFactory.getLogger(EventProcessorService.class);

    @Autowired
    private NotificationRepository notificationRepository;

    // Injected Redis template to publish messages
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    // Injected UserService to find users by role (this uses caching)
    @Autowired
    private UserService userService;

    /**
     * This is the main entry point from your Kafka consumer.
     * It checks the event and decides what to do.
     */
    @Transactional
    public void processEvent(DebeziumEvent event) {
        if (event == null || event.getPayload() == null) {
            log.warn("Received null event or payload, skipping.");
            return;
        }

        // We only care about new rows ("c" for create)
        if ("c".equals(event.getPayload().getOperation())) {
            NotificationOutboxEvent outboxEvent = event.getPayload().getAfter();
            if (outboxEvent == null) {
                log.warn("Received 'create' event with null 'after' data, skipping.");
                return;
            }

            String userId = outboxEvent.getUserId();
            String roleId = outboxEvent.getTargetRole();

            // --- MAKER/CHECKER LOGIC ---

            if (userId != null && !userId.isEmpty()) {
                // SCENARIO A: 1-to-1 Notification (e.g., Checker approves -> Maker)
                log.info("Processing 1-to-1 notification for user: {}", userId);
                processSingleNotification(outboxEvent, userId);

            } else if (roleId != null && !roleId.isEmpty()) {
                // SCENARIO B: 1-to-Many Notification (e.g., Maker creates -> Checkers)
                log.info("Processing 1-to-Many notification for role: {}", roleId);
                
                // 1. Get the list of users for this role (THIS IS CACHED by @Cacheable)
                List<String> userIdsInRole = userService.findUsersByRole(roleId);
                log.info("Found {} users for role {}: {}", userIdsInRole.size(), roleId, userIdsInRole);

                // 2. Fan-out: Create a notification for EACH user.
                for (String targetUserId : userIdsInRole) {
                    processSingleNotification(outboxEvent, targetUserId);
                }
            } else {
                log.warn("Skipping event {}: No USER_ID or TARGET_ROLE defined.", outboxEvent.getEventId());
            }

        } else {
            // We ignore updates ('u') or deletes ('d') for this use case
            log.info("Ignoring operation '{}'", event.getPayload().getOperation());
        }
    }

    /**
     * Helper method to create, save, and BROADCAST a single notification.
     * This is called for every user (whether 1-to-1 or 1-to-many).
     */
    private void processSingleNotification(NotificationOutboxEvent outboxEvent, String userId) {
        Notification notification = new Notification(
            userId,
            outboxEvent.getMessage(),
            outboxEvent.getLinkUrl()
        );

        // 2. Save to Postgres DB (and get the generated ID, createdAt)
        // We use saveAndFlush() to get the timestamp *before* sending to Redis.
        Notification savedNotification = notificationRepository.saveAndFlush(notification);

        // 3. PUSH TO REDIS (for scaling)
        // We broadcast this to ALL instances, and let them find the right user.
        try {
            log.info("Broadcasting notification {} to Redis topic '{}'", savedNotification.getId(), RedisConfig.NOTIFICATION_TOPIC);
            redisTemplate.convertAndSend(RedisConfig.NOTIFICATION_TOPIC, savedNotification);
        } catch (Exception e) {
            log.error("Failed to publish notification to Redis", e);
        }
    }
}












package com.fincore.NotificationService.service;

import com.fincore.NotificationService.model.Notification;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class SsePushService {

    private static final Logger log = LoggerFactory.getLogger(SsePushService.class);

    // This map ONLY stores connections for users connected to THIS specific instance.
    private final Map<String, SseEmitter> emitters = new ConcurrentHashMap<>();

    /**
     * Called by the Controller when a new user connects to THIS instance.
     */
    public SseEmitter subscribe(String userId) {
        // Create an emitter that never times out
        SseEmitter emitter = new SseEmitter(0L); 

        // Store this emitter so we can send messages to it later
        this.emitters.put(userId, emitter);
        log.info("New local SSE connection established for user: {}. Total local connections: {}", userId, emitters.size());

        // Set up handlers for when the connection breaks or times out
        emitter.onCompletion(() -> {
            log.info("SSE connection completed for user: {}. Removing emitter.", userId);
            this.emitters.remove(userId);
        });
        emitter.onTimeout(() -> {
            log.info("SSE connection timed out for user: {}. Removing emitter.", userId);
            this.emitters.remove(userId);
        });
        emitter.onError((e) -> {
            log.error("SSE error for user: {}. Removing emitter.", userId, e);
            this.emitters.remove(userId);
        });

        // Send a "hello" message to confirm the connection
        try {
            emitter.send(SseEmitter.event().name("connected").data("Connection established"));
        } catch (IOException e) {
            log.error("Could not send initial 'connected' event to user: {}", userId, e);
            this.emitters.remove(userId);
        }

        return emitter;
    }

    /**
     * This method is called by the RedisMessageListener.
     * It pushes a notification ONLY if this specific instance is
     * managing the connection for that user.
     */
    public void pushNotificationToLocalEmitter(Notification notification) {
        String userId = notification.getUserId();
        SseEmitter emitter = this.emitters.get(userId);

        // Check if this user is connected to THIS server instance
        if (emitter != null) {
            try {
                log.info("Found local emitter for user {}. Pushing notification {}.", userId, notification.getId());
                // Send an event named "new_notification" with the Notification object as JSON
                emitter.send(SseEmitter.event().name("new_notification").data(notification));
            } catch (IOException e) {
                // This means the client's connection is broken (e.g., they closed their laptop)
                log.error("Failed to push notification to user: {}. Removing emitter.", userId, e);
                this.emitters.remove(userId);
            }
        } else {
             // This is a NORMAL log message. 
             // It just means this user is connected to a different server instance, not this one.
             log.debug("No local emitter for user {}. This is normal.", userId);
        }
    }
}











