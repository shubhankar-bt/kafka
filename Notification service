package com.fincore.NotificationService.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

// This is the main DTO for the NOTIFICATION_TABLE topic
@JsonIgnoreProperties(ignoreUnknown = true)
public class DebeziumEvent {
    @JsonProperty("payload")
    private Payload payload;

    public Payload getPayload() { return payload; }
    public void setPayload(Payload payload) { this.payload = payload; }
}

@JsonIgnoreProperties(ignoreUnknown = true)
class Payload {
    @JsonProperty("after")
    private NotificationOutboxEvent after;

    @JsonProperty("op")
    private String operation; // 'c' for create, 'u' for update, 'd' for delete

    public NotificationOutboxEvent getAfter() { return after; }
    public void setAfter(NotificationOutboxEvent after) { this.after = after; }
    
    public String getOperation() { return operation; }
    public void setOperation(String op) { this.operation = op; }
}







package com.fincore.NotificationService.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

// This MUST match your Oracle FTWOAHM.NOTIFICATION_TABLE columns
@JsonIgnoreProperties(ignoreUnknown = true)
public class NotificationOutboxEvent {

    @JsonProperty("EVENT_ID")
    private String eventId;

    @JsonProperty("USER_ID")
    private String userId;

    @JsonProperty("MESSAGE")
    private String message;
    
    @JsonProperty("LINK_URL")
    private String linkUrl;

    @JsonProperty("EVENT_SOURCE")
    private String eventSource;

    @JsonProperty("AGGREGATE_ID")
    private String aggregateId;

    @JsonProperty("TARGET_ROLE")
    private String targetRole;

    // --- (Generate Getters/Setters for all fields) ---
    
    public String getEventId() { return eventId; }
    public void setEventId(String eventId) { this.eventId = eventId; }
    public String getUserId() { return userId; }
    public void setUserId(String userId) { this.userId = userId; }
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    public String getLinkUrl() { return linkUrl; }
    public void setLinkUrl(String linkUrl) { this.linkUrl = linkUrl; }
    public String getEventSource() { return eventSource; }
    public void setEventSource(String eventSource) { this.eventSource = eventSource; }
    public String getAggregateId() { return aggregateId; }
    public void setAggregateId(String aggregateId) { this.aggregateId = aggregateId; }
    public String getTargetRole() { return targetRole; }
    public void setTargetRole(String targetRole) { this.targetRole = targetRole; }
}







package com.fincore.NotificationService.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

// This DTO hierarchy is for parsing the `fincore.FTWOAHM.USER_ROLES` topic
@JsonIgnoreProperties(ignoreUnknown = true)
public class UserRoleEventDto {
    @JsonProperty("payload")
    private UserRolePayload payload;
    
    public UserRolePayload getPayload() { return payload; }
    public void setPayload(UserRolePayload payload) { this.payload = payload; }
}

@JsonIgnoreProperties(ignoreUnknown = true)
class UserRolePayload {
    @JsonProperty("after")
    private UserRoleData after;
    
    @JsonProperty("before")
    private UserRoleData before;

    @JsonProperty("op")
    private String operation; // 'c' create, 'u' update, 'd' delete

    // Getters/Setters
    public UserRoleData getAfter() { return after; }
    public void setAfter(UserRoleData after) { this.after = after; }
    public UserRoleData getBefore() { return before; }
    public void setBefore(UserRoleData before) { this.before = before; }
    public String getOperation() { return operation; }
    public void setOperation(String op) { this.operation = op; }
}

// This MUST match the columns in FTWOAHM.USER_ROLES
@JsonIgnoreProperties(ignoreUnknown = true)
class UserRoleData {
    @JsonProperty("USER_ID") 
    private String userId;

    @JsonProperty("ROLE_ID")
    private String roleId;
    
    // Getters/Setters
    public String getUserId() { return userId; }
    public void setUserId(String userId) { this.userId = userId; }
    public String getRoleId() { return roleId; }
    public void setRoleId(String roleId) { this.roleId = roleId; }
}
















package com.fincore.NotificationService.model;

import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import java.time.Instant;
import java.util.UUID;

@Entity
@Table(name = "notifications")
public class Notification {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @Column(nullable = false, updatable = false)
    private String userId;

    @Column(nullable = false, length = 1024)
    private String message;

    @Column(nullable = false)
    private boolean isRead = false;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private Instant createdAt;
    
    private String linkUrl;

    // --- Constructors, Getters, and Setters ---
    public Notification() {}

    public Notification(String userId, String message, String linkUrl) {
        this.userId = userId;
        this.message = message;
        this.linkUrl = linkUrl;
    }
    
    // (Lombok would generate these, but here they are manually)
    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }
    public String getUserId() { return userId; }
    public void setUserId(String userId) { this.userId = userId; }
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    public boolean isRead() { return isRead; }
    public void setRead(boolean read) { isRead = read; }
    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }
    public String getLinkUrl() { return linkUrl; }
    public void setLinkUrl(String linkUrl) { this.linkUrl = linkUrl; }
}









package com.fincore.NotificationService.repository;

import com.fincore.NotificationService.model.Notification;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface NotificationRepository extends JpaRepository<Notification, UUID> {

    // For the REST API (history page)
    Page<Notification> findByUserIdOrderByCreatedAtDesc(String userId, Pageable pageable);

    // For the REST API (unread badge)
    long countByUserIdAndIsReadFalse(String userId);
}








package com.fincore.NotificationService.repository;

import com.fincore.NotificationService.model.UserRole;
import com.fincore.NotificationService.model.UserRoleKey;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface UserRoleRepository extends JpaRepository<UserRole, UserRoleKey> {
    
    // This is the query our UserService will use for the fan-out
    List<UserRole> findByRoleId(String roleId);
}













package com.fincore.NotificationService.service;

import com.fincore.NotificationService.dto.DebeziumEvent;
import com.fincore.NotificationService.dto.UserRoleEventDto;
import com.fincore.NotificationService.model.UserRole;
import com.fincore.NotificationService.model.UserRoleKey;
import com.fincore.NotificationService.repository.UserRoleRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.CacheManager;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class KafkaConsumerService {

    private static final Logger log = LoggerFactory.getLogger(KafkaConsumerService.class);
    
    @Autowired
    private EventProcessorService eventProcessorService;

    @Autowired
    private UserRoleRepository userRoleRepository;

    @Autowired
    private CacheManager cacheManager;

    // --- LISTENER 1: For Notifications ---
    @KafkaListener(topics = "fincore.FTWOAHM.NOTIFICATION_TABLE", 
                   containerFactory = "kafkaListenerContainerFactory")
    public void listen(DebeziumEvent event) {
        try {
            log.info("ðŸŽ‰ KAFKA NOTIFICATION EVENT RECEIVED!");
            eventProcessorService.processEvent(event);
        } catch (Exception e) {
            log.error("Error processing notification event: {}", e.getMessage(), e);
            // This throw triggers the DLQ
            throw new RuntimeException("Error processing notification event", e);
        }
    }

    // --- LISTENER 2: For User Role Sync & Cache Invalidation ---
    @KafkaListener(topics = "fincore.FTWOAHM.USER_ROLES", 
                   containerFactory = "userRoleListenerContainerFactory")
    @Transactional
    public void listenToUserRolesChanges(UserRoleEventDto event) {
        try {
            if (event == null || event.getPayload() == null || (event.getPayload().getAfter() == null && event.getPayload().getBefore() == null)) {
                log.warn("Received null or empty user/role event, skipping.");
                return;
            }

            String op = event.getPayload().getOperation();
            var data = "d".equals(op) ? event.getPayload().getBefore() : event.getPayload().getAfter();
            if (data == null || data.getRoleId() == null || data.getUserId() == null) {
                log.warn("Received user/role event with missing data, skipping.");
                return;
            }
            
            log.info("ðŸŽ‰ KAFKA USER_ROLE EVENT RECEIVED! Op: {}", op);

            // 1. Replicate the change to our local Postgres DB
            if ("d".equals(op)) {
                userRoleRepository.deleteById(new UserRoleKey(data.getUserId(), data.getRoleId()));
            } else {
                UserRole ur = new UserRole();
                ur.setUserId(data.getUserId());
                ur.setRoleId(data.getRoleId());
                userRoleRepository.save(ur);
            }

            // 2. Invalidate the Redis cache for this role
            log.info("Cache Invalidation: Evicting cache for role: {}", data.getRoleId());
            cacheManager.getCache("roles").evict(data.getRoleId());

        } catch (Exception e) {
            log.error("Error processing user/role event: {}", e.getMessage(), e);
        }
    }
}











package com.fincore.NotificationService.service;

import com.fincore.NotificationService.repository.UserRoleRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class UserService {

    private static final Logger log = LoggerFactory.getLogger(UserService.class);

    @Autowired
    private UserRoleRepository userRoleRepository;

    /**
     * Finds users for a role.
     * This result is cached in Redis. The cache is automatically
     * cleared by KafkaConsumerService when a role changes.
     */
    @Cacheable(value = "roles", key = "#roleId")
    public List<String> findUserIdsByRole(String roleId) {
        log.info("Cache miss for role: {}. Querying local Postgres DB...", roleId);
        
        // Query our local, replicated Postgres table
        return userRoleRepository.findByRoleId(roleId)
                .stream()
                .map(userRole -> userRole.getUserId())
                .collect(Collectors.toList());
    }
}










package com.fincore.NotificationService.service;

import com.fincore.NotificationService.config.RedisConfig;
import com.fincore.NotificationService.dto.DebeziumEvent;
import com.fincore.NotificationService.dto.NotificationOutboxEvent;
import com.fincore.NotificationService.model.Notification;
import com.fincore.NotificationService.repository.NotificationRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class EventProcessorService {

    private static final Logger log = LoggerFactory.getLogger(EventProcessorService.class);

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private UserService userService;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Transactional
    public void processEvent(DebeziumEvent event) {
        if (event == null || event.getPayload() == null || (event.getPayload().getAfter() == null)) {
            log.warn("Received null or empty notification event, skipping.");
            return;
        }

        if ("c".equals(event.getPayload().getOperation())) {
            NotificationOutboxEvent outboxEvent = event.getPayload().getAfter();
            String userId = outboxEvent.getUserId();
            String roleId = outboxEvent.getTargetRole();

            if (userId != null) {
                // --- SCENARIO 1: 1-to-1 Notification ---
                log.info("Processing 1-to-1 notification for user: {}", userId);
                processAndBroadcast(outboxEvent, userId);

            } else if (roleId != null) {
                // --- SCENARIO 2: 1-to-Many Role-Based (Maker/Checker) ---
                log.info("Processing 1-to-Many notification for role: {}", roleId);
                
                List<String> userIdsInRole = userService.findUserIdsByRole(roleId);
                log.info("Found {} users for role {}. Broadcasting...", userIdsInRole.size(), roleId);

                for (String targetUserId : userIdsInRole) {
                    processAndBroadcast(outboxEvent, targetUserId);
                }
            }
        }
    }

    private void processAndBroadcast(NotificationOutboxEvent outboxEvent, String userId) {
        Notification notification = new Notification(
            userId,
            outboxEvent.getMessage(),
            outboxEvent.getLinkUrl()
        );

        // Use saveAndFlush to get the createdAt timestamp before sending
        Notification savedNotification = notificationRepository.saveAndFlush(notification);
        log.info("Notification saved to DB for user: {}", userId);

        try {
            redisTemplate.convertAndSend(RedisConfig.NOTIFICATION_TOPIC, savedNotification);
            log.info("Broadcasting notification {} to Redis topic...", savedNotification.getId());
        } catch (Exception e) {
            log.error("Failed to publish notification to Redis", e);
        }
    }
}

















package com.fincore.NotificationService.service;

import com.fincore.NotificationService.model.Notification;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.connection.Message;
import org.springframework.data.redis.connection.MessageListener;
import org.springframework.stereotype.Service;

@Service
public class RedisMessageListener implements MessageListener {

    private static final Logger log = LoggerFactory.getLogger(RedisMessageListener.class);

    @Autowired
    private ObjectMapper objectMapper; // The bean we created in RedisConfig

    @Autowired
    private SsePushService ssePushService;

    @Override
    public void onMessage(Message message, byte[] pattern) {
        try {
            Notification notification = objectMapper.readValue(message.getBody(), Notification.class);
            log.info("Received message from Redis Pub/Sub for user: {}", notification.getUserId());
            
            // Push the notification to any users connected to *this server instance*.
            ssePushService.pushNotificationToLocalEmitter(notification);

        } catch (Exception e) {
            log.error("Could not parse message from Redis Pub/Sub", e);
        }
    }
}








package com.fincore.NotificationService.service;

import com.fincore.NotificationService.model.Notification;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class SsePushService {

    private static final Logger log = LoggerFactory.getLogger(SsePushService.class);

    // This map stores the active connections *for this server instance*
    private final Map<String, SseEmitter> emitters = new ConcurrentHashMap<>();

    public SseEmitter subscribe(String userId) {
        SseEmitter emitter = new SseEmitter(0L); // 0L = never timeout

        this.emitters.put(userId, emitter);
        log.info("New SSE connection for user: {}. Total connections: {}", userId, emitters.size());

        emitter.onCompletion(() -> {
            log.info("SSE connection completed for user: {}", userId);
            this.emitters.remove(userId);
        });
        emitter.onTimeout(() -> {
            log.info("SSE connection timed out for user: {}", userId);
            this.emitters.remove(userId);
        });
        emitter.onError((e) -> {
            log.error("SSE error for user: {}", userId, e);
            this.emitters.remove(userId);
        });

        try {
            emitter.send(SseEmitter.event().name("connected").data("Connection established"));
        } catch (IOException e) {
            log.error("Could not send connection event to user: {}", userId, e);
            this.emitters.remove(userId);
        }
        return emitter;
    }

    /**
     * Called by the RedisMessageListener.
     */
    public void pushNotificationToLocalEmitter(Notification notification) {
        String userId = notification.getUserId();
        SseEmitter emitter = this.emitters.get(userId);

        if (emitter != null) {
            try {
                log.info("Pushing notification to local emitter for user: {}", userId);
                emitter.send(SseEmitter.event().name("new_notification").data(notification));
            } catch (IOException e) {
                log.error("Failed to push notification to user: {}. Removing emitter.", userId, e);
                this.emitters.remove(userId);
            }
        } else {
            log.debug("No active local SSE connection for user: {}", userId);
        }
    }
}









package com.fincore.NotificationService.controller;

import com.fincore.NotificationService.model.Notification;
import com.fincore.NotificationService.service.NotificationService;
import com.fincore.NotificationService.service.SsePushService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/notifications")
// CORS is handled by WebConfig.java
public class NotificationController {

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private SsePushService ssePushService;

    // A simple hardcoded user for testing.
    // In a real app, you would get this from the Spring Security token.
    private final String MOCK_USER_ID = "DEBEZIUM"; 

    /**
     * GET /api/notifications/stream
     * The real-time SSE connection endpoint.
     */
    @GetMapping("/stream")
    public SseEmitter streamNotifications() {
        // TODO: Replace MOCK_USER_ID with the real, authenticated user ID
        return ssePushService.subscribe(MOCK_USER_ID);
    }

    /**
     * GET /api/notifications
     * Fetches notification history for the user, with pagination.
     */
    @GetMapping
    public ResponseEntity<Page<Notification>> getNotifications(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        
        // TODO: Replace MOCK_USER_ID with the real, authenticated user ID
        Page<Notification> notifications = notificationService.getNotificationsForUser(MOCK_USER_ID, page, size);
        return ResponseEntity.ok(notifications);
    }

    /**
     * GET /api/notifications/unread-count
     * Gets the count for the notification bell badge.
     */
    @GetMapping("/unread-count")
    public ResponseEntity<Map<String, Long>> getUnreadCount() {
        // TODO: Replace MOCK_USER_ID with the real, authenticated user ID
        long count = notificationService.getUnreadNotificationCount(MOCK_USER_ID);
        return ResponseEntity.ok(Map.of("count", count));
    }

    /**
     * POST /api/notifications/{id}/read
     * Marks a single notification as read.
     */
    @PostMapping("/{id}/read")
    public ResponseEntity<Void> markNotificationAsRead(@PathVariable("id") UUID id) {
        // TODO: Replace MOCK_USER_ID with the real, authenticated user ID
        boolean success = notificationService.markAsRead(MOCK_USER_ID, id);
        
        if (success) {
            return ResponseEntity.ok().build();
        } else {
            return ResponseEntity.notFound().build();
        }
    }
}














package com.fincore.NotificationService.config;

import com.fincore.NotificationService.dto.UserRoleEventDto;
import org.apache.kafka.common.TopicPartition;
import org.springframework.boot.autoconfigure.kafka.KafkaProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.listener.DeadLetterPublishingRecoverer;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.util.backoff.FixedBackOff;

@Configuration
public class KafkaConfig {

    // --- BEAN 1: For Notifications (Uses the default consumerFactory) ---
    @Bean
    public ConcurrentKafkaListenerContainerFactory<Object, Object> kafkaListenerContainerFactory(
            ConsumerFactory<Object, Object> consumerFactory,
            KafkaTemplate<Object, Object> kafkaTemplate) {

        ConcurrentKafkaListenerContainerFactory<Object, Object> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory);
        factory.setCommonErrorHandler(defaultErrorHandler(kafkaTemplate));
        
        return factory;
    }

    // --- BEAN 2: For DLQ ---
    @Bean
    public DefaultErrorHandler defaultErrorHandler(KafkaTemplate<Object, Object> kafkaTemplate) {
        
        DeadLetterPublishingRecoverer recoverer = new DeadLetterPublishingRecoverer(kafkaTemplate,
            (record, exception) -> new TopicPartition(
                "fincore.FTWOAHM.NOTIFICATION_TABLE_DLQ", -1
            )
        );

        FixedBackOff backOff = new FixedBackOff(1000L, 2L);
        DefaultErrorHandler errorHandler = new DefaultErrorHandler(recoverer, backOff);
        errorHandler.addNotRetryableExceptions(RuntimeException.class);

        return errorHandler;
    }
    
    // --- BEAN 3: For UserRoles (Uses a custom consumerFactory) ---
    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, UserRoleEventDto> userRoleListenerContainerFactory(KafkaProperties properties) {
        
        var props = properties.buildConsumerProperties(null);
        props.put(JsonDeserializer.TRUSTED_PACKAGES, "*");
        props.put(JsonDeserializer.USE_TYPE_HEADERS, false);
        // This package name MUST match your project structure
        props.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "com.fincore.NotificationService.dto.UserRoleEventDto");

        var consumerFactory = new DefaultKafkaConsumerFactory<>(
            props, 
            new org.apache.kafka.common.serialization.StringDeserializer(), 
            new JsonDeserializer<>(UserRoleEventDto.class)
        );

        ConcurrentKafkaListenerContainerFactory<String, UserRoleEventDto> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory);
        return factory;
    }
}










package com.fincore.NotificationService.config;

import com.fincore.NotificationService.service.RedisMessageListener;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.cache.CacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.listener.ChannelTopic;
import org.springframework.data.redis.listener.RedisMessageListenerContainer;
import org.springframework.data.redis.listener.adapter.MessageListenerAdapter;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {

    // This is the name of our Pub/Sub topic for scaling
    public static final String NOTIFICATION_TOPIC = "notifications:push";

    // This bean fixes the "cacheManager not found" error
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .disableCachingNullValues();

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(cacheConfig)
                .build();
    }

    // This bean fixes the "java.time.Instant" serialization error
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        return mapper;
    }

    // This bean configures our RedisTemplate to use the fixed ObjectMapper
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory, ObjectMapper objectMapper) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        Jackson2JsonRedisSerializer<Object> serializer = 
            new Jackson2JsonRedisSerializer<>(objectMapper, Object.class);

        template.setValueSerializer(serializer);
        template.setKeySerializer(new StringRedisSerializer());

        return template;
    }

    // This bean registers our RedisMessageListener
    @Bean
    public MessageListenerAdapter messageListenerAdapter(RedisMessageListener listener) {
        return new MessageListenerAdapter(listener, "onMessage");
    }

    // This bean is the main Pub/Sub container
    @Bean
    public RedisMessageListenerContainer redisMessageListenerContainer(RedisConnectionFactory connectionFactory, MessageListenerAdapter listenerAdapter) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        container.addMessageListener(listenerAdapter, new ChannelTopic(NOTIFICATION_TOPIC));
        return container;
    }
}







