DB Timeouts: Configure connection pooling timeouts in application.properties.

spring.datasource.hikari.connection-timeout=20000 # 20s
spring.datasource.hikari.maximum-pool-size=20

API Timeouts: If services call each other (Feign/RestTemplate), set timeouts.
API Timeouts: If services call each other (Feign/RestTemplate), set timeouts.



Ingress Action:
Configure proxy_read_timeout (Nginx) or equivalent in your Gateway/Load Balancer to avoid hanging connections (e.g., 60s limit).















Structured Logging (JSON Format)
• Requirement: "Use JSON-format logging... capturing metadata (timestamps, IP, response times)."
• Backend Action:
• Logback Config: Your UserService.txt shows a custom console pattern (%d{...} %highlight...). This is Text, not JSON.
• Fix: Add logstash-logback-encoder dependency and update logback-spring.xml to output JSON. This makes logs machine-readable (for Splunk/ELK).
• Request Metadata: Add a MDCFilter (Mapped Diagnostic Context) to your common-utilities.
• Extract TraceId, SpanId, ClientIP, UserUser from the request.
• Put them in MDC.
• Now every log line automatically includes {"user": "101", "ip": "10.1.1.1"}.
3. Structured Error Messages
• Requirement: "Error codes, descriptions... Avoid sensitive info."
• Status: Already Implemented ✅.
• Your ContextRbacFilter returns {"status": 401, "error": "TOKEN_EXPIRED", ...}.
• Your ApiResponse wrapper standardizes success/failure.
• Action: Ensure no e.printStackTrace() is ever returned to the UI. Always map exceptions to safe messages in GlobalExceptionHandler.
4. Retry Strategies
• Requirement: "Implement retry strategies for transient failures."
• Backend Action:
• Database: Spring Data JPA / HikariCP handles connection retries automatically to an extent.
• Service-to-Service: If using Feign, add Resilience4j Retry module.
• Kafka: Your Notification Service uses @KafkaListener. Configure SeekToCurrentErrorHandler with Backoff (e.g., 3 retries with 1s delay) to handle temporary DB glitches.
5. Full Audit Trails
• Requirement: "Login, file processing, parameter changes, user changes."
• Status: Mostly Implemented ✅.
• Login/User Changes: You have USER_LOGS populated by the UserActivityLogger Aspect.
• File Processing: For "Journal Bulk Upload", you need to ensure you log the event (Filename, Status, User) into COMMON_REQ or USER_LOGS.
• Parameter Changes: Any update to CGL, Branch, etc., is captured in COMMON_REQ (Maker-Checker). This is your audit trail.
6. PII Encryption (Data at Rest/Motion)
• Requirement: "Encrypt PII sensitive data (at rest, in use/motion)."
• Backend Action:
• Data in Motion (Channel): This is HTTPS/TLS. Ensure your Ingress/Load Balancer terminates SSL. Inside the cluster (Service-to-Service), use mTLS or trust the private network.
• Data at Rest (DB): Use Oracle TDE (Transparent Data Encryption) at the database level. This is a DBA task, not a code change.
• Application Level (Payload):
• Masking: In your MDCFilter or ToString methods, ensure you mask PII (e.g., Mobile, Email) before logging.
• DB Column Encryption: If you store highly sensitive data (e.g., Tax ID), use @ColumnTransformer (Hibernate) or a dedicated Encryption Converter in Java to store it encrypted in the DB column.
Implementation Plan: Critical Backend Changes
We need to add the Request Metadata Filter (MDC) to common-utilities. This solves the "Structured Logging" and "Audit Context" requirements globally.
Canvas: MDC Filter for Audit & Logging
Add this to common-utilities. It extracts IP and User from the Token/Request and puts it in the Logging Context.






















------



package com.fincore.commonutilities.logging;

import com.fincore.commonutilities.jwt.JwtUtil;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.slf4j.MDC;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.UUID;

@Component
@RequiredArgsConstructor
public class MdcLoggingFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        try {
            // 1. Trace ID (Correlation ID)
            // Use header from Gateway/Ingress if present, else generate one
            String traceId = request.getHeader("X-Correlation-ID");
            if (traceId == null) {
                traceId = UUID.randomUUID().toString();
            }
            MDC.put("traceId", traceId);
            response.setHeader("X-Correlation-ID", traceId); // Return to client

            // 2. Client IP
            String ip = request.getHeader("X-Forwarded-For");
            if (ip == null) ip = request.getRemoteAddr();
            MDC.put("clientIp", ip);

            // 3. User ID (If Token is present)
            // We do a "soft" check here just for logging. 
            // Validations happen in ContextRbacFilter later.
            String authHeader = request.getHeader("Authorization");
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                try {
                    String token = authHeader.substring(7);
                    // Just decode, don't validate signature strictly here (RBAC does that)
                    // Or use jwtUtil if it's cheap
                    String userId = jwtUtil.getUserIdFromToken(token);
                    MDC.put("userId", userId);
                } catch (Exception e) {
                    MDC.put("userId", "anonymous");
                }
            } else {
                MDC.put("userId", "anonymous");
            }

            // 4. API Path & Method
            MDC.put("apiPath", request.getRequestURI());
            MDC.put("method", request.getMethod());

            filterChain.doFilter(request, response);

        } finally {
            // CRITICAL: Clear MDC to prevent data leaking to other requests on the same thread
            MDC.clear();
        }
    }
}

How to Register
Add it to your CommonSecurityConfig or SecurityConfig in services, ensuring it runs BEFORE the ContextRbacFilter so that security logs (like "Access Denied") already have the User ID and IP in them.
// In SecurityConfig.java
.addFilterBefore(new MdcLoggingFilter(jwtUtil), ContextRbacFilter.class);

