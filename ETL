package com.fincore.helpservice.config;

import dev.langchain4j.model.chat.ChatLanguageModel;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.ollama.OllamaChatModel;
import dev.langchain4j.model.ollama.OllamaEmbeddingModel;
import dev.langchain4j.store.embedding.EmbeddingStore;
import dev.langchain4j.store.embedding.redis.RedisEmbeddingStore;
import dev.langchain4j.data.segment.TextSegment;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
public class AiConfiguration {

    // Read exactly from your properties file
    @Value("${spring.ai.vectorstore.redis.uri:redis://localhost:6380}")
    private String redisVectorUri;

    @Value("${spring.ai.ollama.base-url:http://localhost:11434}")
    private String ollamaBaseUrl;

    @Value("${spring.ai.vectorstore.redis.index:fincore-help-index}")
    private String indexName;

    @Value("${spring.ai.vectorstore.redis.prefix:fincore:doc:}")
    private String prefix;

    @Bean
    public ChatLanguageModel chatLanguageModel() {
        return OllamaChatModel.builder()
                .baseUrl(ollamaBaseUrl)
                .modelName("phi3-mini")
                .temperature(0.1) 
                .timeout(Duration.ofSeconds(60))
                .build();
    }

    @Bean
    public EmbeddingModel embeddingModel() {
        return OllamaEmbeddingModel.builder()
                .baseUrl(ollamaBaseUrl)
                .modelName("mxbai-embed")
                .timeout(Duration.ofSeconds(15))
                .build();
    }

    @Bean
    public EmbeddingStore<TextSegment> embeddingStore() {
        // LangChain4j uses 'url' instead of host/port to handle full connection strings
        return RedisEmbeddingStore.builder()
                .url(redisVectorUri) 
                .dimension(1024) 
                .indexName(indexName)
                .prefix(prefix)
                .build();
    }
}















package com.fincore.helpservice.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class PermissionService {

    private final JdbcTemplate jdbcTemplate;

    /**
     * Used by the Vector Store to filter which documents the user is mathematically allowed to search.
     * Returns a list of Permission IDs (e.g., ["5", "6", "12"])
     */
    public List<String> getAllAllowedPermissionIdsForRole(String roleId) {
        String sql = """
            SELECT CAST(p.PERMISSION_ID AS VARCHAR2(50))
            FROM PERMISSIONS p
            JOIN ROLE_PERMISSIONS rp ON p.PERMISSION_ID = rp.PERMISSION_ID
            WHERE rp.ROLE_ID = ? AND p.IS_ACTIVE = 'Y'
        """;
        
        return jdbcTemplate.queryForList(sql, String.class, roleId);
    }

    /**
     * Used by the Dynamic Prompt Injection so Phi-3 knows what the user is capable of doing.
     * Returns a list of human-readable action names (e.g., ["Create CGL", "Approve CGL"])
     */
    public List<String> getAllowedActionNamesForRole(String roleId) {
        String sql = """
            SELECT p.PERMISSION_NAME
            FROM PERMISSIONS p
            JOIN ROLE_PERMISSIONS rp ON p.PERMISSION_ID = rp.PERMISSION_ID
            WHERE rp.ROLE_ID = ? AND p.IS_ACTIVE = 'Y'
        """;
        
        return jdbcTemplate.queryForList(sql, String.class, roleId);
    }
}














package com.fincore.helpservice.controller;

import com.fincore.helpservice.dto.HelpRequestDTO;
import com.fincore.helpservice.dto.HelpResponseDTO;
import com.fincore.helpservice.model.HelpQuestionEntity;
import com.fincore.helpservice.repository.HelpQuestionRepository;
import com.fincore.helpservice.service.FinCoreChatAgent;
import com.fincore.helpservice.service.HelpAnalyticsService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

/**
 * Primary REST Controller for the FinCore Help & AI Assistant.
 * Orchestrates Generative AI Chat, Static Module Help, and Global FAQs.
 */
@RestController
@RequestMapping("/api/help")
@RequiredArgsConstructor
@Slf4j
public class HelpController {

    // 1. The New AI Brain
    private final FinCoreChatAgent chatAgent;
    
    // 2. The Traditional DB Repositories (For fast, non-AI queries)
    private final HelpQuestionRepository questionRepository;
    
    // 3. Analytics (For Thumbs Up / Thumbs Down feedback)
    private final HelpAnalyticsService analyticsService;

    // ========================================================================
    // 1. THE AI CHAT ENDPOINT (Powered by Phi-3 & Mxbai)
    // ========================================================================
    @PostMapping("/chat")
    public ResponseEntity<HelpResponseDTO> handleChatQuery(
            @RequestHeader("X-User-Id") String userId,
            @RequestHeader("X-Role-Id") String roleId,
            @RequestBody HelpRequestDTO request) {

        log.info("[API] Chat request received from User: {} | Message: '{}'", userId, request.getUserMessage());
        
        // Route the query through our LangChain4j RAG pipeline
        HelpResponseDTO response = chatAgent.handleChat(userId, roleId, request.getUserMessage());
        
        return ResponseEntity.ok(response);
    }

    // ========================================================================
    // 2. STATIC MODULE HELP (Powered by fast SQL - No AI required)
    // ========================================================================
    @GetMapping("/module")
    public ResponseEntity<List<HelpQuestionEntity>> getModuleHelp(
            @RequestHeader("X-Role-Id") String roleId,
            @RequestParam("screen") String screenName) {

        log.info("[API] Fetching static module help for screen: {}", screenName);
        
        // NOTE: Replace this with your existing traditional service call if you have one.
        // Flow: Fetch active questions matching the screenName and the user's roleId permissions.
        List<HelpQuestionEntity> moduleQuestions = questionRepository.findByScreenNameAndIsActive(screenName, "Y");
        
        // (Assume filtering by roleId happens in your service layer before returning)
        return ResponseEntity.ok(moduleQuestions);
    }

    // ========================================================================
    // 3. GLOBAL FAQS (Powered by fast SQL - No AI required)
    // ========================================================================
    @GetMapping("/faqs")
    public ResponseEntity<List<HelpQuestionEntity>> getGlobalFaqs() {
        log.info("[API] Fetching global FAQs");
        
        // Flow: Fetch predefined global questions (where permission_id is null/GLOBAL)
        List<HelpQuestionEntity> globalFaqs = questionRepository.findGlobalFaqs();
        
        return ResponseEntity.ok(globalFaqs);
    }

    // ========================================================================
    // 4. CHAT FEEDBACK ENDPOINT (For UI Thumbs Up / Thumbs Down)
    // ========================================================================
    @PostMapping("/feedback")
    public ResponseEntity<Void> submitChatFeedback(
            @RequestHeader("X-User-Id") String userId,
            @RequestBody Map<String, Object> feedbackPayload) {

        // Expected payload: { "logId": 12345, "isHelpful": true }
        Long logId = Long.valueOf(feedbackPayload.get("logId").toString());
        boolean isHelpful = (Boolean) feedbackPayload.get("isHelpful");

        log.info("[API] Feedback received for Log ID: {} | Helpful: {}", logId, isHelpful);
        
        // Update the audit trail in Oracle to reflect user satisfaction
        analyticsService.updateFeedback(logId, isHelpful);

        return ResponseEntity.ok().build();
    }
}



















package com.fincore.helpservice.dto;

import lombok.Data;

@Data
public class HelpRequestDTO {
    
    // The actual question typed by the user
    private String userMessage;
    
    // Optional: If the frontend knows what screen the user is currently on, 
    // it can pass it here so you can add it to the AI's context later!
    private String currentScreen; 
}
















package com.fincore.helpservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class HelpResponseDTO {

    /**
     * Dictates the UI State.
     * Expected values: "TEXT_REPLY", "SUGGESTION", "ESCALATION_OFFER", "NO_MATCH"
     */
    private String responseType;

    /**
     * The actual text generated by Phi-3 (or standard fallback text).
     * Can contain HTML like <b> or <br/> for the frontend to render.
     */
    private String botReply;

    /**
     * If the AI found a relevant module, this is the URL/Route (e.g., "/cgl-management")
     */
    private String navigationLink;

    /**
     * The text to display on the UI button (e.g., "Go to CGL Management")
     */
    private String navigationLabel;

    /**
     * CRITICAL FOR FEEDBACK: 
     * The Primary Key ID of the log saved in Oracle DB.
     * The UI needs this so when the user clicks "Thumbs Up", it sends this ID back to the /feedback endpoint.
     */
    private Long logId;

    /**
     * Used ONLY if responseType is "SUGGESTION".
     * A list of clickable follow-up questions for the user.
     */
    private List<String> items;
}
















// 1. Save to Oracle and get the generated ID back
Long generatedLogId = analyticsService.logChatInteraction(userId, "AI_RAG", userMessage, "ANSWERED", 99);

// 2. Pass that ID to the UI
return HelpResponseDTO.builder()
        .responseType("TEXT_REPLY")
        .botReply(aiResponse)
        .navigationLink(primaryActionLink)
        .navigationLabel(primaryActionLabel)
        .logId(generatedLogId) // <-- The UI now has the ID for the Thumbs Up button!
        .build();

With these DTOs matching the Lovable prompt perfectly, your Frontend developer (or AI) and your Backend Spring Boot application are speaking the exact same language. No `undefined` errors in the UI!

















package com.fincore.helpservice.model;

import jakarta.persistence.*;
import lombok.Data;

/**
 * Maps to the Oracle DB table 'HELP_QUESTION_MASTER'.
 * This is the source of truth that gets ingested into the Redis Vector database.
 */
@Entity
@Table(name = "HELP_QUESTION_MASTER")
@Data
public class HelpQuestionEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "QUESTION_ID")
    private Long questionId;

    @Column(name = "SCREEN_NAME")
    private String screenName;

    @Column(name = "QUESTION_TEXT", length = 1000)
    private String questionText;

    @Column(name = "ANSWER_CONTENT", length = 4000)
    private String answerContent;

    // e.g., "5" for Create CGL. Null means it's a Global/General question.
    @Column(name = "PERMISSION_ID")
    private Long permissionId;

    @Column(name = "ACTION_LINK")
    private String actionLink;

    @Column(name = "ACTION_LABEL")
    private String actionLabel;

    @Column(name = "PRO_TIP", length = 1000)
    private String proTip;

    @Column(name = "IS_ACTIVE", length = 1)
    private String isActive;
}
















package com.fincore.helpservice.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

/**
 * Maps to 'HELP_INTERACTION_LOGS'.
 * Crucial for banking compliance to track exactly what the AI told the user.
 */
@Entity
@Table(name = "HELP_INTERACTION_LOGS")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class HelpInteractionLogEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "LOG_ID")
    private Long logId;

    @Column(name = "USER_ID")
    private String userId;

    @Column(name = "SOURCE_ENGINE") // e.g., AI_RAG, SQL_MODULE, UNKNOWN
    private String sourceEngine;

    @Column(name = "USER_MESSAGE", length = 2000)
    private String userMessage;

    @Column(name = "RESPONSE_TYPE") // e.g., ANSWERED, NO_MATCH, ESCALATION
    private String responseType;

    @Column(name = "CONFIDENCE_SCORE")
    private Integer confidenceScore;

    @Column(name = "IS_HELPFUL") // Populated later via the UI Thumbs Up/Down
    private Boolean isHelpful;

    @Column(name = "CREATED_AT")
    private LocalDateTime createdAt;
}
















package com.fincore.helpservice.repository;

import com.fincore.helpservice.model.HelpQuestionEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface HelpQuestionRepository extends JpaRepository<HelpQuestionEntity, Long> {

    // Used by DocumentIngestionService to load all active data into Redis
    List<HelpQuestionEntity> findByIsActive(String isActive);

    // Used by HelpController for fast, static UI module buttons
    List<HelpQuestionEntity> findByScreenNameAndIsActive(String screenName, String isActive);

    // Used by HelpController for the Global FAQs tab
    @Query("SELECT q FROM HelpQuestionEntity q WHERE q.permissionId IS NULL AND q.isActive = 'Y'")
    List<HelpQuestionEntity> findGlobalFaqs();
}















package com.fincore.helpservice.repository;

import com.fincore.helpservice.model.HelpInteractionLogEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface HelpInteractionLogRepository extends JpaRepository<HelpInteractionLogEntity, Long> {
    // Standard save and findById methods are auto-implemented by Spring
}
















package com.fincore.helpservice.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Manages the "3-Strike" Escalation Engine.
 * If the AI fails to answer a user's question multiple times in a row, 
 * this service triggers the IT Support handoff.
 */
@Service
@Slf4j
public class ChatSessionService {

    // In-memory strike counter mapped by UserId.
    private final Map<String, Integer> userStrikes = new ConcurrentHashMap<>();
    
    private static final int MAX_STRIKES = 3;

    public boolean isEscalationRequired(String userId) {
        int currentStrikes = userStrikes.getOrDefault(userId, 0);
        return currentStrikes >= MAX_STRIKES;
    }

    public void addStrikes(String userId, int count) {
        int newStrikes = userStrikes.getOrDefault(userId, 0) + count;
        userStrikes.put(userId, newStrikes);
        log.warn("[SESSION] User {} gained a strike. Current strikes: {}/{}", userId, newStrikes, MAX_STRIKES);
    }

    public void resetStrikes(String userId) {
        if (userStrikes.containsKey(userId)) {
            userStrikes.remove(userId);
            log.debug("[SESSION] User {} chat strikes reset to 0 due to successful AI response.", userId);
        }
    }
}


















package com.fincore.helpservice.service;

import com.fincore.helpservice.model.HelpInteractionLogEntity;
import com.fincore.helpservice.repository.HelpInteractionLogRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

/**
 * Handles the Oracle Database Audit Trail.
 * Records every AI interaction and processes the UI Thumbs Up/Down feedback.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class HelpAnalyticsService {

    private final HelpInteractionLogRepository logRepository;

    /**
     * Logs the chat attempt and returns the DB Primary Key (LogId).
     * This ID is sent to the frontend so the user can rate this specific answer.
     */
    @Transactional
    public Long logChatInteraction(String userId, String sourceEngine, String userMessage, String responseType, int confidenceScore) {
        try {
            HelpInteractionLogEntity logEntity = HelpInteractionLogEntity.builder()
                    .userId(userId)
                    .sourceEngine(sourceEngine)
                    .userMessage(userMessage)
                    .responseType(responseType)
                    .confidenceScore(confidenceScore)
                    .createdAt(LocalDateTime.now())
                    .build();

            logEntity = logRepository.save(logEntity);
            log.debug("[ANALYTICS] Saved interaction log for user {} with LogID {}", userId, logEntity.getLogId());
            
            return logEntity.getLogId();
            
        } catch (Exception e) {
            log.error("[ANALYTICS] Failed to save interaction log to Oracle DB.", e);
            return null; // Don't crash the chat just because logging failed
        }
    }

    /**
     * Called when the user clicks the Thumbs Up or Thumbs Down button in the UI.
     */
    @Transactional
    public void updateFeedback(Long logId, boolean isHelpful) {
        if (logId == null) return;

        logRepository.findById(logId).ifPresentOrElse(logEntity -> {
            logEntity.setIsHelpful(isHelpful);
            logRepository.save(logEntity);
            log.info("[ANALYTICS] LogID {} marked as helpful: {}", logId, isHelpful);
        }, () -> log.warn("[ANALYTICS] Received feedback for unknown LogID: {}", logId));
    }
}
















package com.fincore.helpservice.model;

import jakarta.persistence.*;
import lombok.Data;

/**
 * Maps to the Oracle DB table 'KNOWLEDGE_BASE_MASTER'.
 * Stores long-form conceptual banking rules, definitions, and workflows.
 */
@Entity
@Table(name = "KNOWLEDGE_BASE_MASTER")
@Data
public class KnowledgeBaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "DOC_ID")
    private Long docId;

    @Column(name = "TOPIC", length = 255)
    private String topic;

    @Column(name = "CONTENT_PARAGRAPH", length = 4000)
    private String contentParagraph;

    // Can be null if it's a global concept (like "What is a CGL?")
    @Column(name = "PERMISSION_ID")
    private Long permissionId;

    @Column(name = "IS_ACTIVE", length = 1)
    private String isActive;
}



















package com.fincore.helpservice.repository;

import com.fincore.helpservice.model.KnowledgeBaseEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface KnowledgeBaseRepository extends JpaRepository<KnowledgeBaseEntity, Long> {

    // Used by DocumentIngestionService to load active paragraphs
    List<KnowledgeBaseEntity> findByIsActive(String isActive);
}




















package com.fincore.helpservice.service;

import com.fincore.helpservice.model.HelpQuestionEntity;
import com.fincore.helpservice.model.KnowledgeBaseEntity;
import com.fincore.helpservice.repository.HelpQuestionRepository;
import com.fincore.helpservice.repository.KnowledgeBaseRepository;
import dev.langchain4j.data.document.Document;
import dev.langchain4j.data.document.Metadata;
import dev.langchain4j.data.document.splitter.DocumentSplitters;
import dev.langchain4j.data.embedding.Embedding;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.store.embedding.EmbeddingStore;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

/**
 * Handles converting ALL Oracle DB text (Procedural + Conceptual) 
 * into AI Mathematical Vectors using LangChain4j and Redis.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class DocumentIngestionService {

    private final HelpQuestionRepository questionRepository;
    private final KnowledgeBaseRepository knowledgeBaseRepository; // NEW: Added Knowledge Base
    
    private final EmbeddingModel embeddingModel;
    private final EmbeddingStore<TextSegment> embeddingStore;

    @EventListener(ApplicationReadyEvent.class)
    public void ingestKnowledgeBase() {
        log.info("[AI-INGEST] Starting Knowledge Ingestion to Redis via mxbai-embed...");

        List<Document> allDocuments = new ArrayList<>();

        // ---------------------------------------------------------
        // 1. INGEST PROCEDURAL DATA (Help Questions & UI Buttons)
        // ---------------------------------------------------------
        List<HelpQuestionEntity> questions = questionRepository.findByIsActive("Y");
        for (HelpQuestionEntity q : questions) {
            String content = "Module: " + (q.getScreenName() != null ? q.getScreenName() : "General") +
                    "\nQuestion: " + q.getQuestionText() +
                    "\nAnswer: " + q.getAnswerContent() +
                    (q.getProTip() != null ? "\nPro Tip: " + q.getProTip() : "");

            String permId = q.getPermissionId() != null ? String.valueOf(q.getPermissionId()) : "GLOBAL";

            Metadata metadata = Metadata.from("permissionId", permId)
                    .add("actionLink", q.getActionLink() != null ? q.getActionLink() : "NONE")
                    .add("actionLabel", q.getActionLabel() != null ? q.getActionLabel() : "NONE")
                    .add("dataType", "PROCEDURAL");

            allDocuments.add(Document.from(content, metadata));
        }

        // ---------------------------------------------------------
        // 2. INGEST CONCEPTUAL DATA (Knowledge Base Paragraphs)
        // ---------------------------------------------------------
        List<KnowledgeBaseEntity> knowledgeBase = knowledgeBaseRepository.findByIsActive("Y");
        for (KnowledgeBaseEntity kb : knowledgeBase) {
            String content = "Topic: " + kb.getTopic() + 
                             "\nInformation: " + kb.getContentParagraph();

            String permId = kb.getPermissionId() != null ? String.valueOf(kb.getPermissionId()) : "GLOBAL";

            // Conceptual data doesn't have UI action buttons, so we default to NONE
            Metadata metadata = Metadata.from("permissionId", permId)
                    .add("actionLink", "NONE")
                    .add("actionLabel", "NONE")
                    .add("dataType", "CONCEPTUAL");

            allDocuments.add(Document.from(content, metadata));
        }

        // ---------------------------------------------------------
        // 3. CHUNK AND SAVE TO REDIS
        // ---------------------------------------------------------
        if (!allDocuments.isEmpty()) {
            // Split long documents into overlapping 300-token chunks
            List<TextSegment> segments = DocumentSplitters.recursive(300, 50).splitAll(allDocuments);
            log.info("[AI-INGEST] Chunked {} raw DB records into {} mathematical segments.", allDocuments.size(), segments.size());

            // Generate Vectors via Ollama
            List<Embedding> embeddings = embeddingModel.embedAll(segments).content();

            // Save to Redis
            embeddingStore.addAll(embeddings, segments);
            log.info("[AI-INGEST] Successfully saved {} vectors to Redis Stack.", segments.size());
        } else {
            log.warn("[AI-INGEST] No active documents found in Oracle DB to ingest!");
        }
    }
}






















<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
</dependency>






gap fix ;;:::::



// INSIDE FinCoreChatAgent.java

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import java.util.concurrent.TimeUnit;

// FIX GAP 2: Memory Leak Prevented. Sessions expire after 30 minutes of inactivity.
private final Cache<String, ChatMemory> userMemories = Caffeine.newBuilder()
        .expireAfterAccess(30, TimeUnit.MINUTES)
        .maximumSize(10000) // Max 10,000 concurrent active chat sessions
        .build();

public HelpResponseDTO handleChat(String userId, String roleId, String userMessage) {
    // ... (Keep the existing Escalation Check and RBAC logic) ...

    // ... (Execute Vector Search) ...

    // FIX GAP 3: Ensure logId is captured and returned on FAST-FAIL
    if (matches.isEmpty()) {
        sessionService.addStrikes(userId, 1);
        
        // Capture the Log ID!
        Long failLogId = analyticsService.logChatInteraction(userId, "UNKNOWN", userMessage, "NO_MATCH", 0);
        
        return HelpResponseDTO.builder()
                .responseType("NO_MATCH")
                .botReply("I couldn't find any information about that in your authorized modules. Try rephrasing?")
                .logId(failLogId) // Send it to the UI!
                .build();
    }

    // ... (Build Context and Dynamic Prompt) ...

    // Retrieve or create Chat Memory from Caffeine Cache
    ChatMemory memory = userMemories.get(userId, k -> MessageWindowChatMemory.withMaxMessages(5));
    memory.add(UserMessage.from(userMessage));

    // ... (Call Phi-3) ...

    // FIX GAP 3: Capture Log ID for successful generation
    Long successLogId = analyticsService.logChatInteraction(userId, "AI_RAG", userMessage, "ANSWERED", 99);

    return HelpResponseDTO.builder()
            .responseType("TEXT_REPLY")
            .botReply(aiResponse)
            .navigationLink(primaryActionLink)
            .navigationLabel(primaryActionLabel)
            .logId(successLogId) // Send it to the UI!
            .build();
}












// INSIDE DocumentIngestionService.java (Replace the old Step 3)

// ---------------------------------------------------------
// 3. CHUNK AND SAVE TO REDIS (With Deterministic Overwrite)
// ---------------------------------------------------------
if (!allDocuments.isEmpty()) {
    List<TextSegment> segments = DocumentSplitters.recursive(300, 50).splitAll(allDocuments);
    log.info("[AI-INGEST] Chunked {} raw DB records into {} mathematical segments.", allDocuments.size(), segments.size());

    // Generate Vectors via Ollama
    List<Embedding> embeddings = embeddingModel.embedAll(segments).content();

    // FIX GAP 1: Deterministic IDs to prevent Redis duplication on restart
    for (int i = 0; i < segments.size(); i++) {
        TextSegment segment = segments.get(i);
        Embedding vector = embeddings.get(i);
        
        // Generate a unique, repeatable ID based on the Data Type and Permission
        String dataType = segment.metadata().getString("dataType");
        String perm = segment.metadata().getString("permissionId");
        
        // Example ID: "PROCEDURAL_5_chunk_0", "CONCEPTUAL_GLOBAL_chunk_1"
        String deterministicId = dataType + "_" + perm + "_chunk_" + i;

        // Save one by one using the explicit ID
        embeddingStore.add(deterministicId, vector, segment);
    }
    
    log.info("[AI-INGEST] Successfully saved/overwritten {} vectors to Redis Stack.", segments.size());
}














