package com.fincore.commonutilities.aspect;

import com.fincore.commonutilities.annotation.NoRetry;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.github.resilience4j.retry.Retry;
import io.github.resilience4j.retry.RetryRegistry;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;
import java.util.function.Supplier;

@Aspect
@Component
@Order(Ordered.HIGHEST_PRECEDENCE) // Run BEFORE Transactional to handle connection issues correctly
@RequiredArgsConstructor
@Slf4j
public class GlobalResilienceAspect {

    private final RetryRegistry retryRegistry;
    private final CircuitBreakerRegistry circuitBreakerRegistry;

    // Defined in application.properties
    private static final String SERVICE_NAME = "defaultService";

    @Around("within(@org.springframework.stereotype.Service *)")
    public Object applyResilience(ProceedingJoinPoint joinPoint) throws Throwable {
        
        // 1. SAFETY: Skip if @NoRetry is present (Idempotency Check)
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        if (method.isAnnotationPresent(NoRetry.class)) {
            return joinPoint.proceed();
        }

        // 2. Load Resilience Config
        Retry retry = retryRegistry.retry(SERVICE_NAME);
        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(SERVICE_NAME);

        // 3. Wrap the Service Call
        Supplier<Object> backendCall = () -> {
            try {
                return joinPoint.proceed();
            } catch (Throwable e) {
                // We must wrap checked exceptions to pass them through the Supplier
                throw new RuntimeExceptionWrapper(e);
            }
        };

        // 4. Decorate: CircuitBreaker wraps Retry
        // If Circuit is Open -> Fails Fast.
        // If Closed -> Tries Retry Logic.
        Supplier<Object> retryableSupplier = Retry.decorateSupplier(retry, backendCall);
        Supplier<Object> resilientSupplier = CircuitBreaker.decorateSupplier(circuitBreaker, retryableSupplier);

        // 5. Execute
        try {
            return resilientSupplier.get();
        } catch (RuntimeExceptionWrapper e) {
            // UNWRAP: Throw the original exception (e.g., IllegalArgumentException)
            // so GlobalExceptionHandler catches the REAL error, not a wrapper.
            throw e.getCause();
        } catch (Exception e) {
            throw e;
        }
    }

    /**
     * Helper to transport exceptions through Lambdas.
     */
    private static class RuntimeExceptionWrapper extends RuntimeException {
        public RuntimeExceptionWrapper(Throwable cause) {
            super(cause);
        }
    }
}

















# ==============================================================
# RESILIENCE4J CONFIGURATION (Enterprise Grade)
# ==============================================================

# --- 1. RETRY STRATEGY ---
resilience4j.retry.instances.defaultService.max-attempts=3
resilience4j.retry.instances.defaultService.wait-duration=1s

# --- CORRECT EXCEPTION HANDLING ---

# A. RETRY ON THESE (Transient / "Blips")
# 1. Spring's wrapper for DB Timeouts, Deadlocks, Connection Drops
resilience4j.retry.instances.defaultService.retry-exceptions[0]=org.springframework.dao.TransientDataAccessException
# 2. Connection failure at start of transaction
resilience4j.retry.instances.defaultService.retry-exceptions[1]=org.springframework.transaction.CannotCreateTransactionException
# 3. DB Resource Failure (DB Down)
resilience4j.retry.instances.defaultService.retry-exceptions[2]=org.springframework.dao.DataAccessResourceFailureException
# 4. Network I/O errors (for Feign/RestCalls)
resilience4j.retry.instances.defaultService.retry-exceptions[3]=java.io.IOException
resilience4j.retry.instances.defaultService.retry-exceptions[4]=java.net.ConnectException
resilience4j.retry.instances.defaultService.retry-exceptions[5]=java.net.SocketTimeoutException

# B. DO NOT RETRY ON THESE (Logic / Permanent Errors)
# Even if these happen, we fail immediately so GlobalExceptionHandler can return 400/409
resilience4j.retry.instances.defaultService.ignore-exceptions[0]=java.lang.IllegalArgumentException
resilience4j.retry.instances.defaultService.ignore-exceptions[1]=java.lang.NullPointerException
resilience4j.retry.instances.defaultService.ignore-exceptions[2]=org.springframework.dao.DataIntegrityViolationException
resilience4j.retry.instances.defaultService.ignore-exceptions[3]=org.springframework.dao.DuplicateKeyException
resilience4j.retry.instances.defaultService.ignore-exceptions[4]=org.springframework.web.client.HttpClientErrorException

# --- 2. CIRCUIT BREAKER STRATEGY ---
resilience4j.circuitbreaker.instances.defaultService.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.defaultService.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.defaultService.automatic-transition-from-open-to-half-open-enabled=true
resilience4j.circuitbreaker.instances.defaultService.wait-duration-in-open-state=10s
resilience4j.circuitbreaker.instances.defaultService.permitted-number-of-calls-in-half-open-state=3



