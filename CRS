package com.tcs.fincore.CommonRequestService.advice;

import org.springframework.core.MethodParameter;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

import com.tcs.fincore.CommonRequestService.dto.ApiResponse;

/**
 * This ControllerAdvice intercepts successful responses from any @RestController
 * and wraps them in a standard ApiResponse format.
 */
@ControllerAdvice
public class ApiResponseWrapper implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        // This advice applies to any method in a class annotated with @RestController
        // that is not already returning a ResponseEntity (which gives manual control).
        return AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), RestController.class) &&
                !returnType.getParameterType().equals(ResponseEntity.class);
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  ServerHttpRequest request, ServerHttpResponse response) {

        // If the controller has already manually wrapped the response, do nothing.
        if (body instanceof ApiResponse<?>) {
            return body;
        }

        // Wrap the successful response body in the standard ApiResponse structure.
        return ApiResponse.success(body);
    }
}







//-----------------------------------

package com.tcs.fincore.CommonRequestService.controller;

import java.util.List;

import com.tcs.fincore.CommonRequestService.dto.CancelRequestDto;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.fincore.CommonRequestService.dto.CreateRequestDto;
import com.tcs.fincore.CommonRequestService.dto.MyRequestFilterDto;
import com.tcs.fincore.CommonRequestService.dto.ProcessRequestDto;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.service.RequestService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * RequestController :-
 *
 * This controller handles API requests related to creating, retrieving, and processing common requests within the FinCore Application.
 * It provides endpoints for users to manage their requests, view pending items, and for approvers to update request statuses.
 *
 * @author Shubhankar [v1018405]
 * @version 1.0
 * @since 2025-10-01
 */
@RestController
@RequiredArgsConstructor
@Slf4j
public class RequestController {

	private final RequestService requestService;
    private final JwtUtil jwtUtil;

    /**
     * Creates a new request initiated by a user (maker).
     *
     * @param createRequestDto The data transfer object containing the details of the new request.
     * @param token The authorization token used to identify the user making the request.
     * @return The created CommonReq entity.
     * @throws JsonProcessingException If there is an issue processing the request data.
     */
	@PostMapping("/create-request")
	@ResponseStatus(HttpStatus.CREATED)
	public CommonReq createRequest(
			@Valid @RequestBody CreateRequestDto createRequestDto,
			@RequestHeader("Authorization") String token
	) throws JsonProcessingException {
		String userId = jwtUtil.getUserIdFromToken(token);
		log.info("Received request creation call from user: {}", userId);
		return requestService.createRequest(createRequestDto, userId, token);
	}

    /**
     * Fetches requests created by the current user (maker). Requests can be filtered by `requestType`.
     *
     * @param token The authorization token of the user.
     * @param filterDto An object that may contain a `requestType` for filtering (e.g., `{"requestType": "SEGMENT_CODE"}`).
     * @return A list of CommonReq entities matching the criteria.
     */
	// tab2 master screen
	@PostMapping("/my-requests")
	public List<CommonReq> getMyRequests(
			@RequestHeader("Authorization") String token,
			@RequestBody MyRequestFilterDto filterDto
	) {
		String userId = jwtUtil.getUserIdFromToken(token);
		log.info(
				"Received request for fetch data for the user: {} and request type: {}", userId,
				filterDto.getRequestType()
		);
		return requestService.getMyRequests(userId, filterDto.getRequestType());
	}

    /**
     * Retrieves a list of requests that are pending approval for the current user (excluding the own requests).
     *
     * @param authorizationHeader The authorization token of the user.
     * @param filterDto An object that contain a `requestType` for filtering pending requests.
     * @return A list of pending CommonReq entities excluding the own requests.
     */
	// accept
	@PostMapping("/pending-requests")
	public List<CommonReq> getPendingRequests(
			@RequestHeader("Authorization") String authorizationHeader,
			@RequestBody MyRequestFilterDto filterDto
	) {
		String userId = jwtUtil.getUserIdFromToken(authorizationHeader);
		log.info("Received request for pending data for the request type: {}", filterDto.getRequestType());
		return requestService.getPendingRequests(userId, filterDto.getRequestType());
	}

    /**
     * Retrieves all requests present in the system (intended for admin/supervisory roles).
     *
     * @param authorizationHeader The authorization token.
     * @return A list of all CommonReq entities.
     */
	@GetMapping("/all-requests")
	public List<CommonReq> getAllRequests(@RequestHeader("Authorization") String authorizationHeader) {
		return requestService.getAllRequests();
	}


    /**
     * Updates the status of a request (Accepts/Rejects) by a checker (approver role).
     *
     * @param token The authorization token of the executor (checker).
     * @param processRequestDto The DTO containing the request ID, new status, and any remarks.
     * @return The updated CommonReq entity.
     * @throws JsonProcessingException If there is an issue processing the request data.
     */
	@PatchMapping("/update-request")
	public CommonReq updateRequestStatus(
			@RequestHeader("Authorization") String token,
			@RequestBody ProcessRequestDto processRequestDto
	) throws JsonProcessingException {
		String executorId = jwtUtil.getUserIdFromToken(token);
		// The service layer throws a ResourceNotFoundException if the optional is
		// empty,
		// which is caught by the GlobalExceptionHandler.
		return requestService.updateRequestStatus(processRequestDto, executorId).get();
	}


    /**
     * Cancels a pending request initiated by the user.
     *
     * @param token The authorization token of the user (must be the creator).
     * @param cancelRequestDto The DTO containing the request ID and optional remarks.
     * @return The updated CommonReq entity with status CANCELLED.
     */
    @PatchMapping("/cancel-request")
    public CommonReq cancelRequest(
            @RequestHeader("Authorization") String token,
            @Valid @RequestBody CancelRequestDto cancelRequestDto
    ) {
        String userId = jwtUtil.getUserIdFromToken(token);
        log.info("Received cancellation request for request ID: {} from user: {}", cancelRequestDto.getRequestId(), userId);
        return requestService.cancelRequest(cancelRequestDto, userId);
    }
}









//------------------------------------

//dtos
package com.tcs.fincore.CommonRequestService.dto.payload;

/**
 * An interface for payload DTOs that have a natural primary key
 * which can be used as the targetId in the CommonReq table.
 * 
 * Here we have followed 'Interface Segregation Principle'.
 * A contract to enforce a primary key from any payload type.
 */
public interface KeyablePayload extends Payload {
    /**
     * Constructs and returns the primary key from the payload's data.
     * 
     * @return A string representation of the primary key.
     */
    String getKey();
}













package com.tcs.fincore.CommonRequestService.dto.payload;

/**
 * A marker interface to group different payload types together. It will build
 * the right object from JSON.
 * Used for polymorphic deserialization.
 * Tha jasckson JSON Library will use it
 */
public interface Payload {

}








package com.tcs.fincore.CommonRequestService.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Getter;

import java.time.Instant;

@Getter
@JsonInclude(JsonInclude.Include.NON_NULL) // Don't include null fields in the JSON response
public class ApiResponse<T> {

    private final boolean success;
    private final String message;
    private final T data;
    private final Instant timestamp;

    private ApiResponse(boolean success, String message, T data) {
        this.success = success;
        this.message = message;
        this.data = data;
        this.timestamp = Instant.now();
    }

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, message, data);
    }

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, "Operation completed successfully.", data);
    }

    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(false, message, null);
    }
}

















package com.tcs.fincore.CommonRequestService.dto;

import java.util.Date;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
@JsonTypeName("BRANCH") // This must match the RequestType enum name
public class BranchRequestPayloadDTO implements KeyablePayload {

	@NotNull(message = "Code cannot be null.")
	private String code;

	@NotNull(message = "Name cannot be null")
	@Size(min = 1, max = 50, message = "Name length must be between 1 and 50")
	private String name;

	@NotNull(message = "Circle Code cannot be null")
	@Size(min = 5, max = 5, message = "Circle Code length must be between 5 and 5")
	private String circleCode;

	@NotNull(message = "State cannot be null")
	@Size(min = 1, max = 50, message = "State length must be between 1 and 50")
	private String state;

	@NotNull(message = "City cannot be null")
	@Size(min = 1, max = 50, message = "City length must be between 1 and 50")
	private String city;

	@NotNull(message = "Address cannot be null")
	@Size(min = 1, max = 50, message = "Address length must be between 1 and 50")
	private String address;

	@NotNull(message = "Pincode cannot be null")
	@Size(min = 6, max = 6, message = "Pincode length must be 6")
	private String pinCode;

	@NotNull(message = "Phone Number cannot be null")
	@Size(min = 10, max = 10, message = "Phone Number length must be 10")
	private String phoneNumber;

	@NotNull(message = "Email ID cannot be null")
	@Size(min = 5, max = 50, message = "Email ID length must be between 5 and 50")
	private String emailId;

	@NotNull(message = "N-M-R Code cannot be null")
	@Size(min = 3, max = 50, message = "N-M-R Code length must be between 3 and 50")
	private String nmrCode;

	@NotNull(message = "Status cannot be null")
	private Boolean status;

	@JsonFormat(pattern = "dd/MM/yyyy")
	@NotNull(message = "Open Date cannot be null")
	private Date openDate;

	@JsonFormat(pattern = "dd/MM/yyyy")
	private Date closeDate;

	@JsonFormat(pattern = "dd/MM/yyyy")
	private Date mergeDate;

	@Size(min = 5, max = 5, message = "Merged with Branch length must be 5")
	private String mergedWithBranch;

	@JsonFormat(pattern = "dd/MM/yyyy")
	private Date lastChangeDate;

	@NotNull(message = "CPC Flag cannot be null")
	private Boolean cpcFlag;

	@NotNull(message = "Food Credit Flag cannot be null")
	private Boolean foodCreditFlag;

	@NotNull(message = "Curr Chest Flag cannot be null")
	private Boolean currChestFlag;

	@NotNull(message = "Branch Type cannot be null")
	@Size(min = 1, max = 1, message = "Blength must be 1")
	@Pattern(regexp = "[AM]", message = "Branch Type can only be A or M")
	private String branchType;

	// construct the primary key
	@Override
	@JsonIgnore
	public String getKey(
	) {
		// Construct the composite primary key
		return code;
	}
}














package com.tcs.fincore.CommonRequestService.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;
import com.tcs.fincore.CommonRequestService.dto.payload.Payload;
import com.tcs.fincore.CommonRequestService.validation.ValidDateRange;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Date;

@Data
@JsonTypeName("CALENDER")
@Builder
@ValidDateRange(message = "Year end date must be after the year start date")
@NoArgsConstructor
@AllArgsConstructor
public class CalenderConfigPayloadDto implements KeyablePayload {
//    private Long id;

    @NotNull(message = "Year start date cannot be null")
    private LocalDate yearStartDate;

    @NotNull(message = "Year end date cannot be null")
    private LocalDate yearEndDate;

    @NotNull(message = "Remarks cannot be null")
    @Size(max = 255, message = "Remarks cannot exceed 255 characters")
    private String remarks;
    
    @Override
    @JsonIgnore
    public String getKey() {
        // TODO Auto-generated method stub
        return "Calendar";
    }

//    @NotNull(message = "Updated by cannot be null")
//    @Size(max = 50, message = "Updated by cannot exceed 50 characters")
//    private String updatedBy;
}















package com.tcs.fincore.CommonRequestService.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Data;

/**
 * Data Transfer Object (DTO) for handling Chart of Accounts (CGL_CODE) related
 * requests.
 * This class uses Project Lombok's {@code @Data} annotation to automatically
 * generate
 * boilerplate code like getters, setters, {@code toString()}, {@code equals()},
 * and {@code hashCode()}.
 * It also implements the {@code KeyablePayload} interface to provide a
 * composite key
 * for unique identification within the system, specifically when processing
 * common requests.
 */
@Data
@JsonTypeName("CGL_CODE") // This must match the RequestType enum name used for processing this payload
                          // type
public class CglPayloadDto implements KeyablePayload {

    /**
     * Represents the first component of the General Ledger (GL) code combination.
     * This field is mandatory.
     */
    // Change from Short to String to preserve "08"
    @Pattern(regexp = "\\d+", message = "Comp1 must be numeric")
    @Size(min = 2, max = 4, message = "Comp1 must be exactly 4 digits")
    @NotNull(message = "Component 1 (comp1) cannot be null.")
    private String comp1;

    /**
     * Represents the segment code within the GL code combination.
     * This field is mandatory and has a size constraint.
     */
    @NotNull(message = "Segment Code cannot be null.")
    @Size(min = 1, max = 4, message = "Segment Code must be between 1 and 4 characters.")
    private String segmentCode;

    /**
     * Represents the second component of the GL code combination.
     * This field is mandatory.
     * Change from Short to String
     */
    @Pattern(regexp = "\\d+", message = "Comp2 must be numeric")
    @NotNull(message = "Component 2 (comp2) cannot be null.")
    private String comp2;

    /**
     * A human-readable description for the GL code combination.
     * This field is mandatory and has a size constraint.
     */
    @NotNull(message = "Description cannot be null.")
    @Size(min = 1, max = 100, message = "Description must be between 1 and 100 characters.")
    private String description;

    /**
     * The classification of the account (A, L, I, E, M for Asset, Liability,
     * Income, Expense, Memo).
     * This field is mandatory and has a strict pattern constraint.
     */
    @NotNull(message = "A/C Classification cannot be null.")
    @Pattern(regexp = "[ALIEM]", message = "A/C Classification must be one of: A, L, I, E, M.")
    private String acClassification;

    /**
     * Flag indicating whether balance forwarding is enabled (e.g., 0 for No, 1 for
     * Yes).
     * This field is mandatory.
     */
    @NotNull(message = "Balance Forward (balFwd) flag cannot be null.")
    private Integer balFwd;

    /**
     * The default balance type for the account ('C' for Credit, 'D' for Debit).
     * This field is mandatory and has a strict pattern constraint.
     */
    @NotNull(message = "Default Balance Type cannot be null.")
    @Pattern(regexp = "[CD]", message = "Default Balance Type must be 'C' or 'D'.")
    private String defBalType;

    /**
     * The status of the GL code (e.g., 0 for Inactive, 1 for Active).
     * This field is mandatory.
     */
    @NotNull(message = "Status cannot be null.")
    private Integer status;

    /**
     * Flag indicating if the balance is used for comparison purposes (e.g., 0 for
     * No, 1 for Yes).
     * This field is mandatory.
     */
    @NotNull(message = "Balance Compare (balCompare) flag cannot be null.")
    private Integer balCompare;

    /**
     * Flag indicating if manual posting is allowed for this GL code (e.g., 0 for
     * No, 1 for Yes).
     * This field is mandatory.
     */
    @NotNull(message = "Manual Posting flag cannot be null.")
    private Integer manualPosting;

    /**
     * Constructs and returns the composite primary key for this DTO.
     * The key is used for data identification and integrity checks within the
     * service layer.
     *
     * @return A string representing the concatenated composite primary key (comp1 +
     *         segmentCode + comp2).
     */
    @Override
    @JsonIgnore // Ensures this method's output is not included during JSON serialization of the
                // DTO
    public String getKey() {
        // Construct the composite primary key
        return "" + comp1 + segmentCode + comp2;
    }
}














package com.tcs.fincore.CommonRequestService.dto;

import java.util.Date;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
@JsonTypeName("CIRCLE")
public class CircleRequestPayloadDTO implements KeyablePayload  {
	
	@NotNull(message = "Circle Code cannot be null")
	private String circleCode;
	
	@NotNull(message = "Circle name cannot be null")
	@Size(min = 1, max = 150, message = "Circle name must be between 1 and 150")
	public String circleName;
	
	@NotNull(message = "Zone Code cannot be null")
	@Size(min = 1, max = 3, message = "Code must be between 1 and 3")
	public String zoneCode;

	
	@Override
	@JsonIgnore
	public String getKey(
	) {
		// Construct the composite primary key
		return circleCode;
	}
	
}












package com.tcs.fincore.CommonRequestService.dto;

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.tcs.fincore.CommonRequestService.dto.payload.Payload;
import com.tcs.fincore.CommonRequestService.model.enums.ChangeType;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class CreateRequestDto {
	// Jackson will convert the incoming JSON string "SEGMENT_CODE" to the enum
	// RequestType.SEGMENT_CODE
	@NotNull(message = "Request Type cannot be null.")
	private RequestType requestType;

	@NotNull(message = "Change Type cannot be null.")
	private ChangeType changeType;

	private String targetId;

	@NotNull(message = "Payload cannot be null.")
	@Valid // This annotation triggers the validation of the nested payload object 
	@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, // Use a sibling property
			property = "requestType" // The field that determines the payload type
	)
	@JsonSubTypes({ @JsonSubTypes.Type(value = SegmentPayloadDto.class, name = "SEGMENT_CODE"),
			@JsonSubTypes.Type(value = CglPayloadDto.class, name = "CGL_CODE"),
			@JsonSubTypes.Type(value = BranchRequestPayloadDTO.class, name = "BRANCH"),
			@JsonSubTypes.Type(value = CircleRequestPayloadDTO.class, name = "CIRCLE"),
			@JsonSubTypes.Type(value = StateReqPayloadDto.class, name = "STATE"),
			@JsonSubTypes.Type(value = CurrencyMasterDto.class, name = "CURRENCY"),
            @JsonSubTypes.Type(value = CalenderConfigPayloadDto.class, name = "CALENDER"),
            @JsonSubTypes.Type(value = CurrencyRateChangeDto.class, name = "CURRENCY_RATE_CHANGE")
    })
	private Payload payload;
}
















package com.tcs.fincore.CommonRequestService.dto;

import java.math.BigDecimal;
import java.time.LocalDate;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CurrencyMasterDto implements KeyablePayload {

	@NotNull(message = "currency code cannot be null")
	@Size(min = 3, max = 3, message = "currency code must be exactly 2 characters")
	private String currencyCode;

	@NotNull(message = "currency name cannot be null")

	private String currencyName;

	@NotNull(message = "currency flag cannot be null")

	private Integer flag;

	@NotNull(message = "currency Rate cannot be null")

	private BigDecimal currencyRate;
	private LocalDate rateDate;

	@Override
	@JsonIgnore
	public String getKey(
	) {
		// TODO Auto-generated method stub
		return this.currencyCode.toString();
	}
}

















package com.tcs.fincore.CommonRequestService.dto;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Date;

import com.fasterxml.jackson.annotation.JsonTypeName;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.Data;

@Data
@JsonTypeName("CURRENCY_RATE_CHANGE")

public class CurrencyRateChangeDto implements KeyablePayload{

   @NotNull
    private String currencyCode;

    @NotNull
    @Positive
    private BigDecimal currencyRate;

//    @NotNull
    // @PastOrPresent
    private Date rateChangeDate;

@Override
public String getKey() {
	// TODO Auto-generated method stub
	return this.currencyCode.toString();
}

   
   

}




















package com.tcs.fincore.CommonRequestService.dto;

import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import lombok.Data;

/**
 * Dto for the payload of /my-requests endpoint
 * Allows filtering of requests by their type
 */
@Data
public class MyRequestFilterDto {
    /**
     * The type of request to filter by.
     * This field is optional, If null, requests of all types will be returned.
     */
    private RequestType requestType;
}















package com.tcs.fincore.CommonRequestService.dto;

import com.tcs.fincore.CommonRequestService.model.enums.RequestStatus;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class ProcessRequestDto {

    @NotNull(message = "Request Id cannot be null")
    private Long requestId;

    @NotNull(message = "Status cannot be null")
    private RequestStatus status;

    @Size(max = 500, message = "Remarks cannot exceed 500 characters")
    private String remarks;
}










package com.tcs.fincore.CommonRequestService.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

/*
 * Dto for validating the request of a segment code request
 */
@Data
@JsonTypeName("SEGMENT_CODE")
public class SegmentPayloadDto implements KeyablePayload {
    @NotNull(message = "Segment Code cannot be null.")
    @Size(min = 4, max = 4, message = "Segment Code must be exactly 4 characters.")
    private String segmentCode;

    @NotNull(message = "Description cannot be null.")
    @Size(min = 1, max = 100, message = "Description must be between 1 and 100 characters.")
    private String description;

    // construct the primary key
    @Override
    @JsonIgnore // Exclude this method from JSON serialization
    public String getKey() {
        return this.segmentCode;
    }
}








package com.tcs.fincore.CommonRequestService.dto;

import org.springframework.validation.annotation.Validated;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;


@Data
@JsonTypeName("STATE")
public class StateReqPayloadDto implements KeyablePayload {
    @NotNull(message = "State name cannot be null.")
    @Size(min = 3, max = 20, message = "State name cant exceed 20 characters")
    private String stateName;

    @NotNull(message = "State Code cannot be null.")
    @Size(min = 2, max = 2, message = "State Code must be exactly 2 characters")
    private String stateCode;

    public void setStateName(String fieldName) {
            this.stateName = fieldName.toUpperCase(); // Capitalize the value here
        }

    public void setStateCode(String fieldName) {
            this.stateCode = fieldName.toUpperCase(); // Capitalize the value here
        }

    @Override
    @JsonIgnore
    public String getKey() {
        // TODO Auto-generated method stub
        return this.stateCode;
    }
    
}








package com.tcs.fincore.CommonRequestService.dto;


import com.tcs.fincore.CommonRequestService.model.enums.RequestStatus;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class UpdateRequestStatusDto {
    // Jackson will convert the incoming JSON string "ACCEPTED" to the enum RequestStatus.ACCEPTED
    private RequestStatus status;
    private String remarks;
}













//--------------------------------------------------

package com.tcs.fincore.CommonRequestService.exception;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.tcs.fincore.CommonRequestService.dto.ApiResponse;

import lombok.extern.slf4j.Slf4j;

import java.util.stream.Collectors;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.context.request.WebRequest;

import jakarta.validation.ConstraintViolationException;

@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<Object>> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        log.error("Resource not found: {}", ex.getMessage());
        return new ResponseEntity<>(ApiResponse.error(ex.getMessage()), HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler({JsonProcessingException.class, HttpMessageNotReadableException.class})
    public ResponseEntity<ApiResponse<Object>> handleJsonProcessingException(Exception ex, WebRequest request) {
        log.error("Error processing JSON payload: {}", ex.getMessage());
        return new ResponseEntity<>(ApiResponse.error("Invalid request payload format. Please check the JSON structure and data types."), HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiResponse<Object>> handleDataIntegrityViolationException(DataIntegrityViolationException ex, WebRequest request) {
        log.error("Data integrity violation: {}", ex.getMessage());
        // Check for common unique constraint violation message
        log.error("error: {}",ex.getMostSpecificCause().getMessage());
        if (ex.getMostSpecificCause().getMessage().contains("unique constraint")) {
            return new ResponseEntity<>(ApiResponse.error("A resource with the provided identifier already exists."), HttpStatus.CONFLICT);
        }else if(ex.getMostSpecificCause().getMessage().contains("pending request")) {
        	return new ResponseEntity<>(ApiResponse.error("A pending request is already exists."), HttpStatus.CONFLICT);
        }
        return new ResponseEntity<>(ApiResponse.error("Database constraint violation. A required field may be missing or a value is invalid."), HttpStatus.CONFLICT);
    }

    @ExceptionHandler({IllegalArgumentException.class, IllegalStateException.class})
    public ResponseEntity<ApiResponse<Object>> handleArgumentAndStateExceptions(RuntimeException ex, WebRequest request) {
        log.error("Illegal argument or state: {}", ex.getMessage());
        return new ResponseEntity<>(ApiResponse.error(ex.getMessage()), HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Object>> handleGlobalException(Exception ex, WebRequest request) {
        log.error("An unexpected error occurred: {}", ex.getMessage(), ex);
        return new ResponseEntity<>(ApiResponse.error("An internal server error occurred."), HttpStatus.INTERNAL_SERVER_ERROR);
    }


    /**
     * Handles exceptions thrown when @Valid validation fails on a request body.
     * Returns a 400 Bad Request with a list of validation errors.
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ResponseEntity<ApiResponse<Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        // Collect all validation error messages into a single string.
        String errors = ex.getBindingResult().getFieldErrors().stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.joining(", "));
        
        log.warn("Validation failed for incoming request: {}", errors);
         return new ResponseEntity<>(ApiResponse.error("Validation Failed: "+errors), HttpStatus.BAD_REQUEST);
    }

    /**
     * Handles exceptions thrown by the Jakarta Validator, for example,
     * when we manually trigger validation in our strategies.
     */
    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ResponseEntity<ApiResponse<Object>> handleConstraintViolationException(ConstraintViolationException ex) {
        String errors = ex.getConstraintViolations().stream()
                .map(cv -> cv.getPropertyPath() + ": " + cv.getMessage())
                .collect(Collectors.joining(", "));
                
        log.warn("Constraint violation during processing: {}", errors);
        return new ResponseEntity<>(ApiResponse.error("Validation Failed: "+errors), HttpStatus.BAD_REQUEST);
    }
}





package com.tcs.fincore.CommonRequestService.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}





//--------------------------------------------------

package com.tcs.fincore.CommonRequestService.model.converters;

import com.tcs.fincore.CommonRequestService.model.enums.ChangeType;
import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;
import java.util.stream.Stream;

/**
 * This converter handles the mapping between the ChangeType enum in Java
 * and its single-character representation ('A', 'U', 'D') in the database.
 */
@Converter(autoApply = true)
public class ChangeTypeConverter implements AttributeConverter<ChangeType, String> {

    @Override
    public String convertToDatabaseColumn(ChangeType changeType) {
        if (changeType == null) {
            return null;
        }
        return changeType.getCode();
    }

    @Override
    public ChangeType convertToEntityAttribute(String code) {
        if (code == null) {
            return null;
        }
        return Stream.of(ChangeType.values())
                .filter(c -> c.getCode().equals(code))
                .findFirst()
                .orElseThrow(IllegalArgumentException::new);
    }
}



package com.tcs.fincore.CommonRequestService.model.converters;


import com.tcs.fincore.CommonRequestService.model.enums.RequestStatus;
import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;
import java.util.stream.Stream;

/**
 * This converter handles the mapping between the RequestStatus enum in Java
 * and its single-character representation ('P', 'A', 'R') in the database.
 * The autoApply=true attribute means JPA will automatically use this converter
 * for all fields of type RequestStatus.
 */
@Converter(autoApply = true)
public class RequestStatusConverter implements AttributeConverter<RequestStatus, String> {

    /**
     * Converts the enum constant to its database character code.
     * @param status The enum value (e.g., RequestStatus.PENDING)
     * @return The database value (e.g., "P")
     */
    @Override
    public String convertToDatabaseColumn(RequestStatus status) {
        if (status == null) {
            return null;
        }
        return status.getCode();
    }

    /**
     * Converts the character code from the database back to the enum constant.
     * @param code The database value (e.g., "P")
     * @return The enum value (e.g., RequestStatus.PENDING)
     */
    @Override
    public RequestStatus convertToEntityAttribute(String code) {
        if (code == null) {
            return null;
        }
        return Stream.of(RequestStatus.values())
                .filter(c -> c.getCode().equals(code))
                .findFirst()
                .orElseThrow(IllegalArgumentException::new);
    }
}




















package com.tcs.fincore.CommonRequestService.model.converters;

import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;
import java.util.stream.Stream;

/**
 * This converter handles the mapping between the RequestType enum in Java
 * and its custom string representation ('SegmentCode', 'CGL') in the database.
 */
@Converter(autoApply = true)
public class RequestTypeConverter implements AttributeConverter<RequestType, String> {

    @Override
    public String convertToDatabaseColumn(RequestType requestType) {
        if (requestType == null) {
            return null;
        }
        return requestType.getDbValue();
    }

    @Override
    public RequestType convertToEntityAttribute(String dbValue) {
        if (dbValue == null) {
            return null;
        }
        return Stream.of(RequestType.values())
                .filter(c -> c.getDbValue().equals(dbValue))
                .findFirst()
                .orElseThrow(IllegalArgumentException::new);
    }
}













//--------------------------




package com.tcs.fincore.CommonRequestService.model.enums;

import lombok.Getter;

/**
 * Enumeration representing the types of changes that can be applied to a record or entity.
 * This is commonly used in tracking the nature of a data modification request.
 */
@Getter
public enum ChangeType {
    /**
     * Represents the addition (creation) of a new record.
     */
    ADD("A"),

    /**
     * Represents the modification (update) of an existing record.
     */
    UPDATE("U"),

    /**
     * Represents the removal (deletion) of an existing record.
     */
    DELETE("D"),

    /**
     * Represents the block state of an existing record in the master table.
     */
    BLOCK("B"),


    /**
     *Represents the unblock state of an existing record in the master table
     */
    UNBLOCK("UB");

    /**
     * The single-character code associated with the change type.
     */
    private final String code;

    /**
     * Constructs a {@code ChangeType} enum constant with the specified code.
     *
     * @param code The single-character representation of the change type (e.g., "A", "U", "D").
     */
    ChangeType(String code) {
        this.code = code;
    }
}






package com.tcs.fincore.CommonRequestService.model.enums;

/**
 * Represents the status of a request in the system.
 * This enum provides a structured way to manage and reference different states
 * a request can be in throughout its lifecycle within the application.
 */
import lombok.Getter;

@Getter
public enum RequestStatus {
    /**
     * The initial state of a request, awaiting review or processing.
     * Mapped to the database code "P".
     */
    PENDING("P"),

    /**
     * The request has been reviewed and approved/accepted.
     * Mapped to the database code "A".
     */
    ACCEPTED("A"),

    /**
     * The request has been reviewed and denied/rejected.
     * Mapped to the database code "R".
     */
    REJECTED("R"),

    /**
     * The created request has been cancelled before execution.
     * Mapped to the database code "C".
     */
    CANCELLED("C");

    /**
     * The single-character code used to represent the status in the database or external systems.
     */
    private final String code;

    /**
     * Constructs a RequestStatus enum constant with the specified code.
     *
     * @param code The single-character representation of the status.
     */
    RequestStatus(String code) {
        this.code = code;
    }

    /**
     * Returns the single-character code associated with this request status.
     *
     * @return The status code.
     */
    public String getCode() {
        return this.code;
    }
}





package com.tcs.fincore.CommonRequestService.model.enums;

/**
 * Defines the type of entity a request is for (e.g., Segment Code, CGL).
 * This enum provides a mapping between the logical request type and its
 * corresponding database value representation.
 */

import lombok.Getter;

@Getter
public enum RequestType {
    // The dbValue (e.g., "SegmentCode") is used for the database.

    /**
     * Represents a request type for Segment Code entities.
     * Database value: "SEGMENT"
     */
    SEGMENT_CODE("SEGMENT"),

    /**
     * Represents a request type for CGL Code entities.
     * Database value: "CGL"
     */
    CGL_CODE("CGL"),

    /**
     * Represents a request type for State entities.
     * Database value: "STATE"
     */
    STATE("STATE"),

    /**
     * Represents a request type for Branch entities.
     * Database value: "BRANCH"
     */
    BRANCH("BRANCH"),

    /**
     * Represents a request type for Circle entities.
     * Database value: "CIRCLE"
     */
    CIRCLE("CIRCLE"),

    /**
     * Represents a request type for Currency entities.
     * Database value: "CURRENCY"
     */
    CURRENCY("CURRENCY"),

    /**
     * Represents a request type for Calendar entities.
     * Database value: "CALENDER"
     */
    CALENDER("CALENDER"),

    /**
     * Represents a request type for Currency Rate Change entities.
     * Database value: "CURRENCY_RATE"
     */
    CURRENCY_RATE_CHANGE("CURRENCY_RATE_CHANGE");

    /**
     * The database value associated with the request type.
     */
    private final String dbValue;

    /**
     * Constructs a new RequestType enum constant with the specified database value.
     * @param dbValue The value used for database representation.
     */
    RequestType(String dbValue) {
        this.dbValue = dbValue;
    }

    /**
     * Retrieves the database value associated with this request type.
     * This method is generated automatically by the {@link lombok.Getter} annotation.
     * @return The database value as a String.
     */
    // public String getDbValue() is generated by Lombok
}






//------------------------------


package com.tcs.fincore.CommonRequestService.model;

import java.util.Date;

import com.fasterxml.jackson.annotation.JsonFormat;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * Represents the Branch Master entity, mapping to the "BRANCH_MASTER" table in
 * the database. This class uses Project Lombok annotations for boilerplate code
 * reduction (getters, setters, constructors, builder pattern).
 */
@Getter
@Setter
@Entity
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "BRANCH_MASTER")
public class BranchMaster {

	/**
	 * The unique five-character code identifying the branch. This is the primary
	 * key.
	 */
	@Id
	@Column(name = "CODE", nullable = false, length = 5, updatable = false)
	private String code;

	/**
	 * The official name of the branch.
	 */
	@Column(name = "NAME", nullable = false, length = 50)
	private String name;

	/**
	 * The code for the operational circle the branch belongs to.
	 */
	@Column(name = "CIRCLE_CODE", nullable = false, length = 5)
	private String circleCode;

	/**
	 * The state where the branch is located.
	 */
	@Column(name = "STATE", nullable = false, length = 50)
	private String state;

	/**
	 * The city where the branch is located.
	 */
	@Column(name = "CITY", nullable = true, length = 50)
	private String city;

	/**
	 * The physical address of the branch.
	 */
	@Column(name = "ADDRESS", nullable = true, length = 50)
	private String address;

	/**
	 * The postal identification code (PIN code) for the branch location.
	 */
	@Column(name = "PINCODE", nullable = true, length = 6)
	private String pinCode;

	/**
	 * The primary contact phone number for the branch.
	 */
	@Column(name = "PHONE_NUMBER", nullable = false, length = 12)
	private String phoneNumber;

	/**
	 * The official email ID for the branch.
	 */
	@Column(name = "EMAIL_ID", nullable = false, length = 50)
	private String emailId;

	/**
	 * The NMR (Network Management Region/Rural) code associated with the branch.
	 */
	@Column(name = "NMR_CODE", nullable = false, length = 50)
	private String nmrCode;

	/**
	 * The current operational status of the branch (e.g., active/inactive).
	 */
	@Column(name = "STATUS", nullable = false)
	private Boolean status;

	/**
	 * The date the branch was officially opened. This field is not updatable after
	 * creation.
	 */
	@Column(name = "OPEN_DATE", nullable = false, updatable = false)
	@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd/MM/yyyy")
	private Date openDate;

	/**
	 * The date the branch was officially closed, if applicable.
	 */
	@Column(name = "CLOSE_DATE")
	@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd/MM/yyyy")
	private Date closeDate;

	/**
	 * The date the branch was merged into another branch, if applicable.
	 */
	@Column(name = "MERGE_DATE")
	@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd/MM/yyyy")
	private Date mergeDate;

	/**
	 * The code of the branch this branch was merged with.
	 */
	@Column(name = "MERGED_WITH_BRANCH", length = 5)
	private String mergedWithBranch;

	/**
	 * The timestamp of the last modification made to this branch record.
	 */
	@Column(name = "LAST_CHANGE_DATE")
	@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd/MM/yyyy")
	private Date lastChangeDate;

	/**
	 * Flag indicating if the branch is a Centralized Processing Centre (CPC).
	 */
	@Column(name = "CPC_FLAG", nullable = false)
	private Boolean cpcFlag;

	/**
	 * Flag indicating if the branch supports food credit services.
	 */
	@Column(name = "FOOD_CREDIT_FLAG", nullable = false)
	private Boolean foodCreditFlag;

	/**
	 * Flag indicating if the branch operates as a currency chest.
	 */
	@Column(name = "CURR_CHEST_FLAG", nullable = false)
	private Boolean currChestFlag;

	/**
	 * The type of branch (e.g., 'M' for Main, 'S' for Satellite).
	 */
	@Column(name = "BRANCH_TYPE", length = 1)
	private String branchType;
}












package com.tcs.fincore.CommonRequestService.model;

import jakarta.persistence.*;
import lombok.Data;
import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Represents the configuration entity for the financial calendar.
 * This entity maps to the "CALENDER_CONFIG" table in the database and is used to store
 * and retrieve calendar-specific information, including fiscal year dates and approval details.
 */
@Entity
@Table(name = "CALENDER_CONFIG")
@Data
public class CalenderConfigModel {

    /**
     * The unique identifier for the calendar configuration record.
     * This field serves as the primary key for the CALENDER_CONFIG table.
     */
    @Id
    @Column(name = "ID")
    private Long id;

    /**
     * The start date of the configured financial year.
     * This field is mandatory and cannot be null.
     */
    @Column(name = "YEAR_START_DATE", nullable = false)
    private LocalDate yearStartDate;

    /**
     * The end date of the configured financial year.
     * This field is mandatory and cannot be null.
     */
    @Column(name = "YEAR_END_DATE", nullable = false)
    private LocalDate yearEndDate;

    /**
     * Any relevant remarks or comments concerning this calendar configuration.
     * This field is mandatory and has a maximum length of 255 characters.
     */
    @Column(name = "REMARKS", nullable = false, length = 255)
    private String remarks;

    /**
     * The timestamp indicating when this calendar configuration was approved.
     * Can be null if not yet approved.
     */
    @Column(name = "APPROVEDAT")
    private LocalDateTime approvedAt;

    /**
     * The user ID or name of the individual who approved the configuration.
     * Can be null if not yet approved. Maximum length is 50 characters.
     */
    @Column(name = "APPROVEDBY", length = 50)
    private String approvedBy;

    /**
     * The timestamp indicating when this calendar configuration was requested.
     * Can be null.
     */
    @Column(name = "REQUESTEDAT")
    private LocalDateTime requestedAt;

    /**
     * The user ID or name of the individual who requested the configuration.
     * Can be null. Maximum length is 50 characters.
     */
    @Column(name = "REQUESTEDBY", length = 50)
    private String requestedBy;
}














package com.tcs.fincore.CommonRequestService.model;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.ColumnDefault;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.Generated;
import org.hibernate.generator.EventType;
import java.time.LocalDate;

/**
 * Represents a General Ledger (GL) account master record in the CGL_MASTER
 * database table.
 * This entity is used to manage and persist Chart of Accounts (CoA)
 * information.
 * It uses Lombok's {@code @Data} for automatic generation of getters, setters,
 * equals, hashCode, and toString methods.
 */
@Entity
@Data
@Table(name = "CGL_MASTER")
public class CGLMaster {

    /**
     * The computed General Ledger (CGL) account number, serving as the primary key.
     * This value is generated by the database upon insertion and is not directly
     * insertable or updatable by the application.
     * The {@code @Generated} annotation ensures Hibernate re-reads the value after
     * the insert operation.
     */
    @Id
    @Column(name = "CGL_NUMBER", insertable = false, updatable = false)
    @Generated(event = EventType.INSERT)
    private String cglNumber;

    /**
     * Component 1 of the CGL number, representing the primary segment of the
     * account structure.
     * This field is mandatory (non-nullable).
     */
    @Column(name = "COMP_1", nullable = false, length = 4)
    private String comp1;

    /**
     * Segment code of the CGL number, defining the functional area or department.
     * This field is mandatory (non-nullable) with a maximum length of 4 characters.
     */
    @Column(name = "SEGMENT_CODE", nullable = false, length = 4)
    private String segmentCode;

    /**
     * Component 2 of the CGL number, representing a sub-segment or specific detail.
     * This field is mandatory (non-nullable).
     */
    @Column(name = "COMP_2", nullable = false, length = 2)
    private String comp2;

    /**
     * A human-readable description of the GL account.
     * This field is mandatory (non-nullable) with a maximum length of 100
     * characters.
     */
    @Column(name = "DESCRIPTION", nullable = false, length = 100)
    private String description;

    /**
     * Account classification (e.g., 'A' for Asset, 'L' for Liability, 'E' for
     * Expense, 'R' for Revenue).
     * This field is mandatory (non-nullable) with a length of 1 character.
     */
    @Column(name = "AC_CLASSIFICATION", nullable = false, length = 1)
    private String acClassification;

    /**
     * Flag indicating balance forwarding settings (e.g., 0 for No, 1 for Yes).
     * This field is mandatory (non-nullable).
     */
    @Column(name = "BAL_FWD", nullable = false)
    private Integer balFwd;

    /**
     * Default balance type (e.g., 'D' for Debit, 'C' for Credit).
     * This field is mandatory (non-nullable) with a length of 1 character.
     */
    @Column(name = "DEF_BAL_TYPE", nullable = false, length = 1)
    private String defBalType;

    /**
     * The current status of the account (e.g., 1 for Active, 0 for Inactive).
     * This field is mandatory (non-nullable).
     */
    @Column(name = "STATUS", nullable = false)
    private Integer status;

    /**
     * The date the account was opened.
     * This value is typically set by the database using a default (e.g., the system
     * date) upon insertion.
     * The application does not insert or update this field.
     * The {@code @Generated} annotation ensures Hibernate re-reads the value after
     * the insert operation.
     */
    @Column(name = "OPEN_DATE", nullable = false, insertable = false, updatable = false)
    @Generated(event = EventType.INSERT)
    private LocalDate openDate;

    /**
     * The date the account was closed, if applicable.
     * This field is nullable.
     */
    @Column(name = "CLOSE_DATE")
    private LocalDate closeDate;

    /**
     * Flag or value used for balance comparison logic.
     * This field is mandatory (non-nullable).
     */
    @Column(name = "BAL_COMPARE", nullable = false)
    private Integer balCompare;

    /**
     * Flag indicating whether manual postings are allowed for this account.
     * This field is mandatory (non-nullable).
     */
    @Column(name = "MANUAL_POSTING", nullable = false)
    private Integer manualPosting;

    /**
     * Lifecycle method annotated with {@code @PrePersist}.
     * This method is executed automatically before the entity is saved (persisted)
     * to the database for the first time.
     * It formats the {@code cglNumber} based on the constituent components
     * (`comp1`, `segmentCode`, `comp2`).
     * Note: While the application can compute the value here for internal use or
     * logging, the database value is authoritative due to the
     * {@code insertable=false, updatable=false} and {@code @Generated} annotations
     * on the {@code cglNumber} field.
     */
    @PrePersist
    private void computeCglNumber() {
        this.cglNumber = String.format("%s%s%s", comp1, segmentCode, comp2);
    }

}












package com.tcs.fincore.CommonRequestService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;
import java.util.Date;

/**
 * Represents the `CIRCLE_MASTER` table in the database.
 * This entity is used to store and retrieve information about different operational circles within the organization.
 * It uses Jakarta Persistence API (JPA) annotations for object-relational mapping (ORM) and Lombok annotations for boilerplate code reduction.
 */
@Entity
@Getter
@Setter
@Table(name="CIRCLE_MASTER")
public class CircleMaster {

    /**
     * The unique code identifying the circle.
     * This is the primary key of the `CIRCLE_MASTER` table.
     * Corresponds to the `CIRCLE_CODE` column, which is non-null and has a maximum length of 3 characters.
     */
    @Id
    @Column(name="CIRCLE_CODE" , nullable = false , length = 3)
    public String circleCode;

    /**
     * The full name of the circle.
     * Corresponds to the `CIRCLE_NAME` column, which is non-null and has a maximum length of 150 characters.
     */
    @Column(name="CIRCLE_NAME", nullable = false , length = 150)
    public String circleName;

    /**
     * The code identifying the zone to which the circle belongs.
     * Corresponds to the `ZONE_CODE` column, which is non-null and has a maximum length of 3 characters.
     */
    @Column(name="ZONE_CODE", nullable = false , length = 3)
    public String zoneCode;

    /**
     * The date and time when the record was created.
     * This field is automatically populated by the database (or ORM mechanism) upon insertion and is not intended to be inserted manually.
     * Corresponds to the `CREATED_DATE` column.
     */
    @Column(name="CREATED_DATE", insertable = false )
    public Date createdDate;

}









package com.tcs.fincore.CommonRequestService.model;

import com.fasterxml.jackson.annotation.JsonRawValue;
import com.tcs.fincore.CommonRequestService.model.enums.ChangeType;
import com.tcs.fincore.CommonRequestService.model.enums.RequestStatus;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import java.time.LocalDateTime;

/**
 * Represents a common request entity stored in the "COMMON_REQ" database table.
 * This entity is used to log and track various types of requests within the system,
 * including their status, payload, and execution details.
 *
 * All enum fields are now handled by their respective {@link jakarta.persistence.Converter @Converter(autoApply = true)} classes.
 */
@Getter
@Setter
@Entity
@Table(name = "COMMON_REQ")
public class CommonReq {
    /**
     * The unique identifier for the request.
     * Generated using a sequence "COMMON_REQ_SEQ".
     */
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "COMMON_REQ_id_gen")
    @SequenceGenerator(name = "COMMON_REQ_id_gen", sequenceName = "COMMON_REQ_SEQ", allocationSize = 1)
    @Column(name = "REQ_ID", nullable = false)
    private Long id;

    /**
     * The type of request (e.g., New, Update, Delete).
     * Mapped to the "REQ_TYPE" column. Handled by an auto-applied JPA converter.
     */
    @Column(name = "REQ_TYPE", nullable = false, length = 20)
    private RequestType reqType;

    /**
     * The specific type of change associated with the request.
     * Mapped to the "CHANGE_TYPE" column. Handled by an auto-applied JPA converter.
     */
    @Column(name = "CHANGE_TYPE", nullable = false, length = 2)
    private ChangeType changeType;

    /**
     * The current status of the request (e.g., PENDING, APPROVED, REJECTED).
     * Mapped to the "REQ_STATUS" column. Handled by an auto-applied JPA converter.
     */
    @Column(name = "REQ_STATUS", nullable = false, length = 2)
    private RequestStatus reqStatus;

    /**
     * The timestamp when the request was created.
     * Automatically set upon entity creation and is not updatable.
     */
    @CreationTimestamp
    @Column(name = "REQ_DATE", nullable = false, updatable = false)
    private LocalDateTime reqDate;

    /**
     * The ID of the user who created the request.
     * Mapped to the "CREATOR_ID" column.
     */
    @Column(name = "CREATOR_ID", nullable = false, length = 12)
    private String creatorId;

    /**
     * The timestamp when the request was executed or processed.
     * Mapped to the "EXECUTION_DATE" column.
     */
    @Column(name = "EXECUTION_DATE")
    private LocalDateTime executionDate;

    /**
     * General remarks regarding the execution process.
     * Stored as a Large Object (LOB) in the "EXECUTION_REMARKS" column.
     */
    @Lob
    @Column(name = "EXECUTION_REMARKS")
    private String executionRemarks;

    /**
     * The ID of the user who executed or processed the request.
     * Mapped to the "EXECUTOR_ID" column.
     */
    @Column(name = "EXECUTOR_ID", length = 12)
    private String executorId;

    /**
     * Specific remarks provided by the executor.
     * Mapped to the "EXECUTOR_REMARKS" column.
     */
    @Column(name = "EXECUTOR_REMARKS", length = 500)
    private String executorRemarks;

    /**
     * The request's main data payload, typically a JSON string.
     * Stored as a Large Object (LOB) in the "PAYLOAD" column.
     */
    @Lob
    @Column(name = "PAYLOAD", nullable = false)
    private String payload;

    /**
     * An identifier for the target entity affected by the request (e.g., account number, user ID).
     * Mapped to the "TARGET_ID" column.
     */
    @Column(name = "TARGET_ID", length = 4000)
    private String targetId;


    /**
     * Retrieves the payload and marks it for raw JSON serialization.
     *
     * When this entity is serialized to JSON (e.g., in a REST API response),
     * the value returned by this getter will be inserted directly as raw JSON,
     * assuming the {@link #payload} field already contains a valid JSON string.
     *
     * @return The raw JSON payload string.
     */
    @JsonRawValue
    public String getPayload() {
        return payload;
    }
}











package com.tcs.fincore.CommonRequestService.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Date;

/**
 * Represents a historical record of a currency rate change within the Fincore system.
 * This entity maps to the "CURRENCY_RATE_CHANGE" table in the database.
 *
 * It captures essential details such as the currency involved, the specific rate,
 * and the exact timestamp when the record was created or last updated.
 */
@Entity
@Data
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "CURRENCY_RATE_CHANGE")
public class Currency_Rate_Change_Model {

    /**
     * The unique identifier for the currency rate change record.
     * This field is auto-generated by the persistence provider.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    /**
     * The ISO 4217 currency code (e.g., "USD", "EUR").
     * Must be non-null and exactly 3 characters long.
     */
    @Column(name = "currency_code", nullable = false, length = 3)
    private String currencyCode;

    /**
     * The currency exchange rate value.
     * Stored with high precision (19 total digits, 9 digits after the decimal point)
     * to ensure financial accuracy.
     */
    @Column(name = "currency_rate", nullable = false, precision = 19, scale = 9)
    private BigDecimal currencyRate;

    /**
     * The date and time when this specific rate change record was persisted or updated
     * in the database.
     */
    @Column(name = "rate_change_date")
    private Date rateChangeDate;


    /**
     * Lifecycle hook executed before an existing entity is updated in the database.
     * Automatically sets the {@code rateChangeDate} to the current system date and time.
     */
    @PreUpdate
    public void onPreUpdate() {
        this.rateChangeDate = new Date();
    }


    /**
     * Lifecycle hook executed before a new entity is first persisted in the database.
     * Automatically sets the {@code rateChangeDate} to the current system date and time.
     */
    @PrePersist
    public void onPrePersist() {
        this.rateChangeDate = new Date();
    }
}













package com.tcs.fincore.CommonRequestService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Represents a currency entity in the financial core system, mapped to the "CURRENCY_MASTER" database table.
 *
 * This entity stores essential details about various currencies, including their codes, names,
 * current rates, and system audit information.
 */
@Entity
@Table(name = "CURRENCY_MASTER")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CurrencyMasterModel {

    /**
     * The unique ISO currency code (e.g., "USD", "INR").
     * This field serves as the primary identifier for the entity.
     */
    @Id
    @Column(name = "CURRENCY_CODE", nullable = false, unique = true, length = 3)
    private String currencyCode;

    /**
     * The full name of the currency (e.g., "United States Dollar", "Indian Rupee").
     */
    @Column(name = "CURRENCY_NAME", nullable = false, length = 50)
    private String currencyName;

    /**
     * A flag indicating the status of the currency (e.g., active/inactive).
     */
    @Column(name = "FLAG", nullable = false)
    private Integer flag;

    /**
     * The current exchange rate for the currency, stored as a precise decimal value.
     */
    @Column(name = "CURRENCY_RATE")
    private BigDecimal currencyRate;

    /**
     * The date on which the {@code currencyRate} was last updated or validated.
     */
    @Column(name = "RATE_DATE")
    private LocalDate rateDate;

    /**
     * The timestamp when the record was initially created.
     * This field is automatically managed and cannot be updated manually.
     */
    @Column(name = "CREATED_AT", updatable = false)
    private LocalDateTime createdAt;

    /**
     * The timestamp when the record was last modified.
     * This field is automatically managed upon updates.
     */
    @Column(name = "UPDATED_AT")
    private LocalDateTime updatedAt;

    /**
     * Lifecycle method invoked automatically before a new entity is persisted (inserted) into the database.
     * It sets both {@code createdAt} and {@code updatedAt} timestamps to the current time.
     */
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Lifecycle method invoked automatically before an existing entity is updated in the database.
     * It updates the {@code updatedAt} timestamp to the current time.
     */
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}










package com.tcs.fincore.CommonRequestService.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Date;

/**
 * Represents a historical change in currency exchange rates within the fincore system.
 * This entity is mapped to the "CURRENCY_RATE_CHANGE" database table.
 * It captures details such as the currency involved, the new rate, and when the change took effect.
 */
@Entity
@Data
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "CURRENCY_RATE_CHANGE")
public class CurrencyRateChange {

    /**
     * The unique identifier for the currency rate change record.
     * This is an auto-generated primary key.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    /**
     * The 3-character ISO currency code (e.g., "USD", "EUR").
     * This field is mandatory and limited to a length of 3 characters.
     */
    @Column(name = "currency_code", nullable = false, length = 3)
    private String currencyCode;

    /**
     * The new exchange rate for the specified currency.
     * Stored as a high-precision BigDecimal (19 total digits, 9 digits after the decimal point).
     * This field is mandatory.
     */
    @Column(name = "currency_rate", nullable = false, precision = 19, scale = 9)
    private BigDecimal currencyRate;

    /**
     * The timestamp indicating when this rate change was persisted or updated in the system.
     * This field is automatically managed by JPA lifecycle callbacks.
     */
    @Column(name = "rate_change_date")
    private Date rateChangeDate;


    /**
     * Lifecycle callback method executed automatically before the entity is updated in the database.
     * It ensures the {@code rateChangeDate} is set to the current system date/time upon any modification.
     */
    @PreUpdate
    public void onPreUpdate() {
        this.rateChangeDate = new Date();
    }


    /**
     * Lifecycle callback method executed automatically before the entity is first persisted (inserted) into the database.
     * It ensures the {@code rateChangeDate} is set to the current system date/time upon creation.
     */
    @PrePersist
    public void onPrePersist() {
        this.rateChangeDate = new Date();
    }
}

















package com.tcs.fincore.CommonRequestService.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp; // Import this
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.io.Serializable;
import java.time.Instant; // This is the correct type
import java.util.Objects;
import java.util.UUID;

/**
 * Represents an event in the outbox system, intended for notification purposes.
 * This entity maps to the {@code notification_table} in the database. It captures all necessary details
 * for a notification to be processed and displayed to a user or a group of users (via roles).
 * <p>
 * The {@code @CreationTimestamp} annotation ensures that the {@code eventTimestamp} is automatically
 * populated upon entity creation, providing an accurate record of when the event occurred.
 * </p>
 */
@Entity
@Table(name = "notifications")
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class NotificationTable implements Serializable {

    /**
     * Unique primary key for the outbox event.
     * Uses a generated {@link UUID} strategy, which is suitable for Oracle's SYS_GUID() or RAW(16) columns.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "EVENT_ID", updatable = false, nullable = false)
    private UUID eventId;

    /**
     * The ID of the user who should receive this notification (for 1-to-1 notifications).
     * This field is used when targeting a specific user.
     */
    @Column(name = "USER_ID", length = 255)
    private String userId;

    /**
     * The human-readable message to be displayed in the UI.
     * This is the main content of the notification.
     */
    @Column(name = "MESSAGE", length = 1024, nullable = false)
    private String message;

    /**
     * The relative URL the user should be taken to when clicking the notification.
     * Provides a direct link to the relevant business object or view.
     */
    @Column(name = "LINK_URL", length = 1024)
    private String linkUrl;

    /**
     * The microservice that generated this event.
     * Helps in tracing the origin of the notification within a microservice architecture.
     */
    @Column(name = "EVENT_SOURCE", length = 100)
    private String eventSource;

    /**
     * The primary key of the related business object (e.g., the Common Request ID).
     * Used to link the notification back to the original business data.
     */
    @Column(name = "AGGREGATE_ID", length = 255)
    private String aggregateId;

    /**
     * The timestamp when the event was created.
     * Automatically populated using {@link CreationTimestamp} and stored as an {@link Instant}.
     * The column is both non-nullable and non-updatable after creation.
     */
    @CreationTimestamp
    @Column(name = "EVENT_TIMESTAMP", nullable = false, updatable = false)
    private Instant eventTimestamp;

    /**
     * For 1-to-Many notifications. If {@code userId} is null, this role is used to determine the recipients.
     * Enables broadcasting notifications to all users within a specific role.
     */
    @Column(name = "TARGET_ROLE", length = 100)
    private String targetRole;


    /**
     * Compares this NotificationTable entity with another object for equality based solely on the {@code eventId}.
     *
     * @param o The object to compare with.
     * @return true if the objects are equal (have the same eventId), false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        NotificationTable that = (NotificationTable) o;
        return Objects.equals(eventId, that.eventId);
    }

    /**
     * Generates a hash code for the NotificationTable entity based solely on the {@code eventId}.
     *
     * @return The hash code.
     */
    @Override
    public int hashCode() {
        return Objects.hash(eventId);
    }


    /**
     * Provides a string representation of the NotificationTable entity, primarily for logging and debugging purposes.
     *
     * @return A string containing key fields of the entity.
     */
    @Override
    public String toString() {
        return "NotificationTable{" +
                "eventId='" + eventId + '\'' +
                ", userId='" + userId + '\'' +
                ", targetRole='" + targetRole + '\'' +
                ", eventSource='" + eventSource + '\'' +
                ", aggregateId='" + aggregateId + '\'' +
                ", eventTimestamp=" + eventTimestamp +
                '}';
    }
}





package com.tcs.fincore.CommonRequestService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.*;

/**
 * Represents the PERMISSIONS entity in the database.
 * This class is a JPA entity that maps to the 'PERMISSIONS' table and uses Lombok annotations
 * to automatically generate getters, setters, constructors, and a toString method.
 */
@Entity
@Table(name = "PERMISSIONS")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class Permissions {

    /**
     * The unique identifier for the menu item.
     * This field is the primary key of the PERMISSIONS table.
     */
    @Id
    @Column(name = "MENU_ID")
    private int menuId;

    /**
     * The title of the menu item.
     * Cannot be null.
     */
    @Column(name = "MENU_TITLE", nullable = false, length = 100)
    private String menuTitle;

    /**
     * The icon associated with the menu item, if any.
     */
    @Column(name = "MENU_ICON", length = 100)
    private String menuIcon;

    /**
     * Indicates the submenu the item belongs to, if any.
     */
    @Column(name = "MENU_SUBMENU", length = 100)
    private String menuSubmenu;

    /**
     * The action associated with the menu item.
     * Cannot be null.
     */
    @Column(name = "MENU_ACTION", nullable = false, length = 200)
    private String menuAction;

    /**
     * The URL path for the menu item.
     * Cannot be null.
     */
    @Column(name = "MENU_URL", nullable = false, length = 200)
    private String menuUrl;

    /**
     * The component path in the frontend application associated with the menu item.
     * Cannot be null.
     */
    @Column(name = "MENU_COMPONENT_PATH", nullable = false, length = 200)
    private String menuComponentPath;

    /**
     * A brief description of the menu item and its purpose.
     * Cannot be null.
     */
    @Column(name = "MENU_DESCRIPTION", nullable = false, length = 255)
    private String menuDescription;

    /**
     * The ID of a parent or dependent menu item, if applicable.
     */
    @Column(name = "MENU_DEPENDANT")
    private Integer menuDependant;

    /**
     * The type of request mapped to this permission, if any.
     */
    @Column(name = "MAPPED_REQUEST_TYPE", length = 50)
    private String mappedRequestType;

    /**
     * Backend routes for authorisation check(e.g: //reports/**)
     */
    @Column(name = "API_RESOURCE_PATTERN")
    private String apiResourcePattern;
}














package com.tcs.fincore.CommonRequestService.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

/**
 * Represents the Segment Code Master entity in the FINCORE system.
 * This entity is mapped to the "SEGMENT_CODE_MASTER" table in the database and
 * stores information about various segment codes and their descriptions.
 * The use of {@link Getter} and {@link Setter} annotations from Project Lombok automatically
 * generates the boilerplate getter and setter methods for all fields at compile time.
 */
@Getter
@Setter
@Entity
@Table(name = "SEGMENT_CODE_MASTER")
public class SegmentCodeMaster {

    /**
     * The unique identifier for the segment.
     * This field serves as the primary key for the SEGMENT_CODE_MASTER table.
     * It is mapped to the "SEGMENT_CODE" column, cannot be null, and has a maximum length of 4 characters.
     */
    @Id
    @Column(name = "SEGMENT_CODE", nullable = false, length = 4)
    private String segmentCode;

    /**
     * A detailed description of the segment code.
     * This field is mapped to the "DESCRIPTION" column, cannot be null, and has a maximum length of 100 characters.
     */
    @Column(name = "DESCRIPTION", nullable = false, length = 100)
    private String description;
}













package com.tcs.fincore.CommonRequestService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

/**
 * Represents a state entity within the application, mapping to the "STATE_MASTER" database table.
 * This class uses Jakarta Persistence API (JPA) annotations to define the entity and its mapping to database columns.
 * It also leverages Lombok annotations {@link lombok.Getter @Getter} and {@link lombok.Setter @Setter}
 * to automatically generate getter and setter methods for the fields.
 */
@Getter
@Setter
@Entity
@Table(name = "STATE_MASTER")
public class StateMaster {

    /**
     * The unique code representing the state.
     * This field is the primary key of the STATE_MASTER table and maps to the "STATE_CODE" column.
     * It is a non-nullable column with a maximum length of 4 characters.
     */
    @Id
    @Column(name = "STATE_CODE", nullable = false, length = 4)
    private String stateCode;

    /**
     * The full name of the state.
     * This field maps to the "NAME" column in the database.
     * It is a non-nullable column with a maximum length of 20 characters.
     */
    @Column(name = "NAME", nullable = false, length = 20)
    private String stateName;
}






//----------------------------------------------------


package com.tcs.fincore.CommonRequestService.repository;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import com.tcs.fincore.CommonRequestService.model.BranchMaster;

@Repository
public interface BranchMasterRepository extends CrudRepository<BranchMaster, String> {

}






package com.tcs.fincore.CommonRequestService.repository;

import com.tcs.fincore.CommonRequestService.model.CalenderConfigModel;

import java.util.Optional;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface CalenderConfigRepository extends CrudRepository<CalenderConfigModel, Long> { 
	
	//find latest entry
	Optional<CalenderConfigModel> findFirstByOrderByIdDesc();
}




package com.tcs.fincore.CommonRequestService.repository;

import com.tcs.fincore.CommonRequestService.model.CGLMaster;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface CGLMasterRepository extends CrudRepository<CGLMaster, String> {
}







package com.tcs.fincore.CommonRequestService.repository;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.tcs.fincore.CommonRequestService.model.CircleMaster;

@Repository
public interface CircleMasterRepository extends JpaRepository<CircleMaster,String>{
	
}








package com.tcs.fincore.CommonRequestService.repository;

import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.RequestStatus;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * Repository interface for managing {@link CommonReq} entities.
 * <p>
 * This interface leverages Spring Data JPA to provide standard and custom data access operations
 * for common request data within the application. The methods defined here allow for retrieving requests
 * based on various criteria such as creator ID, request status, and request type.
 * </p>
 *
 * @author Shubhankar Das [v1018405]
 * @version 1.0
 * @since 2023-01-01
 */
@Repository
public interface CommonRequestRepository extends JpaRepository<CommonReq, Long> {

    /**
     * Finds all requests created by a specific user.
     *
     * @param creatorId The ID of the user.
     * @return A list of requests.
     */
    List<CommonReq> findByCreatorId(String creatorId);

    /**
     * Finds requests not created by a specific user that match a given status and type.
     * <p>
     * This is typically used to find requests pending action by a user other than the creator,
     * such as finding all 'PENDING' requests of a specific 'type' for an 'approver'.
     * The {@link RequestStatusConverter} automatically handles converting the enum
     * to its database character code (e.g., 'P', 'A', 'R').
     * </p>
     *
     * @param creatorId The ID of the user who should NOT be the creator of the requests.
     * @param status    The enum status to search for (e.g., {@link RequestStatus#PENDING}).
     * @param reqType   The type of request to filter by (e.g., {@link RequestType#CGL_CREATION}).
     * @return A list of matching requests.
     */
    List<CommonReq> findByCreatorIdNotAndReqStatusAndReqType(String creatorId, RequestStatus status, RequestType reqType);

    /**
     * Finds requests for a specific creator filtered by the request type.
     *
     * @param creatorId The ID of the user who created the requests.
     * @param reqType   The type of request to filter by.
     * @return A filtered list of matching requests.
     */
    List<CommonReq> findByCreatorIdAndReqType(String creatorId, RequestType reqType);

    /**
     * Finds requests by their {@code targetId} and {@code reqStatus}.
     * <p>
     * This method is generally used to check for existing PENDING or ACCEPTED requests related
     * to a specific business identifier (e.g., CGL Number) to prevent duplicates or conflicts
     * before processing a new request.
     * </p>
     *
     * @param targetId The target ID (e.g., CGL Number) to check for.
     * @param status   The status to match (e.g., {@link RequestStatus#PENDING}).
     * @return A list of matching requests.
     */
    List<CommonReq> findByTargetIdAndReqStatus(String targetId, RequestStatus status);

}








package com.tcs.fincore.CommonRequestService.repository;

import org.springframework.data.repository.CrudRepository;

import com.tcs.fincore.CommonRequestService.model.CurrencyMasterModel;

public interface CurrencyMasterRepository extends CrudRepository<CurrencyMasterModel , String> {
    
}








package com.tcs.fincore.CommonRequestService.repository;

import org.springframework.data.repository.CrudRepository;

import com.tcs.fincore.CommonRequestService.model.CurrencyRateChange;

public interface CurrencyRateChangeRepository extends CrudRepository<CurrencyRateChange , Long> {
    
}









/**
 * 
 */
package com.tcs.fincore.CommonRequestService.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.tcs.fincore.CommonRequestService.model.NotificationTable;

/**
 * 
 */
@Repository
public interface NotificationRepository extends JpaRepository<NotificationTable, String>{
}



package com.tcs.fincore.CommonRequestService.repository;

import com.tcs.fincore.CommonRequestService.model.Permissions;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;


/**
 * Repository interface for managing {@link Permissions} entities.
 * <p>
 * This interface extends {@link JpaRepository} to provide standard CRUD operations
 * and defines custom queries for fetching permission and role-related data
 * from the underlying database, primarily for authorization and caching mechanisms.
 * </p>
 */
@Repository
public interface PermissionRepository extends JpaRepository<Permissions, Integer> {

    /**
     * Fetches both the Target URL and the authorized Role IDs in a single database call.
     * This query retrieves menu URLs and associated active role IDs for 'approve' or 'reject' actions,
     * filtered by a specific request type.
     *
     * @param requestType The mapped request type string (e.g., 'SEGMENT_CODE')
     * @return A list of arrays where index [0] is MENU_URL (String) and index [1] is ROLE_ID (Number)
     */
    @Query(value = """
       SELECT p.MENU_URL, rp.ROLE_ID
       FROM PERMISSIONS p
       JOIN ROLE_PERMISSIONS rp ON p.MENU_ID = rp.PERMISSION_ID
       JOIN ROLES r ON rp.ROLE_ID = r.ROLE_ID
       WHERE p.MAPPED_REQUEST_TYPE = :requestType
         AND (p.MENU_ACTION LIKE '%approve%' OR p.MENU_ACTION LIKE '%reject%')
         AND r.ROLE_STATUS = 'ACTIVE'
   """, nativeQuery = true)
    List<Object[]> findUrlAndRolesByRequestType(@Param("requestType") String requestType);

}








package com.tcs.fincore.CommonRequestService.repository;

import com.tcs.fincore.CommonRequestService.model.SegmentCodeMaster;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface SegmentCodeMasterRepository extends CrudRepository<SegmentCodeMaster, String> {

}







package com.tcs.fincore.CommonRequestService.repository;

import org.springframework.stereotype.Repository;
import com.tcs.fincore.CommonRequestService.model.StateMaster;
import org.springframework.data.repository.CrudRepository;


@Repository
public interface StateMasterRepository extends CrudRepository<StateMaster, String> {
    
}



//-----------------------------------------------------
package com.tcs.fincore.CommonRequestService.service;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.fincore.CommonRequestService.model.enums.ChangeType;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;

/**
 * SECURITY VALIDATOR
 * validate any request (create|modify|block) based on their
 * given action permissions from redis
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class BusinessSecurityService {

    private final StringRedisTemplate redisTemplate;
    private final JwtUtil jwtUtil;

    /**
     * Checks if the user has specific permission for the INTENT (ChangeType).
     * @param token JWT Token
     * @param requestType e.g., CGL_CODE
     * @param changeType e.g., BLOCK
     */
    public void validateUserAction(String token, RequestType requestType, ChangeType changeType) {

        // 1. Get Role from Token
        int roleId = jwtUtil.getUserRoleFromToken(token);

        // 2. Construct Redis Key (Must match UserService logic)
        String opsKey = "RBAC::OPS::" + roleId + "::" + requestType.name();

        // 3. Check Redis: Does the set contain this specific operation?
        Boolean isAllowed = redisTemplate.opsForSet().isMember(opsKey, changeType.name());

        if (Boolean.FALSE.equals(isAllowed)) {
            log.warn("SECURITY ALERT: User (Role {}) tried to perform restricted action {} on {}. Access Denied.",
                    roleId, changeType, requestType);
            throw new AccessDeniedException("You do not have permission to perform '" + changeType + "' actions on this screen.");
        }

        log.debug("Action {} on {} allowed for Role {}", changeType, requestType, roleId);
    }
}











package com.tcs.fincore.CommonRequestService.service;


import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.model.CGLMaster;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.NotificationTable;
import com.tcs.fincore.CommonRequestService.model.enums.ChangeType;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * A service to create and save Notification events to the outbox table.
 * This is designed to be called from within a parent @Transactional method
 * in RequestServiceImpl to ensure atomic operations.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationWriterService {

    private final NotificationRepository notificationRepository;
    private final ObjectMapper objectMapper;

    /**
     * Creates and saves a notification outbox event.
     * This method joins the existing transaction from the calling service.
     *
     * @param userId       The specific user to notify (for 1-to-1). Null if using targetRole.
     * @param targetRole   The role to notify (for 1-to-many). Null if using userId.
     * @param message      The human-readable message.
     * @param linkUrl      The frontend link for the notification.
     * @param aggregateId  The ID of the business object (e.g., the CommonReq ID).
     * @param eventSource  The name of this service.
     */
    @Transactional(propagation = Propagation.MANDATORY) // Ensures this is only called from within an existing transaction
    public void createNotification(String userId, String targetRole, String message, String linkUrl, String aggregateId, String eventSource) {

        if (userId == null && targetRole == null) {
            log.warn("Skipping notification creation: Both userId and targetRole are null. AggregateID: {}", aggregateId);
            // In a real scenario, you might want to throw an exception here
            // if one of them is strictly required, to roll back the parent transaction.
            return;
        }

        if (message == null || message.isBlank()) {
            log.warn("Skipping notification creation: Message is null or blank. AggregateID: {}", aggregateId);
            // Throwing an exception ensures the parent transaction rolls back.
            throw new IllegalArgumentException("Notification message cannot be null or blank.");
        }

        NotificationTable notification = NotificationTable.builder()
                .userId(userId)
                .targetRole(targetRole)
                .message(message)
                .linkUrl(linkUrl)
                .aggregateId(aggregateId)
                .eventSource(eventSource)
                .build();

        // The EVENT_ID (UUID) and EVENT_TIMESTAMP (CreationTimestamp)
        // will be set automatically by the NotificationTable entity.

        notificationRepository.save(notification);

        if (targetRole != null) {
            log.info("Saved 1-to-many notification event for role: {} (AggregateID: {})", targetRole, aggregateId);
        } else {
            log.info("Saved 1-to-1 notification event for user: {} (AggregateID: {})", userId, aggregateId);
        }
    }


    @SneakyThrows
    public void createRequestApprovedNotification(CommonReq request, String approverId) {
        // 1. Custom check for update/block request message
        String action = request.getChangeType().name(); // Default is UPDATE

        // Custom logic to detect "Block" action
        if (request.getReqType() == RequestType.CGL_CODE && request.getChangeType() == ChangeType.UPDATE) {
            // Parse payload to check if status is 0 (Blocked)
            CGLMaster payload = objectMapper.readValue(request.getPayload(), CGLMaster.class);
            if (payload.getStatus() == 0) {
                action = "BLOCK"; // Override action name for the message
            }
        }

        // 2. Prepare the success notification message
        String notificationMessage = "Your " + request.getReqType().name().toLowerCase() +" "+action
                + " request for '" + request.getTargetId() + "' has been approved by " + approverId;

        createNotification(
                request.getCreatorId(),
                null,
                notificationMessage,
                "/my-requests", // Or specific link
                request.getId().toString(),
                "CommonRequestService"
        );
    }

    @SneakyThrows
    public void createRequestRejectedNotification(CommonReq request, String rejectorId, String reason) {
        // 2. Prepare the rejection notification message
        String notificationMessage = "Your " + request.getReqType().name().toLowerCase() +" "+request.getChangeType().name()
                + " request for '" + request.getTargetId() + "' was rejected by " + rejectorId;
        if (reason != null && reason.isBlank()) {
            notificationMessage += " Reason: " + reason;
        }

        createNotification(
                request.getCreatorId(),
                null,
                notificationMessage,
                "/my-requests",
                request.getId().toString(),
                "CommonRequestService"
        );
    }
}













package com.tcs.fincore.CommonRequestService.service;

import com.tcs.fincore.CommonRequestService.dto.NotificationConfigDto;

import com.tcs.fincore.CommonRequestService.repository.PermissionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class PermissionConfigService {

    private final PermissionRepository permissionRepository;

    /**
     * This method is Cached.
     * - First call: Hits DB (approx 10ms).
     * - Subsequent calls: Hits Memory
     * - Key: The RequestType string (e.g., "SEGMENT_CODE").
     */
    @Cacheable(value = "notification_configs", key = "#requestType")
    public NotificationConfigDto getConfig(String requestType) {

        log.info("Cache Miss: Fetching DB permissions for type: {}", requestType);

        // 1. Single DB Call
        List<Object[]> results = permissionRepository.findUrlAndRolesByRequestType(requestType);

        if (results.isEmpty()) {
            // Return default fallback logic if no config found
            log.info("No URL and roles found for request type {}. Using defaults, need to change this in code later", requestType);
            return new NotificationConfigDto("/dashboard", "ALL_USERS");
        }

        log.info("Fetched Url and roles from db for the request type {} : {}", requestType, results.getFirst()[0]);

        // 2. Process logic in Java
        // The URL is the same for all rows (index 0)
        String url = (String) results.get(0)[0];

        if (url == null) url = "/dashboard";
        // Collect all Role IDs (index 1) into a comma-separated string.

        String roles = results.stream()
                .map(row -> String.valueOf(row[1])) // Role ID
                .distinct()
                .collect(Collectors.joining(","));

        if (roles.isEmpty()) roles = "ALL_USERS";

        return new NotificationConfigDto(url, roles);
    }
}








package com.tcs.fincore.CommonRequestService.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.tcs.fincore.CommonRequestService.dto.CancelRequestDto;
import com.tcs.fincore.CommonRequestService.dto.CreateRequestDto;
import com.tcs.fincore.CommonRequestService.dto.ProcessRequestDto;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;

import java.util.List;
import java.util.Optional;

public interface RequestService {

    /**
     * Creates a new request.
     *
     * @param createRequestDto DTO containing request details.
     * @param creatorId        The ID of the user creating the request.
     * @return The saved request entity.
     */
    CommonReq createRequest(CreateRequestDto createRequestDto, String creatorId, String token) throws JsonProcessingException;

    /**
     * Retrieves all requests created by a specific user (Maker).
     *
     * @param userId The user's ID and requestType like : SegmentCode, CGL
     * @return A list of their requests.
     */
    List<CommonReq> getMyRequests(String userId, RequestType requestType);

    /**
     * Retrieves all pending requests for Checkers.
     *
     * @return A list of pending requests.
     */
    List<CommonReq> getPendingRequests(String userId, RequestType requestType);

    /**
     * Retrieves all requests for Checkers (Pending, Accepted, Rejected).
     *
     * @return A list of all requests.
     */
    List<CommonReq> getAllRequests();

    /**
     * Updates the status of a request (Accept/Reject).
     *
     * @param processRequestDto DTO containing the request id, new status and
     *                          executor remarks.
     * @param executorId        The ID of the user performing the action.
     * @return The updated request entity.
     */
    Optional<CommonReq> updateRequestStatus(ProcessRequestDto processRequestDto, String executorId) throws JsonProcessingException;


    CommonReq cancelRequest(CancelRequestDto cancelRequestDto, String userId);
}















package com.tcs.fincore.CommonRequestService.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.dto.*;
import com.tcs.fincore.CommonRequestService.dto.payload.KeyablePayload;
import com.tcs.fincore.CommonRequestService.exception.ResourceNotFoundException;
import com.tcs.fincore.CommonRequestService.model.CGLMaster;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.ChangeType;
import com.tcs.fincore.CommonRequestService.model.enums.RequestStatus;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.CommonRequestRepository;
import com.tcs.fincore.CommonRequestService.service.strategy.RequestStrategyFactory;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * - Handle all requests for different business objects [CGL, SEGMENT, CURRENCY]
 * - Handle creator/executor scenarios
 * - Used strategy design patter to differentiate different business objects
 * - Injected NotificationWriterService and PermissionConfigService for notification
 * - Injected BusinessSecurityService for second level RBAC authentication to check BLOCK/UNBLOCK/CREATE permissions
 *
 *   @author Shubhankar Das [v1018405]
 *   @version 1.0
 *   @since 2025-12-11
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RequestServiceImpl implements RequestService {

    private static final String EVENT_SOURCE = "CommonRequestService";
    private final CommonRequestRepository commonRequestRepository;
    private final RequestStrategyFactory strategyFactory;
    private final ObjectMapper objectMapper;
    private final NotificationWriterService notificationWriterService;
    private final PermissionConfigService permissionConfigService;
    private final BusinessSecurityService businessSecurityService;

    @Override
    @Transactional(rollbackOn = Exception.class) // Ensure rollback on any exception
    public CommonReq createRequest(
            CreateRequestDto dto,
            String creatorId,
            String token
    ) throws JsonProcessingException {

        // --- LAYER 2 SECURITY CHECK ---
        // Validate that the user is allowed to perform this SPECIFIC ChangeType (e.g. BLOCK)
        businessSecurityService.validateUserAction(token, dto.getRequestType(), dto.getChangeType());

        KeyablePayload payload = (KeyablePayload) dto.getPayload();

        // --- PRE CHECKS ---
        String targetId = payload.getKey();
        if (targetId == null || targetId.isBlank()) {
            throw new IllegalArgumentException("Could not determine targetId from payload.");
        }
        log.info("Determined targetId for new request as: {}", targetId);

        List<CommonReq> existingRequests = commonRequestRepository.findByTargetIdAndReqStatus(targetId,
                RequestStatus.PENDING);

        if (!existingRequests.isEmpty()) {
            log.warn("Attempted to create a duplicate request for targetId {} which already has a {} request.",
                    targetId, existingRequests.get(0).getReqStatus());
            throw new DataIntegrityViolationException(
                    "An active or pending request for '" + targetId + "' already exists.");
        }
        log.info("Uniqueness check passed for targetId: {}", targetId);

        // --- CREATE AND SAVE REQUEST ---
        CommonReq request = new CommonReq();
        request.setCreatorId(creatorId);
        request.setReqType(dto.getRequestType());
        request.setChangeType(dto.getChangeType());
        request.setPayload(objectMapper.writeValueAsString(payload));
        request.setTargetId(targetId);
        request.setReqStatus(RequestStatus.PENDING);

        log.info("Saving new, validated request for targetId {}", targetId);
        CommonReq savedRequest = commonRequestRepository.save(request);

        try {
            // --- NOTIFICATION LOGIC ---

            // 1. Fetch Config from CACHE (Fast)
            String requestTypeKey = dto.getRequestType().name(); // e.g., "SEGMENT_CODE"
            log.info("Request Type String to fetch role ids from PERMISSIONS: {}", requestTypeKey);
            NotificationConfigDto config = permissionConfigService.getConfig(requestTypeKey);

            // 2. Customize Message
            String action = request.getChangeType().name(); // ADD/ DELETE/ UPDATE / BLOCK

            // Validate payload to detect "Block", "UNBLOCK action
            if (request.getChangeType() == ChangeType.BLOCK || request.getChangeType() == ChangeType.UNBLOCK) {
                // Parse payload to check if status is 0 (Blocked)
                CGLMaster payload2 = objectMapper.readValue(request.getPayload(), CGLMaster.class);
                if (payload2.getStatus() == 0) {
                    action = "BLOCK"; // Override action name for the message
                } else if (payload2.getStatus() == 1) {
                    action = "UNBLOCK"; // Override action name for the message
                }
            }
            String message = "New " + action + " request (" + targetId + ") pending for " + dto.getRequestType();

            // 3. Send to Group (1-to-Many via Outbox)
            notificationWriterService.createNotification(
                    creatorId,                  // USER ID TO EXCLUDE FROM ROLES, IN THIS CASE ROLE WILL BE USED TO TARGET USER
                    config.getTargetRoles(),    // Group to SEND TO "51,55" (Fetched from Cache/DB)
                    message,
                    config.getTargetUrl(),      // "/segment-requests" (Fetched from Cache/DB)
                    savedRequest.getId().toString(),
                    EVENT_SOURCE
            );

        } catch (Exception e) {
            // Log the error and re-throw as a RuntimeException to force a rollback.
            log.error("CRITICAL: Failed to create 'pending' notification for request: {}. Rolling back transaction.", savedRequest.getId(), e);
            throw new RuntimeException("Failed to create notification event, rolling back request creation.", e);
        }
        return savedRequest;
    }

    @Override
    @Transactional(rollbackOn = Exception.class) // Ensure rollback on any exception
    public Optional<CommonReq> updateRequestStatus(
            ProcessRequestDto dto,
            String executorId
    ) throws JsonProcessingException {

        Long requestId = dto.getRequestId();
        log.info("Attempting to update status for request ID: {} by executor: {}", requestId, executorId);

        CommonReq request = commonRequestRepository.findById(requestId)
                .orElseThrow(() -> new ResourceNotFoundException("Request with ID " + requestId + " not found."));

        // SELF-APPROVAL CHECK
        if (executorId.equals(request.getCreatorId())) {
            log.warn("SECURITY VIOLATION: User {} attempted to approve their own request (ID: {}).", executorId,
                    requestId);
            throw new IllegalStateException("User cannot approve or reject their own request.");
        }

        if (request.getReqStatus() != RequestStatus.PENDING) {
            log.warn("Attempted to modify an already processed request. ID: {}, Current Status: {}", dto.getRequestId(),
                    request.getReqStatus());
            throw new IllegalStateException("Request has already been processed and cannot be modified.");
        }

        // --- UPDATE REQUEST STATE ---
        request.setExecutorId(executorId);
        request.setExecutorRemarks(dto.getRemarks());
        request.setExecutionDate(LocalDateTime.now());
        request.setReqStatus(dto.getStatus());

        // --- PROCESS BUSINESS LOGIC (STRATEGY) & PREPARE NOTIFICATION 1: TO MAKER (1-to-1) ---
        // This is a 1-to-1, so USER_ID is the recipient, TARGET_ROLE is null.
        if (RequestStatus.ACCEPTED.equals(dto.getStatus())) {
            log.info("Request {} ACCEPTED. Applying strategy for type {}", dto.getRequestId(), request.getReqType());
            // 1. Execute the business logic (e.g., save to master table)
            strategyFactory.getStrategy(request.getReqType()).processApproval(request);

            // Notify Maker: Approved
            notificationWriterService.createRequestApprovedNotification(request, executorId);
            request.setExecutionRemarks("Successfully processed approval.");

        } else {
            log.info("Request {} REJECTED.", dto.getRequestId());

            // Notify Maker: Rejected
            notificationWriterService.createRequestRejectedNotification(request, executorId, dto.getRemarks());
            request.setExecutionRemarks("Request rejected by user.");
        }

        // --- NOTIFICATION 2: CLOSURE (1-to-Many, Filtered) ---
        // We wrap this in Try/Catch because if this fails, we do NOT want to roll back the actual Approval.
        // The approval is critical data; the "FYI" notification to the group is secondary.
        try {
            // A. Get Group Config from Cache (Zero DB Cost)
            NotificationConfigDto config = permissionConfigService.getConfig(request.getReqType().name());

            // B. Prepare Message
            String action = dto.getStatus().equals(RequestStatus.ACCEPTED) ? "Approved" : "Rejected";
            String closureMessage = "CLOSURE: Request " + request.getTargetId() + " was " + action + " by " + executorId;

            // C. Send to Group (1-to-Many)
            // Pass the CHECKER'S ID as the exclusion ID.
            notificationWriterService.createNotification(
                    executorId,                 // User to EXCLUDE
                    config.getTargetRoles(),    // // Group to SEND TO -> The same roles that received the Pending alert excluding the executor
                    closureMessage,
                    config.getTargetUrl(),      // Link to history
                    request.getId().toString(),
                    "CommonRequestService"
            );
            log.info("Sent closure notification to group for Request ID: {}", requestId);

        } catch (Exception e) {
            // Log error but allow transaction to commit
            log.error("Failed to send closure notification for Request ID: {}", requestId, e);
        }

        // --- SAVE THE UPDATED REQUEST ---
        CommonReq updatedRequest = commonRequestRepository.save(request);

        return Optional.of(updatedRequest);
    }

    @Override
    @Transactional(rollbackOn = Exception.class)
    public CommonReq cancelRequest(CancelRequestDto dto, String userId) {

        Long requestId = dto.getRequestId();
        log.info("Attempting to cancel request ID: {} by user: {}", requestId, userId);

        // 1. Fetch Request
        CommonReq request = commonRequestRepository.findById(requestId)
                .orElseThrow(() -> new ResourceNotFoundException("Request with ID " + requestId + " not found."));

        // 2. Security Check: Only the CREATOR can cancel
        if (!request.getCreatorId().equals(userId)) {
            log.warn("SECURITY VIOLATION: User {} attempted to cancel request {} owned by {}",
                    userId, requestId, request.getCreatorId());
            throw new AccessDeniedException("You are not authorized to cancel this request.");
        }

        // 3. State Check: Must be PENDING
        if (request.getReqStatus() != RequestStatus.PENDING) {
            log.warn("Attempted to cancel a processed request. ID: {}, Status: {}", requestId, request.getReqStatus());
            throw new IllegalStateException("Only pending requests can be cancelled. Current status: " + request.getReqStatus());
        }

        // 4. Update State
        request.setReqStatus(RequestStatus.CANCELLED);

        // We use Executor fields to track who cancelled it (the creator themselves)
        request.setExecutorId(userId);
        request.setExecutionDate(LocalDateTime.now());
        request.setExecutorRemarks("CANCELLED BY USER: " + (dto.getRemarks() != null ? dto.getRemarks() : "No remarks"));

        // 5. Save & Return
        CommonReq updatedRequest = commonRequestRepository.save(request);
        log.info("Request {} successfully cancelled by user.", requestId);

        return updatedRequest;
    }

    @Override
    public List<CommonReq> getMyRequests(
            String userId,
            RequestType requestType
    ) {
        if (requestType == null) {
            log.info("Request type is missing, Please provide correct request type to fetch requests for user : {}",
                    userId);
            throw new IllegalArgumentException(
                    "Request type is missing, Please provide correct request type to fetch requests.");
        }
        log.info("Fetching my requests for user {} with type {}", userId, requestType);
        return commonRequestRepository.findByCreatorIdAndReqType(userId, requestType);
    }

    @Override
    public List<CommonReq> getPendingRequests(
            String userId,
            RequestType requestType
    ) {
        if (requestType == null) {
            log.info("Request type is missing, Please provide correct request type to fetch pending requests.");
            throw new IllegalArgumentException(
                    "Request type is missing, Please provide correct request type to fetch pending requests."
            );
        }
        log.info("Fetching pending requests for user :  {} with type : {}",userId, requestType);
        return commonRequestRepository
                .findByCreatorIdNotAndReqStatusAndReqType(userId, RequestStatus.PENDING, requestType);
    }


    @Override
    public List<CommonReq> getAllRequests(
    ) {
        return commonRequestRepository.findAll();
    }

}
















------------------

package com.tcs.fincore.CommonRequestService.service.strategy;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Component;
import com.tcs.fincore.CommonRequestService.exception.ResourceNotFoundException;
import com.tcs.fincore.CommonRequestService.model.CGLMaster;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.CGLMasterRepository;

import java.time.LocalDate;

@Component
@RequiredArgsConstructor
@Slf4j
public class CglCodeStrategy implements RequestTypeStrategy {

    private final CGLMasterRepository cglMasterRepository;
    private final ObjectMapper objectMapper;
    private static final Integer STATUS_BLOCKED = 0;

    @Override
    public RequestType getRequestType() {
        return RequestType.CGL_CODE;
    }

    @Override
    public void processApproval(CommonReq request) throws JsonProcessingException {
        switch (request.getChangeType()) {
            case ADD:
                handleAdd(request);
                break;
            case UPDATE:
                handleUpdate(request);
                break;
            case BLOCK:
                handleStatusChange(request, 0); // 0 = Inactive/Blocked
                break;
            case UNBLOCK:
                handleStatusChange(request, 1); // 1 = Active
                break;
            default:
                throw new UnsupportedOperationException(
                        "Change type " + request.getChangeType() + " is not supported.");
        }
    }

    private void handleAdd(CommonReq request) throws JsonProcessingException {
        CGLMaster newCgl = objectMapper.readValue(request.getPayload(), CGLMaster.class);

        // Although the DB computes the final CGL_NUMBER, we also construct it here for
        // uniqueness
        String potentialCglNumber = newCgl.getComp1() + newCgl.getSegmentCode() + newCgl.getComp2();
        log.info("Performing uniqueness check for potential CGL Number: {}", potentialCglNumber);

        if (cglMasterRepository.existsById(potentialCglNumber)) {
            log.error("Attempted to add a CGL that already exists: {}", potentialCglNumber);
            throw new DataIntegrityViolationException("CGL Code '" + potentialCglNumber + "' already exists.");
        }

        CGLMaster savedCgl = cglMasterRepository.save(newCgl);
        log.info("Successfully added new CGL with ID: {}", savedCgl.getCglNumber());
    }

    private void handleUpdate(CommonReq request) throws JsonProcessingException {
        String targetId = request.getTargetId();
        if (targetId == null || targetId.isBlank()) {
            throw new IllegalArgumentException("Target ID is required for an UPDATE operation.");
        }

        log.info("Fetching existing CGL with ID: {} for update.", targetId);
        CGLMaster existingCgl = cglMasterRepository.findById(targetId)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "CGL Code with ID '" + targetId + "' not found for update."));

        // Deserialize the payload containing the changes
        CGLMaster updates = objectMapper.readValue(request.getPayload(), CGLMaster.class);

        if (updates.getStatus().equals(STATUS_BLOCKED)) {

            // CASE 1: BLOCKING ACTION
            // We ONLY update the status. We intentionally IGNORE description/flags
            // to prevent "Edit + Block" ambiguity.
            log.info("Operation identified as BLOCK for CGL {}. Ignoring other field updates.", targetId);
            existingCgl.setStatus(updates.getStatus());
            existingCgl.setCloseDate(LocalDate.now());
        } else {
            // CASE 2: NORMAL UPDATE
            // Apply the updates to the existing entity all fields
            // We only update fields that are allowed to change.
            existingCgl.setDescription(updates.getDescription());
            existingCgl.setAcClassification(updates.getAcClassification());
            existingCgl.setBalFwd(updates.getBalFwd());
            existingCgl.setDefBalType(updates.getDefBalType());
            existingCgl.setStatus(updates.getStatus());
            existingCgl.setBalCompare(updates.getBalCompare());
            existingCgl.setManualPosting(updates.getManualPosting());
            // We do not update comp1, comp2, segmentCode as they form the primary key.

        }
        cglMasterRepository.save(existingCgl);
        log.info("Successfully processed CGL update/block with ID: {}", targetId);
    }

    /**
     * Logic to Block or Unblock a CGL
     */
    private void handleStatusChange(CommonReq request, Integer newStatus) {
        String targetId = request.getTargetId();
        log.info("Processing Status Change ({}) for CGL ID: {}", newStatus, targetId);

        CGLMaster existingCgl = cglMasterRepository.findById(targetId)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "CGL Code with ID '" + targetId + "' not found for status update."));

        // Update the status
        existingCgl.setStatus(newStatus);

        cglMasterRepository.save(existingCgl);
        log.info("Successfully updated CGL Status to {} for ID: {}", newStatus, targetId);
    }
}












package com.tcs.fincore.CommonRequestService.service.strategy;


import org.springframework.stereotype.Component;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.exception.ResourceNotFoundException;
import com.tcs.fincore.CommonRequestService.model.CircleMaster;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.CircleMasterRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;


@Component
@RequiredArgsConstructor
@Slf4j
public class CircleMasterStrategy  implements RequestTypeStrategy {

	private final ObjectMapper objectMapper;
	private final CircleMasterRepository circleMasterRepository;
	

	@Override
	public RequestType getRequestType() {
		return RequestType.CIRCLE;
	}
	
	
		
	@Override
	public void processApproval(CommonReq request) throws JsonProcessingException {
	        switch (request.getChangeType()) {
	            case ADD:
	                handleAdd(request);
	                break;
	            case UPDATE:
	                handleUpdate(request);
	                break;
	            case DELETE:
	                handleDelete(request);
	                break;
	            default:
	                throw new UnsupportedOperationException(
	                        "Change type " + request.getChangeType() + " is not supported.");

	        }
	    }
	

	    private void handleAdd(CommonReq request) throws JsonProcessingException {
	    	CircleMaster circleMaster = objectMapper.readValue(request.getPayload(), CircleMaster.class);
	        CircleMaster saveCircleMaster = circleMasterRepository.save(circleMaster);
	        log.info("Successfully added new Circle ");
	    }

	    
	    private void handleUpdate(CommonReq request) throws JsonProcessingException {

	        String targetId = request.getTargetId();

	        if (targetId == null || targetId.isBlank()) {
	            throw new IllegalArgumentException("Target ID is required for an UPDATE operation.");
	        }


	        log.info("Fetching existing Circle with ID: {} for update.", targetId);

	        CircleMaster existingCircleMatser = circleMasterRepository.findById(targetId)
	                .orElseThrow(() -> new ResourceNotFoundException(
	                        "Circle Code with ID '" + targetId + "' not found for update."));

	        CircleMaster updates = objectMapper.readValue(request.getPayload(), CircleMaster.class);

	        existingCircleMatser.setCircleName(updates.getCircleName());
	        existingCircleMatser.setZoneCode(updates.getZoneCode());
	        

	        circleMasterRepository.save(existingCircleMatser);
	        log.info("Successfully Updated Circle with ID ", targetId);


	    }
	    
	    
	    private void handleDelete(CommonReq request) throws JsonProcessingException{
	          String targetId = request.getTargetId();
	        if (targetId == null || targetId.isBlank()) {
	            throw new IllegalArgumentException("Target ID is required for an DELETE operation.");
	        }
	        CircleMaster existingCircle = circleMasterRepository.findById(targetId)
	                .orElseThrow(() -> new ResourceNotFoundException(
	                        "State with code: '" + targetId + "' not found for delete."));
	        
	        circleMasterRepository.deleteById(targetId);
	         log.info("Successfully Deleted Circle with ID ", targetId);

	    }

	}





package com.tcs.fincore.CommonRequestService.service.strategy;

import org.springframework.stereotype.Component;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.exception.ResourceNotFoundException;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.CurrencyMasterModel;
import com.tcs.fincore.CommonRequestService.model.StateMaster;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.CurrencyMasterRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Component
@RequiredArgsConstructor
@Slf4j
public class CurrencyMasterStrategy implements RequestTypeStrategy {

    private final CurrencyMasterRepository currencyMasterRepository;
    private final ObjectMapper objectMapper;

    @Override
    public RequestType getRequestType() {
        return RequestType.CURRENCY;
    }

    @Override
    public void processApproval(CommonReq request) throws JsonProcessingException {
        switch (request.getChangeType()) {
            case ADD:
                handleAdd(request);
                break;
            case UPDATE:
                handleUpdate(request);
                break;
            case DELETE:
                handleDelete(request);
                break;
            default:
                throw new UnsupportedOperationException(
                        "Change type " + request.getChangeType() + " is not supported.");

        }
    }

    private void handleAdd(CommonReq request) throws JsonProcessingException {
        CurrencyMasterModel newCurrency = objectMapper.readValue(request.getPayload(), CurrencyMasterModel.class);
        CurrencyMasterModel saveCurrency = currencyMasterRepository.save(newCurrency);
        log.info("Successfully added new Currency ");

    }

    private void handleUpdate(CommonReq request) throws JsonProcessingException {

        String targetId = request.getTargetId();

        if (targetId == null || targetId.isBlank()) {
            throw new IllegalArgumentException("Target ID is required for an UPDATE operation.");

        }

        // Long CurrencyId = Long.valueOf(targetId);

        log.info("Fetching existing Currency with ID: {} for update.", targetId);

        CurrencyMasterModel existingCurrency = currencyMasterRepository.findById(targetId)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "Currency Code with ID '" + targetId + "' not found for update."));

        CurrencyMasterModel updates = objectMapper.readValue(request.getPayload(), CurrencyMasterModel.class);

        existingCurrency.setCurrencyName(updates.getCurrencyName());
        existingCurrency.setCreatedAt(updates.getCreatedAt());
        existingCurrency.setCurrencyCode(updates.getCurrencyCode());
        existingCurrency.setCurrencyRate(updates.getCurrencyRate());
        existingCurrency.setFlag(updates.getFlag());
        existingCurrency.setRateDate(updates.getRateDate());
        existingCurrency.setUpdatedAt(updates.getUpdatedAt());

        currencyMasterRepository.save(existingCurrency);
        log.info("Successfully Updated Currency with ID ", targetId);


    }

    
    private void handleDelete(CommonReq request) throws JsonProcessingException{
          String targetId = request.getTargetId();
        if (targetId == null || targetId.isBlank()) {
            throw new IllegalArgumentException("Target ID is required for an DELETE operation.");
        }
        CurrencyMasterModel existingState = currencyMasterRepository.findById(targetId)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "State with code: '" + targetId + "' not found for delete."));
        
        currencyMasterRepository.deleteById(targetId);
         log.info("Successfully Deleted Currency with ID ", targetId);

    }

}









package com.tcs.fincore.CommonRequestService.service.strategy;

import org.springframework.stereotype.Component;

import com.tcs.fincore.CommonRequestService.model.enums.RequestType;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class RequestStrategyFactory {

	private final SegmentCodeStrategy segmentCodeStrategy;
	private final CglCodeStrategy cglCodeStrategy;
	private final BranchMasterStrategy branchCodeStrategy;
	private final StateReqStrategy stateReqStrategy;
	private final CurrencyMasterStrategy currencyMasterStrategy;
    private final CalenderConfigStrategy calenderConfigStrategy;
    private final CircleMasterStrategy circleMasterStrategy;
    private final CurrencyRateChangeStrategy CURRENCY_RATE_CHANGE;

	public RequestTypeStrategy getStrategy(RequestType requestType) {
		switch (requestType) {
        case CALENDER:
            return calenderConfigStrategy;
		case SEGMENT_CODE:
			return segmentCodeStrategy;
		case CGL_CODE:
			return cglCodeStrategy;
		case BRANCH:
			return branchCodeStrategy;
		case STATE:
			return stateReqStrategy;
		case CURRENCY:
			return currencyMasterStrategy;
		case CIRCLE:
			return circleMasterStrategy;
	    case CURRENCY_RATE_CHANGE:
				return CURRENCY_RATE_CHANGE;

		default:
			throw new IllegalArgumentException("Unsupported request type: " + requestType);
		}
	}
}




















package com.tcs.fincore.CommonRequestService.service.strategy;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;

/**
 * Strategy interface to handle the processing of different request types.
 */
public interface RequestTypeStrategy {
    /**
     * Processes the request upon approval. This typically involves saving the
     * payload data to the relevant master table.
     *
     * @param request The common request object containing the payload.
     * @throws JsonProcessingException if there is an error processing the JSON payload.
     */
    void processApproval(CommonReq request) throws JsonProcessingException;


    RequestType getRequestType();
}

















package com.tcs.fincore.CommonRequestService.service.strategy;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.exception.ResourceNotFoundException;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.SegmentCodeMaster;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.SegmentCodeMasterRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
public class SegmentCodeStrategy implements RequestTypeStrategy {

    private final SegmentCodeMasterRepository segmentCodeMasterRepository;
    private final ObjectMapper objectMapper;

    @Override
    public RequestType getRequestType() {
        return RequestType.SEGMENT_CODE;
    }

    @Override
    public void processApproval(CommonReq request) throws JsonProcessingException {
        // ---- LOGIC TO HANDLE ADD vs UPDATE -----
        switch (request.getChangeType()) {
            case ADD:
                handleAdd(request);
                break;
            case UPDATE:
                handleUpdate(request);
                break;
            default:
                throw new UnsupportedOperationException(
                        "Change type " + request.getChangeType() + " is not supported for Segment Codes.");
        }

    }

    private void handleAdd(CommonReq request) throws JsonProcessingException {
        SegmentCodeMaster segmentData = objectMapper.readValue(request.getPayload(), SegmentCodeMaster.class);

        String segmentCode = segmentData.getSegmentCode();
        log.info("Performing uniqueness check for Segment Code : {}", segmentCode);

        if (segmentCodeMasterRepository.existsById(segmentCode)) {
            log.error("Attempting to add a Segment Code that already exists: {}", segmentCode);
            throw new DataIntegrityViolationException("'Segment Code '" + segmentCode + "' already exists");
        }

        SegmentCodeMaster savedSegment = segmentCodeMasterRepository.save(segmentData);
        log.info("Succesfully added new Segment Code: {}", savedSegment.getSegmentCode());
    }

    private void handleUpdate(CommonReq request) throws JsonProcessingException {
        String targetId = request.getTargetId();
        if (targetId == null || targetId.isBlank()) {
            throw new IllegalArgumentException("Target ID is required for an UPDATE operation.");
        }

        log.info("Fetching existing Segment Code with ID: {} for update.", targetId);
        SegmentCodeMaster existingSegment = segmentCodeMasterRepository.findById(targetId)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "Segment Code with ID '" + targetId + "' not found for update."));

        SegmentCodeMaster updates = objectMapper.readValue(request.getPayload(), SegmentCodeMaster.class);

        // For Segment Code, only the description can be updated.
        existingSegment.setDescription(updates.getDescription());

        segmentCodeMasterRepository.save(existingSegment);
        log.info("Successfully updated Segment Code with ID: {}", targetId);
    }
}















package com.tcs.fincore.CommonRequestService.service.strategy;

import com.tcs.fincore.CommonRequestService.model.CGLMaster;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.exception.ResourceNotFoundException;
import com.tcs.fincore.CommonRequestService.model.BranchMaster;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.BranchMasterRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * A strategy component responsible for processing approval requests related to the
 * {@link BranchMaster} entity. This class implements the {@link RequestTypeStrategy}
 * interface and handles operations (ADD and UPDATE) for branch master data based on
 * the type of change requested in a {@link CommonReq}.
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class BranchMasterStrategy implements RequestTypeStrategy {

    private final BranchMasterRepository branchMasterRepository;
    private final ObjectMapper objectMapper;

    /**
     * Returns the request type handled by this strategy.
     *
     * @return The {@link RequestType} enum constant for BRANCH requests.
     */
    @Override
    public RequestType getRequestType() {
        return RequestType.BRANCH;
    }

    /**
     * Processes the approval of a {@link CommonReq} for branch master data.
     * It delegates to specific handlers for ADD or UPDATE operations based on the
     * {@code changeType} field in the request.
     *
     * @param request The common request object containing the payload and change type.
     * @throws JsonProcessingException if the JSON payload cannot be deserialized into a {@link BranchMaster}.
     * @throws UnsupportedOperationException if the {@code changeType} is not supported.
     */
    @Override
    public void processApproval(CommonReq request) throws JsonProcessingException {
        switch (request.getChangeType()) {
            case ADD:
                handleAdd(request);
                break;
            case UPDATE:
                handleUpdate(request);
                break;
            case BLOCK:
                handleStatusChange(request, Boolean.FALSE); // Inactive/Blocked
                break;
            case UNBLOCK:
                handleStatusChange(request, Boolean.TRUE); // Active
                break;
            default:
                throw new UnsupportedOperationException(
                        "Change type " + request.getChangeType() + " is not supported.");
        }
    }


    /**
     * Handles the ADD operation for a new branch master record.
     * It performs a uniqueness check on the branch code before saving the new record.
     *
     * @param request The common request object containing the new branch details in the payload.
     * @throws JsonProcessingException if the payload cannot be mapped to {@link BranchMaster}.
     * @throws DataIntegrityViolationException if a branch with the same code already exists.
     */
    private void handleAdd(CommonReq request) throws JsonProcessingException {
        BranchMaster payload = objectMapper.readValue(request.getPayload(), BranchMaster.class);

        String code = payload.getCode();
        log.info("Performing uniqueness check for Branch Code : {}", code);

        if (branchMasterRepository.existsById(code)) {
            log.error("Attempting to add a Branch Code that already exists: {}", code);
            throw new DataIntegrityViolationException("'Branch Code '" + code + "' already exists");
        }

        BranchMaster saved = branchMasterRepository.save(payload);
        log.info("Successfully added new Branch with code: {}", saved.getCode());
    }

    /**
     * Handles the UPDATE operation for an existing branch master record.
     * It fetches the existing entity, applies updates from the payload to specific fields,
     * and saves the modified entity.
     *
     * @param request The common request object containing the target ID and updated details in the payload.
     * @throws IllegalArgumentException if the target ID is null or blank.
     * @throws ResourceNotFoundException if the branch with the specified ID is not found.
     * @throws JsonProcessingException if the payload cannot be mapped to {@link BranchMaster}.
     */
    private void handleUpdate(CommonReq request) throws JsonProcessingException {
        String targetId = request.getTargetId();
        if (targetId == null || targetId.isBlank()) {
            throw new IllegalArgumentException("Target ID is required for an UPDATE operation.");
        }

        log.info("Fetching existing Branch with ID: {} for update.", targetId);
        BranchMaster existing = branchMasterRepository.findById(targetId).orElseThrow(
                () -> new ResourceNotFoundException("Branch Code with ID '" + targetId + "' not found for update."));

        BranchMaster updated = objectMapper.readValue(request.getPayload(), BranchMaster.class);

        // Set all fields which can be updated
        existing.setName(updated.getName());
        existing.setCircleCode(updated.getCircleCode());
        existing.setState(updated.getState());
        existing.setCity(updated.getCity());
        existing.setAddress(updated.getAddress());
        existing.setPinCode(updated.getPinCode());
        existing.setPhoneNumber(updated.getPhoneNumber());
        existing.setEmailId(updated.getEmailId());
        existing.setNmrCode(updated.getNmrCode());
        existing.setStatus(updated.getStatus());
        existing.setCloseDate(updated.getCloseDate());
        existing.setMergeDate(updated.getMergeDate());
        existing.setMergedWithBranch(updated.getMergedWithBranch());
        existing.setLastChangeDate(updated.getLastChangeDate());
        existing.setCpcFlag(updated.getCpcFlag());
        existing.setFoodCreditFlag(updated.getFoodCreditFlag());
        existing.setCurrChestFlag(updated.getCurrChestFlag());
        existing.setBranchType(updated.getBranchType());

        branchMasterRepository.save(existing);
        log.info("Successfully updated Branch with Code: {}", targetId);
    }

    /**
     * Logic to Block or Unblock a CGL
     */
    private void handleStatusChange(CommonReq request, Boolean newStatus) {
        String targetId = request.getTargetId();
        log.info("Processing Status Change ({}) for CGL ID: {}", newStatus, targetId);

        BranchMaster existing = branchMasterRepository.findById(targetId).orElseThrow(
                () -> new ResourceNotFoundException("Branch Code with ID '" + targetId + "' not found for update."));

        // Update the status
        existing.setStatus(newStatus );

        branchMasterRepository.save(existing);
        log.info("Successfully updated Branch Status to {} for ID: {}", newStatus, targetId);
    }
}













package com.tcs.fincore.CommonRequestService.service.strategy;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.exception.ResourceNotFoundException;
import com.tcs.fincore.CommonRequestService.model.CalenderConfigModel;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.SegmentCodeMaster;
import com.tcs.fincore.CommonRequestService.model.enums.ChangeType;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.CalenderConfigRepository;
//import com.tcs.fincore.CommonRequestService.repository.calenderConfigRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Component;


@Slf4j
@Component
@RequiredArgsConstructor
public class CalenderConfigStrategy implements RequestTypeStrategy {

    private final CalenderConfigRepository calenderConfigRepository;
    private final ObjectMapper objectMapper;

    @Override
    public RequestType getRequestType() {
        return RequestType.CALENDER;
    }

    @Override
    public void processApproval(CommonReq request) throws JsonProcessingException {
        switch (request.getChangeType()) {
//            case ADD:
//                handleAdd(request);
//                break;
            case UPDATE:
                handleUpdate(request);
                break;
            default:
                throw new UnsupportedOperationException(
                        "Change type " + request.getChangeType() + " is not supported.");
        }
    }


//    private void handleAdd(CommonReq request) throws JsonProcessingException {
//        CalenderConfigModel calenderConfigModel = objectMapper.readValue(request.getPayload(), CalenderConfigModel.class);
//        calenderConfigModel.setApprovedBy(request.getExecutorId());
//        calenderConfigModel.setApprovedAt(request.getExecutionDate());
//        calenderConfigModel.setRequestedBy(request.getCreatorId());
//        calenderConfigModel.setRequestedAt(request.getReqDate());
//        
//        log.info(calenderConfigModel.getRemarks());
//        CalenderConfigModel savedCalenderConfig = calenderConfigRepository.save(calenderConfigModel);
//        log.info("Succesfully added new calender config: {}", savedCalenderConfig.getYearStartDate() + " " + savedCalenderConfig.getYearEndDate());
//    }

    private void handleUpdate(CommonReq request) throws JsonProcessingException {
        String targetId = request.getTargetId();
        if (targetId == null || targetId.isBlank()) {
            throw new IllegalArgumentException("Target ID is required for an UPDATE operation.");
        }

        log.info("{}","Fetching existing entry");
        CalenderConfigModel existingCalenderConfig = calenderConfigRepository.findFirstByOrderByIdDesc()
                .orElseThrow(() -> new ResourceNotFoundException(
                        "Entry Not Found"));

        CalenderConfigModel updates = objectMapper.readValue(request.getPayload(), CalenderConfigModel.class);


        existingCalenderConfig.setYearStartDate(updates.getYearStartDate());
        existingCalenderConfig.setYearEndDate(updates.getYearEndDate());
        existingCalenderConfig.setRemarks(updates.getRemarks());
        existingCalenderConfig.setApprovedBy(request.getExecutorId());
        existingCalenderConfig.setApprovedAt(request.getExecutionDate());
        existingCalenderConfig.setRequestedBy(request.getCreatorId());
        existingCalenderConfig.setRequestedAt(request.getReqDate());

        calenderConfigRepository.save(existingCalenderConfig);
        log.info("{}","Successfully updated Calender Configuration");
    }


}











package com.tcs.fincore.CommonRequestService.service.strategy;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.fincore.CommonRequestService.exception.ResourceNotFoundException;
import com.tcs.fincore.CommonRequestService.model.CommonReq;
import com.tcs.fincore.CommonRequestService.model.StateMaster;
import com.tcs.fincore.CommonRequestService.model.enums.RequestType;
import com.tcs.fincore.CommonRequestService.repository.StateMasterRepository;

@Slf4j
@Component
@RequiredArgsConstructor
public class StateReqStrategy implements RequestTypeStrategy{

    private final StateMasterRepository stateMasterRepository;
    private final ObjectMapper objectMapper;


    @Override
    public void processApproval(CommonReq request) throws JsonProcessingException {
       switch (request.getChangeType()) {
            case ADD:
                handleAdd(request);
                break;
            case UPDATE:
                handleUpdate(request);
                break;
            case DELETE:
                handleDelete(request);
                break;
            default:
                throw new UnsupportedOperationException(
                        "Change type " + request.getChangeType() + " is not supported for State Codes.");
        }
    }

    @Override
    public RequestType getRequestType() {
       return RequestType.STATE;
    }

    private void handleAdd(CommonReq request) throws JsonProcessingException{
     log.info("inside ADD");
      StateMaster stateData = objectMapper.readValue(request.getPayload(),StateMaster.class);
      String stateCode =stateData.getStateCode();
      log.info("{}",stateCode);
       if (stateMasterRepository.existsById(stateCode)) {
            log.error("Attempting to add a State Code that already exists: {}", stateCode);
            throw new DataIntegrityViolationException("'State code '" + stateCode + "' already exists");
        }

        StateMaster savedData = stateMasterRepository.save(stateData);
        log.info("Succesfully added State: {} , Code: {} ", savedData.getStateName(), savedData.getStateCode());
    }

    private void handleUpdate(CommonReq request) throws JsonProcessingException{
       String targetId = request.getTargetId();
        if (targetId == null || targetId.isBlank()) {
            throw new IllegalArgumentException("Target ID is required for an UPDATE operation.");
        }

        log.info("Fetching existing State Code with ID: {} for update.", targetId);
        StateMaster existingState = stateMasterRepository.findById(targetId)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "State with code: '" + targetId + "' not found for update."));

        StateMaster updates = objectMapper.readValue(request.getPayload(), StateMaster.class);

        // For Segment Code, only the description can be updated.
        existingState.setStateName(updates.getStateName());
        stateMasterRepository.save(existingState);
        // log.info("Successfully updated State Code with ID: {}", targetId);


    }

    private void handleDelete(CommonReq request) throws JsonProcessingException{
          String targetId = request.getTargetId();
        if (targetId == null || targetId.isBlank()) {
            throw new IllegalArgumentException("Target ID is required for an DELETE operation.");
        }
        StateMaster existingState = stateMasterRepository.findById(targetId)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "State with code: '" + targetId + "' not found for delete."));
        
        stateMasterRepository.deleteById(targetId);
        log.info("Successfully Deleted State with Code ", targetId);
    }

    
}



















//-------------------------

package com.tcs.fincore.CommonRequestService.validation;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Documented
@Constraint(validatedBy = ValidDateRangeValidator.class)
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface ValidDateRange {
    String message() default "Invalid date range";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}






package com.tcs.fincore.CommonRequestService.validation;

import com.tcs.fincore.CommonRequestService.dto.CalenderConfigPayloadDto;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import java.time.LocalDate;

public class ValidDateRangeValidator implements ConstraintValidator<ValidDateRange, CalenderConfigPayloadDto> {

    @Override
    public boolean isValid(CalenderConfigPayloadDto dto, ConstraintValidatorContext context) {
        if (dto == null) {
            return true;
        }

        final LocalDate yearStartDate = dto.getYearStartDate();
        final LocalDate yearEndDate = dto.getYearEndDate();

        // The @NotNull annotations already handle null checks
        if (yearStartDate == null || yearEndDate == null) {
            return true;
        }

        return yearEndDate.isAfter(yearStartDate);
    }
}

//------------------------





package com.tcs.fincore.CommonRequestService;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CommonRequestServiceApplication {
	public static void main(String[] args) {
		System.setProperty("spring.classformat.ignore", "true");
		SpringApplication.run(CommonRequestServiceApplication.class, args);
	}

}






//-------------------------------------------



spring.application.name=CommonRequestService
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.profiles.active=dev
server.port=9000

#todo Expose all actuator endpoints over HTTP.
management.endpoints.web.exposure.include=*

# Always show full details on the health endpoint (e.g., database connection status)
management.endpoint.health.show-details=always

# Add some custom info to the /info endpoint
info.app.name=CommonRequestService
info.app.description=Service for managing Different Screen requests. [ex: SegmentRequest, CGL etc]
info.app.version=1.0.0

spring.jackson.date-format=dd/MM/yyyy
spring.jackson.serialization.write-dates-as-timestamps=false






//--------------------------

// db table : 

REQ_ID	NUMBER	No	"FTWOAHM"."COMMON_REQ_SEQ"."NEXTVAL" 	1	Unique PK.
REQ_TYPE	VARCHAR2(20 BYTE)	No		2	Which type of request it. SegmentCode, CGL.
CHANGE_TYPE	VARCHAR2(2 BYTE)	No		3	What type of change it is. A: Add, U: Update, D: Delete.
REQ_STATUS	VARCHAR2(2 BYTE)	No	'P'                                  	4	Status of the request. P: Pending, A: Accepted, R: Rejected.
REQ_DATE	DATE	No	SYSDATE                              	5	When this request was created.
CREATOR_ID	VARCHAR2(12 BYTE)	No		6	User id of the user who created this request.
EXECUTION_DATE	DATE	Yes		7	Timestamp when the request was actually applied to the target table.
EXECUTION_REMARKS	CLOB	Yes		8	JSON string containing details about the execution (e.g., success/failure message, errors).
EXECUTOR_ID	VARCHAR2(12 BYTE)	Yes		9	User id of the user who accepted/rejected this request.
EXECUTOR_REMARKS	VARCHAR2(500 BYTE)	Yes		10	Remarks added by executor.
PAYLOAD	CLOB	Yes		11	Actual change request data to be updated to the target table. Can be null id delete request.
TARGET_ID	VARCHAR2(4000 BYTE)	Yes		12	Target table row id of this request. Can be null if add request.






package com.tcs.fincore.CommonRequestService.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.jsontype.BasicPolymorphicTypeValidator;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

/**
 * Configuration class for setting up Redis integration within the Spring Boot application.
 *
 * This class enables Spring's caching mechanism via `@EnableCaching` and customizes
 * how data is serialized and deserialized when stored in Redis, primarily using JSON
 * and ensuring correct handling of Java 8 Date/Time API types.
 */
@Configuration
@EnableCaching
public class RedisConfig {

    /**
     * Configures and provides a custom `CacheManager` bean for Redis caching operations.
     *
     * This manager sets up default cache behavior, including a 24-hour Time-To-Live (TTL)
     * for entries, prevention of caching `null` values, and specialized JSON serialization.
     *
     * The serialization is configured with `GenericJackson2JsonRedisSerializer` and includes
     * polymorphic type handling (`activateDefaultTyping`) to ensure that cached objects
     * retain their original class information during deserialization, which is crucial
     * for generic object caching.
     *
     * @param connectionFactory The auto-configured RedisConnectionFactory provided by Spring.
     * @return A configured RedisCacheManager instance.
     */
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        // 1. Create a specialized ObjectMapper for Redis
        ObjectMapper redisObjectMapper = new ObjectMapper();
        redisObjectMapper.registerModule(new JavaTimeModule());
        // --- THIS IS THE FIX / CRUCIAL CONFIGURATION ---
        // We explicitly verify and enable "Type Info" (polymorphic deserialization)
        // so Redis saves the Java class name metadata alongside the JSON data.
        redisObjectMapper.activateDefaultTyping(
                BasicPolymorphicTypeValidator.builder()
                        .allowIfBaseType(Object.class)
                        .build(),
                ObjectMapper.DefaultTyping.NON_FINAL
        );
        // -----------------------
        GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(redisObjectMapper);

        // Define the default configuration for all caches managed by this manager
        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(24)) // Set default cache expiration to 24 hours
                .disableCachingNullValues() // Prevent caching of null results
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(serializer));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(cacheConfig)
                .build();
    }

    /**
     * Provides a standard `ObjectMapper` bean for general application use outside of the
     * specific `CacheManager` configuration.
     *
     * Ensures proper handling of Java 8 Date/Time types (like `LocalDate`, `Instant`)
     * in standard JSON marshalling operations elsewhere in the application (e.g., REST controllers).
     *
     * @return A configured ObjectMapper instance.
     */
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); // Write dates as ISO-8601 strings
        return mapper;
    }

    /**
     * Configures and provides a custom `RedisTemplate` bean.
     *
     * This bean is used for direct, programmatic interaction with Redis (e.g., using `redisTemplate.opsForValue().set(...)`)
     * rather than using the `@Cacheable` annotations. It uses the application's standard
     * `ObjectMapper` for serialization, which is suitable for specific key-value operations
     * where polymorphic typing might not be necessary or is handled explicitly.
     *
     * @param connectionFactory The auto-configured RedisConnectionFactory.
     * @param objectMapper The standard application ObjectMapper bean.
     * @return A configured RedisTemplate instance for String keys and Object values.
     */
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory, ObjectMapper objectMapper) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        // Use the standard Jackson2JsonRedisSerializer for the value serializer
        Jackson2JsonRedisSerializer<Object> serializer =
                new Jackson2JsonRedisSerializer<>(objectMapper, Object.class);

        template.setValueSerializer(serializer);
        template.setKeySerializer(new StringRedisSerializer()); // Ensure keys are always strings

        return template;
    }

}






//-----------------------

  package com.tcs.fincore.CommonRequestService.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                // 1. Disable CSRF, not needed for stateless REST APIs
                .csrf(csrf -> csrf.disable())

                // 2. Define authorization rules
                .authorizeHttpRequests(authz -> authz
                        // IMPORTANT: For now, permit all requests to solve the 401 error.
                        // In a real application,we would secure these endpoints.
                        // Example: .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                        .requestMatchers("/**").permitAll() // Allows access to all your API endpoints
                        .requestMatchers("/actuator/**").permitAll() // Allows access to Spring Actuator
                        .anyRequest().authenticated() // Secure any other endpoints not listed
                )

                // 3. Set session management to stateless, essential for REST APIs
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        // In a real application with JWTs, you would add your JWT filter here
        // .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}














package com.tcs.fincore.CommonRequestService.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class NotificationConfigDto {

    private String targetUrl;

    private String targetRoles; // Comma separated string: "51,52,55"

}















spring.application.name=CommonRequestService
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.profiles.active=dev
server.port=9000

#todo Expose all actuator endpoints over HTTP.
management.endpoints.web.exposure.include=*

# Always show full details on the health endpoint (e.g., database connection status)
management.endpoint.health.show-details=always

# Add some custom info to the /info endpoint
info.app.name=CommonRequestService
info.app.description=Service for managing Different Screen requests. [ex: SegmentRequest, CGL etc]
info.app.version=1.0.0

spring.jackson.date-format=dd/MM/yyyy
spring.jackson.serialization.write-dates-as-timestamps=false


# --- Redis Configuration ---
spring.data.redis.host=localhost
spring.data.redis.port=6379
spring.cache.type=redis







spring.datasource.url=jdbc:oracle:thin:@10.177.103.192:1523/fincorepdb1
spring.datasource.username=fincore
spring.datasource.password=Password#1234







permissions table schema :

MENU_ID	NUMBER(38,0)	No	"FINCORE"."MENU_ITEMS_SEQ"."NEXTVAL"	1	
MENU_TITLE	VARCHAR2(255 CHAR)	No		2	
MENU_ICON	VARCHAR2(255 CHAR)	Yes		3	
MENU_SUBMENU	VARCHAR2(255 CHAR)	Yes		4	
MENU_ACTION	VARCHAR2(255 CHAR)	No	NULL	5	
MENU_URL	VARCHAR2(255 CHAR)	No		6	
MENU_COMPONENT_PATH	VARCHAR2(255 CHAR)	No		7	
MENU_DESCRIPTION	VARCHAR2(255 BYTE)	No		8	
MENU_DEPENDANT	NUMBER(38,0)	Yes		9	
MAPPED_REQUEST_TYPE	VARCHAR2(255 CHAR)	Yes		10	
MENU_ORDER	VARCHAR2(255 CHAR)	Yes		11	
API_RESOURCE_PATTERN	VARCHAR2(255 CHAR)	Yes		12	"Defines the Backend REST API Endpoint pattern (e.g., /user/**, /cgl*) required to ACCESS data for this screen.
CRITICAL: This is used by the RBAC Filter to grant "Read/View" access.
If NULL, the screen may load blank."




data :

1	Circle Management	AccountTree		view|create|modify	/circle-management	circle/CircleMaster	To manage circles in application		CIRCLE		/circle-codes,/zone-codes
2	Circle Requests	Ballot		view|approve|reject	/circle-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for circle master.		CIRCLE		/circle-codes,/zone-codes
5	CGL Management	Casino		create|modify|delete|cancel	/cgl-management	cgl/CGLMaster	To edit or update active CGLs and to view pending cgl requests		CGL_CODE		/cgl*
6	CGL Requests	WorkspacePremium		view|approve|reject	/cgl-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for cgl master.		CGL_CODE		/cgl*
7	Segment Management	Segment		view|create|modify	/segment-management	segment/SegmentMaster	To manage segments in application		SEGMENT_CODE		/segment-codes
8	Segment Requests	Grading		view|approve|reject	/segment-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for segment master.		SEGMENT_CODE		/segment-codes
9	Branch Management	AccountBalance		view|create|modify	/branch-management	branch/BranchMaster	To edit update branches and to check pending branch update requests		BRANCH		/branches*
10	Branch Requests	AssuredWorkload		view|approve|reject	/branch-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for branch master.		BRANCH		/branches*
11	Downloads	Download		view|download	/download	branch/BranchMaster	This is demo description				/branches*
12	User Management	People	User Creation	view|create|modify|delete	/user-management/create	user/pages/UserManagement	For creating new user		USER_MANAGEMENT		/user/**
13	User Management	WorkspacePremium	User Requests	view|approve|reject	/user-management/requests	user/pages/UserApprovals	To approve or reject user requests		USER_MANAGEMENT		/user/**
14	Calendar Configuration	EditCalendar		view|create|modify	/calendar-configuration	calendarConfig/CalendarConfig	To manage financial calender configuration in application		CALENDER		/calendar-configuration
15	Calendar Config Requests	EventAvailable		view|approve|reject	/calendar-config-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for calender config master.		CALENDER		/calendar-configuration
16	State Management	Domain		view|create|modify	/state-management	state/StateMaster	To manage states in application		STATE		/states
17	State Requests	DomainVerification		view|approve|reject	/state-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for state master.		STATE		/states
18	Currency Management	LocalAtm		view|create|modify	/currency-management	currency/CurrencyMaster	To manage currency in application		CURRENCY		/currency*
19	Currency Requests	CreditScore		view|approve|reject	/currency-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for currency master.		CURRENCY		/currency*
20	Currency Rate Change	PriceChange		view|create|modify	/currency-rate-change	currency/CurrencyRateChange	To manage currency rate in application		CURRENCY_RATE_CHANGE		/currency-rate-change
21	Currency Rate Requests	CurrencyRupee		view|approve|reject	/currency-rate-requests	common/CommonRequestScreen	To efficiently review and process the pending requests for currency rate master.		CURRENCY_RATE_CHANGE		/currency-rate-change
22	Role Management	Badge		view|create|modify|cancel	/role-management	role/RoleManagement	To manage roles in application		ROLE_MANAGEMENT		/role/**
23	Role Management Requests	Elevator		view|approve|reject	/role-management-requests	role/RoleApprovals	To approve/reject role management related requests.		ROLE_MANAGEMENT		/role/**
24	User Management	People	User Requests Audit	view	/user-management/user-audit	user/pages/UserLogs	Shows user audit requests		USER_MANAGEMENT		/user/**
25	Process Status	Memory		view	/process-status	process-status/ProcessStatusPage	This is demo description				/processes
26	GLIF Reports	Summarize		view|download	/glif-Reports	glifReports/GlifReports	This is demo description				/reports/**
30	Journal Posting	EditCalendar		view|create	/journal-posting	journal/JournalPosting	This is demo description		JOURNAL_AUTH		
31	Journal Authrization	Ballot		view|approve|reject	/journal-authrization	journal/JournalAuthrization	This is demo description		JOURNAL_AUTH		
32	Journal Posting Status	Ballot		view|cancel	/journal-posting-status	journal/JournalPostingStatus	to cansel there own Request				
33	Balance Enquiry	AccountBalance		view	/balance-enquiry	balanceEnquiry/BalanceEnquiryScreen	This provides closing balance for each day according to selected range.				/balance/**
34	Transaction Enquiry	ReceiptLong		view	/transaction-enquiry	transaction-enquiry/TransactionEnquiry	This is demo description				/transactions*
35	Dashboard	GridView		view	/dashboard	user/pages/Dashboard	Sample Dashboard screen MUI				/notifications/**
36	Journal Bulk Upload	GridView		view|upload	/journal-bulk-upload	journal/JournalBulkUpload	To Upload the Bulk Journals				/journal-bulk-upload/**
105	CGL Management	Casino		block|unblock	/cgl-management	cgl/CGLMaster	Block or Unblock CGL codes		CGL_CODE		/cgl*
106	Branch Management	AccountBalance		block|unblock	/branch-management	branch/BranchMaster	To block/unblock branches		BRANCH		/branches*














role_permissions table schema : 
ROLE_ID	NUMBER(10,0)	No		1	Foreign key to the ROLES table.
PERMISSION_ID	NUMBER(10,0)	No		2	Foreign key to the PERMISSIONS table.
PERMISSION_ORDER	NUMBER	Yes		3	Storing permission order against each role.




samplem data :
56	26	1
51	35	1
53	2	1
58	19	1
55	19	1
54	9	1
56	33	2
51	11	2
53	10	2
58	11	2
55	11	2
54	10	2
51	1	3
53	13	3
58	2	3
55	2	3
56	22	3
54	16	3
51	25	4
53	6	4
58	1	4
55	1	4
56	12	4
54	17	4
51	5	5
53	8	5
58	10	5
55	10	5
56	13	5
54	15	5
51	14	6
53	15	6
58	25	6
55	25	6
54	18	6
56	34	6
51	9	7
53	17	7
58	5	7
55	5	7
54	19	7
51	7	8
53	21	8
58	13	8
55	13	8
54	20	8
53	23	9
51	12	9
58	14	9
55	14	9
54	21	9
51	16	10
53	31	10
58	6	10
55	6	10
54	24	10
53	19	11
51	18	11
58	9	11
55	9	11
54	25	11
53	25	12
51	20	12
58	8	12
55	8	12
54	35	12
51	22	13
58	7	13
55	7	13
54	23	13
51	24	14
58	12	14
55	12	14
54	32	14
51	26	15
58	15	15
55	15	15
54	11	15
51	30	16
58	16	16
55	16	16
54	22	16
51	32	17
58	17	17
55	17	17
54	12	17
51	34	18
58	18	18
55	18	18
54	13	18
51	33	19
58	20	19
55	20	19
54	26	19
58	21	20
55	21	20
51	19	20
54	31	20
58	22	21
55	22	21
54	34	21
51	36	21







roles table : 

ROLE_ID	NUMBER(10,0)	No	"FINCORE"."ROLE_ID_SEQUENCE"."NEXTVAL"	1	 Unique identifier for the role
ROLE_NAME	VARCHAR2(50 BYTE)	No		2	 Name of the role
DESCRIPTION	VARCHAR2(150 BYTE)	Yes		3	 Description of the role
ROLE_STATUS	VARCHAR2(20 BYTE)	No	"'ACTIVE'
   "	4	Status of the role ( Active/Blocked)



notifications table :

EVENT_ID	RAW	No	SYS_GUID()	1	Unique primary key for the outbox event.
USER_ID	VARCHAR2(255 BYTE)	Yes		2	The ID of the user who should receive this notification.
MESSAGE	VARCHAR2(1024 BYTE)	No		3	The human-readable message to be displayed.
LINK_URL	VARCHAR2(1024 BYTE)	Yes		4	The relative URL the user should be taken to when clicking the notification.
EVENT_SOURCE	VARCHAR2(100 BYTE)	Yes		5	The microservice that generated this event (e.g., REPORT_SERVICE).
AGGREGATE_ID	VARCHAR2(255 BYTE)	Yes		6	The primary key of the business object (e.g., the Report ID).
EVENT_TIMESTAMP	TIMESTAMP(6) WITH TIME ZONE	No	CURRENT_TIMESTAMP	7	The timestamp when the event was created.
TARGET_ROLE	VARCHAR2(100 BYTE)	Yes		8	For 1-to-Many notifications. If USER_ID is null, this role is used.





** branch master table :
CODE	VARCHAR2(5 BYTE)	No		1	Unique 5 digit branch code.
NAME	VARCHAR2(50 BYTE)	No		2	Branch name.
CIRCLE_CODE	VARCHAR2(3 BYTE)	No		3	FK Circle code of this branch.
STATE	VARCHAR2(3 BYTE)	No		4	FK State code of this branch.
CITY	VARCHAR2(50 BYTE)	Yes		5	City of this branch.
ADDRESS	VARCHAR2(50 BYTE)	Yes		6	Street/Address of this branch.
PINCODE	VARCHAR2(6 BYTE)	Yes		7	Pincode of this branch.
PHONE_NUMBER	VARCHAR2(12 BYTE)	No		8	Contact number of this branch.
EMAIL_ID	VARCHAR2(50 BYTE)	No		9	Contact email of this branch.
NMR_CODE	VARCHAR2(50 BYTE)	No		10	N-M-R code (NETWORK_CODE - module_CODE - region_CODE).
STATUS	NUMBER(1,0)	No		11	Status of this branch (Live/Closed). value: '1' or '0'
OPEN_DATE	DATE	No		12	When this branch was created.
CLOSE_DATE	DATE	Yes		13	When this branch was closed.
MERGE_DATE	DATE	Yes		14	When this branch was merged with other branch.
MERGED_WITH_BRANCH	VARCHAR2(5 BYTE)	Yes		15	Branch code of the branch with which this branch was merged.
LAST_CHANGE_DATE	DATE	Yes	SYSDATE 	16	When this branch was last changed.
CPC_FLAG	NUMBER(1,0)	Yes		17	CPC Flag.
FOOD_CREDIT_FLAG	NUMBER(1,0)	No		18	Food credit flag.
CURR_CHEST_FLAG	NUMBER(1,0)	No		19	CURR_CHEST_FLAG.
BRANCH_TYPE	VARCHAR2(1 BYTE)	No		20	Type of this branch (A: Automated, M: Manual).


sample data :

32121	JASWANTGARH	023	JK	Thane	Tower No 7, 4th Flr, Railway Stn Bldg, CBD Belapur	400614	475738168645	sbi.32121@sbi.co.in	454229852	0	24-11-25	30-12-25	30-12-25	00002		1	1	1	M
32122	PANCHMUKHI	009	LA	Thane	Tower No 7, 4th Flr, Railway Stn Bldg, CBD Belapur	400614	355179093927	test48@example.com	872138781	1	24-11-25				26-11-25	0	1	1	A
32130	SULTANPUR	023	LD	Thane	Tower No 7, 4th Flr, Railway Stn Bldg, CBD Belapur	400614	346996277935	test704@example.com	098488313	1	24-11-25				26-11-25	0	1	1	A
32131	LAKHERI	023	PY	Thane	Tower No 7, 4th Flr, Railway Stn Bldg, CBD Belapur	400614	605874726756	test940@example.com	548843309	1	24-11-25				26-11-25	0	1	1	A
32132	AAU	023	AP	Thane	Tower No 7, 4th Flr, Railway Stn Bldg, CBD Belapu	400614	077439157411	sbi.32132@sbi.co.in	049189990	1	24-11-25					0	1	1	A
31774	ITAWA DISTT. KOTAH	023	AR	Thane	Tower No 7, 4th Flr, Railway Stn Bldg, CBD Belapur	400614	657169339668	test29@example.com	766362631	1	24-11-25				26-11-25	0	1	1	A
31776	SURYA NAGAR	002	AS	Thane	Tower No 7, 4th Flr, Railway Stn Bldg, CBD Belapur	400614	099592138780	sbi.31776@sbi.co.in	022612726	0	24-11-25	30-12-25				0	1	1	M
