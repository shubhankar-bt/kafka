package com.tcs.userservice.utility;

import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;

import java.sql.Clob;

@Slf4j
@UtilityClass
public class ClobUtil {

    /**
     * Safely converts a Database CLOB object (Proxy) to a Java String.
     * Prevents Serialization errors when returning DB results to UI.
     */
    public static String clobToString(Object clobObj) {
        if (clobObj == null) {
            return null;
        }
        try {
            if (clobObj instanceof String) {
                return (String) clobObj;
            }
            if (clobObj instanceof Clob) {
                Clob clob = (Clob) clobObj;
                long length = clob.length();
                if (length == 0) return "";
                return clob.getSubString(1, (int) length);
            }
            return clobObj.toString();
        } catch (Exception e) {
            log.error("Error converting CLOB to String", e);
            return "ERROR_READING_PAYLOAD";
        }
    }
}












package com.tcs.userservice;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.http.HttpStatusCode;

import java.time.Instant;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ResponseVO<T> {
    private HttpStatusCode statusCode;
    private String message;
    private T result;
    @Builder.Default
    private Instant timestamp = Instant.now();
}













package com.tcs.userservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.Data;
import java.util.Map;

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class RoleRequestCreateDto {
    private String requestType; // CREATE, MODIFY, DELETE
    private int targetRoleId;
    // Payload kept as Map for flexibility, will be serialized to JSON
    private Map<String, Object> requestPayload; 
}












package com.tcs.userservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.Data;
import java.util.Map;

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class RoleRequestCreateDto {
    private String requestType; // CREATE, MODIFY, DELETE
    private int targetRoleId;
    // Payload kept as Map for flexibility, will be serialized to JSON
    private Map<String, Object> requestPayload; 
}








package com.tcs.userservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.Data;
import java.util.Map;

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class UserRequestCreateDto {
    private String requestType; // CREATE, MODIFY, LOCK, UNLOCK
    private String targetUserId;
    private Map<String, Object> requestPayload;
}











package com.tcs.userservice.dto;

import java.sql.Timestamp;

public interface UserRequestProjection {
    
    // Core fields
    String getRequestId();
    String getRequestType();
    String getRequestorUserId();
    String getRequestStatus();
    Timestamp getRequestDate();
    
    // Role specific
    String getTargetRoleId();
    
    // User specific
    String getTargetUserId();

    // CRITICAL FIX: Return Object (Clob) instead of String to prevent conversion crashes
    Object getRequestPayload(); 
    
    // Audit fields
    Timestamp getApprovalDate();
    String getApproverUserId();
    String getReasonForRejection();
    Timestamp getExecutionDate();
    String getExecutionDetails();
}














package com.tcs.userservice.repository;

import com.tcs.userservice.dto.UserRequestProjection;
import com.tcs.userservice.model.RoleRequest;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface RoleRequestRepository extends JpaRepository<RoleRequest, Integer> {

    @Query(value = "SELECT count(*) FROM role_requests WHERE TARGET_ROLE_ID=:roleId AND request_status='PENDING'", nativeQuery = true)
    int countPendingRoleRequests(@Param("roleId") int roleId);

    @Query(value = """
            SELECT COUNT(*) FROM role_requests 
            WHERE lower(JSON_VALUE(request_payload, '$.roleName')) = lower(:roleName) 
            AND request_status = 'PENDING'
            """, nativeQuery = true)
    int countPendingRoleRequestsByRoleName(@Param("roleName") String roleName);

    // OPTIMIZED: Removed dbms_lob.substr, selecting raw CLOB
    @Query(value = """
            SELECT 
                request_id AS requestId,
                request_type AS requestType,
                requestor_user_id AS requestorUserId,
                target_role_id AS targetRoleId,
                request_payload AS requestPayload, 
                request_status AS requestStatus,
                request_date AS requestDate,
                approval_date AS approvalDate,
                approver_user_id AS approverUserId,
                reason_for_rejection AS reasonForRejection,
                execution_date AS executionDate,
                execution_details AS executionDetails
            FROM role_requests
            WHERE requestor_user_id != :requestedByUserId
            AND request_status = 'PENDING'
            """, nativeQuery = true)
    List<UserRequestProjection> findPendingRoleRequests(@Param("requestedByUserId") String requestedByUserId);

    @Query(value = """
            SELECT 
                request_id AS requestId,
                request_type AS requestType,
                requestor_user_id AS requestorUserId,
                target_role_id AS targetRoleId,
                request_payload AS requestPayload,
                request_status AS requestStatus,
                request_date AS requestDate,
                approval_date AS approvalDate,
                approver_user_id AS approverUserId,
                reason_for_rejection AS reasonForRejection,
                execution_date AS executionDate,
                execution_details AS executionDetails
            FROM role_requests
            WHERE requestor_user_id = :requestedByUserId
            ORDER BY request_id DESC
            """, nativeQuery = true)
    List<UserRequestProjection> findMyPendingRoleRequests(@Param("requestedByUserId") String requestedByUserId);

    RoleRequest findRoleRequestByRequestId(int requestId);

    RoleRequest getRoleRequestByRequestId(long requestId);

    @Query(nativeQuery = true, value = "SELECT ROLE_ID_SEQUENCE.NEXTVAL FROM DUAL")
    int getNewRoleIdOnCreation();
}













package com.tcs.userservice.repository;

import com.tcs.userservice.dto.UserRequestProjection;
import com.tcs.userservice.model.UserRequest;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface UserRequestRepository extends JpaRepository<UserRequest, Integer> {

    @Query(value="SELECT count(*) FROM user_requests WHERE target_user_id=:targetUserId AND request_status='PENDING'", nativeQuery=true)
    int countUserPendingRequests(@Param("targetUserId") String targetUserId);

    // OPTIMIZED: Removed dbms_lob.substr, using Projection
    @Query(value = """
            SELECT 
                request_id AS requestId,
                request_type AS requestType,
                requestor_user_id AS requestorUserId,
                target_user_id AS targetUserId,
                request_payload AS requestPayload,
                request_status AS requestStatus,
                request_date AS requestDate
            FROM user_requests 
            WHERE REQUESTOR_USER_ID != :requestedByUserId 
            AND request_status='PENDING'
            """, nativeQuery = true)
    List<UserRequestProjection> findUserPendingRequests(@Param("requestedByUserId") String requestedByUserId);

    UserRequest findUserRequestsByRequestId(long requestId);

    // OPTIMIZED: Removed dbms_lob.substr, using Projection
    @Query(value = """
            SELECT 
                request_id AS requestId,
                request_type AS requestType,
                requestor_user_id AS requestorUserId,
                target_user_id AS targetUserId,
                request_payload AS requestPayload,
                request_status AS requestStatus,
                request_date AS requestDate
            FROM user_requests 
            WHERE REQUESTOR_USER_ID = :userId 
            ORDER BY request_id DESC
            """, nativeQuery = true)
    List<UserRequestProjection> findUserRequestsByRequestorUserId(@Param("userId") String userId);
}
















package com.tcs.userservice.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.userservice.ResponseVO;
import com.tcs.userservice.dto.*;
import com.tcs.userservice.model.*;
import com.tcs.userservice.repository.*;
import com.tcs.userservice.utility.ClobUtil;
import com.tcs.userservice.utility.Constant;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class RoleRequestServiceImpl implements RoleRequestService {

    private static final String EVENT_SOURCE = "USER_SERVICE";
    private static final String REQUEST_TYPE_KEY = "ROLE_MANAGEMENT";

    private final RoleRequestRepository roleRequestRepository;
    private final RoleRepository roleRepository;
    private final ObjectMapper objectMapper;
    private final RoleService roleService;
    private final PermissionsRepository permissionsRepository;
    private final RolePermissionsRepository rolePermissionsRepository;
    private final CacheManager cacheManager;
    private final PermissionConfigService permissionConfigService;
    private final NotificationWriterService notificationWriterService;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<RoleRequest>> createNewRoleRequest(RoleRequestCreateDto dto, String userId) {
        
        RoleRequest roleRequest = new RoleRequest();
        roleRequest.setRequestType(dto.getRequestType());
        roleRequest.setTargetRoleId(dto.getTargetRoleId());
        roleRequest.setRequestorUserId(userId);
        roleRequest.setRequestStatus(Constant.PENDING);
        roleRequest.setRequestDate(new Timestamp(System.currentTimeMillis()));
        
        try {
            // Serialize payload Map to JSON String for CLOB
            String jsonPayload = objectMapper.writeValueAsString(dto.getRequestPayload());
            roleRequest.setRequestPayload(jsonPayload);
        } catch (JsonProcessingException e) {
            throw new IllegalArgumentException("Invalid JSON payload", e);
        }

        boolean isCreate = Constant.CREATE.equalsIgnoreCase(dto.getRequestType());
        String roleName = (String) dto.getRequestPayload().get("roleName");

        // Validations
        validateRequest(isCreate, dto.getTargetRoleId(), roleName);

        if (isCreate) {
            roleRequest.setTargetRoleId(roleRequestRepository.getNewRoleIdOnCreation());
        }

        RoleRequest saved = roleRequestRepository.save(roleRequest);

        createRoleRequestNotification(saved, Constant.PENDING, true, 
             "New role request: " + saved.getTargetRoleId() + " pending approval.");

        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ResponseVO.<RoleRequest>builder()
                        .statusCode(HttpStatus.CREATED)
                        .message("Request Created")
                        .result(saved)
                        .build());
    }

    private void validateRequest(boolean isCreate, int roleId, String roleName) {
        if (isCreate) {
             Role existingRole = roleRepository.findRoleByRoleId(roleId);
             if(existingRole != null) throw new IllegalArgumentException("Role ID already exists");
             
             if(roleName != null && roleRequestRepository.countPendingRoleRequestsByRoleName(roleName.toLowerCase()) > 0) {
                 throw new IllegalArgumentException("Creation request for this Role Name already pending");
             }
        } else {
            if(roleRequestRepository.countPendingRoleRequests(roleId) > 0) {
                throw new IllegalArgumentException("Pending request already exists for this Role ID");
            }
        }
    }

    @Override
    public ResponseEntity<ResponseVO<Map<String, Object>>> getPendingRoleRequests(String userId) {
        List<UserRequestProjection> rawList = roleRequestRepository.findPendingRoleRequests(userId);
        return processProjectionList(rawList, "pendingRequests");
    }

    @Override
    public ResponseEntity<ResponseVO<Map<String, Object>>> getMyRoleRequests(String userId) {
        List<UserRequestProjection> rawList = roleRequestRepository.findMyPendingRoleRequests(userId);
        return processProjectionList(rawList, "myRequests");
    }

    // Common processor to convert CLOB to String
    private ResponseEntity<ResponseVO<Map<String, Object>>> processProjectionList(List<UserRequestProjection> rawList, String keyName) {
        List<Map<String, Object>> processedList = rawList.stream().map(req -> {
            Map<String, Object> map = new HashMap<>();
            map.put("requestId", req.getRequestId());
            map.put("requestType", req.getRequestType());
            map.put("requestorUserId", req.getRequestorUserId());
            map.put("targetRoleId", req.getTargetRoleId());
            map.put("requestStatus", req.getRequestStatus());
            map.put("requestDate", req.getRequestDate());
            // FIX: Use ClobUtil
            map.put("requestPayload", ClobUtil.clobToString(req.getRequestPayload()));
            return map;
        }).collect(Collectors.toList());

        Map<String, Object> result = new HashMap<>();
        result.put(keyName, processedList);
        result.put("count", processedList.size());

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .message("Fetched " + processedList.size() + " requests")
                .result(result)
                .build());
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> acceptOrRejectRoleRequest(Map<String, Object> request, String userId) {
        String actionFlag = (String) request.get("actionFlag");
        int requestId = Integer.parseInt(String.valueOf(request.get("requestId")));
        
        RoleRequest roleRequest = roleRequestRepository.findRoleRequestByRequestId(requestId);
        roleRequest.setApproverUserId(userId);
        roleRequest.setApprovalDate(new Timestamp(System.currentTimeMillis()));

        Map<String, Object> result = new HashMap<>();
        performUpdateOperation(result, actionFlag, roleRequest);
        
        boolean success = (boolean) result.get(Constant.STATUS);
        createRoleRequestNotification(roleRequest, actionFlag, success, 
            "Your role request has been " + (success ? "Approved" : "Rejected"));

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .message((String) result.get(Constant.MESSAGE))
                .result(result)
                .build());
    }

    private void performUpdateOperation(Map<String, Object> result, String actionFlag, RoleRequest roleRequest) {
        if (actionFlag.equalsIgnoreCase(Constant.ACCEPT)) {
            try {
                // Read CLOB payload safely
                String jsonPayload = ClobUtil.clobToString(roleRequest.getRequestPayload());
                RoleRequestPayload payload = objectMapper.readValue(jsonPayload, RoleRequestPayload.class);
                int roleId = roleRequest.getTargetRoleId();

                Role role = roleRepository.findRoleByRoleId(roleId);
                boolean isCreate = Constant.CREATE.equalsIgnoreCase(roleRequest.getRequestType());

                if (isCreate) role = new Role();
                if (role == null) {
                    result.put(Constant.STATUS, false);
                    result.put(Constant.MESSAGE, "Role not found");
                    return;
                }

                role.setRoleId(roleId); // Important for Create
                role.setRoleName(payload.getRoleName());
                role.setDescription(payload.getDescription());
                role.setStatus(Constant.ACTIVE);
                roleRepository.save(role);

                savePermissions(payload, roleId);
                
                // Evict Cache if needed
                evictPermissionCache(payload.getPermissions());

                roleRequest.setRequestStatus(Constant.ACCEPTED);
                roleRequestRepository.save(roleRequest);

                result.put(Constant.STATUS, true);
                result.put(Constant.MESSAGE, isCreate ? "Role Created" : "Role Updated");

            } catch (Exception e) {
                log.error("Error updating role", e);
                throw new RuntimeException("Update failed", e);
            }
        } else {
            roleRequest.setRequestStatus(Constant.REJECTED);
            roleRequest.setReasonForRejection("Rejected by approver");
            roleRequestRepository.save(roleRequest);
            result.put(Constant.STATUS, true);
            result.put(Constant.MESSAGE, "Request Rejected");
        }
    }
    
    private void evictPermissionCache(List<PermissionList> permissions) {
        if(permissions == null) return;
        try {
            Set<Integer> ids = permissions.stream().map(PermissionList::getId).collect(Collectors.toSet());
            List<String> keys = permissionsRepository.findMappedRequestTypeByMenuId(ids);
            Cache cache = cacheManager.getCache("notification_configs");
            if (cache != null && keys != null) {
                keys.forEach(cache::evict);
            }
        } catch (Exception e) {
            log.warn("Cache eviction failed", e);
        }
    }

    // Permission saving logic (optimized)
    private void savePermissions(RoleRequestPayload payload, int roleId) {
        List<PermissionList> newPerms = payload.getPermissions();
        if (newPerms == null) return;

        List<RolePermissions> current = rolePermissionsRepository.findByIdRoleId(roleId);
        rolePermissionsRepository.deleteAll(current);
        rolePermissionsRepository.flush();

        List<RolePermissions> toSave = newPerms.stream().map(p -> {
            RolePermissions rp = new RolePermissions();
            rp.setId(new RolePermissionId(roleId, p.getId()));
            rp.setPermissionOrder(p.getOrder());
            return rp;
        }).collect(Collectors.toList());

        rolePermissionsRepository.saveAll(toSave);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> cancelRoleRequest(Map<String, Object> request, String userId) {
        int requestId = Integer.parseInt(String.valueOf(request.get("requestId")));
        RoleRequest roleRequest = roleRequestRepository.getRoleRequestByRequestId(requestId);

        if(!roleRequest.getRequestorUserId().equals(userId)) {
             return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }
        
        roleRequest.setRequestStatus(Constant.CANCEL);
        roleRequestRepository.save(roleRequest);
        
        createRoleRequestNotification(roleRequest, Constant.CANCEL, true, "Request Cancelled");

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .message("Cancelled")
                .result(Map.of("status", true))
                .build());
    }

    private void createRoleRequestNotification(RoleRequest roleRequest, String actionFlag, boolean success, String msg) {
        try {
            NotificationConfigDto config = permissionConfigService.getConfig(REQUEST_TYPE_KEY);
            String targetUser = (Constant.ACCEPT.equalsIgnoreCase(actionFlag) || Constant.REJECT.equalsIgnoreCase(actionFlag)) 
                                ? roleRequest.getRequestorUserId() : null;
            
            String targetRoles = (targetUser == null) ? config.getTargetRoles() : null;
            
            notificationWriterService.createNotification(targetUser, targetRoles, msg, 
                                                         config.getTargetUrl(), 
                                                         String.valueOf(roleRequest.getRequestId()), 
                                                         EVENT_SOURCE);
        } catch (Exception e) {
             throw new RuntimeException("Notification failed", e);
        }
    }
    
    @Override
	public ResponseEntity<ResponseVO<Map<String, Object>>> getAllRoles(Map<String, Object> request) {
        boolean includePermissions = Boolean.parseBoolean(String.valueOf(request.get("permissions")));
        List<RoleDto> roles = roleService.getAllRolesWithPermissions(includePermissions);
        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .result(Map.of("roles", roles))
                .build());
    }

    @Override
    public ResponseEntity<ResponseVO<List<PermissionDto>>> getAllPermissions() {
        List<Permissions> permissions = permissionsRepository.findAll();
        List<PermissionDto> dtos = permissions.stream().map(p -> PermissionDto.builder()
                .id(p.getMenuId())
                .title(p.getMenuTitle())
                .icon(p.getMenuIcon())
                .menuSubmenu(p.getMenuSubmenu())
                .description(p.getMenuDescription())
                .build()).collect(Collectors.toList());
        
        return ResponseEntity.ok(ResponseVO.<List<PermissionDto>>builder()
                .statusCode(HttpStatus.OK)
                .result(dtos)
                .build());
    }

    @Override
    public ResponseEntity<?> savePermissionOrder(PermissionOrderDto payload) {
        // Implementation as per previous code
        return null; 
    }
}

















package com.tcs.userservice.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.userservice.ResponseVO;
import com.tcs.userservice.dto.*;
import com.tcs.userservice.model.*;
import com.tcs.userservice.repository.*;
import com.tcs.userservice.utility.ClobUtil;
import com.tcs.userservice.utility.Constant;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class UserRequestServiceImpl implements UserRequestService {

    private static final String EVENT_SOURCE = "USER_SERVICE";
    private static final String REQUEST_TYPE_KEY = "USER_MANAGEMENT";

    private final UserRequestRepository userRequestRepository;
    private final UserRepository userRepository;
    private final UserRoleRepository userRoleRepository;
    private final ObjectMapper objectMapper;
    private final NotificationWriterService notificationWriterService;
    private final PermissionConfigService permissionConfigService;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> createNewRequest(UserRequestCreateDto dto, String userId) {
        String targetUserId = dto.getTargetUserId();
        String requestType = dto.getRequestType();

        // 1. Conflict Checks
        if (userRequestRepository.countUserPendingRequests(targetUserId) > 0) {
             return buildError(HttpStatus.CONFLICT, "Pending request already exists");
        }
        User existingUser = userRepository.findUserByUserId(targetUserId);
        if (Constant.CREATE.equalsIgnoreCase(requestType) && existingUser != null) {
             return buildError(HttpStatus.CONFLICT, "User already exists");
        }
        if (!Constant.CREATE.equalsIgnoreCase(requestType) && existingUser == null) {
             return buildError(HttpStatus.NOT_FOUND, "User does not exist");
        }

        // 2. Create Entity
        UserRequest request = new UserRequest();
        request.setRequestType(requestType);
        request.setTargetUserId(targetUserId);
        request.setRequestorUserId(userId);
        request.setRequestStatus(Constant.PENDING);
        request.setRequestDate(new Timestamp(System.currentTimeMillis()));

        try {
            request.setRequestPayload(objectMapper.writeValueAsString(dto.getRequestPayload()));
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Invalid Payload", e);
        }

        // 3. Save
        UserRequest saved = userRequestRepository.save(request);

        // 4. Notify
        createNotification(saved.getRequestorUserId(), null, "User Request Created", String.valueOf(saved.getRequestId()));

        return ResponseEntity.status(HttpStatus.CREATED)
            .body(ResponseVO.<Map<String, Object>>builder()
                    .statusCode(HttpStatus.CREATED)
                    .message("Request Created")
                    .result(Map.of("userRequest", saved))
                    .build());
    }

    @Override
    public ResponseEntity<ResponseVO<Map<String, Object>>> getPendingRequests(Map<String, Object> params, String userId) {
        List<UserRequestProjection> rawList = userRequestRepository.findUserPendingRequests(userId);
        return processProjections(rawList, "pendingRequests");
    }

    @Override
    public ResponseEntity<ResponseVO<Map<String, Object>>> getMyRequests(Map<String, String> params) {
        String userId = params.get("userId");
        List<UserRequestProjection> rawList = userRequestRepository.findUserRequestsByRequestorUserId(userId);
        return processProjections(rawList, "myRequests");
    }

    private ResponseEntity<ResponseVO<Map<String, Object>>> processProjections(List<UserRequestProjection> rawList, String key) {
        List<Map<String, Object>> processed = rawList.stream().map(req -> {
            Map<String, Object> map = new HashMap<>();
            map.put("requestId", req.getRequestId());
            map.put("requestType", req.getRequestType());
            map.put("targetUserId", req.getTargetUserId());
            map.put("requestStatus", req.getRequestStatus());
            map.put("requestDate", req.getRequestDate());
            // FIX: Clob conversion
            map.put("requestPayload", ClobUtil.clobToString(req.getRequestPayload()));
            return map;
        }).collect(Collectors.toList());

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .result(Map.of(key, processed))
                .build());
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> acceptOrRejectUserRequest(UserRequestDto dto, String ipAddress, String userId) {
        UserRequest request = userRequestRepository.findUserRequestsByRequestId(dto.getRequestId());
        request.setApproverUserId(userId);
        request.setApprovalDate(new Timestamp(System.currentTimeMillis()));
        
        Map<String, Object> result = new HashMap<>();
        String action = dto.getActionFlag();

        if (Constant.ACCEPT.equalsIgnoreCase(action) || Constant.APPROVE.equalsIgnoreCase(action)) { // Support both
            handleAccept(request, result, dto, ipAddress);
        } else {
            request.setRequestStatus(Constant.REJECTED);
            request.setReasonForRejection(dto.getRemarks());
            userRequestRepository.save(request);
            result.put("status", true);
            result.put("message", "Rejected");
        }

        boolean success = (boolean) result.get("status");
        if(success && (Constant.ACCEPT.equalsIgnoreCase(action) || Constant.APPROVE.equalsIgnoreCase(action))) {
            request.setRequestStatus(Constant.ACCEPTED);
            userRequestRepository.save(request);
        }

        createNotification(request.getRequestorUserId(), null, 
            "Request " + (success ? "Processed" : "Failed"), String.valueOf(request.getRequestId()));

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .result(result)
                .build());
    }

    private void handleAccept(UserRequest request, Map<String, Object> result, UserRequestDto dto, String ip) {
        try {
            String jsonPayload = ClobUtil.clobToString(request.getRequestPayload());
            Map<String, Object> payloadMap = objectMapper.readValue(jsonPayload, new TypeReference<>() {});
            
            User user = userRepository.findUserByUserId(request.getTargetUserId());
            String type = request.getRequestType();

            if (Constant.CREATE.equalsIgnoreCase(type)) {
                if (user != null) throw new RuntimeException("User already exists");
                user = new User();
                user.setCreatedAt(new Timestamp(System.currentTimeMillis()));
                user.setAccountStatus(Constant.ACTIVE);
            } else if (user == null) {
                throw new RuntimeException("User not found");
            }

            // Apply changes
            if (Constant.CREATE.equalsIgnoreCase(type) || Constant.MODIFY.equalsIgnoreCase(type)) {
                user.setUserId(request.getTargetUserId());
                user.setFirstName((String) payloadMap.get("firstName"));
                user.setEmail((String) payloadMap.get("email"));
                // Add other fields...
                userRepository.save(user);
                
                // Update Role
                if(payloadMap.containsKey("roleId")) {
                    UserRole ur = userRoleRepository.getUserRolesByUserId(user.getUserId());
                    if(ur == null) ur = new UserRole();
                    ur.setUserId(user.getUserId());
                    ur.setRoleId(Integer.parseInt(String.valueOf(payloadMap.get("roleId"))));
                    userRoleRepository.save(ur);
                }
            } else if (Constant.LOCK.equalsIgnoreCase(type)) {
                user.setAccountStatus(Constant.LOCKED);
                userRepository.save(user);
            } else if (Constant.UNLOCK.equalsIgnoreCase(type)) {
                user.setAccountStatus(Constant.ACTIVE);
                userRepository.save(user);
            }

            result.put("status", true);
            result.put("message", "User Updated");

        } catch (Exception e) {
            log.error("Error applying user changes", e);
            result.put("status", false);
            result.put("message", e.getMessage());
        }
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity cancelRequest(Map<String, Object> requestMap) {
        long id = Long.parseLong(String.valueOf(requestMap.get("requestId")));
        UserRequest req = userRequestRepository.findUserRequestsByRequestId(id);
        
        userRequestRepository.delete(req);
        
        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .message("Cancelled")
                .result(Map.of("status", true))
                .build());
    }

    private void createNotification(String userId, String roles, String msg, String refId) {
        try {
            NotificationConfigDto config = permissionConfigService.getConfig(REQUEST_TYPE_KEY);
            notificationWriterService.createNotification(userId, roles, msg, config.getTargetUrl(), refId, EVENT_SOURCE);
        } catch (Exception e) {
            throw new RuntimeException("Notification Error", e);
        }
    }

    private ResponseEntity<ResponseVO<Map<String, Object>>> buildError(HttpStatus status, String msg) {
        return ResponseEntity.status(status).body(ResponseVO.<Map<String, Object>>builder()
                .statusCode(status)
                .message(msg)
                .result(Map.of("status", false, "message", msg))
                .build());
    }

    @Override
    public ResponseEntity getUserDetails(Map<String, String> request) {
        // Implementation remains same, can be copied from old file
        return null;
    }
}


















package com.tcs.userservice.controller;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.userservice.dto.PermissionOrderDto;
import com.tcs.userservice.dto.RoleRequestCreateDto;
import com.tcs.userservice.service.RoleRequestService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/role")
@RequiredArgsConstructor
public class RoleRequestController {

    private final RoleRequestService roleRequestService;
    private final JwtUtil jwtUtil;

    @GetMapping("/get-roles")
    public ResponseEntity getAllRoles(@RequestParam Map<String, Object> requestParams) {
        return roleRequestService.getAllRoles(requestParams);
    }

    // UPDATED: Now accepts DTO for type safety
    @PostMapping("/create-role-request")
    public ResponseEntity createNewRequest(@RequestBody RoleRequestCreateDto request, 
                                           @RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return roleRequestService.createNewRoleRequest(request, userId);
    }

    @GetMapping("/pending-role-requests")
    public ResponseEntity getPendingRequests(@RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return roleRequestService.getPendingRoleRequests(userId);
    }

    @PostMapping("/role-request-action")
    public ResponseEntity acceptRequest(@RequestBody Map<String, Object> request, 
                                        @RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return roleRequestService.acceptOrRejectRoleRequest(request, userId);
    }

    @GetMapping("/my-role-requests")
    public ResponseEntity getMyRequests(@RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return roleRequestService.getMyRoleRequests(userId);
    }

    @PostMapping("/cancel-role-request")
    public ResponseEntity cancelRoleRequest(@RequestBody Map<String, Object> request, 
                                            @RequestHeader("Authorization") String token) {
        return roleRequestService.cancelRoleRequest(request, jwtUtil.getUserIdFromToken(token));
    }

    @GetMapping("/get-all-permissions")
    public ResponseEntity getRoleWisePermissions() {
        return roleRequestService.getAllPermissions();
    }
    
    @PatchMapping("/save-permission-order")
    public ResponseEntity savePermissionOrder(@RequestBody PermissionOrderDto payload) {
        return roleRequestService.savePermissionOrder(payload);
    }
}

















package com.tcs.userservice.controller;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.userservice.dto.UserLogsDto;
import com.tcs.userservice.dto.UserRequestCreateDto;
import com.tcs.userservice.dto.UserRequestDto;
import com.tcs.userservice.service.UserLogsService;
import com.tcs.userservice.service.UserRequestService;
import com.tcs.userservice.utility.RequestUtility;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping("/user")
@RequiredArgsConstructor
public class UserRequestController {

    private final UserRequestService userRequestService;
    private final UserLogsService userLogsService;
    private final JwtUtil jwtUtil;

    // UPDATED: Now accepts DTO
    @PostMapping("/create-request")
    public ResponseEntity createNewRequest(@RequestBody UserRequestCreateDto request, 
                                           @RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return userRequestService.createNewRequest(request, userId);
    }

    @GetMapping("/pending-user-requests")
    public ResponseEntity getPendingRequests(@RequestParam Map<String, Object> params, 
                                             @RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return userRequestService.getPendingRequests(params, userId);
    }

    @PostMapping("/accept-request")
    public ResponseEntity acceptRequest(HttpServletRequest request, 
                                        @RequestBody UserRequestDto userRequest, 
                                        @RequestHeader("Authorization") String token) {
        String clientIp = RequestUtility.getClientIp(request);
        String userId = jwtUtil.getUserIdFromToken(token);
        userRequest.setApproverUserId(userId); 
        return userRequestService.acceptOrRejectUserRequest(userRequest, clientIp, userId);
    }

    @GetMapping("/user-details")
    public ResponseEntity getUserDetails(@RequestParam Map<String, String> request) {
        return userRequestService.getUserDetails(request);
    }

    @GetMapping("/my-requests")
    public ResponseEntity getMyRequests(@RequestParam Map<String, String> params) {
        return userRequestService.getMyRequests(params);
    }

    @PostMapping("/cancel-request")
    public ResponseEntity cancelRequest(@RequestBody Map<String, Object> request) {
        return userRequestService.cancelRequest(request);
    }

    @PostMapping("/logs-batch")
    public ResponseEntity<List<UserLogsDto>> createLogsBatch(@RequestBody List<UserLogsDto> payload) {
        List<UserLogsDto> savedLogs = (List<UserLogsDto>) userLogsService.saveLogs(payload);
        return new ResponseEntity<>(savedLogs, HttpStatus.CREATED);
    }

    @GetMapping("/all-logs")
    public ResponseEntity<List<UserLogsDto>> findAllLogs() {
        return ResponseEntity.ok(userLogsService.findAllLogs());
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserLogsDto> findLogById(@PathVariable Integer id) {
        return ResponseEntity.ok(userLogsService.findLogById(id));
    }
}

















package com.tcs.userservice.aspect;

import com.tcs.userservice.ResponseVO;
import com.tcs.userservice.dto.RoleRequestCreateDto;
import com.tcs.userservice.dto.UserRequestCreateDto;
import com.tcs.userservice.dto.UserRequestDto;
import com.tcs.userservice.model.UserLogs;
import com.tcs.userservice.repository.UserLogsRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;

import java.sql.Timestamp;
import java.time.Instant;
import java.util.Map;

@Aspect
@Component
@Slf4j
@RequiredArgsConstructor
public class UserActivityLogger {

    private final UserLogsRepository userLogsRepository;

    // Log User Creation (Handles DTO)
    @AfterReturning(
            pointcut = "execution(* com.tcs.userservice.service.UserRequestService.createNewRequest(..)) && args(request, userId)",
            returning = "result")
    public void logUserRequest(JoinPoint joinPoint, Object request, String userId, Object result) {
        if (isSuccess(result)) {
            String type = "UNKNOWN";
            String payload = "";
            
            if (request instanceof UserRequestCreateDto) {
                UserRequestCreateDto dto = (UserRequestCreateDto) request;
                type = dto.getRequestType();
                payload = dto.toString();
            } else if (request instanceof Map) {
                type = String.valueOf(((Map) request).get("requestType"));
                payload = request.toString();
            }
            saveLog(userId, "USER_REQUEST", type + " Request Raised", payload);
        }
    }

    // Log Role Creation (Handles DTO)
    @AfterReturning(
            pointcut = "execution(* com.tcs.userservice.service.RoleRequestService.createNewRoleRequest(..)) && args(request, userId)",
            returning = "result")
    public void logRoleRequest(JoinPoint joinPoint, Object request, String userId, Object result) {
        if (isSuccess(result)) {
            String payload = request.toString();
            saveLog(userId, "ROLE_REQUEST", "Role Request Raised", payload);
        }
    }

    // Log User Approval
    @AfterReturning(pointcut = "execution(* com.tcs.userservice.service.UserRequestService.acceptOrRejectUserRequest(..)) && args(dto, ip, userId)",
            returning = "result")
    public void logUserApproval(JoinPoint joinPoint, UserRequestDto dto, String ip, String userId, Object result) {
        if (!isSuccess(result)) return;
        String actionFlag = dto == null ? "" : dto.getActionFlag();
        String description = "Processed User Request (" + (dto != null ? dto.getRequestType() : "") + ") - " + actionFlag;
        saveLog(userId, "USER_" + actionFlag, description, "Target ID: " + dto.getRequestId());
    }
    
    // Log Role Approval
    @AfterReturning(pointcut = "execution(* com.tcs.userservice.service.RoleRequestService.acceptOrRejectRoleRequest(..)) && args(request, userId)",
            returning = "result")
    public void logRoleApproval(JoinPoint joinPoint, Map<String, Object> request, String userId, Object result) {
        if (isSuccess(result)) {
            String actionFlag = String.valueOf(request.get("actionFlag"));
            String requestId = String.valueOf(request.get("requestId"));
            saveLog(userId, "ROLE_" + actionFlag, "Processed Role Request", "Request ID: " + requestId);
        }
    }

    private void saveLog(String userId, String actionType, String changeType, String newValue) {
        try {
            UserLogs logEntry = new UserLogs();
            // Assuming UserID is Integer in Audit Table
            logEntry.setUserId(Integer.parseInt(userId)); 
            logEntry.setActionType(actionType);
            logEntry.setChangeType(changeType);
            logEntry.setActionTime(Timestamp.from(Instant.now()));
            if (newValue != null && newValue.length() > 3900) {
                newValue = newValue.substring(0, 3900) + "...";
            }
            logEntry.setNewValue(newValue);
            userLogsRepository.save(logEntry);
        } catch (Exception e) {
            log.error("Failed to save audit log", e);
        }
    }

    private boolean isSuccess(Object result) {
        if (result instanceof ResponseEntity) {
            ResponseEntity<?> response = (ResponseEntity<?>) result;
            if (!response.getStatusCode().is2xxSuccessful()) return false;
            // Add specific business check if needed
            return true;
        }
        return false;
    }
}



