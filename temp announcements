package com.tcs.fincore.CommonMasterService.advice;

import com.tcs.fincore.CommonMasterService.dto.ApiResponse;
import org.springframework.core.MethodParameter;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

/**
 * This ControllerAdvice intercepts successful responses from any @RestController
 * and wraps them in a standard ApiResponse format.
 */
@ControllerAdvice
public class ApiResponseWrapper implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        // This advice applies to any method in a class annotated with @RestController
        // that is not already returning a ResponseEntity (which gives manual control).
        return AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), RestController.class) && !returnType.getParameterType().equals(ResponseEntity.class);
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class<? extends HttpMessageConverter<?>> selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {

        // If the controller has already manually wrapped the response, do nothing.
        if (body instanceof ApiResponse<?>) {
            return body;
        }

        // Wrap the successful response body in the standard ApiResponse structure.
        return ApiResponse.success(body);
    }
}












// config

package com.tcs.fincore.CommonMasterService.config;

import com.fincore.commonutilities.config.CommonSecurityConfig;
import com.fincore.commonutilities.config.RedisConfig;
import com.fincore.commonutilities.jwt.JwtUtil;
import com.fincore.commonutilities.security.ContextRbacFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/**
 * Common Security Configuration.
 * * Aligned with the "Distributed Gateway" architecture.
 * It uses the ContextRbacFilter from Common Utilities to enforce:
 * 1. Token Validity
 * 2. Single Session (Redis check)
 * 3. RBAC Permissions
 */
@Configuration
@EnableWebSecurity
@Import({RedisConfig.class, JwtUtil.class, CommonSecurityConfig.class}) // Import logic from JAR
public class SecurityConfig {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private CommonSecurityConfig commonSecurityConfig; // Wire in the CORS config

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                // 1. Disable CSRF (Stateless API)
                .csrf(csrf -> csrf.disable())

                // 2. Apply Centralized CORS Policy
                .cors(cors -> cors.configurationSource(commonSecurityConfig.corsConfigurationSource()))

                // 3. Stateless Session (No JSESSIONID)
                .sessionManagement(s -> s.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                // 4. Authorization Rules
                .authorizeHttpRequests(authz -> authz
                        // Public Endpoints
                        .requestMatchers("/actuator/**", "/auth/**", "/error").permitAll()
                        // All other endpoints require Authentication (and RBAC filter check)
                        .anyRequest().authenticated()
                )

                // 5. Add the "Distributed Gateway" Filter
                .addFilterBefore(new ContextRbacFilter(redisTemplate, jwtUtil), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}










// controller
package com.tcs.fincore.CommonMasterService.Controller;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.fincore.CommonMasterService.dto.AnnouncementDto;
import com.tcs.fincore.CommonMasterService.service.AnnouncementService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;


/**
 * AnnouncementController :-
 *
 * This controller handles API requests related to Announcement Screen.
 * It provides endpoints for Admin Management Screen: For creating, editing, and toggling announcements
 *
 * @author Shubhankar [v1018405]
 * @version 1.0
 * @since 2025-12-11
 */
@RestController
@RequestMapping("/announcements")
@RequiredArgsConstructor
public class AnnouncementController {
    private final AnnouncementService service;
    private final JwtUtil jwtUtil;

    /**
     * 1. CREATE ANNOUNCEMENT
     */
    @PostMapping
    public ResponseEntity<AnnouncementDto> create(
            @RequestHeader("Authorization") String token,
            @Valid @RequestBody AnnouncementDto dto) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return ResponseEntity.ok(service.createAnnouncement(dto, userId));
    }

    /**
     * 2. UPDATE ANNOUNCEMENT
     */
    @PutMapping("/{id}")
    public ResponseEntity<AnnouncementDto> update(
            @RequestHeader("Authorization") String token,
            @PathVariable Long id,
            @Valid @RequestBody AnnouncementDto dto) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return ResponseEntity.ok(service.updateAnnouncement(id, dto, userId));
    }

    /**
     * 3. LIST ALL
     * Used for the Management Grid.
     */
    @GetMapping("/list")
    public ResponseEntity<List<AnnouncementDto>> listAll() {
        return ResponseEntity.ok(service.getAllAnnouncements());
    }

    /**
     * 4. TOGGLE STATUS
     * Returns the updated DTO so UI can reflect the new Status immediately.
     */
    @PatchMapping("/{id}/toggle")
    public ResponseEntity<AnnouncementDto> toggle(@PathVariable Long id) {
        // No Token needed for toggle if we don't track "Who toggled it",
        // otherwise add @RequestHeader("Authorization") and pass userId to service.
        return ResponseEntity.ok(service.toggleStatus(id));
    }
}








package com.tcs.fincore.CommonMasterService.Controller;

import com.tcs.fincore.CommonMasterService.dto.ApiResponse;
import com.tcs.fincore.CommonMasterService.dto.BalanceRequestDTO;
import com.tcs.fincore.CommonMasterService.dto.BalanceResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.PaginatedResponseDto;
import com.tcs.fincore.CommonMasterService.service.CommonMasterService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/balance-enquiry")
@RequiredArgsConstructor
public class BalanceController {

    private final CommonMasterService service;

    @PostMapping("/enquires")
    public ResponseEntity<ApiResponse<PaginatedResponseDto<BalanceResponseDTO>>> getBalance(
            @RequestBody BalanceRequestDTO request) {

        PaginatedResponseDto<BalanceResponseDTO> result = service.getBalanceDetails(request);
        return ResponseEntity.ok(ApiResponse.success(result, "Balance records fetched Successfully"));
    }

    @PostMapping("/export")
    public ResponseEntity<byte[]> exportBalance(@RequestBody BalanceRequestDTO request) {
        byte[] bytes = service.exportBalanceToExcel(request);
        return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, "atttachmet; filename=balance_enquiry.xlsx")
                .contentType(
                        MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"))
                .body(bytes);
    }

}








package com.tcs.fincore.CommonMasterService.Controller;

import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.tcs.fincore.CommonMasterService.dto.ApiResponse;
import com.tcs.fincore.CommonMasterService.dto.BranchStateCircleResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CGLSegmentResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CglSearchRequest;
import com.tcs.fincore.CommonMasterService.dto.PaginatedResponseDto;
import com.tcs.fincore.CommonMasterService.model.BranchCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.BranchMaster;
import com.tcs.fincore.CommonMasterService.model.CGLCodeDescriptionOnly;
import com.tcs.fincore.CommonMasterService.model.CGLMaster;
import com.tcs.fincore.CommonMasterService.model.CalenderConfigModel;
import com.tcs.fincore.CommonMasterService.model.CircleMaster;
import com.tcs.fincore.CommonMasterService.model.CurrencyCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.CurrencyMasterModel;
import com.tcs.fincore.CommonMasterService.model.CurrencyRateChange;
import com.tcs.fincore.CommonMasterService.model.SegmentCodeMaster;
import com.tcs.fincore.CommonMasterService.model.StateMaster;
import com.tcs.fincore.CommonMasterService.model.ZoneMaster;
import com.tcs.fincore.CommonMasterService.repository.BranchMasterWithStateCircleRepository;
import com.tcs.fincore.CommonMasterService.service.CommonMasterService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@RestController
public class CommonMasterController {

	private final CommonMasterService service;

	@GetMapping("/segment-codes")
	public List<SegmentCodeMaster> getSegmentCodes(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getSegmentCodes();
	}

	@PostMapping("/cgls")
	public PaginatedResponseDto<CGLMaster> getCGLs(
			@RequestHeader("Authorization") String authorizationHeader,
			@RequestBody CglSearchRequest request) {
		return service.getCGLs(request);
	}

	@GetMapping("/cgl-code-description-only")
	public List<CGLCodeDescriptionOnly> getCGLsCodeDescriptionOnly(@RequestParam String q) {
		return service.getCGLsCodeDescriptionOnly(q);
	}

	@GetMapping("/cgl-codes")
	public List<String> getCGLCodes(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCGLCodes();
	}

	@GetMapping("/states")
	public List<StateMaster> getStateList(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getStateList();
	}

	@GetMapping("/branches")
	public List<BranchMaster> getBranches(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getBranches();
	}

	@GetMapping("/branches-code-name-only")
	public List<BranchCodeNameOnly> getBranchesCodeNameOnly(@RequestParam String q) {
		return service.getBranchesCodeNameOnly(q);
	}

	@GetMapping("/zone-codes")
	public List<ZoneMaster> getZoneCodes() {
		return service.getZoneCodes();
	}

	@GetMapping("/circle-codes")
	public List<CircleMaster> getCircleList() {
		return service.getCircleList();
	}

	@GetMapping("/currency-master")
	public List<CurrencyMasterModel> getCurrency(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCurrency();
	}

	@GetMapping("/currency-code-name-only")
	public List<CurrencyCodeNameOnly> getCurrencyCodeNameOnly(
			@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCurrencyCodeNameOnly();
	}

	@GetMapping("/currency")
	public List<String> getCurrencys(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCurrencys();
	}

	@GetMapping("/calendar-configuration")
	public CalenderConfigModel getCalenderConfig(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getCalenderConfig();
	}

	@GetMapping("/currency-rate-change")
	public List<CurrencyRateChange> getRateChange(@RequestHeader("Authorization") String authorizationHeader) {
		return service.getRateChange();
	}

	@GetMapping("/branchesNewAPI")
	public Page<BranchMaster> getBranchNames(Pageable pageable) {
		return service.getBranchNames(pageable);
	}

	@GetMapping("/viewCgl")
	public ResponseEntity<ApiResponse<PaginatedResponseDto<CGLSegmentResponseDTO>>> searchCglWithSegment(
			@RequestParam String cglCodeOrDesc, @RequestParam(required = false) Integer page,
			@RequestParam(required = false) Integer size) {

		PaginatedResponseDto<CGLSegmentResponseDTO> result = service.searchCglWithSegment(cglCodeOrDesc, page, size);

		return ResponseEntity.ok(ApiResponse.success(result, "CGL Details fetched Successfully"));
	}

	
	@GetMapping("/viewBranch")
	public ResponseEntity<ApiResponse<List<BranchStateCircleResponseDTO>>> searchByBranchNameORCode(
			@RequestParam String branchCodeOrName) {
		List<BranchStateCircleResponseDTO> result = service.searchByBranchNameORCode(branchCodeOrName);
		return ResponseEntity.ok(ApiResponse.success(result, "Branch Details Feched Successfully"));
	}

}








// DTO

package com.tcs.fincore.CommonMasterService.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AnnouncementDto {

    private Long id;

    @NotBlank(message = "Title is required")
    private String title;

    @NotBlank(message = "Message content is required")
    private String message;

    private String severity; // INFO, WARN, CRITICAL

    private List<String> targetRoles; // e.g. ["51", "55"] or ["ALL"]

    // Used for Request (Post/Edit)
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startDate;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Future(message = "Expiry date must be in the future")
    private LocalDateTime expiryDate;

    private String isActive; // 'Y' or 'N'

    // Derived Status for UI (e.g. "ACTIVE", "EXPIRED", "SCHEDULED", "DISABLED")
    private String displayStatus;

    // Read-only fields
    private String createdBy;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createdAt;
}






package com.tcs.fincore.CommonMasterService.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Getter;

import java.time.Instant;

@Getter
@JsonInclude(JsonInclude.Include.NON_NULL) // Don't include null fields in the JSON response
public class ApiResponse<T> {

    private final boolean success;
    private final String message;
    private final T data;
    private final Instant timestamp;

    private ApiResponse(boolean success, String message, T data) {
        this.success = success;
        this.message = message;
        this.data = data;
        this.timestamp = Instant.now();
    }

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, message, data);
    }

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, "Operation completed successfully.", data);
    }

    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(false, message, null);
    }
}








package com.tcs.fincore.CommonMasterService.dto;

import java.util.Date;

import com.fasterxml.jackson.annotation.JsonFormat;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class BalanceRequestDTO {

    @NotNull(message = "Branch is required")
    private String branch;

    @NotNull(message = "CGL is required")
    private String cgl;

    @NotNull(message = "Currency is required")
    private String currency;

    @NotNull(message = "End date is required")
    @JsonFormat(pattern = "dd-MM-yyyy")
    private Date endDate;

    @NotNull(message = "Start date is required")
    @JsonFormat(pattern = "dd-MM-yyyy")
    private Date startDate;

    private Integer page;

    private Integer size;

    private String sortIn;

}










package com.tcs.fincore.CommonMasterService.dto;

import java.util.Date;

import com.fasterxml.jackson.annotation.JsonFormat;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class BalanceResponseDTO {
    
    private Integer id;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd-MM-yyyy")
    private Date date;

    private String branch;

    private String cgl;

    private String currency;

    private Double balance;

}








package com.tcs.fincore.CommonMasterService.dto;

import java.util.Date;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BranchStateCircleResponseDTO {

    private String branchCode;
    private String branchName;
    private String branchCity;

    private String circleCode;
    private String circleName;

    private String stateCode;
    private String stateName;

    private String address;
    private String pinCode;
    private String phoneNumber;
    private String emailId;
    private String nmrCode;
    private Boolean status;
    private Date openDate;
    private Date closeDate;
    private Date mergeDate;
    private String mergedWithBranch;
    private Date lastChangeDate;
    private Boolean cpcFlag;
    private Boolean foodCreditFlag;
    private Boolean currChestFlag;
    private String branchType;

}










package com.tcs.fincore.CommonMasterService.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class CglFilterRequest {
    private String field;
    private String operator;
    private String value;
}









package com.tcs.fincore.CommonMasterService.dto;

import lombok.Getter;
import lombok.Setter;
import java.util.List;

@Getter
@Setter
public class CglSearchRequest {
    private String requestType;
    private int page;
    private int size;
    private List<CglFilterRequest> filters;
}






package com.tcs.fincore.CommonMasterService.dto;

import java.time.LocalDate;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CGLSegmentResponseDTO {
    
    private String cglNumber;
    private String description;

    private String comp1;
    private String comp2;
    private String acClassification;
    
    private String segmentCode;
    private String segmentDescription;

    private Integer balFwd;
    private String defValType;
    private Integer status;
    private LocalDate openDate;
    private LocalDate closeDate;
    private Integer balcompare;
    private Integer manualPosting;

    
}






package com.tcs.fincore.CommonMasterService.dto;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class PaginatedResponseDto<T> {

    private int currentPage;
    private int totalPages;
    private int pageSize;
    private long totalElements;
    private String sortIn;
    private List<T> data;
    
    

}







package com.tcs.fincore.CommonMasterService.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.tcs.fincore.CommonMasterService.dto.ApiResponse;

import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NoDataFoundException.class)
    public ResponseEntity<ApiResponse<?>> handleNoData(NoDataFoundException e) {
        return ResponseEntity.ok(ApiResponse.error(e.getMessage()));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<?>> handleValidationErrors(MethodArgumentNotValidException e) {
        String errorMsg = e.getBindingResult().getFieldError().getDefaultMessage();
        return ResponseEntity.badRequest().body(ApiResponse.error(errorMsg));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<?>> handleGeneralException(Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("Spmething went wrong: " + e.getMessage()));
    }

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<Map<String, String>> handleIllegalState(IllegalStateException ex) {
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(Map.of("error", "Validation Error", "message", ex.getMessage()));
    }

}








package com.tcs.fincore.CommonMasterService.exception;

public class NoDataFoundException extends RuntimeException{

    public NoDataFoundException(String message){
        super(message);
    }

}







package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.*;
import lombok.Data;

import java.time.LocalDateTime;
import java.util.Date;

@Entity
@Table(name = "ANNOUNCEMENTS")
@Data
public class Announcements {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID")
    private Long id;

    @Column(name = "TITLE")
    private String title;

    @Column(name = "MESSAGE")
    private String message;

    @Column(name = "SEVERITY")
    private String severity;

    @Column(name = "TARGET_ROLE", length = 255)
    private String targetRole; // Stored as "51,55,53" or "ALL"

    @Column(name = "START_DATE")
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime startDate;

    @Column(name = "EXPIRY_DATE")
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime expiryDate;

    @Column(name = "IS_ACTIVE")
    private String isActive;  

    @Column(name = "CREATED_BY")
    private String createdBy;

    @Column(name = "CREATED_AT")
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime createdAt;
}










package com.tcs.fincore.CommonMasterService.model;

import java.util.Date;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Table(name = "GL_BALANCE")
@Entity
public class BalanceRecord {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID")
    private Integer id;

    @Column(name = "BRANCH_CODE", nullable = false)
    private String branch;

    @Column(name = "CGL", nullable = false)
    private String cgl;

    @Column(name = "CURRENCY", nullable = false)
    private String currency;

    @Column(name = "BALANCE", nullable = false)
    private double balance;

    @Temporal(TemporalType.DATE)
    @Column(name = "BALANCE_DATE", nullable = false)
    private Date date;

}








package com.tcs.fincore.CommonMasterService.model;

public interface BranchCodeNameOnly {
	String getCode();

	String getName();
}




package com.tcs.fincore.CommonMasterService.model;

import java.util.Date;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Entity
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "BRANCH_MASTER")
public class BranchMaster {
	@Id
	@Column(name = "CODE", nullable = false, length = 5, updatable = false)
	private String code;

	@Column(name = "NAME", nullable = false, length = 50)
	private String name;

	@Column(name = "CIRCLE_CODE", nullable = false, length = 5)
	private String circleCode;

	@Column(name = "STATE", nullable = false, length = 50)
	private String state;

	@Column(name = "CITY", nullable = true, length = 50)
	private String city;

	@Column(name = "ADDRESS", nullable = true, length = 50)
	private String address;

	@Column(name = "PINCODE", nullable = true, length = 6)
	private String pinCode;

	@Column(name = "PHONE_NUMBER", nullable = false, length = 12)
	private String phoneNumber;

	@Column(name = "EMAIL_ID", nullable = false, length = 50)
	private String emailId;

	@Column(name = "NMR_CODE", nullable = false, length = 50)
	private String nmrCode;

	@Column(name = "STATUS", nullable = false)
	private Boolean status;

	@Column(name = "OPEN_DATE", nullable = false, updatable = false)
	private Date openDate;

	@Column(name = "CLOSE_DATE")
	private Date closeDate;

	@Column(name = "MERGE_DATE")
	private Date mergeDate;

	@Column(name = "MERGED_WITH_BRANCH", length = 5)
	private String mergedWithBranch;

	@Column(name = "LAST_CHANGE_DATE")
	private Date lastChangeDate;

	@Column(name = "CPC_FLAG", nullable = false)
	private Boolean cpcFlag;

	@Column(name = "FOOD_CREDIT_FLAG", nullable = false)
	private Boolean foodCreditFlag;

	@Column(name = "CURR_CHEST_FLAG", nullable = false)
	private Boolean currChestFlag;

	@Column(name = "BRANCH_TYPE", length = 1)
	private String branchType;
}









package com.tcs.fincore.CommonMasterService.model;

import java.util.Date;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Entity
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "BRANCH_MASTER")
public class BranchMasterWithCircleState {
    @Id
    @Column(name = "CODE", nullable = false, length = 5, updatable = false)
    private String code;

    @Column(name = "NAME", nullable = false, length = 50)
    private String name;

    @Column(name = "CIRCLE_CODE", nullable = false, length = 5)
    private String circleCode;

    @Column(name = "STATE", nullable = false, length = 50)
    private String stateCode;

    @Column(name = "CITY", nullable = true, length = 50)
    private String city;

    @Column(name = "ADDRESS", nullable = true, length = 50)
    private String address;

    @Column(name = "PINCODE", nullable = true, length = 6)
    private String pinCode;

    @Column(name = "PHONE_NUMBER", nullable = false, length = 12)
    private String phoneNumber;

    @Column(name = "EMAIL_ID", nullable = false, length = 50)
    private String emailId;

    @Column(name = "NMR_CODE", nullable = false, length = 50)
    private String nmrCode;

    @Column(name = "STATUS", nullable = false)
    private Boolean status;

    @Column(name = "OPEN_DATE", nullable = false, updatable = false)
    private Date openDate;

    @Column(name = "CLOSE_DATE")
    private Date closeDate;

    @Column(name = "MERGE_DATE")
    private Date mergeDate;

    @Column(name = "MERGED_WITH_BRANCH", length = 5)
    private String mergedWithBranch;

    @Column(name = "LAST_CHANGE_DATE")
    private Date lastChangeDate;

    @Column(name = "CPC_FLAG", nullable = false)
    private Boolean cpcFlag;

    @Column(name = "FOOD_CREDIT_FLAG", nullable = false)
    private Boolean foodCreditFlag;

    @Column(name = "CURR_CHEST_FLAG", nullable = false)
    private Boolean currChestFlag;

    @Column(name = "BRANCH_TYPE", length = 1)
    private String branchType;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "STATE", referencedColumnName = "STATE_CODE", insertable = false, updatable = false)
    private StateMaster state;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "CIRCLE_CODE", referencedColumnName = "CIRCLE_CODE", insertable = false, updatable = false)
    private CircleMaster circle;

}











package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.*;
import lombok.Data;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "CALENDER_CONFIG")
@Data
public class CalenderConfigModel {

    @Id
    @Column(name = "ID")
    private Long id;

    @Column(name = "YEAR_START_DATE", nullable = false)
    private LocalDate yearStartDate;

    @Column(name = "YEAR_END_DATE", nullable = false)
    private LocalDate yearEndDate;

    @Column(name = "REMARKS", nullable = false, length = 255)
    private String remarks;

    @Column(name = "APPROVEDAT")
    private LocalDateTime approvedAt;

    @Column(name = "APPROVEDBY", length = 50)
    private String approvedBy;

    @Column(name = "REQUESTEDAT")
    private LocalDateTime requestedAt;

    @Column(name = "REQUESTEDBY", length = 50)
    private String requestedBy;

}









package com.tcs.fincore.CommonMasterService.model;

public interface CGLCodeDescriptionOnly {
	String getCglNumber();

	String getDescription();
}







package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;
import org.hibernate.annotations.Generated;
import org.hibernate.generator.EventType;

import java.time.LocalDate;

@Getter
@Setter
@Entity
@Table(name = "CGL_MASTER")
public class CGLMaster {
    @Id
    @Generated(event = EventType.INSERT)
    @Column(name = "CGL_NUMBER", insertable = false, updatable = false)
    private String cglNumber;

    @Column(name = "COMP_1", nullable = false)
    private String comp1;

    @Column(name = "SEGMENT_CODE", nullable = false)
    private String segmentCode;

    @Column(name = "COMP_2", nullable = false)
    private String comp2;

    @Column(name = "DESCRIPTION", nullable = false, length = 100)
    private String description;

    @Column(name = "AC_CLASSIFICATION", nullable = false, length = 1)
    private String acClassification;

    @Column(name = "BAL_FWD", nullable = false)
    private Integer balFwd = 0;

    @Column(name = "DEF_BAL_TYPE", nullable = false, length = 1)
    private String defBalType;

    @Column(name = "STATUS", nullable = false)
    private Integer status;

    @ColumnDefault("SYSDATE")
    @Generated(event = EventType.INSERT)
    @Column(name = "OPEN_DATE", nullable = false, insertable = false, updatable = false)
    private LocalDate openDate;

    @Column(name = "CLOSE_DATE")
    private LocalDate closeDate;

    @Column(name = "BAL_COMPARE", nullable = false)
    private Integer balCompare = 0;

    @Column(name = "MANUAL_POSTING", nullable = false)
    private Integer manualPosting = 0;
}










package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.ColumnDefault;
import org.hibernate.annotations.Generated;
import org.hibernate.generator.EventType;

import java.time.LocalDate;

@Getter
@Setter
@Entity
@Table(name = "CGL_MASTER")
public class CGLMasterWithSegment {
    @Id
    // @Generated(event = EventType.INSERT)
    @Column(name = "CGL_NUMBER", insertable = false, updatable = false)
    private String cglNumber;

    @Column(name = "COMP_1", nullable = false)
    private String comp1;

    @Column(name = "SEGMENT_CODE", nullable = false)
    private String segmentCode;

    @Column(name = "COMP_2", nullable = false)
    private String comp2;

    @Column(name = "DESCRIPTION", nullable = false, length = 100)
    private String description;

    @Column(name = "AC_CLASSIFICATION", nullable = false, length = 1)
    private String acClassification;

    @Column(name = "BAL_FWD", nullable = false)
    private Integer balFwd = 0;

    @Column(name = "DEF_BAL_TYPE", nullable = false, length = 1)
    private String defBalType;

    @Column(name = "STATUS", nullable = false)
    private Integer status;

    @ColumnDefault("SYSDATE")
    @Generated(event = EventType.INSERT)
    @Column(name = "OPEN_DATE", nullable = false, insertable = false, updatable = false)
    private LocalDate openDate;

    @Column(name = "CLOSE_DATE")
    private LocalDate closeDate;

    @Column(name = "BAL_COMPARE", nullable = false)
    private Integer balCompare = 0;

    @Column(name = "MANUAL_POSTING", nullable = false)
    private Integer manualPosting = 0;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "SEGMENT_CODE", referencedColumnName = "SEGMENT_CODE", insertable = false,updatable =false)
    private SegmentCodeMaster segment;

}














package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;
import java.util.Date;

@Entity
@Getter
@Setter
@Table(name="CIRCLE_MASTER")
public class CircleMaster{
	
	@Id 
	@Column(name="CIRCLE_CODE" , nullable = false , length = 3)
	public String circleCode;
	
	@Column(name="CIRCLE_NAME", nullable = false , length = 150)
	public String circleName;
	
	@Column(name="ZONE_CODE", nullable = false , length = 3)
	public String zoneCode;
	
	@Column(name="CREATED_DATE", insertable = false )
	public Date createdDate;
	
	
}







package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Data
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "CURRENCY_RATE_CHANGE")
public class Currency_Rate_Change_Model {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "currency_code", nullable = false, length = 3)
    private String currencyCode;

    @Column(name = "currency_rate", nullable = false, precision = 19, scale = 9)
    private BigDecimal currencyRate;

    @Column(name = "rate_change_date")
    private LocalDateTime rateChangeDate;


    @PreUpdate
    public void onPreUpdate() {
        this.rateChangeDate = LocalDateTime.now();
    }

 
    @PrePersist
    public void onPrePersist() {
        this.rateChangeDate = LocalDateTime.now();
    }
}











package com.tcs.fincore.CommonMasterService.model;

public interface CurrencyCodeNameOnly {
	String getCurrencyCode();

	String getCurrencyName();
}








package com.tcs.fincore.CommonMasterService.model;


import java.time.LocalDateTime;
import java.util.Date;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "CURRENCY_MASTER")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor

public class CurrencyMasterModel {
 
     @Id
     @Column(name = "CURRENCY_CODE", nullable = false, unique = true, length = 3)
     private String currencyCode;

     @Column(name = "CURRENCY_NAME", nullable = false, length = 50)
     private String currencyName;

     @Column(name = "FLAG", nullable = false)
     private Integer flag;

     @Column(name = "CURRENCY_RATE")
     private BigDecimal currencyRate;

     @Column(name = "RATE_DATE")
     private Date rateDate;

     @Column(name = "CREATED_AT", updatable = false)
     private LocalDateTime createdAt;

     @Column(name = "UPDATED_AT")
     private LocalDateTime updatedAt;

     @PrePersist
     
     protected void onCreate() {
         this.createdAt = LocalDateTime.now();
         this.updatedAt = LocalDateTime.now();
     }

     @PreUpdate
     protected void onUpdate() {
         this.updatedAt = LocalDateTime.now();
     }
 
 
 
}











package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Data
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "CURRENCY_RATE_CHANGE")
public class CurrencyRateChange {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "currency_code", nullable = false, length = 3)
    private String currencyCode;

    @Column(name = "currency_rate", nullable = false, precision = 19, scale = 9)
    private BigDecimal currencyRate;

    @Column(name = "rate_change_date")
    private LocalDateTime rateChangeDate;


    @PreUpdate
    public void onPreUpdate() {
        this.rateChangeDate = LocalDateTime.now();
    }

 
    @PrePersist
    public void onPrePersist() {
        this.rateChangeDate = LocalDateTime.now();
    }
}








package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp; // Import this
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.io.Serializable;
import java.time.Instant; // This is the correct type
import java.util.Objects;
import java.util.UUID;

/**
 * Represents an event in the outbox system, intended for notification purposes.
 * This entity maps to the {@code notification_table} in the database. It captures all necessary details
 * for a notification to be processed and displayed to a user or a group of users (via roles).
 * <p>
 * The {@code @CreationTimestamp} annotation ensures that the {@code eventTimestamp} is automatically
 * populated upon entity creation, providing an accurate record of when the event occurred.
 * </p>
 */
@Entity
@Table(name = "notifications")
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class NotificationTable implements Serializable {

    /**
     * Unique primary key for the outbox event.
     * Uses a generated {@link UUID} strategy, which is suitable for Oracle's SYS_GUID() or RAW(16) columns.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "EVENT_ID", updatable = false, nullable = false)
    private UUID eventId;

    /**
     * The ID of the user who should receive this notification (for 1-to-1 notifications).
     * This field is used when targeting a specific user.
     */
    @Column(name = "USER_ID", length = 255)
    private String userId;

    /**
     * The human-readable message to be displayed in the UI.
     * This is the main content of the notification.
     */
    @Column(name = "MESSAGE", length = 1024, nullable = false)
    private String message;

    /**
     * The relative URL the user should be taken to when clicking the notification.
     * Provides a direct link to the relevant business object or view.
     */
    @Column(name = "LINK_URL", length = 1024)
    private String linkUrl;

    /**
     * The microservice that generated this event.
     * Helps in tracing the origin of the notification within a microservice architecture.
     */
    @Column(name = "EVENT_SOURCE", length = 100)
    private String eventSource;

    /**
     * The primary key of the related business object (e.g., the Common Request ID).
     * Used to link the notification back to the original business data.
     */
    @Column(name = "AGGREGATE_ID", length = 255)
    private String aggregateId;

    /**
     * The timestamp when the event was created.
     * Automatically populated using {@link CreationTimestamp} and stored as an {@link Instant}.
     * The column is both non-nullable and non-updatable after creation.
     */
    @CreationTimestamp
    @Column(name = "EVENT_TIMESTAMP", nullable = false, updatable = false)
    private Instant eventTimestamp;

    /**
     * For 1-to-Many notifications. If {@code userId} is null, this role is used to determine the recipients.
     * Enables broadcasting notifications to all users within a specific role.
     */
    @Column(name = "TARGET_ROLE", length = 100)
    private String targetRole;


    /**
     * Compares this NotificationTable entity with another object for equality based solely on the {@code eventId}.
     *
     * @param o The object to compare with.
     * @return true if the objects are equal (have the same eventId), false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        NotificationTable that = (NotificationTable) o;
        return Objects.equals(eventId, that.eventId);
    }

    /**
     * Generates a hash code for the NotificationTable entity based solely on the {@code eventId}.
     *
     * @return The hash code.
     */
    @Override
    public int hashCode() {
        return Objects.hash(eventId);
    }


    /**
     * Provides a string representation of the NotificationTable entity, primarily for logging and debugging purposes.
     *
     * @return A string containing key fields of the entity.
     */
    @Override
    public String toString() {
        return "NotificationTable{" +
                "eventId='" + eventId + '\'' +
                ", userId='" + userId + '\'' +
                ", targetRole='" + targetRole + '\'' +
                ", eventSource='" + eventSource + '\'' +
                ", aggregateId='" + aggregateId + '\'' +
                ", eventTimestamp=" + eventTimestamp +
                '}';
    }
}












package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "SEGMENT_CODE_MASTER")
public class SegmentCodeMaster {
    @Id
    @Column(name = "SEGMENT_CODE", nullable = false, length = 4)
    private String segmentCode;

    @Column(name = "DESCRIPTION", nullable = false, length = 100)
    private String description;
}








package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "STATE_MASTER")
public class StateMaster {

    @Id
    @Column(name = "STATE_CODE", nullable = false, length = 4)
    private String StateCode;

    @Column(name = "NAME", nullable = false, length = 20)
    private String stateName;
}






package com.tcs.fincore.CommonMasterService.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "ZONE_MASTER")
public class ZoneMaster {
	
	@Id
    @Column(name = "ID")
    private String id;

    @Column(name = "ZONE_DESC")
    private String description;
	
}

