package com.tcs.userservice.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.userservice.ResponseVO;
import com.tcs.userservice.dto.*;
import com.tcs.userservice.model.*;
import com.tcs.userservice.repository.PermissionsRepository;
import com.tcs.userservice.repository.RolePermissionsRepository;
import com.tcs.userservice.repository.RoleRepository;
import com.tcs.userservice.repository.RoleRequestRepository;
import com.tcs.userservice.utility.ClobUtil;
import com.tcs.userservice.utility.Constant;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class RoleRequestServiceImpl implements RoleRequestService {

    // =============== CONFIGURATION CONSTANTS ======
    private static final String EVENT_SOURCE = "USER_SERVICE";
    private static final String REQUEST_TYPE_KEY = "ROLE_MANAGEMENT";
    private static final List<String> HIDDEN_ROLES = Arrays.asList("ADMIN");
    private static final String RESTRICTED_PERMISSION_TITLE = "Role Management";

    private final RoleRequestRepository roleRequestRepository;
    private final RoleRepository roleRepository;
    private final ObjectMapper objectMapper;
    private final RoleService roleService;
    private final PermissionsRepository permissionsRepository;
    private final RolePermissionsRepository rolePermissionsRepository;
    private final CacheManager cacheManager;
    private final PermissionConfigService permissionConfigService;
    private final NotificationWriterService notificationWriterService;

    private String formatTimestamp(Timestamp ts) {
        if (ts == null)
            return null;
        // Use SimpleDateFormat to strictly control output string
        // This produces "2026-01-02T14:14:00.123"
        return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(ts);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<RoleRequest>> createNewRoleRequest(RoleRequestCreateDto dto, String userId) {

        RoleRequest roleRequest = new RoleRequest();
        roleRequest.setRequestType(dto.getRequestType());
        roleRequest.setTargetRoleId(dto.getTargetRoleId());
        roleRequest.setRequestorUserId(userId);
        roleRequest.setRequestStatus(Constant.PENDING);
        roleRequest.setRequestDate(LocalDateTime.now(ZoneId.of("Asia/Kolkata")));

        String finalJsonPayload;
        Map<String, Object> payloadMap;
        try {
            if (dto.getRequestPayload() instanceof String) {
                // Case 1: Frontend sent a Stringified JSON "{\"roleName\":...}"
                finalJsonPayload = (String) dto.getRequestPayload();
                payloadMap = objectMapper.readValue(finalJsonPayload, Map.class);
            } else {
                // Case 2: Frontend sent a real JSON Object {"roleName":...}
                payloadMap = (Map<String, Object>) dto.getRequestPayload();
                finalJsonPayload = objectMapper.writeValueAsString(payloadMap);
            }
            roleRequest.setRequestPayload(finalJsonPayload);
        } catch (Exception e) {
            throw new IllegalArgumentException("Invalid JSON payload structure", e);
        }

        boolean isCreate = Constant.CREATE.equalsIgnoreCase(dto.getRequestType());
        String roleName = (String) payloadMap.get("roleName");

        validateRequest(isCreate, dto.getTargetRoleId(), roleName);

        if (isCreate) {
            roleRequest.setTargetRoleId(roleRequestRepository.getNewRoleIdOnCreation());
        }

        RoleRequest saved = roleRequestRepository.save(roleRequest);

        // 1. Notification (To Approvers)
        // Msg: "New Role Request (ID: 55) for Role 51 (MODIFY) is pending approval."
        String notifMsg = String.format("New Role Request (ID: %s) for Role %s (%s) is pending approval.",
                saved.getRequestId(), saved.getTargetRoleId(), saved.getRequestType());

        NotificationConfigDto config = permissionConfigService.getConfig(REQUEST_TYPE_KEY);

        createNotification(
                saved.getRequestorUserId(), // creator exclusion
                config.getTargetRoles(),
                config.getTargetUrl(),
                notifMsg,
                String.valueOf(saved.getRequestId()));

        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ResponseVO.<RoleRequest>builder()
                        .statusCode(HttpStatus.CREATED)
                        .message("Request Created")
                        .result(saved)
                        .build());
    }

    private void validateRequest(boolean isCreate, int roleId, String roleName) {
        // 1. Validate ID conflict
        if (isCreate) {
            Role existingRole = roleRepository.findRoleByRoleId(roleId);
            if (existingRole != null) {
                throw new IllegalArgumentException("Role ID " + roleId + " already exists in the system.");
            }
            // 2. Validate Name Conflict (Master Table) - Case Insensitive, Trimmed
            if (roleName != null && !roleName.trim().isEmpty()) {
                // Check Master Table (e.g. F1/BOG vs f1/bog)
                if (roleRepository.existsByRoleNameIgnoreCase(roleName.trim())) {
                    throw new IllegalArgumentException(
                            "Role Name '" + roleName + "' already exists. Please choose a different name.");
                }
                // Check Pending Requests
                if (roleRequestRepository.countPendingRoleRequestsByRoleName(roleName.trim().toLowerCase()) > 0) {
                    throw new IllegalArgumentException(
                            "The request for Role Name " + roleName + " is already pending approval.");
                }
            } else {
                throw new IllegalArgumentException("Role Name cannot be empty.");
            }
        } else {
            // Modification Validation
            if (roleRequestRepository.countPendingRoleRequests(roleId) > 0) {
                throw new IllegalArgumentException("A pending request already exists for Role ID " + roleId);
            }
        }
    }

    @Override
    public ResponseEntity<ResponseVO<Map<String, Object>>> getPendingRoleRequests(String userId) {
        List<UserRequestProjection> rawList = roleRequestRepository.findPendingRoleRequests(userId);
        return processProjectionList(rawList, "pendingRequests");
    }

    @Override
    public ResponseEntity<ResponseVO<Map<String, Object>>> getMyRoleRequests(String userId) {
        List<UserRequestProjection> rawList = roleRequestRepository.findMyPendingRoleRequests(userId);
        return processProjectionList(rawList, "myRequests");
    }

    // Common processor to convert CLOB to String
    private ResponseEntity<ResponseVO<Map<String, Object>>> processProjectionList(List<UserRequestProjection> rawList,
            String keyName) {
        List<Map<String, Object>> processedList = rawList.stream().map(req -> {
            Map<String, Object> map = new HashMap<>();
            map.put("requestId", req.getRequestId());
            map.put("requestType", req.getRequestType());
            map.put("requestorUserId", req.getRequestorUserId());
            map.put("targetRoleId", req.getTargetRoleId());
            map.put("requestStatus", req.getRequestStatus());
            map.put("requestDate", formatTimestamp(req.getRequestDate()));
            map.put("requestPayload", ClobUtil.clobToString(req.getRequestPayload()));

            // add approver details
            map.put("approverId", req.getApproverUserId());
            map.put("approvalDate", formatTimestamp(req.getApprovalDate()));
            map.put("rejectionReason", req.getReasonForRejection());
            return map;
        }).collect(Collectors.toList());

        Map<String, Object> result = new HashMap<>();
        result.put(keyName, processedList);
        result.put("count", processedList.size());

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .message("Fetched " + processedList.size() + " requests")
                .result(result)
                .build());
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> acceptOrRejectRoleRequest(Map<String, Object> request,
            String userId) {
        String actionFlag = (String) request.get("actionFlag");
        int requestId = Integer.parseInt(String.valueOf(request.get("requestId")));
        String remarks = (String) request.getOrDefault("remarks", "No Remarks: Rejected by approver");

        RoleRequest roleRequest = roleRequestRepository.findRoleRequestByRequestId(requestId);
        roleRequest.setApproverUserId(userId);
        roleRequest.setApprovalDate(LocalDateTime.now(ZoneId.of("Asia/Kolkata")));

        Map<String, Object> result = new HashMap<>();
        boolean isApproved = Constant.ACCEPT.equalsIgnoreCase(actionFlag);

        performUpdateOperation(result, actionFlag, roleRequest, remarks);

        // Notification (To Requestor)
        // Msg: "Your Role Request (ID: 55) for Role 51 has been ACCEPTED."
        String status = isApproved ? "ACCEPTED" : "REJECTED";
        String notifMsg = String.format("Your Role Request (ID: %s) for Role %s has been %s.",
                roleRequest.getRequestId(), roleRequest.getTargetRoleId(), status);

        if (!isApproved) {
            notifMsg += " Reason: " + roleRequest.getReasonForRejection();
        }

        createNotification(roleRequest.getRequestorUserId(), null, "/role-management", notifMsg,
                String.valueOf(roleRequest.getRequestId()));

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .message((String) result.get(Constant.MESSAGE))
                .result(result)
                .build());
    }

    private void performUpdateOperation(Map<String, Object> result, String actionFlag, RoleRequest roleRequest,
            String remarks) {
        if (actionFlag.equalsIgnoreCase(Constant.ACCEPT)) {
            try {
                // Read CLOB payload safely
                String jsonPayload = ClobUtil.clobToString(roleRequest.getRequestPayload());
                RoleRequestPayload payload = objectMapper.readValue(jsonPayload, RoleRequestPayload.class);
                int roleId = roleRequest.getTargetRoleId();

                Role role = roleRepository.findRoleByRoleId(roleId);
                boolean isCreate = Constant.CREATE.equalsIgnoreCase(roleRequest.getRequestType());

                if (isCreate)
                    role = new Role();
                if (role == null) {
                    result.put(Constant.STATUS, false);
                    result.put(Constant.MESSAGE, "Role not found");
                    return;
                }

                role.setRoleId(roleId); // Important for Create
                role.setRoleName(payload.getRoleName());
                role.setDescription(payload.getDescription());
                role.setStatus(Constant.ACTIVE);
                roleRepository.save(role);

                savePermissions(payload, roleId);

                // Evict Cache if needed
                evictPermissionCache(payload.getPermissions());

                roleRequest.setRequestStatus(Constant.ACCEPTED);
                roleRequest.setExecutionDate(LocalDateTime.now(ZoneId.of("Asia/Kolkata")));
                roleRequest.setExecutionDetails("SUCCESS");
                roleRequestRepository.save(roleRequest);

                result.put(Constant.STATUS, true);
                result.put(Constant.MESSAGE, isCreate ? "Role Created" : "Role Updated");

            } catch (Exception e) {
                log.error("Error updating role", e);
                throw new RuntimeException("Update failed", e);
            }
        } else {
            try {
                roleRequest.setRequestStatus(Constant.REJECTED);
                roleRequest.setReasonForRejection(remarks);
                roleRequest.setExecutionDate(LocalDateTime.now(ZoneId.of("Asia/Kolkata")));
                roleRequest.setExecutionDetails("SUCCESS");
                roleRequestRepository.save(roleRequest);
                result.put(Constant.STATUS, true);
                result.put(Constant.MESSAGE, "Request Rejected");
            } catch (Exception e) {
                log.error("Error updating role", e);
                throw new RuntimeException("Update failed", e);
            }

        }
    }

    private void evictPermissionCache(List<PermissionList> permissions) {
        if (permissions == null)
            return;
        try {
            Set<Integer> ids = permissions.stream().map(PermissionList::getId).collect(Collectors.toSet());
            List<String> keys = permissionsRepository.findMappedRequestTypeByMenuId(ids);
            Cache cache = cacheManager.getCache("notification_configs");
            if (cache != null && keys != null) {
                keys.forEach(cache::evict);
            }
        } catch (Exception e) {
            log.warn("Cache eviction failed", e);
        }
    }

    // Permission saving logic
    private void savePermissions(RoleRequestPayload payload, int roleId) {
        List<PermissionList> newPerms = payload.getPermissions();
        if (newPerms == null)
            return;

        List<RolePermissions> current = rolePermissionsRepository.findByIdRoleId(roleId);
        rolePermissionsRepository.deleteAll(current);
        rolePermissionsRepository.flush();

        List<RolePermissions> toSave = newPerms.stream().map(p -> {
            RolePermissions rp = new RolePermissions();
            rp.setId(new RolePermissionId(roleId, p.getId()));
            rp.setPermissionOrder(p.getOrder());
            return rp;
        }).collect(Collectors.toList());

        rolePermissionsRepository.saveAll(toSave);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> cancelRoleRequest(Map<String, Object> request,
            String userId) {
        int requestId = Integer.parseInt(String.valueOf(request.get("requestId")));
        String remarks = (String) request.get("reason") != null ? (String) request.get("reason") : "No Remarks";
        RoleRequest roleRequest = roleRequestRepository.getRoleRequestByRequestId(requestId);

        if (!roleRequest.getRequestorUserId().equals(userId)) {
            log.warn("SECURITY VIOLATION: User {} attempted to cancel request {} owned by {}",
                    userId, requestId, roleRequest.getRequestorUserId());
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }

        // 3. State Check: Must be PENDING
        if (!roleRequest.getRequestStatus().equals(Constant.PENDING)) {
            log.warn("Attempted to cancel a processed request. ID: {}, Status: {}", requestId,
                    roleRequest.getRequestStatus());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
        }

        // update cancel status
        roleRequest.setRequestStatus(Constant.CANCEL);
        // update creator id as approver for cancel case
        roleRequest.setApproverUserId(userId);
        roleRequest.setApprovalDate(LocalDateTime.now(ZoneId.of("Asia/Kolkata")));
        roleRequest.setReasonForRejection("CANCELLED BY USER: " + remarks);

        roleRequestRepository.save(roleRequest);

        createNotification(roleRequest.getRequestorUserId(), null, "/role-management",
                "Role Request (ID: " + requestId + ") has been cancelled.",
                String.valueOf(requestId));

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .message("Cancelled")
                .result(Map.of("status", true))
                .build());
    }

    private void createNotification(String targetUser, String roles, String url, String msg, String refId) {
        try {
            notificationWriterService.createNotification(targetUser, roles, msg,
                    url,
                    refId, EVENT_SOURCE);
        } catch (Exception e) {
            throw new RuntimeException("Notification failed", e);
        }
    }

    @Override
    public ResponseEntity<ResponseVO<Map<String, Object>>> getAllRoles(Map<String, Object> request) {
        boolean includePermissions = Boolean.parseBoolean(String.valueOf(request.get("permissions")));
        List<RoleDto> roles = roleService.getAllRolesWithPermissions(includePermissions);

        // =============== FILTERING (REMOVE F1/BOG. ADMIN FROM THE ROLES LIST)
        // ==============
        if (roles != null) {
            roles = roles.stream()
                    .filter(r -> r.getRoleName() != null &&
                            HIDDEN_ROLES.stream().noneMatch(hidden -> hidden.equalsIgnoreCase(r.getRoleName())))
                    .collect(Collectors.toList());
        }

        return ResponseEntity.ok(ResponseVO.<Map<String, Object>>builder()
                .statusCode(HttpStatus.OK)
                .result(Map.of("roles", roles))
                .build());
    }

    @Override
    public ResponseEntity<ResponseVO<List<PermissionDto>>> getAllPermissions() {
        List<Permissions> permissions = permissionsRepository.findAllExceptTitle(RESTRICTED_PERMISSION_TITLE);

        List<PermissionDto> dtos = permissions.stream()
                .map(p -> PermissionDto.builder()
                        .id(p.getMenuId())
                        .title(p.getMenuTitle())
                        .icon(p.getMenuIcon())
                        .menuSubmenu(p.getMenuSubmenu())
                        .description(p.getMenuDescription())
                        .build())
                .collect(Collectors.toList());

        return ResponseEntity.ok(ResponseVO.<List<PermissionDto>>builder()
                .statusCode(HttpStatus.OK)
                .result(dtos)
                .build());

    }

    /**
     * Saves the display order of permissions for a given role.
     * <p>
     * Note: this is a direct write, no notifications triggered from here.
     */
    @Override
    public ResponseEntity<?> savePermissionOrder(PermissionOrderDto payload) {

        try {
            List<RolePermissions> newPermissions = payload.getPermissions().stream()
                    .map(p -> {
                        RolePermissions rp = new RolePermissions();
                        RolePermissionId newId = new RolePermissionId(payload.getSelectedRole(), p.getId());
                        rp.setId(newId);
                        rp.setPermissionOrder(p.getOrder());
                        return rp;
                    })
                    .collect(Collectors.toList());

            if (newPermissions.isEmpty()) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(Map.of("message", "No permissions provided"));
            }

            rolePermissionsRepository.saveAll(newPermissions);

            return ResponseEntity.ok(
                    Map.of("message", "Permissions saved successfully", "savedCount", newPermissions.size()));

        } catch (Exception e) {
            log.error("Error saving permissions for roleId {}: {}", payload.getSelectedRole(), e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("message", "Failed to save permissions", "error", e.getMessage()));
        }

    }

    private ResponseEntity<ResponseVO<Map<String, Object>>> buildError(HttpStatus status, String msg) {
        return ResponseEntity.status(status).body(ResponseVO.<Map<String, Object>>builder()
                .statusCode(status)
                .message(msg)
                .result(Map.of("status", false, "message", msg))
                .build());
    }
}










package com.tcs.userservice.model;

import jakarta.persistence.*;
import lombok.Data;
import org.springframework.cglib.core.Local;

import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Data
@Table(name = "ROLE_REQUESTS")
public class RoleRequest {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "role_req_seq_gen")
	@SequenceGenerator(name = "role_req_seq_gen", sequenceName = "ROLE_REQUEST_ID_SEQUENCE", allocationSize = 1)
	@Column(name = "REQUEST_ID")
	private int requestId;

	@Column(name = "REQUEST_TYPE")
	private String requestType;

	@Column(name = "REQUESTOR_USER_ID")
	private String requestorUserId;

	@Column(name = "TARGET_ROLE_ID")
	private int targetRoleId;

	@Column(name = "REQUEST_PAYLOAD")
	private String requestPayload;

	@Column(name = "REQUEST_STATUS")
	private String requestStatus;

	@Column(name = "REQUEST_DATE", nullable = false, updatable = false)
	private LocalDateTime requestDate;

	@Column(name = "APPROVAL_DATE")
	private LocalDateTime approvalDate;

	@Column(name = "APPROVER_USER_ID")
	private String approverUserId;

	@Column(name = "REASON_FOR_REJECTION")
	private String reasonForRejection;

	@Column(name = "EXECUTION_DATE")
	private LocalDateTime executionDate;

	@Column(name = "EXECUTION_DETAILS")
	private String executionDetails;

}












package com.tcs.userservice.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "ROLES")
public class Role {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "ROLE_ID")
	private int roleId;

	@Column(name = "ROLE_NAME")
	private String roleName;

	@Column(name = "DESCRIPTION")
	private String description;

	@Column(name = "ROLE_STATUS")
	private String status;
}
