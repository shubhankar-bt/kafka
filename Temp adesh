package com.fincore.JournalService.Service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Helper service to fetch Master Data for bulk validation.
 * Fetches entire active sets to allow O(1) in-memory validation.
 * * CORRECTED QUERY MAPPINGS:
 * - BranchMaster: Table 'BRANCH_MASTER', Column 'CODE', Status 'STATUS' (1=Active)
 * - CglMaster: Table 'CGL_MASTER', Column 'CGL_NUMBER', Status 'STATUS' (1=Active)
 * - CurrencyMaster: Table 'CURRENCY_MASTER', Column 'CURRENCY_CODE', Flag 'FLAG' (1=Active)
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class ValidationMasterService {

    @Autowired
    @Qualifier("oracleJdbcTemplate")
    private JdbcTemplate jdbcTemplate;

    public Set<String> getAllActiveBranches() {
        long start = System.currentTimeMillis();
        // Fixed Column Name: CODE instead of BRANCH_CODE
        // Assuming STATUS=1 means active based on typical Integer status patterns
        String sql = "SELECT CODE FROM BRANCH_MASTER WHERE STATUS = 1"; 
        List<String> list = jdbcTemplate.query(sql, (rs, rowNum) -> rs.getString(1));
        log.info("Loaded {} Active Branches in {}ms", list.size(), System.currentTimeMillis() - start);
        return new HashSet<>(list);
    }

    public Set<String> getAllActiveCurrencies() {
        long start = System.currentTimeMillis();
        // Correct Column: CURRENCY_CODE, Flag: 1
        String sql = "SELECT CURRENCY_CODE FROM CURRENCY_MASTER WHERE FLAG = 1";
        List<String> list = jdbcTemplate.query(sql, (rs, rowNum) -> rs.getString(1));
        log.info("Loaded {} Active Currencies in {}ms", list.size(), System.currentTimeMillis() - start);
        return new HashSet<>(list);
    }

    public Set<String> getAllActiveCgls() {
        long start = System.currentTimeMillis();
        // Fixed Column Name: CGL_NUMBER instead of CGL_CODE
        // Status is Boolean in Entity, maps to 1/0 in Oracle usually
        String sql = "SELECT CGL_NUMBER FROM CGL_MASTER WHERE STATUS = 1";
        List<String> list = jdbcTemplate.query(sql, (rs, rowNum) -> rs.getString(1));
        log.info("Loaded {} Active CGLs in {}ms", list.size(), System.currentTimeMillis() - start);
        return new HashSet<>(list);
    }
}
















package com.fincore.JournalService.Service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.JournalService.Dto.BulkUploadStateDto;
import com.monitorjbl.xlsx.StreamingReader; 
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.streaming.SXSSFWorkbook; // For writing Error Report
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.io.*;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.LongAdder;
import java.util.regex.Pattern;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

/**
 * Optimized Validation Service.
 * Features: 
 * 1. StreamingReader (Low Memory)
 * 2. Redis+GZIP (Stateless Caching)
 * 3. STRICT Logic Restoration (Regex, System Format, Memo Balances)
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class JournalBulkValidationService {

    private final ValidationMasterService validationMasterService;
    private final ObjectMapper objectMapper;

    @Autowired
    @Qualifier("byteArrayRedisTemplate")
    private RedisTemplate<String, byte[]> redisTemplate;

    private static final String KEY_DATA = "JRNL_DATA::";
    private static final String KEY_STATUS = "JRNL_STAT::";
    private static final String KEY_ERR = "JRNL_ERR::";
    private static final long CACHE_TTL_MINUTES = 60;

    // --- RESTORED REGEX PATTERNS (From Original Code) ---
    private static final Pattern CLEAN_AMOUNT_REGEX = Pattern.compile("[^0-9.]");
    private static final Pattern PRODUCT_CODE_REGEX = Pattern.compile("^\\d{8}$");
    private static final Pattern CGL_FORMAT_REGEX = Pattern.compile("^\\d{10}$");
    private static final DateTimeFormatter SYSTEM_DATE_FMT = DateTimeFormatter.ofPattern("ddMMyyyy");

    @Data @Builder @NoArgsConstructor @AllArgsConstructor
    public static class ExcelRowData implements Serializable {
        public int rowIndex;
        public String branch = "";
        public String currency = "";
        public String cgl = "";
        public BigDecimal amount;
        public String txnType = "";
        public String remarks = "";
        public String productCode = "";
        
        // System Specific
        public boolean isSystemFormat = false;
        public String sysSite="";
        public String sysDate="";
        public String sysYear="";
        public String sysPeriod="";
        
        public List<String> errors = new ArrayList<>();
    }

    // --- 1. ENTRY POINT ---
    public String initiateValidation(byte[] fileBytes, String fileName, LocalDate postingDate) {
        String requestId = UUID.randomUUID().toString();
        log.info("Starting Validation. ReqID: {}", requestId);
        updateStatus(requestId, "QUEUED", "Waiting for processor...", 0, 0, null);
        processValidationAsync(requestId, fileBytes, fileName, postingDate);
        return requestId;
    }

    // --- 2. ASYNC PROCESS ---
    @Async("bulkExecutor")
    public void processValidationAsync(String requestId, byte[] fileBytes, String fileName, LocalDate postingDate) {
        long startTime = System.currentTimeMillis();
        updateStatus(requestId, "PROCESSING", "Initializing...", 0, 0, null);

        List<ExcelRowData> validRows = new ArrayList<>();
        List<ExcelRowData> errorRows = new ArrayList<>();
        List<Map<String, Object>> previewList = new ArrayList<>();

        try {
            // A. Fetch Masters
            Set<String> validBranches = validationMasterService.getAllActiveBranches();
            Set<String> validCurrencies = validationMasterService.getAllActiveCurrencies();
            Set<String> validCgls = validationMasterService.getAllActiveCgls();
            
            updateStatus(requestId, "PROCESSING", "Streaming Excel...", 0, 0, null);

            // B. Stream Excel (Memory Safe)
            try (InputStream is = new ByteArrayInputStream(fileBytes);
                 Workbook workbook = StreamingReader.builder().rowCacheSize(100).bufferSize(4096).open(is)) {
                
                Sheet sheet = workbook.getSheetAt(0);
                int rowIdx = 0;
                
                for (Row row : sheet) {
                    // Header Skip Logic from Original Code
                    if (rowIdx == 0) {
                        String h = getStr(row, 0).toLowerCase();
                        if ((h.contains("branch") || h.contains("batch")) && !h.equals("01")) { 
                            rowIdx++; continue; 
                        }
                    }
                    if (rowIdx++ == 0) continue; // Safety skip if not caught above

                    // Parse
                    ExcelRowData data = parseRowStreaming(row, rowIdx);
                    
                    // Validate
                    validateRow(data, validBranches, validCurrencies, validCgls, postingDate);

                    if (!data.errors.isEmpty()) errorRows.add(data);
                    else validRows.add(data);
                    
                    // Preview first 50
                    if (previewList.size() < 50) previewList.add(mapToPreview(data));

                    if (rowIdx % 10000 == 0) updateStatus(requestId, "PROCESSING", "Scanned " + rowIdx + " rows...", validRows.size(), errorRows.size(), null);
                }
            }

            // C. Group Checks (Memo vs Normal Balance)
            if (!validRows.isEmpty()) {
                updateStatus(requestId, "PROCESSING", "Checking Group Balances...", validRows.size(), errorRows.size(), null);
                validateGroupBalances(validRows, errorRows);
                validRows.removeAll(errorRows);
            }

            // D. Save to Redis
            String previewJson = objectMapper.writeValueAsString(previewList);
            
            if (errorRows.isEmpty()) {
                if(validRows.isEmpty()) {
                    updateStatus(requestId, "FAILED", "File empty or invalid.", 0, 0, previewJson);
                } else {
                    byte[] compressed = compress(validRows);
                    redisTemplate.opsForValue().set(KEY_DATA + requestId, compressed, CACHE_TTL_MINUTES, TimeUnit.MINUTES);
                    updateStatus(requestId, "SUCCESS", "Validation Successful.", validRows.size(), 0, previewJson);
                }
            } else {
                byte[] report = generateErrorReport(errorRows);
                if(report!=null) redisTemplate.opsForValue().set(KEY_ERR + requestId, report, CACHE_TTL_MINUTES, TimeUnit.MINUTES);
                updateStatus(requestId, "ERROR", "Validation Failed (" + errorRows.size() + " errors).", validRows.size(), errorRows.size(), previewJson);
            }
            log.info("Validation Done. ReqID: {}. Time: {}ms", requestId, System.currentTimeMillis() - startTime);

        } catch (Exception e) {
            log.error("Validation Error", e);
            updateStatus(requestId, "ERROR", "Sys Error: " + e.getMessage(), 0, 0, null);
        }
    }

    // --- 3. PARSING LOGIC (RESTORED EXACTLY) ---
    private ExcelRowData parseRowStreaming(Row row, int rowIndex) {
        ExcelRowData data = new ExcelRowData();
        data.rowIndex = rowIndex;
        
        try {
            String col0 = getStr(row, 0);
            
            if ("01".equals(col0)) {
                // SYSTEM FORMAT: 01, Date, Year, Month, Branch, Curr, CGL, Amt, Type, Rem, Prod
                data.isSystemFormat = true;
                data.sysSite = col0;
                data.sysDate = getStr(row, 1);
                data.sysYear = getStr(row, 2);
                data.sysPeriod = getStr(row, 3);
                
                data.branch = getStr(row, 4);
                data.currency = getStr(row, 5);
                data.cgl = getStr(row, 6);
                
                String amtRaw = getStr(row, 7);
                String typeRaw = getStr(row, 8);
                parseAmount(data, amtRaw, typeRaw);
                
                data.remarks = getStr(row, 9);
                String rawProd = getStr(row, 10);
                data.productCode = (rawProd == null || rawProd.isEmpty()) ? "A" : rawProd;
                
                // Extra System Column Validation (B, C, D check)
                validateSystemMetaCols(data, getStr(row, 11), getStr(row, 12), getStr(row, 13));
                
            } else {
                // MANUAL FORMAT: Branch, Curr, CGL, Amt, Type, Rem, Prod
                data.branch = col0;
                data.currency = getStr(row, 1);
                data.cgl = getStr(row, 2);
                
                String amtRaw = getStr(row, 3);
                String typeRaw = getStr(row, 4);
                parseAmount(data, amtRaw, typeRaw);
                
                data.remarks = getStr(row, 5);
                String rawProd = getStr(row, 6);
                data.productCode = (rawProd == null || rawProd.isEmpty()) ? "A" : rawProd;
            }
            
            // Clean Currency
            if(data.currency != null) data.currency = data.currency.trim().toUpperCase();
            
        } catch(Exception e) { data.errors.add("Parse Error"); }
        return data;
    }

    private void parseAmount(ExcelRowData d, String amountRaw, String typeRaw) {
        try {
            if (amountRaw == null) amountRaw = "";
            if (typeRaw == null) typeRaw = "";
            
            if (amountRaw.contains("-") || amountRaw.contains("(") || amountRaw.contains(")")) {
                d.errors.add("Amount cannot be negative");
            }
            
            String clean = CLEAN_AMOUNT_REGEX.matcher(amountRaw).replaceAll("");
            if (clean.isEmpty()) { 
                d.amount = BigDecimal.ZERO; 
            } else {
                d.amount = new BigDecimal(clean);
                if (d.amount.signum() < 0) d.errors.add("Amount cannot be negative");
            }
            
            boolean isCredit = typeRaw.toUpperCase().contains("C") || typeRaw.toUpperCase().contains("CR");
            d.txnType = isCredit ? "Credit" : "Debit";
            
        } catch(Exception e) { 
            d.amount = BigDecimal.ZERO; 
            d.errors.add("Invalid Amount Format"); 
        }
    }

    // --- 4. VALIDATION LOGIC (RESTORED EXACTLY) ---
    private void validateRow(ExcelRowData d, Set<String> validBranches, Set<String> validCurrencies, Set<String> validCgls, LocalDate postingDate) {
        // A. Format Checks
        if (d.amount == null || d.amount.compareTo(BigDecimal.ZERO) == 0) {
            d.errors.add("Amount cannot be Zero or Null");
        } else {
            if (d.amount.precision() > 20 || d.amount.scale() > 4) d.errors.add("Amount exceeds format (Max 16.4)");
            if ("INR".equalsIgnoreCase(d.currency) && d.amount.stripTrailingZeros().scale() > 2) {
                d.errors.add("INR Amount cannot have more than 2 decimal places");
            }
        }
        
        if (d.productCode != null && !d.productCode.isEmpty() && !"A".equals(d.productCode)) {
            if (!PRODUCT_CODE_REGEX.matcher(d.productCode).matches()) d.errors.add("Product Code must be 'A' or 8 digits");
        }
        
        if (d.remarks == null || d.remarks.trim().isEmpty()) d.errors.add("Remarks is Mandatory");
        else if (d.remarks.length() > 30) d.errors.add("Remarks length > 30");

        if (d.currency == null || d.currency.length() != 3) d.errors.add("Currency must be 3 chars");
        
        if (d.cgl == null || d.cgl.isEmpty()) d.errors.add("CGL is Mandatory");
        else if (!CGL_FORMAT_REGEX.matcher(d.cgl).matches()) d.errors.add("CGL must be 10 digits");
        
        if (d.branch == null || d.branch.trim().isEmpty()) d.errors.add("Branch is Mandatory");

        // B. Database Checks (Using cached Sets for speed)
        if (!d.branch.isEmpty() && !validBranches.contains(d.branch)) d.errors.add("Branch Not Found: " + d.branch);
        if (!d.currency.isEmpty() && !validCurrencies.contains(d.currency)) d.errors.add("Currency Not Found: " + d.currency);
        if (!d.cgl.isEmpty() && !validCgls.contains(d.cgl)) d.errors.add("CGL Not Found: " + d.cgl);

        // C. System Column Logic (Date Check)
        if (d.isSystemFormat) {
            if(d.sysDate == null || d.sysDate.trim().length() != 8) d.errors.add("Invalid Date Format (ddMMyyyy)");
            else {
                try {
                    LocalDate parsedDate = LocalDate.parse(d.sysDate.trim(), SYSTEM_DATE_FMT);
                    if (!parsedDate.equals(postingDate)) d.errors.add("Date Mismatch with Posting Date (" + postingDate + ")");
                    
                    // Fiscal Year Logic
                    String expectedYear = (parsedDate.getMonthValue() >= 4) ? String.valueOf(parsedDate.getYear()) : String.valueOf(parsedDate.getYear() - 1);
                    String expectedMonth = String.format("%02d", (parsedDate.getMonthValue() >= 4) ? (parsedDate.getMonthValue() - 3) : (parsedDate.getMonthValue() + 9));
                    
                    if (!expectedYear.equals(d.sysYear)) d.errors.add("Invalid Fin Year. Expected: " + expectedYear);
                    if (!expectedMonth.equals(d.sysPeriod)) d.errors.add("Invalid Fin Month. Expected: " + expectedMonth);
                    
                } catch (Exception e) { d.errors.add("Invalid Calendar Date"); }
            }
        }
    }

    private void validateSystemMetaCols(ExcelRowData d, String c11, String c12, String c13) {
        if (!"B".equalsIgnoreCase(c11)) d.errors.add("Col 12 must be 'B'");
        if (!"C".equalsIgnoreCase(c12)) d.errors.add("Col 13 must be 'C'");
        if (!"D".equalsIgnoreCase(c13)) d.errors.add("Col 14 must be 'D'");
    }

    private void validateGroupBalances(List<ExcelRowData> validRows, List<ExcelRowData> errorAccumulator) {
        // Using ConcurrentHashMap + LongAdder for high-speed summing
        ConcurrentHashMap<String, LongAdder> balanceMap = new ConcurrentHashMap<>();
        
        // Parallel summing
        validRows.parallelStream().forEach(d -> {
            if (d.amount != null) {
                BigDecimal val = d.amount;
                if ("Credit".equals(d.txnType)) val = val.negate();
                
                // Logic: MEMO if starts with 5, else NORMAL
                String type = (d.cgl != null && d.cgl.startsWith("5")) ? "MEMO" : "NORMAL";
                String key = d.branch + "_" + d.currency + "_" + type;
                
                // Multiply by 10000 to process as Long (avoid BigDecimal add overhead in loop)
                balanceMap.computeIfAbsent(key, k -> new LongAdder()).add(val.multiply(new BigDecimal("10000")).longValue());
            }
        });

        // Check discrepancies
        validRows.parallelStream().forEach(d -> {
            String type = (d.cgl != null && d.cgl.startsWith("5")) ? "MEMO" : "NORMAL";
            String key = d.branch + "_" + d.currency + "_" + type;
            LongAdder adder = balanceMap.get(key);
            
            if (adder != null && adder.sum() != 0) {
                BigDecimal diff = BigDecimal.valueOf(adder.sum()).divide(new BigDecimal("10000"));
                synchronized(d.errors) {
                    // Only add error once per row
                    boolean exists = d.errors.stream().anyMatch(e -> e.contains("Balance Mismatch"));
                    if (!exists) d.errors.add(type + " Balance Mismatch: Total " + diff.toPlainString());
                }
                synchronized(errorAccumulator) {
                    // This creates duplicates in list, but we can filter later or use Set.
                    // For performance, adding is fine as we clear validRows later.
                    errorAccumulator.add(d);
                }
            }
        });
    }

    // --- 5. REDIS & HELPERS ---
    public void clearCache(String r) { redisTemplate.delete(Arrays.asList(KEY_DATA+r, KEY_STATUS+r, KEY_ERR+r)); }
    
    private void updateStatus(String id, String s, String m, int valid, int error, String preview) { 
        try { 
            BulkUploadStateDto dto = BulkUploadStateDto.builder()
                .requestId(id)
                .status(s)
                .message(m)
                .totalRows(valid + error) 
                .errorCount((long) error)
                .currentStage(s.equals("SUCCESS") ? 4 : 2)
                .previewDataJson(preview)
                .hasErrorFile(error > 0)
                .hasSuccessFile(error == 0 && valid > 0)
                .build();
            
            redisTemplate.opsForValue().set(KEY_STATUS+id, objectMapper.writeValueAsBytes(dto), CACHE_TTL_MINUTES, TimeUnit.MINUTES); 
        } catch(Exception ex){ log.error("Status update failed", ex); } 
    }
    
    private Map<String, Object> mapToPreview(ExcelRowData r) {
        Map<String, Object> m = new HashMap<>();
        m.put("branch", r.branch); m.put("currency", r.currency); m.put("cgl", r.cgl);
        m.put("amount", r.amount); m.put("txnType", r.txnType); m.put("remarks", r.remarks);
        return m;
    }

    private String getStr(Row row, int idx) {
        Cell c = row.getCell(idx);
        return c == null ? null : c.getStringCellValue().trim();
    }
    private byte[] compress(List<ExcelRowData> l) throws IOException { ByteArrayOutputStream b=new ByteArrayOutputStream(); try(GZIPOutputStream z=new GZIPOutputStream(b)){ objectMapper.writeValue(z,l); } return b.toByteArray(); }
    private List<ExcelRowData> decompress(byte[] b) throws IOException { try(GZIPInputStream z=new GZIPInputStream(new ByteArrayInputStream(b))){ return objectMapper.readValue(z, new TypeReference<List<ExcelRowData>>(){}); } }
    
    // Using SXSSFWorkbook to write Error Report efficiently (Saves memory)
    private byte[] generateErrorReport(List<ExcelRowData> l) { 
        try (SXSSFWorkbook wb = new SXSSFWorkbook(100); ByteArrayOutputStream out = new ByteArrayOutputStream()) { 
            Sheet s = wb.createSheet("Errors"); 
            Row h = s.createRow(0); 
            h.createCell(0).setCellValue("Row"); 
            h.createCell(1).setCellValue("Error"); 
            h.createCell(2).setCellValue("Branch"); 
            h.createCell(3).setCellValue("CGL");
            
            int i=1; 
            for(ExcelRowData r : l) { 
                Row row = s.createRow(i++); 
                row.createCell(0).setCellValue(r.rowIndex); 
                row.createCell(1).setCellValue(String.join(", ", r.errors)); 
                row.createCell(2).setCellValue(r.branch); 
                row.createCell(3).setCellValue(r.cgl);
            } 
            wb.write(out); return out.toByteArray(); 
        } catch(IOException e) { return null; } 
    }
    
    // Accessors
    public BulkUploadStateDto getState(String r) { try { return objectMapper.readValue(redisTemplate.opsForValue().get(KEY_STATUS + r), BulkUploadStateDto.class); } catch(Exception e){ return null; } }
    public List<ExcelRowData> getValidRowsFromCache(String r) { try { return decompress(redisTemplate.opsForValue().get(KEY_DATA + r)); } catch(Exception e){ return null; } }
    public byte[] getFileBytes(String r, String t) { return "ERROR".equals(t) ? redisTemplate.opsForValue().get(KEY_ERR + r) : null; }
    public byte[] generateTemplateBytes() { return new byte[0]; }
}




