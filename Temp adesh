2026-01-08T14:23:55.047+05:30  INFO 8504 --- [JournalService] [nio-9999-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2026-01-08T14:23:55.048+05:30  INFO 8504 --- [JournalService] [nio-9999-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2026-01-08T14:23:55.050+05:30  INFO 8504 --- [JournalService] [nio-9999-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 2 ms
2026-01-08T14:23:57.257+05:30  INFO 8504 --- [JournalService] [nio-9999-exec-1] c.f.J.S.JournalBulkValidationService     : Starting Validation. ReqID: ad5c6eaf-d909-4661-bfd1-f3fb6f6ba37d
2026-01-08T14:23:57.564+05:30  INFO 8504 --- [JournalService] [nio-9999-exec-1] c.f.J.Service.ValidationMasterService    : Loaded 25760 Active Branches in 237ms
2026-01-08T14:23:57.589+05:30  INFO 8504 --- [JournalService] [nio-9999-exec-1] c.f.J.Service.ValidationMasterService    : Loaded 33 Active Currencies in 23ms
2026-01-08T14:23:57.698+05:30  INFO 8504 --- [JournalService] [nio-9999-exec-1] c.f.J.Service.ValidationMasterService    : Loaded 6886 Active CGLs in 109ms
2026-01-08T14:23:58.687+05:30  WARN 8504 --- [JournalService] [nio-9999-exec-1] o.apache.poi.openxml4j.opc.ZipPackage    : Error in zip file C:\Users\v1018405\AppData\Local\Temp\tmp-2849206066709937455.xlsx - falling back to stream processing (i.e. ignoring zip central directory)
2026-01-08T14:23:58.803+05:30 ERROR 8504 --- [JournalService] [nio-9999-exec-1] c.f.J.S.JournalBulkValidationService     : Validation Error

org.apache.poi.openxml4j.exceptions.NotOfficeXmlFileException: No valid entries or contents found, this is not a valid OOXML (Office Open XML) file
	at org.apache.poi.openxml4j.util.ZipArchiveThresholdInputStream.getNextEntry(ZipArchiveThresholdInputStream.java:159) ~[poi-ooxml-5.2.5.jar:5.2.5]
	at org.apache.poi.openxml4j.util.ZipInputStreamZipEntrySource.<init>(ZipInputStreamZipEntrySource.java:94) ~[poi-ooxml-5.2.5.jar:5.2.5]
	at org.apache.poi.openxml4j.opc.ZipPackage.openZipEntrySourceStream(ZipPackage.java:258) ~[poi-ooxml-5.2.5.jar:5.2.5]
	at org.apache.poi.openxml4j.opc.ZipPackage.openZipEntrySourceStream(ZipPackage.java:242) ~[poi-ooxml-5.2.5.jar:5.2.5]
	at org.apache.poi.openxml4j.opc.ZipPackage.openZipEntrySourceStream(ZipPackage.java:216) ~[poi-ooxml-5.2.5.jar:5.2.5]
	at org.apache.poi.openxml4j.opc.ZipPackage.<init>(ZipPackage.java:197) ~[poi-ooxml-5.2.5.jar:5.2.5]
	at org.apache.poi.openxml4j.opc.OPCPackage.open(OPCPackage.java:285) ~[poi-ooxml-5.2.5.jar:5.2.5]
	at org.apache.poi.openxml4j.opc.OPCPackage.open(OPCPackage.java:192) ~[poi-ooxml-5.2.5.jar:5.2.5]
	at com.monitorjbl.xlsx.impl.StreamingWorkbookReader.init(StreamingWorkbookReader.java:113) ~[xlsx-streamer-2.2.0.jar:na]
	at com.monitorjbl.xlsx.impl.StreamingWorkbookReader.init(StreamingWorkbookReader.java:91) ~[xlsx-streamer-2.2.0.jar:na]
	at com.monitorjbl.xlsx.StreamingReader$Builder.open(StreamingReader.java:251) ~[xlsx-streamer-2.2.0.jar:na]
	at com.fincore.JournalService.Service.JournalBulkValidationService.processValidationAsync(JournalBulkValidationService.java:88) ~[classes/:na]
	at com.fincore.JournalService.Service.JournalBulkValidationService.initiateValidation(JournalBulkValidationService.java:64) ~[classes/:na]
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:354) ~[spring-aop-6.1.8.jar:6.1.8]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:716) ~[spring-aop-6.1.8.jar:6.1.8]
	at com.fincore.JournalService.Service.JournalBulkValidationService$$SpringCGLIB$$0.initiateValidation(<generated>) ~[classes/:na]
	at com.fincore.JournalService.Controllers.JournalRequestController.initiateValidation(JournalRequestController.java:161) ~[classes/:na]
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:255) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:188) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118) ~[spring-webmvc-6.1.8.jar:6.1.8]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:926) ~[spring-webmvc-6.1.8.jar:6.1.8]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:831) ~[spring-webmvc-6.1.8.jar:6.1.8]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-6.1.8.jar:6.1.8]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089) ~[spring-webmvc-6.1.8.jar:6.1.8]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979) ~[spring-webmvc-6.1.8.jar:6.1.8]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) ~[spring-webmvc-6.1.8.jar:6.1.8]
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914) ~[spring-webmvc-6.1.8.jar:6.1.8]
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590) ~[tomcat-embed-core-10.1.24.jar:6.0]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885) ~[spring-webmvc-6.1.8.jar:6.1.8]
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658) ~[tomcat-embed-core-10.1.24.jar:6.0]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) ~[tomcat-embed-websocket-10.1.24.jar:10.1.24]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:100) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:126) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:120) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:131) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:85) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at com.fincore.commonutilities.security.ContextRbacFilter.doFilterInternal(ContextRbacFilter.java:145) ~[classes/:na]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:91) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191) ~[spring-security-web-6.3.0.jar:6.3.0]
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:195) ~[spring-webmvc-6.1.8.jar:6.1.8]
	at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:230) ~[spring-security-config-6.3.0.jar:6.3.0]
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:352) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:268) ~[spring-web-6.1.8.jar:6.1.8]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.1.8.jar:6.1.8]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.1.8.jar:6.1.8]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-6.1.8.jar:6.1.8]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.1.8.jar:6.1.8]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:389) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:896) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1741) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1190) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) ~[tomcat-embed-core-10.1.24.jar:10.1.24]
	at java.base/java.lang.Thread.run(Thread.java:1570) ~[na:na]
Caused by: java.util.zip.ZipException: Unexpected record signature: 0x302c3130
	at org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.getNextZipEntry(ZipArchiveInputStream.java:770) ~[commons-compress-1.25.0.jar:1.25.0]
	at org.apache.poi.openxml4j.util.ZipArchiveThresholdInputStream.getNextEntry(ZipArchiveThresholdInputStream.java:150) ~[poi-ooxml-5.2.5.jar:5.2.5]
	... 116 common frames omitted
















old validation code :

package com.fincore.JournalService.Service;

import com.fincore.JournalService.Dto.BulkUploadStateDto;
import com.fincore.JournalService.Repository.*;
import com.fincore.JournalService.Models.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.io.*;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class JournalBulkValidationService {

    private final BranchMasterRepository branchRepo;
    private final CglMasterRepository cglRepo;
    private final CurrencyMasterRepository currencyRepo;

    private final Map<String, BulkUploadStateDto> statusCache = new ConcurrentHashMap<>();
    private final Map<String, List<ExcelRowData>> dataCache = new ConcurrentHashMap<>();
    private final Map<String, byte[]> fileCache = new ConcurrentHashMap<>();

    @Autowired @Lazy private JournalBulkValidationService self;

    // --- REGEX PATTERNS ---
    private static final Pattern CLEAN_AMOUNT_REGEX = Pattern.compile("[^0-9.]");
    private static final Pattern PRODUCT_CODE_REGEX = Pattern.compile("^\\d{8}$");
    private static final Pattern CGL_FORMAT_REGEX = Pattern.compile("^\\d{10}$");
    private static final DateTimeFormatter SYSTEM_DATE_FMT = DateTimeFormatter.ofPattern("ddMMyyyy");

    public static class ExcelRowData {
        public int rowIndex;
        public String branch = "", currency = "", cgl = "", txnType = "", remarks = "", productCode = "";
        public BigDecimal amount;

        public boolean isSystemFormat = false;
        public String sysSite="", sysDate="", sysYear="", sysPeriod="";

        public List<String> formatErrors = Collections.synchronizedList(new ArrayList<>());
        public List<String> dbErrors = Collections.synchronizedList(new ArrayList<>());
        public List<String> balErrors = Collections.synchronizedList(new ArrayList<>());

        public boolean hasErrors() { return !formatErrors.isEmpty() || !dbErrors.isEmpty() || !balErrors.isEmpty(); }
        public String getAllErrors() {
            List<String> all = new ArrayList<>();
            all.addAll(formatErrors); all.addAll(dbErrors); all.addAll(balErrors);
            return String.join("; ", all);
        }
    }

    public BulkUploadStateDto getState(String reqId) { return statusCache.get(reqId); }
    public byte[] getFileBytes(String reqId, String type) { return fileCache.get(reqId + "_" + type); }
    public List<ExcelRowData> getValidRowsFromCache(String requestId) { return dataCache.get(requestId); }

    public String initiateValidation(byte[] fileBytes, String filename, LocalDate postingDate) throws IOException {
        String requestId = UUID.randomUUID().toString();
        BulkUploadStateDto state = new BulkUploadStateDto();
        state.setRequestId(requestId);
        state.setStatus("PROCESSING");
        state.setCurrentStage(1);
        state.setMessage("Initializing Upload...");
        state.setTotalRows(0);

        statusCache.put(requestId, state);
        self.processAsync(requestId, fileBytes, filename, postingDate);
        return requestId;
    }

    @Async("bulkExecutor")
    public void processAsync(String requestId, byte[] fileBytes, String filename, LocalDate postingDate) {
        log.info("Starting Async Validation for ReqID: {}", requestId);
        try {
            updateState(requestId, s -> s.setMessage("Parsing File..."));
            List<ExcelRowData> parsedRows;
            boolean isCsv = filename != null && (filename.toLowerCase().endsWith(".csv") || filename.toLowerCase().endsWith(".txt"));

            if (isCsv) parsedRows = parseCsvBytes(fileBytes, postingDate);
            else parsedRows = parseExcelBytes(fileBytes, postingDate);

            updateState(requestId, s -> { s.setTotalRows(parsedRows.size()); s.setMessage("Validating Formats..."); });

            if (runFormatCheck(parsedRows)) {
                failRequest(requestId, parsedRows, "Format Validation Failed", 1);
                return;
            }

            updateState(requestId, s -> { s.setCurrentStage(2); s.setMessage("Checking Database..."); });
            if (runDbCheck(parsedRows)) { failRequest(requestId, parsedRows, "Database Validation Failed", 2); return; }

            updateState(requestId, s -> { s.setCurrentStage(3); s.setMessage("Checking Balances..."); });
            if (runBalanceCheck(parsedRows)) { failRequest(requestId, parsedRows, "Debit/Credit Balance Mismatch", 3); return; }

            completeRequest(requestId, parsedRows, postingDate, isCsv);
        } catch (Exception e) {
            log.error("Async Validation Error", e);
            updateState(requestId, s -> { s.setStatus("ERROR"); s.setMessage("System Error: " + e.getMessage()); s.setHasErrorFile(false); });
        }
    }

    private List<ExcelRowData> parseCsvBytes(byte[] bytes, LocalDate postingDate) throws IOException {
        List<ExcelRowData> list = new ArrayList<>();
        try(BufferedReader br = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(bytes), StandardCharsets.UTF_8))) {
            String line; int i=0;
            while((line=br.readLine())!=null) {
                if(line.trim().isEmpty()) continue;
                String[] c = line.split(",", -1);

                if (i == 0) {
                    String h = c.length > 0 ? c[0].trim().toLowerCase() : "";
                    if ((h.contains("branch") || h.contains("batch")) && !h.equals("01")) { i++; continue; }
                }
                ExcelRowData d = new ExcelRowData(); d.rowIndex = i++;

                if(c.length > 0) d.sysSite = c[0].trim();
                if(c.length > 1) d.sysDate = c[1].trim();
                if(c.length > 2) d.sysYear = c[2].trim();
                if(c.length > 3) d.sysPeriod = c[3].trim();
                if(c.length > 4) d.branch = c[4].trim();
                if(c.length > 5) d.currency = c[5].trim().toUpperCase();
                if(c.length > 6) d.cgl = c[6].trim();

                String amtRaw = (c.length > 7) ? c[7].trim() : "";
                String txnRaw = (c.length > 8) ? c[8].trim() : "";
                parseAmount(d, amtRaw, txnRaw);

                if(c.length > 9) d.remarks = c[9].trim();
                String rawProd = (c.length > 10) ? c[10].trim() : "";
                d.productCode = rawProd.isEmpty() ? "A" : rawProd;

                if (c.length != 14) {
                    d.formatErrors.add("Invalid CSV Format: Row has " + c.length + " columns. Expected 14.");
                } else {
                    d.isSystemFormat = true;
                    if(d.sysSite.isEmpty()) d.formatErrors.add("Batch ID is Mandatory");
                    if(d.branch.isEmpty()) d.formatErrors.add("Branch is Mandatory");
                    if(d.currency.isEmpty()) d.formatErrors.add("Currency is Mandatory");
                    if(d.cgl.isEmpty()) d.formatErrors.add("CGL is Mandatory");
                    if(amtRaw.isEmpty()) d.formatErrors.add("Amount is Mandatory");
                    validateSystemColumns(d, d.sysSite, d.sysDate, d.sysYear, d.sysPeriod, c[11], c[12], c[13], postingDate);
                }
                list.add(d);
            }
        }
        return list;
    }

    private List<ExcelRowData> parseExcelBytes(byte[] bytes, LocalDate postingDate) throws IOException {
        try(Workbook wb = new XSSFWorkbook(new ByteArrayInputStream(bytes))) { return parseSheet(wb.getSheetAt(0), postingDate); }
    }

    private List<ExcelRowData> parseSheet(Sheet sheet, LocalDate postingDate) {
        List<ExcelRowData> list = new ArrayList<>();
        DataFormatter fmt = new DataFormatter();
        for(Row r : sheet) {
            if(isRowEmpty(r)) continue;
            if (r.getRowNum() == 0) {
                String h = fmt.formatCellValue(r.getCell(0)).toLowerCase();
                if ((h.contains("branch") || h.contains("batch")) && !h.equals("01")) continue;
            }
            ExcelRowData d = new ExcelRowData(); d.rowIndex = r.getRowNum();

            String col0 = parseCode(r.getCell(0), fmt);

            if (col0.equals("01")) {
                d.isSystemFormat = true;
                d.sysSite=col0;
                d.sysDate=parseCode(r.getCell(1), fmt);
                d.sysYear=parseCode(r.getCell(2), fmt);
                d.sysPeriod=parseCode(r.getCell(3), fmt);
                d.branch = parseCode(r.getCell(4), fmt);
                d.currency = fmt.formatCellValue(r.getCell(5)).trim().toUpperCase();
                d.cgl = parseCode(r.getCell(6), fmt);
                parseAmount(d, fmt.formatCellValue(r.getCell(7)), fmt.formatCellValue(r.getCell(8)));
                d.remarks = fmt.formatCellValue(r.getCell(9));
                String rawProd = parseCode(r.getCell(10), fmt);
                d.productCode = rawProd.isEmpty() ? "A" : rawProd;

                if(isCellEmpty(r.getCell(0))) d.formatErrors.add("Batch ID is Mandatory");
                validateSystemColumns(d, col0, d.sysDate, d.sysYear, d.sysPeriod,
                        parseCode(r.getCell(11), fmt), parseCode(r.getCell(12), fmt), parseCode(r.getCell(13), fmt), postingDate);
            } else {
                d.branch = col0;
                d.currency = fmt.formatCellValue(r.getCell(1)).trim().toUpperCase();
                d.cgl = parseCode(r.getCell(2), fmt);
                parseAmount(d, fmt.formatCellValue(r.getCell(3)), fmt.formatCellValue(r.getCell(4)));
                d.remarks = fmt.formatCellValue(r.getCell(5));
                String rawProd = parseCode(r.getCell(6), fmt);
                d.productCode = rawProd.isEmpty() ? "A" : rawProd;
            }
            list.add(d);
        }
        return list;
    }

    private boolean runFormatCheck(List<ExcelRowData> rows) {
        rows.parallelStream().forEach(d -> {
            if (d.amount == null || d.amount.compareTo(BigDecimal.ZERO) == 0) {
                d.formatErrors.add("Amount cannot be Zero or Null");
            } else {
                if (d.amount.signum() < 0) d.formatErrors.add("Amount cannot be negative");
                if (d.amount.precision() > 20 || d.amount.scale() > 4) d.formatErrors.add("Amount exceeds format (Max 16.4)");
                if ("INR".equalsIgnoreCase(d.currency)) {
                    if (d.amount.stripTrailingZeros().scale() > 2) {
                        d.formatErrors.add("INR Amount cannot have more than 2 decimal places");
                    }
                }
            }
            if (d.productCode != null && !d.productCode.isEmpty()) {
                if (!d.productCode.equals("A") && !PRODUCT_CODE_REGEX.matcher(d.productCode).matches()) {
                    d.formatErrors.add("Product Code must be 'A' or 8 digits");
                }
            }
            if (d.remarks == null || d.remarks.trim().isEmpty()) d.formatErrors.add("Remarks is Mandatory");
            else if (d.remarks.length() > 30) d.formatErrors.add("Remarks length must be <= 30 chars");

            if (d.currency == null || d.currency.length() != 3) d.formatErrors.add("Currency must be exactly 3 characters");
            if (d.cgl == null || d.cgl.isEmpty()) d.formatErrors.add("CGL is Mandatory");
            else if (!CGL_FORMAT_REGEX.matcher(d.cgl).matches()) d.formatErrors.add("CGL must be exactly 10 digits");
            if (d.branch == null || d.branch.trim().isEmpty()) d.formatErrors.add("Branch is Mandatory");
        });
        return rows.stream().anyMatch(ExcelRowData::hasErrors);
    }

    private void validateSystemColumns(ExcelRowData d, String c0, String cDate, String cYear, String cMonth, String c11, String c12, String c13, LocalDate postingDate) {
        if (!"01".equals(c0)) d.formatErrors.add("Batch ID must be '01'");
        LocalDate parsedDate = null;
        if (cDate == null || cDate.trim().length() != 8) d.formatErrors.add("Invalid Date Format (ddMMyyyy)");
        else {
            try {
                parsedDate = LocalDate.parse(cDate.trim(), SYSTEM_DATE_FMT);
                if (!parsedDate.equals(postingDate)) d.formatErrors.add("Date Mismatch with Posting Date (" + postingDate + ")");
            } catch (Exception e) { d.formatErrors.add("Invalid Calendar Date"); }
        }
        if (parsedDate != null) {
            String expectedYear = (parsedDate.getMonthValue() >= 4) ? String.valueOf(parsedDate.getYear()) : String.valueOf(parsedDate.getYear() - 1);
            String expectedMonth = String.format("%02d", (parsedDate.getMonthValue() >= 4) ? (parsedDate.getMonthValue() - 3) : (parsedDate.getMonthValue() + 9));
            if (cYear == null || !cYear.trim().equals(expectedYear)) d.formatErrors.add("Invalid Fin Year. Expected: " + expectedYear);
            if (cMonth == null || !cMonth.trim().equals(expectedMonth)) d.formatErrors.add("Invalid Fin Month. Expected: " + expectedMonth);
        }
        if (c11 == null || !"B".equalsIgnoreCase(c11.trim())) d.formatErrors.add("Col 12 must be 'B'");
        if (c12 == null || !"C".equalsIgnoreCase(c12.trim())) d.formatErrors.add("Col 13 must be 'C'");
        if (c13 == null || !"D".equalsIgnoreCase(c13.trim())) d.formatErrors.add("Col 14 must be 'D'");
    }

    private void parseAmount(ExcelRowData d, String amountRaw, String typeRaw) {
        try {
            if (amountRaw == null) amountRaw = ""; if (typeRaw == null) typeRaw = "";
            if (amountRaw.contains("-") || amountRaw.contains("(") || amountRaw.contains(")")) d.formatErrors.add("Amount cannot be negative");
            String clean = CLEAN_AMOUNT_REGEX.matcher(amountRaw).replaceAll("");
            if (clean.isEmpty()) { d.amount = BigDecimal.ZERO; return; }
            BigDecimal v = new BigDecimal(clean);
            if (v.signum() < 0) d.formatErrors.add("Amount cannot be negative");
            boolean isCredit = typeRaw.toUpperCase().contains("C") || typeRaw.toUpperCase().contains("CR");
            d.txnType = isCredit ? "Credit" : "Debit";
            d.amount = v; // Store absolute, type determines sign later
        } catch(Exception e) { d.amount = BigDecimal.ZERO; }
    }

    private boolean runBalanceCheck(List<ExcelRowData> rows) {
        ConcurrentHashMap<String, LongAdder> balanceMap = new ConcurrentHashMap<>();
        rows.parallelStream().forEach(d -> {
            if (d.amount != null) {
                BigDecimal val = d.amount;
                if ("Credit".equals(d.txnType)) val = val.negate();
                String type = (d.cgl != null && d.cgl.startsWith("5")) ? "MEMO" : "NORMAL";
                String key = d.branch + "_" + d.currency + "_" + type;
                balanceMap.computeIfAbsent(key, k -> new LongAdder()).add(val.multiply(new BigDecimal("10000")).longValue());
            }
        });
        rows.parallelStream().forEach(d -> {
            String type = (d.cgl != null && d.cgl.startsWith("5")) ? "MEMO" : "NORMAL";
            String key = d.branch + "_" + d.currency + "_" + type;
            LongAdder adder = balanceMap.get(key);
            if (adder != null && adder.sum() != 0) {
                BigDecimal diff = BigDecimal.valueOf(adder.sum()).divide(new BigDecimal("10000"));
                synchronized(d.balErrors) { if (d.balErrors.isEmpty()) d.balErrors.add(type + " Balance Mismatch: Total " + diff.toPlainString()); }
            }
        });
        return rows.stream().anyMatch(ExcelRowData::hasErrors);
    }

    private boolean runDbCheck(List<ExcelRowData> rows) {
        Set<String> branches = rows.parallelStream().map(r -> r.branch).collect(Collectors.toSet());
        Set<String> cgls = rows.parallelStream().map(r -> r.cgl).collect(Collectors.toSet());
        Set<String> currs = rows.parallelStream().map(r -> r.currency).collect(Collectors.toSet());
        Set<String> validBranches = branchRepo.findAllById(branches).stream().map(BranchMaster::getCode).collect(Collectors.toSet());
        Set<String> validCgls = cglRepo.findAllById(cgls).stream().map(CglMaster::getCglNumber).collect(Collectors.toSet());
        Set<String> validCurrs = currencyRepo.findAllById(currs).stream().map(CurrencyMaster::getCurrencyCode).collect(Collectors.toSet());
        rows.parallelStream().forEach(d -> {
            if (!validBranches.contains(d.branch)) d.dbErrors.add("Branch Not Found: " + d.branch);
            if (!validCurrs.contains(d.currency)) d.dbErrors.add("Currency Not Found: " + d.currency);
            if (!validCgls.contains(d.cgl)) d.dbErrors.add("CGL Not Found: " + d.cgl);
        });
        return rows.stream().anyMatch(ExcelRowData::hasErrors);
    }

    private void failRequest(String reqId, List<ExcelRowData> rows, String msg, int stage) throws IOException {
        byte[] excel = generateErrorExcelFast(rows);
        fileCache.put(reqId + "_ERROR", excel);
        updateState(reqId, s -> { s.setStatus("ERROR"); s.setMessage(msg); s.setCurrentStage(stage); s.setErrorCount(rows.stream().filter(ExcelRowData::hasErrors).count()); s.setHasErrorFile(true); });
    }

    private void completeRequest(String reqId, List<ExcelRowData> rows, LocalDate pDate, boolean isCsv) throws IOException {
        dataCache.put(reqId, rows);
        if (!isCsv) { byte[] csv = generateSuccessCsv(rows, pDate); fileCache.put(reqId + "_SUCCESS", csv); }
        List<Map<String, Object>> preview = rows.stream().limit(2000).map(this::mapToPreview).collect(Collectors.toList());
        updateState(reqId, s -> { s.setCurrentStage(4); s.setStatus("SUCCESS"); s.setMessage("Validation Successful"); s.setHasSuccessFile(!isCsv); try { s.setPreviewDataJson(new com.fasterxml.jackson.databind.ObjectMapper().writeValueAsString(preview)); } catch(Exception e){} });
    }

    private byte[] generateSuccessCsv(List<ExcelRowData> rows, LocalDate postingDate) {
        StringBuilder csv = new StringBuilder(rows.size() * 100);
        DateTimeFormatter ddMMyyyy = DateTimeFormatter.ofPattern("ddMMyyyy");
        String col2 = postingDate.format(ddMMyyyy);
        String year = (postingDate.getMonthValue() >= 4) ? String.valueOf(postingDate.getYear()) : String.valueOf(postingDate.getYear() - 1);
        String month = String.format("%02d", (postingDate.getMonthValue() >= 4) ? (postingDate.getMonthValue() - 3) : (postingDate.getMonthValue() + 9));
        for (ExcelRowData row : rows) {
            String cDate = row.isSystemFormat ? row.sysDate : col2;
            String cYear = row.isSystemFormat ? row.sysYear : year;
            String cMonth = row.isSystemFormat ? row.sysPeriod : month;
            String col5 = String.format("%5s", row.branch).replace(' ', '0');
            String col6 = (row.currency == null || row.currency.isEmpty()) ? "INR" : row.currency;
            String plainAmt = row.amount.abs().setScale(4, RoundingMode.HALF_UP).toPlainString();
            int dotIndex = plainAmt.indexOf('.');
            String intPart = (dotIndex == -1) ? plainAmt : plainAmt.substring(0, dotIndex);
            String decPart = (dotIndex == -1) ? "0000" : plainAmt.substring(dotIndex + 1);
            String col8 = String.format("%16s", intPart).replace(' ', '0') + "." + decPart;
            String col9 = "Credit".equalsIgnoreCase(row.txnType) ? "Cr" : "Dr";
            String col10 = (row.remarks != null) ? row.remarks.replace(",", " ") : "";
            String col11 = (row.productCode != null && !row.productCode.isEmpty()) ? row.productCode : "A";
            csv.append("01,").append(cDate).append(",").append(cYear).append(",").append(cMonth).append(",")
                    .append(col5).append(",").append(col6).append(",").append(row.cgl).append(",").append(col8).append(",")
                    .append(col9).append(",").append(col10).append(",").append(col11).append(",B,C,D\n");
        }
        return csv.toString().getBytes(StandardCharsets.UTF_8);
    }

    private byte[] generateErrorExcelFast(List<ExcelRowData> rows) throws IOException {
        try (SXSSFWorkbook workbook = new SXSSFWorkbook(100)) {
            Sheet sheet = workbook.createSheet("Error Report");
            CellStyle errStyle = workbook.createCellStyle(); Font f = workbook.createFont(); f.setColor(IndexedColors.RED.getIndex()); errStyle.setFont(f);
            Row h = sheet.createRow(0);
            List<String> headerList = new ArrayList<>();
            boolean isSystem = rows.stream().anyMatch(r -> r.isSystemFormat);
            if (isSystem) { headerList.add("BatchID"); headerList.add("Date"); headerList.add("Year"); headerList.add("Month"); }
            headerList.addAll(Arrays.asList("Branch", "Currency", "CGL", "Amount", "TxnType", "Remarks", "Product", "ERRORS"));
            for(int i=0; i<headerList.size(); i++) h.createCell(i).setCellValue(headerList.get(i));
            int idx = 1;
            for(ExcelRowData d : rows) {
                Row r = sheet.createRow(idx++);
                int col = 0;
                if (isSystem) {
                    r.createCell(col++).setCellValue(d.sysSite);
                    r.createCell(col++).setCellValue(d.sysDate);
                    r.createCell(col++).setCellValue(d.sysYear);
                    r.createCell(col++).setCellValue(d.sysPeriod);
                }
                r.createCell(col++).setCellValue(d.branch);
                r.createCell(col++).setCellValue(d.currency);
                r.createCell(col++).setCellValue(d.cgl);
                r.createCell(col++).setCellValue(d.amount != null ? d.amount.toString() : "");
                r.createCell(col++).setCellValue(d.txnType);
                r.createCell(col++).setCellValue(d.remarks);
                r.createCell(col++).setCellValue(d.productCode);
                Cell c = r.createCell(col);
                if (d.hasErrors()) { c.setCellValue(d.getAllErrors()); c.setCellStyle(errStyle); }
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream(); workbook.write(out); return out.toByteArray();
        }
    }

    public byte[] generateTemplateBytes() throws IOException {
        try (SXSSFWorkbook wb = new SXSSFWorkbook()) {
            Sheet sheet = wb.createSheet("Journal Template"); Row row = sheet.createRow(0);
            String[] headers = {"Branch", "Currency", "CGL", "Amount", "TxnType", "Remarks", "Product"};
            for (int i = 0; i < headers.length; i++) { Cell cell = row.createCell(i); cell.setCellValue(headers[i]); sheet.setColumnWidth(i, 4000); }
            ByteArrayOutputStream out = new ByteArrayOutputStream(); wb.write(out); return out.toByteArray();
        }
    }

    private String parseCode(Cell c, DataFormatter f) { if(c==null) return ""; if(c.getCellType()==CellType.NUMERIC) return BigDecimal.valueOf(c.getNumericCellValue()).toPlainString().split("\\.")[0]; return f.formatCellValue(c).trim(); }
    private boolean isRowEmpty(Row r) { if(r==null) return true; for(int c=r.getFirstCellNum(); c<r.getLastCellNum(); c++) if(r.getCell(c)!=null && r.getCell(c).getCellType()!=CellType.BLANK && !r.getCell(c).toString().trim().isEmpty()) return false; return true; }
    private boolean isCellEmpty(Cell c) { return c == null || c.getCellType() == CellType.BLANK || c.toString().trim().isEmpty(); }
    private Map<String, Object> mapToPreview(ExcelRowData r) {
        Map<String, Object> m = new HashMap<>();
        m.put("id", r.rowIndex); m.put("branch", r.branch); m.put("currency", r.currency); m.put("cgl", r.cgl);
        m.put("amount", r.amount!=null?r.amount.toString():"");
        m.put("txnType", r.txnType); m.put("remarks", r.remarks); m.put("productCode", r.productCode);
        return m;
    }
    private void updateState(String requestId, java.util.function.Consumer<BulkUploadStateDto> updater) { BulkUploadStateDto state = statusCache.getOrDefault(requestId, new BulkUploadStateDto()); updater.accept(state); statusCache.put(requestId, state); }
}

package com.fincore.JournalService.Service;

import com.fincore.JournalService.Dto.BulkUploadStateDto;
import com.fincore.JournalService.Repository.*;
import com.fincore.JournalService.Models.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.io.*;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class JournalBulkValidationService {

    private final BranchMasterRepository branchRepo;
    private final CglMasterRepository cglRepo;
    private final CurrencyMasterRepository currencyRepo;

    private final Map<String, BulkUploadStateDto> statusCache = new ConcurrentHashMap<>();
    private final Map<String, List<ExcelRowData>> dataCache = new ConcurrentHashMap<>();
    private final Map<String, byte[]> fileCache = new ConcurrentHashMap<>();

    @Autowired @Lazy private JournalBulkValidationService self;

    // --- REGEX PATTERNS ---
    private static final Pattern CLEAN_AMOUNT_REGEX = Pattern.compile("[^0-9.]");
    private static final Pattern PRODUCT_CODE_REGEX = Pattern.compile("^\\d{8}$");
    private static final Pattern CGL_FORMAT_REGEX = Pattern.compile("^\\d{10}$");
    private static final DateTimeFormatter SYSTEM_DATE_FMT = DateTimeFormatter.ofPattern("ddMMyyyy");

    public static class ExcelRowData {
        public int rowIndex;
        public String branch = "", currency = "", cgl = "", txnType = "", remarks = "", productCode = "";
        public BigDecimal amount;

        public boolean isSystemFormat = false;
        public String sysSite="", sysDate="", sysYear="", sysPeriod="";

        public List<String> formatErrors = Collections.synchronizedList(new ArrayList<>());
        public List<String> dbErrors = Collections.synchronizedList(new ArrayList<>());
        public List<String> balErrors = Collections.synchronizedList(new ArrayList<>());

        public boolean hasErrors() { return !formatErrors.isEmpty() || !dbErrors.isEmpty() || !balErrors.isEmpty(); }
        public String getAllErrors() {
            List<String> all = new ArrayList<>();
            all.addAll(formatErrors); all.addAll(dbErrors); all.addAll(balErrors);
            return String.join("; ", all);
        }
    }

    public BulkUploadStateDto getState(String reqId) { return statusCache.get(reqId); }
    public byte[] getFileBytes(String reqId, String type) { return fileCache.get(reqId + "_" + type); }
    public List<ExcelRowData> getValidRowsFromCache(String requestId) { return dataCache.get(requestId); }

    public String initiateValidation(byte[] fileBytes, String filename, LocalDate postingDate) throws IOException {
        String requestId = UUID.randomUUID().toString();
        BulkUploadStateDto state = new BulkUploadStateDto();
        state.setRequestId(requestId);
        state.setStatus("PROCESSING");
        state.setCurrentStage(1);
        state.setMessage("Initializing Upload...");
        state.setTotalRows(0);

        statusCache.put(requestId, state);
        self.processAsync(requestId, fileBytes, filename, postingDate);
        return requestId;
    }

    @Async("bulkExecutor")
    public void processAsync(String requestId, byte[] fileBytes, String filename, LocalDate postingDate) {
        log.info("Starting Async Validation for ReqID: {}", requestId);
        try {
            updateState(requestId, s -> s.setMessage("Parsing File..."));
            List<ExcelRowData> parsedRows;
            boolean isCsv = filename != null && (filename.toLowerCase().endsWith(".csv") || filename.toLowerCase().endsWith(".txt"));

            if (isCsv) parsedRows = parseCsvBytes(fileBytes, postingDate);
            else parsedRows = parseExcelBytes(fileBytes, postingDate);

            updateState(requestId, s -> { s.setTotalRows(parsedRows.size()); s.setMessage("Validating Formats..."); });

            if (runFormatCheck(parsedRows)) {
                failRequest(requestId, parsedRows, "Format Validation Failed", 1);
                return;
            }

            updateState(requestId, s -> { s.setCurrentStage(2); s.setMessage("Checking Database..."); });
            if (runDbCheck(parsedRows)) { failRequest(requestId, parsedRows, "Database Validation Failed", 2); return; }

            updateState(requestId, s -> { s.setCurrentStage(3); s.setMessage("Checking Balances..."); });
            if (runBalanceCheck(parsedRows)) { failRequest(requestId, parsedRows, "Debit/Credit Balance Mismatch", 3); return; }

            completeRequest(requestId, parsedRows, postingDate, isCsv);
        } catch (Exception e) {
            log.error("Async Validation Error", e);
            updateState(requestId, s -> { s.setStatus("ERROR"); s.setMessage("System Error: " + e.getMessage()); s.setHasErrorFile(false); });
        }
    }

    private List<ExcelRowData> parseCsvBytes(byte[] bytes, LocalDate postingDate) throws IOException {
        List<ExcelRowData> list = new ArrayList<>();
        try(BufferedReader br = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(bytes), StandardCharsets.UTF_8))) {
            String line; int i=0;
            while((line=br.readLine())!=null) {
                if(line.trim().isEmpty()) continue;
                String[] c = line.split(",", -1);

                if (i == 0) {
                    String h = c.length > 0 ? c[0].trim().toLowerCase() : "";
                    if ((h.contains("branch") || h.contains("batch")) && !h.equals("01")) { i++; continue; }
                }
                ExcelRowData d = new ExcelRowData(); d.rowIndex = i++;

                if(c.length > 0) d.sysSite = c[0].trim();
                if(c.length > 1) d.sysDate = c[1].trim();
                if(c.length > 2) d.sysYear = c[2].trim();
                if(c.length > 3) d.sysPeriod = c[3].trim();
                if(c.length > 4) d.branch = c[4].trim();
                if(c.length > 5) d.currency = c[5].trim().toUpperCase();
                if(c.length > 6) d.cgl = c[6].trim();

                String amtRaw = (c.length > 7) ? c[7].trim() : "";
                String txnRaw = (c.length > 8) ? c[8].trim() : "";
                parseAmount(d, amtRaw, txnRaw);

                if(c.length > 9) d.remarks = c[9].trim();
                String rawProd = (c.length > 10) ? c[10].trim() : "";
                d.productCode = rawProd.isEmpty() ? "A" : rawProd;

                if (c.length != 14) {
                    d.formatErrors.add("Invalid CSV Format: Row has " + c.length + " columns. Expected 14.");
                } else {
                    d.isSystemFormat = true;
                    if(d.sysSite.isEmpty()) d.formatErrors.add("Batch ID is Mandatory");
                    if(d.branch.isEmpty()) d.formatErrors.add("Branch is Mandatory");
                    if(d.currency.isEmpty()) d.formatErrors.add("Currency is Mandatory");
                    if(d.cgl.isEmpty()) d.formatErrors.add("CGL is Mandatory");
                    if(amtRaw.isEmpty()) d.formatErrors.add("Amount is Mandatory");
                    validateSystemColumns(d, d.sysSite, d.sysDate, d.sysYear, d.sysPeriod, c[11], c[12], c[13], postingDate);
                }
                list.add(d);
            }
        }
        return list;
    }

    private List<ExcelRowData> parseExcelBytes(byte[] bytes, LocalDate postingDate) throws IOException {
        try(Workbook wb = new XSSFWorkbook(new ByteArrayInputStream(bytes))) { return parseSheet(wb.getSheetAt(0), postingDate); }
    }

    private List<ExcelRowData> parseSheet(Sheet sheet, LocalDate postingDate) {
        List<ExcelRowData> list = new ArrayList<>();
        DataFormatter fmt = new DataFormatter();
        for(Row r : sheet) {
            if(isRowEmpty(r)) continue;
            if (r.getRowNum() == 0) {
                String h = fmt.formatCellValue(r.getCell(0)).toLowerCase();
                if ((h.contains("branch") || h.contains("batch")) && !h.equals("01")) continue;
            }
            ExcelRowData d = new ExcelRowData(); d.rowIndex = r.getRowNum();

            String col0 = parseCode(r.getCell(0), fmt);

            if (col0.equals("01")) {
                d.isSystemFormat = true;
                d.sysSite=col0;
                d.sysDate=parseCode(r.getCell(1), fmt);
                d.sysYear=parseCode(r.getCell(2), fmt);
                d.sysPeriod=parseCode(r.getCell(3), fmt);
                d.branch = parseCode(r.getCell(4), fmt);
                d.currency = fmt.formatCellValue(r.getCell(5)).trim().toUpperCase();
                d.cgl = parseCode(r.getCell(6), fmt);
                parseAmount(d, fmt.formatCellValue(r.getCell(7)), fmt.formatCellValue(r.getCell(8)));
                d.remarks = fmt.formatCellValue(r.getCell(9));
                String rawProd = parseCode(r.getCell(10), fmt);
                d.productCode = rawProd.isEmpty() ? "A" : rawProd;

                if(isCellEmpty(r.getCell(0))) d.formatErrors.add("Batch ID is Mandatory");
                validateSystemColumns(d, col0, d.sysDate, d.sysYear, d.sysPeriod,
                        parseCode(r.getCell(11), fmt), parseCode(r.getCell(12), fmt), parseCode(r.getCell(13), fmt), postingDate);
            } else {
                d.branch = col0;
                d.currency = fmt.formatCellValue(r.getCell(1)).trim().toUpperCase();
                d.cgl = parseCode(r.getCell(2), fmt);
                parseAmount(d, fmt.formatCellValue(r.getCell(3)), fmt.formatCellValue(r.getCell(4)));
                d.remarks = fmt.formatCellValue(r.getCell(5));
                String rawProd = parseCode(r.getCell(6), fmt);
                d.productCode = rawProd.isEmpty() ? "A" : rawProd;
            }
            list.add(d);
        }
        return list;
    }

    private boolean runFormatCheck(List<ExcelRowData> rows) {
        rows.parallelStream().forEach(d -> {
            if (d.amount == null || d.amount.compareTo(BigDecimal.ZERO) == 0) {
                d.formatErrors.add("Amount cannot be Zero or Null");
            } else {
                if (d.amount.signum() < 0) d.formatErrors.add("Amount cannot be negative");
                if (d.amount.precision() > 20 || d.amount.scale() > 4) d.formatErrors.add("Amount exceeds format (Max 16.4)");
                if ("INR".equalsIgnoreCase(d.currency)) {
                    if (d.amount.stripTrailingZeros().scale() > 2) {
                        d.formatErrors.add("INR Amount cannot have more than 2 decimal places");
                    }
                }
            }
            if (d.productCode != null && !d.productCode.isEmpty()) {
                if (!d.productCode.equals("A") && !PRODUCT_CODE_REGEX.matcher(d.productCode).matches()) {
                    d.formatErrors.add("Product Code must be 'A' or 8 digits");
                }
            }
            if (d.remarks == null || d.remarks.trim().isEmpty()) d.formatErrors.add("Remarks is Mandatory");
            else if (d.remarks.length() > 30) d.formatErrors.add("Remarks length must be <= 30 chars");

            if (d.currency == null || d.currency.length() != 3) d.formatErrors.add("Currency must be exactly 3 characters");
            if (d.cgl == null || d.cgl.isEmpty()) d.formatErrors.add("CGL is Mandatory");
            else if (!CGL_FORMAT_REGEX.matcher(d.cgl).matches()) d.formatErrors.add("CGL must be exactly 10 digits");
            if (d.branch == null || d.branch.trim().isEmpty()) d.formatErrors.add("Branch is Mandatory");
        });
        return rows.stream().anyMatch(ExcelRowData::hasErrors);
    }

    private void validateSystemColumns(ExcelRowData d, String c0, String cDate, String cYear, String cMonth, String c11, String c12, String c13, LocalDate postingDate) {
        if (!"01".equals(c0)) d.formatErrors.add("Batch ID must be '01'");
        LocalDate parsedDate = null;
        if (cDate == null || cDate.trim().length() != 8) d.formatErrors.add("Invalid Date Format (ddMMyyyy)");
        else {
            try {
                parsedDate = LocalDate.parse(cDate.trim(), SYSTEM_DATE_FMT);
                if (!parsedDate.equals(postingDate)) d.formatErrors.add("Date Mismatch with Posting Date (" + postingDate + ")");
            } catch (Exception e) { d.formatErrors.add("Invalid Calendar Date"); }
        }
        if (parsedDate != null) {
            String expectedYear = (parsedDate.getMonthValue() >= 4) ? String.valueOf(parsedDate.getYear()) : String.valueOf(parsedDate.getYear() - 1);
            String expectedMonth = String.format("%02d", (parsedDate.getMonthValue() >= 4) ? (parsedDate.getMonthValue() - 3) : (parsedDate.getMonthValue() + 9));
            if (cYear == null || !cYear.trim().equals(expectedYear)) d.formatErrors.add("Invalid Fin Year. Expected: " + expectedYear);
            if (cMonth == null || !cMonth.trim().equals(expectedMonth)) d.formatErrors.add("Invalid Fin Month. Expected: " + expectedMonth);
        }
        if (c11 == null || !"B".equalsIgnoreCase(c11.trim())) d.formatErrors.add("Col 12 must be 'B'");
        if (c12 == null || !"C".equalsIgnoreCase(c12.trim())) d.formatErrors.add("Col 13 must be 'C'");
        if (c13 == null || !"D".equalsIgnoreCase(c13.trim())) d.formatErrors.add("Col 14 must be 'D'");
    }

    private void parseAmount(ExcelRowData d, String amountRaw, String typeRaw) {
        try {
            if (amountRaw == null) amountRaw = ""; if (typeRaw == null) typeRaw = "";
            if (amountRaw.contains("-") || amountRaw.contains("(") || amountRaw.contains(")")) d.formatErrors.add("Amount cannot be negative");
            String clean = CLEAN_AMOUNT_REGEX.matcher(amountRaw).replaceAll("");
            if (clean.isEmpty()) { d.amount = BigDecimal.ZERO; return; }
            BigDecimal v = new BigDecimal(clean);
            if (v.signum() < 0) d.formatErrors.add("Amount cannot be negative");
            boolean isCredit = typeRaw.toUpperCase().contains("C") || typeRaw.toUpperCase().contains("CR");
            d.txnType = isCredit ? "Credit" : "Debit";
            d.amount = v; // Store absolute, type determines sign later
        } catch(Exception e) { d.amount = BigDecimal.ZERO; }
    }

    private boolean runBalanceCheck(List<ExcelRowData> rows) {
        ConcurrentHashMap<String, LongAdder> balanceMap = new ConcurrentHashMap<>();
        rows.parallelStream().forEach(d -> {
            if (d.amount != null) {
                BigDecimal val = d.amount;
                if ("Credit".equals(d.txnType)) val = val.negate();
                String type = (d.cgl != null && d.cgl.startsWith("5")) ? "MEMO" : "NORMAL";
                String key = d.branch + "_" + d.currency + "_" + type;
                balanceMap.computeIfAbsent(key, k -> new LongAdder()).add(val.multiply(new BigDecimal("10000")).longValue());
            }
        });
        rows.parallelStream().forEach(d -> {
            String type = (d.cgl != null && d.cgl.startsWith("5")) ? "MEMO" : "NORMAL";
            String key = d.branch + "_" + d.currency + "_" + type;
            LongAdder adder = balanceMap.get(key);
            if (adder != null && adder.sum() != 0) {
                BigDecimal diff = BigDecimal.valueOf(adder.sum()).divide(new BigDecimal("10000"));
                synchronized(d.balErrors) { if (d.balErrors.isEmpty()) d.balErrors.add(type + " Balance Mismatch: Total " + diff.toPlainString()); }
            }
        });
        return rows.stream().anyMatch(ExcelRowData::hasErrors);
    }

    private boolean runDbCheck(List<ExcelRowData> rows) {
        Set<String> branches = rows.parallelStream().map(r -> r.branch).collect(Collectors.toSet());
        Set<String> cgls = rows.parallelStream().map(r -> r.cgl).collect(Collectors.toSet());
        Set<String> currs = rows.parallelStream().map(r -> r.currency).collect(Collectors.toSet());
        Set<String> validBranches = branchRepo.findAllById(branches).stream().map(BranchMaster::getCode).collect(Collectors.toSet());
        Set<String> validCgls = cglRepo.findAllById(cgls).stream().map(CglMaster::getCglNumber).collect(Collectors.toSet());
        Set<String> validCurrs = currencyRepo.findAllById(currs).stream().map(CurrencyMaster::getCurrencyCode).collect(Collectors.toSet());
        rows.parallelStream().forEach(d -> {
            if (!validBranches.contains(d.branch)) d.dbErrors.add("Branch Not Found: " + d.branch);
            if (!validCurrs.contains(d.currency)) d.dbErrors.add("Currency Not Found: " + d.currency);
            if (!validCgls.contains(d.cgl)) d.dbErrors.add("CGL Not Found: " + d.cgl);
        });
        return rows.stream().anyMatch(ExcelRowData::hasErrors);
    }

    private void failRequest(String reqId, List<ExcelRowData> rows, String msg, int stage) throws IOException {
        byte[] excel = generateErrorExcelFast(rows);
        fileCache.put(reqId + "_ERROR", excel);
        updateState(reqId, s -> { s.setStatus("ERROR"); s.setMessage(msg); s.setCurrentStage(stage); s.setErrorCount(rows.stream().filter(ExcelRowData::hasErrors).count()); s.setHasErrorFile(true); });
    }

    private void completeRequest(String reqId, List<ExcelRowData> rows, LocalDate pDate, boolean isCsv) throws IOException {
        dataCache.put(reqId, rows);
        if (!isCsv) { byte[] csv = generateSuccessCsv(rows, pDate); fileCache.put(reqId + "_SUCCESS", csv); }
        List<Map<String, Object>> preview = rows.stream().limit(2000).map(this::mapToPreview).collect(Collectors.toList());
        updateState(reqId, s -> { s.setCurrentStage(4); s.setStatus("SUCCESS"); s.setMessage("Validation Successful"); s.setHasSuccessFile(!isCsv); try { s.setPreviewDataJson(new com.fasterxml.jackson.databind.ObjectMapper().writeValueAsString(preview)); } catch(Exception e){} });
    }

    private byte[] generateSuccessCsv(List<ExcelRowData> rows, LocalDate postingDate) {
        StringBuilder csv = new StringBuilder(rows.size() * 100);
        DateTimeFormatter ddMMyyyy = DateTimeFormatter.ofPattern("ddMMyyyy");
        String col2 = postingDate.format(ddMMyyyy);
        String year = (postingDate.getMonthValue() >= 4) ? String.valueOf(postingDate.getYear()) : String.valueOf(postingDate.getYear() - 1);
        String month = String.format("%02d", (postingDate.getMonthValue() >= 4) ? (postingDate.getMonthValue() - 3) : (postingDate.getMonthValue() + 9));
        for (ExcelRowData row : rows) {
            String cDate = row.isSystemFormat ? row.sysDate : col2;
            String cYear = row.isSystemFormat ? row.sysYear : year;
            String cMonth = row.isSystemFormat ? row.sysPeriod : month;
            String col5 = String.format("%5s", row.branch).replace(' ', '0');
            String col6 = (row.currency == null || row.currency.isEmpty()) ? "INR" : row.currency;
            String plainAmt = row.amount.abs().setScale(4, RoundingMode.HALF_UP).toPlainString();
            int dotIndex = plainAmt.indexOf('.');
            String intPart = (dotIndex == -1) ? plainAmt : plainAmt.substring(0, dotIndex);
            String decPart = (dotIndex == -1) ? "0000" : plainAmt.substring(dotIndex + 1);
            String col8 = String.format("%16s", intPart).replace(' ', '0') + "." + decPart;
            String col9 = "Credit".equalsIgnoreCase(row.txnType) ? "Cr" : "Dr";
            String col10 = (row.remarks != null) ? row.remarks.replace(",", " ") : "";
            String col11 = (row.productCode != null && !row.productCode.isEmpty()) ? row.productCode : "A";
            csv.append("01,").append(cDate).append(",").append(cYear).append(",").append(cMonth).append(",")
                    .append(col5).append(",").append(col6).append(",").append(row.cgl).append(",").append(col8).append(",")
                    .append(col9).append(",").append(col10).append(",").append(col11).append(",B,C,D\n");
        }
        return csv.toString().getBytes(StandardCharsets.UTF_8);
    }

    private byte[] generateErrorExcelFast(List<ExcelRowData> rows) throws IOException {
        try (SXSSFWorkbook workbook = new SXSSFWorkbook(100)) {
            Sheet sheet = workbook.createSheet("Error Report");
            CellStyle errStyle = workbook.createCellStyle(); Font f = workbook.createFont(); f.setColor(IndexedColors.RED.getIndex()); errStyle.setFont(f);
            Row h = sheet.createRow(0);
            List<String> headerList = new ArrayList<>();
            boolean isSystem = rows.stream().anyMatch(r -> r.isSystemFormat);
            if (isSystem) { headerList.add("BatchID"); headerList.add("Date"); headerList.add("Year"); headerList.add("Month"); }
            headerList.addAll(Arrays.asList("Branch", "Currency", "CGL", "Amount", "TxnType", "Remarks", "Product", "ERRORS"));
            for(int i=0; i<headerList.size(); i++) h.createCell(i).setCellValue(headerList.get(i));
            int idx = 1;
            for(ExcelRowData d : rows) {
                Row r = sheet.createRow(idx++);
                int col = 0;
                if (isSystem) {
                    r.createCell(col++).setCellValue(d.sysSite);
                    r.createCell(col++).setCellValue(d.sysDate);
                    r.createCell(col++).setCellValue(d.sysYear);
                    r.createCell(col++).setCellValue(d.sysPeriod);
                }
                r.createCell(col++).setCellValue(d.branch);
                r.createCell(col++).setCellValue(d.currency);
                r.createCell(col++).setCellValue(d.cgl);
                r.createCell(col++).setCellValue(d.amount != null ? d.amount.toString() : "");
                r.createCell(col++).setCellValue(d.txnType);
                r.createCell(col++).setCellValue(d.remarks);
                r.createCell(col++).setCellValue(d.productCode);
                Cell c = r.createCell(col);
                if (d.hasErrors()) { c.setCellValue(d.getAllErrors()); c.setCellStyle(errStyle); }
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream(); workbook.write(out); return out.toByteArray();
        }
    }

    public byte[] generateTemplateBytes() throws IOException {
        try (SXSSFWorkbook wb = new SXSSFWorkbook()) {
            Sheet sheet = wb.createSheet("Journal Template"); Row row = sheet.createRow(0);
            String[] headers = {"Branch", "Currency", "CGL", "Amount", "TxnType", "Remarks", "Product"};
            for (int i = 0; i < headers.length; i++) { Cell cell = row.createCell(i); cell.setCellValue(headers[i]); sheet.setColumnWidth(i, 4000); }
            ByteArrayOutputStream out = new ByteArrayOutputStream(); wb.write(out); return out.toByteArray();
        }
    }

    private String parseCode(Cell c, DataFormatter f) { if(c==null) return ""; if(c.getCellType()==CellType.NUMERIC) return BigDecimal.valueOf(c.getNumericCellValue()).toPlainString().split("\\.")[0]; return f.formatCellValue(c).trim(); }
    private boolean isRowEmpty(Row r) { if(r==null) return true; for(int c=r.getFirstCellNum(); c<r.getLastCellNum(); c++) if(r.getCell(c)!=null && r.getCell(c).getCellType()!=CellType.BLANK && !r.getCell(c).toString().trim().isEmpty()) return false; return true; }
    private boolean isCellEmpty(Cell c) { return c == null || c.getCellType() == CellType.BLANK || c.toString().trim().isEmpty(); }
    private Map<String, Object> mapToPreview(ExcelRowData r) {
        Map<String, Object> m = new HashMap<>();
        m.put("id", r.rowIndex); m.put("branch", r.branch); m.put("currency", r.currency); m.put("cgl", r.cgl);
        m.put("amount", r.amount!=null?r.amount.toString():"");
        m.put("txnType", r.txnType); m.put("remarks", r.remarks); m.put("productCode", r.productCode);
        return m;
    }
    private void updateState(String requestId, java.util.function.Consumer<BulkUploadStateDto> updater) { BulkUploadStateDto state = statusCache.getOrDefault(requestId, new BulkUploadStateDto()); updater.accept(state); statusCache.put(requestId, state); }
}

