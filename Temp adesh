package com.fincore.JournalService.Service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Helper service to fetch Master Data for bulk validation.
 * Optimized with FetchSize to prevent network latency on large tables.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class ValidationMasterService {

    @Autowired
    @Qualifier("oracleJdbcTemplate")
    private JdbcTemplate jdbcTemplate;

    public Set<String> getAllActiveBranches() {
        long start = System.currentTimeMillis();
        // Optimized query with FetchSize
        String sql = "SELECT CODE FROM BRANCH_MASTER WHERE STATUS = 1";
        List<String> list = jdbcTemplate.query(con -> {
            var ps = con.prepareStatement(sql);
            ps.setFetchSize(5000); // Critical for performance
            return ps;
        }, (rs, rowNum) -> rs.getString(1));
        
        log.info("Loaded {} Active Branches in {}ms", list.size(), System.currentTimeMillis() - start);
        return new HashSet<>(list);
    }

    public Set<String> getAllActiveCurrencies() {
        long start = System.currentTimeMillis();
        String sql = "SELECT CURRENCY_CODE FROM CURRENCY_MASTER WHERE FLAG = 1";
        List<String> list = jdbcTemplate.query(con -> {
            var ps = con.prepareStatement(sql);
            ps.setFetchSize(1000);
            return ps;
        }, (rs, rowNum) -> rs.getString(1));
        
        log.info("Loaded {} Active Currencies in {}ms", list.size(), System.currentTimeMillis() - start);
        return new HashSet<>(list);
    }

    public Set<String> getAllActiveCgls() {
        long start = System.currentTimeMillis();
        String sql = "SELECT CGL_NUMBER FROM CGL_MASTER WHERE STATUS = 1";
        List<String> list = jdbcTemplate.query(con -> {
            var ps = con.prepareStatement(sql);
            ps.setFetchSize(2000);
            return ps;
        }, (rs, rowNum) -> rs.getString(1));
        
        log.info("Loaded {} Active CGLs in {}ms", list.size(), System.currentTimeMillis() - start);
        return new HashSet<>(list);
    }
}














package com.fincore.JournalService.Service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.JournalService.Dto.BulkUploadStateDto;
import com.monitorjbl.xlsx.StreamingReader;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.io.*;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.LongAdder;
import java.util.regex.Pattern;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

@Service
@RequiredArgsConstructor
@Slf4j
public class JournalBulkValidationService {

    private final ValidationMasterService validationMasterService;
    private final ObjectMapper objectMapper;

    @Autowired
    @Qualifier("byteArrayRedisTemplate")
    private RedisTemplate<String, byte[]> redisTemplate;

    private static final String KEY_DATA = "JRNL_DATA::";
    private static final String KEY_STATUS = "JRNL_STAT::";
    private static final String KEY_ERR = "JRNL_ERR::";
    private static final long CACHE_TTL_MINUTES = 60;

    // Regex
    private static final Pattern CLEAN_AMOUNT_REGEX = Pattern.compile("[^0-9.]");
    private static final Pattern PRODUCT_CODE_REGEX = Pattern.compile("^\\d{8}$");
    private static final Pattern CGL_FORMAT_REGEX = Pattern.compile("^\\d{10}$");
    private static final DateTimeFormatter SYSTEM_DATE_FMT = DateTimeFormatter.ofPattern("ddMMyyyy");

    @Data @Builder @NoArgsConstructor @AllArgsConstructor
    public static class ExcelRowData implements Serializable {
        public int rowIndex;
        public String branch = "";
        public String currency = "";
        public String cgl = "";
        public BigDecimal amount;
        public String txnType = "";
        public String remarks = "";
        public String productCode = "";
        
        // System Specific
        public boolean isSystemFormat = false;
        public String sysSite="";
        public String sysDate="";
        public String sysYear="";
        public String sysPeriod="";
        
        public List<String> errors = new ArrayList<>();
    }

    // --- 1. ENTRY POINT ---
    public String initiateValidation(byte[] fileBytes, String fileName, LocalDate postingDate) {
        String requestId = UUID.randomUUID().toString();
        log.info("Init Validation. ReqID: {}, File: {}", requestId, fileName);
        updateStatus(requestId, "QUEUED", "Waiting for processor...", 0, 0, null);
        processValidationAsync(requestId, fileBytes, fileName, postingDate);
        return requestId;
    }

    // --- 2. ASYNC PROCESS ---
    @Async("bulkExecutor")
    public void processValidationAsync(String requestId, byte[] fileBytes, String fileName, LocalDate postingDate) {
        long startTime = System.currentTimeMillis();
        updateStatus(requestId, "PROCESSING", "Initializing...", 0, 0, null);

        List<ExcelRowData> validRows = new ArrayList<>();
        List<ExcelRowData> errorRows = new ArrayList<>();
        List<Map<String, Object>> previewList = new ArrayList<>();

        try {
            // A. Fetch Masters
            Set<String> validBranches = validationMasterService.getAllActiveBranches();
            Set<String> validCurrencies = validationMasterService.getAllActiveCurrencies();
            Set<String> validCgls = validationMasterService.getAllActiveCgls();
            
            updateStatus(requestId, "PROCESSING", "Parsing File...", 0, 0, null);

            boolean isCsv = fileName != null && (fileName.toLowerCase().endsWith(".csv") || fileName.toLowerCase().endsWith(".txt"));

            if (isCsv) {
                // --- CSV PROCESSING ---
                try (BufferedReader br = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(fileBytes), StandardCharsets.UTF_8))) {
                    String line;
                    int rowIdx = 0;
                    while ((line = br.readLine()) != null) {
                        if (line.trim().isEmpty()) continue;
                        
                        // Header Skip Logic
                        if (rowIdx == 0) {
                            String lower = line.toLowerCase();
                            // Check header signature but allow '01' data row
                            if ((lower.contains("branch") || lower.contains("batch")) && !line.startsWith("01")) {
                                rowIdx++; continue;
                            }
                        }
                        // Treat as data if we didn't skip
                        ExcelRowData data = parseCsvRow(line, rowIdx++);
                        processRow(data, validBranches, validCurrencies, validCgls, postingDate, validRows, errorRows, previewList);
                        
                        if (rowIdx % 10000 == 0) updateStatus(requestId, "PROCESSING", "Scanned " + rowIdx + " rows...", validRows.size(), errorRows.size(), null);
                    }
                }
            } else {
                // --- EXCEL PROCESSING (Streaming) ---
                try (InputStream is = new ByteArrayInputStream(fileBytes);
                     Workbook workbook = StreamingReader.builder().rowCacheSize(100).bufferSize(4096).open(is)) {
                    
                    Sheet sheet = workbook.getSheetAt(0);
                    int rowIdx = 0;
                    
                    for (Row row : sheet) {
                        if (rowIdx == 0) {
                            String h = getStr(row, 0).toLowerCase();
                            if ((h.contains("branch") || h.contains("batch")) && !h.equals("01")) { 
                                rowIdx++; continue; 
                            }
                        }
                        if (rowIdx++ == 0) continue; // Skip if still 0 after check

                        ExcelRowData data = parseExcelRowStreaming(row, rowIdx);
                        processRow(data, validBranches, validCurrencies, validCgls, postingDate, validRows, errorRows, previewList);

                        if (rowIdx % 10000 == 0) updateStatus(requestId, "PROCESSING", "Scanned " + rowIdx + " rows...", validRows.size(), errorRows.size(), null);
                    }
                }
            }

            // C. Group Checks
            if (!validRows.isEmpty()) {
                updateStatus(requestId, "PROCESSING", "Checking Group Balances...", validRows.size(), errorRows.size(), null);
                validateGroupBalances(validRows, errorRows);
                validRows.removeAll(errorRows);
            }

            // D. Save to Redis
            String previewJson = objectMapper.writeValueAsString(previewList);
            
            if (errorRows.isEmpty()) {
                if(validRows.isEmpty()) {
                    updateStatus(requestId, "FAILED", "File empty or invalid.", 0, 0, previewJson);
                } else {
                    byte[] compressed = compress(validRows);
                    redisTemplate.opsForValue().set(KEY_DATA + requestId, compressed, CACHE_TTL_MINUTES, TimeUnit.MINUTES);
                    updateStatus(requestId, "SUCCESS", "Validation Successful.", validRows.size(), 0, previewJson);
                }
            } else {
                byte[] report = generateErrorReport(errorRows);
                if(report!=null) redisTemplate.opsForValue().set(KEY_ERR + requestId, report, CACHE_TTL_MINUTES, TimeUnit.MINUTES);
                updateStatus(requestId, "ERROR", "Validation Failed (" + errorRows.size() + " errors).", validRows.size(), errorRows.size(), previewJson);
            }
            log.info("Validation Done. ReqID: {}. Time: {}ms", requestId, System.currentTimeMillis() - startTime);

        } catch (Exception e) {
            log.error("Validation Error", e);
            updateStatus(requestId, "ERROR", "Sys Error: " + e.getMessage(), 0, 0, null);
        }
    }

    private void processRow(ExcelRowData data, Set<String> branches, Set<String> currencies, Set<String> cgls, LocalDate pDate, 
                            List<ExcelRowData> valid, List<ExcelRowData> errors, List<Map<String, Object>> preview) {
        validateRow(data, branches, currencies, cgls, pDate);
        if (!data.errors.isEmpty()) errors.add(data);
        else valid.add(data);
        if (preview.size() < 50) preview.add(mapToPreview(data));
    }

    // --- 3. PARSING LOGIC (Unified for CSV & Excel) ---

    private ExcelRowData parseCsvRow(String line, int rowIndex) {
        // Split handling empty tokens
        String[] c = line.split(",", -1);
        return parseUnified(rowIndex, 
            getArr(c,0), getArr(c,1), getArr(c,2), getArr(c,3), getArr(c,4), getArr(c,5), getArr(c,6), 
            getArr(c,7), getArr(c,8), getArr(c,9), getArr(c,10), getArr(c,11), getArr(c,12), getArr(c,13)
        );
    }

    private ExcelRowData parseExcelRowStreaming(Row row, int rowIndex) {
        return parseUnified(rowIndex,
            getStr(row,0), getStr(row,1), getStr(row,2), getStr(row,3), getStr(row,4), getStr(row,5), getStr(row,6),
            getStr(row,7), getStr(row,8), getStr(row,9), getStr(row,10), getStr(row,11), getStr(row,12), getStr(row,13)
        );
    }

    private ExcelRowData parseUnified(int rowIndex, String c0, String c1, String c2, String c3, String c4, String c5, String c6, String c7, String c8, String c9, String c10, String c11, String c12, String c13) {
        ExcelRowData data = new ExcelRowData();
        data.rowIndex = rowIndex;
        
        try {
            if ("01".equals(c0)) {
                // SYSTEM: 01, Date, Year, Month, Branch, Curr, CGL, Amt, Type, Rem, Prod, Meta...
                data.isSystemFormat = true;
                data.sysSite = c0;
                data.sysDate = c1; data.sysYear = c2; data.sysPeriod = c3;
                data.branch = c4; data.currency = c5; data.cgl = c6;
                parseAmount(data, c7, c8);
                data.remarks = c9; data.productCode = (c10 == null || c10.isEmpty()) ? "A" : c10;
                validateSystemMetaCols(data, c11, c12, c13);
            } else {
                // MANUAL: Branch, Curr, CGL, Amt, Type, Rem, Prod
                data.branch = c0; data.currency = c1; data.cgl = c2;
                parseAmount(data, c3, c4);
                data.remarks = c5; data.productCode = (c6 == null || c6.isEmpty()) ? "A" : c6;
            }
            if(data.branch==null) data.branch="";
            if(data.currency==null) data.currency=""; else data.currency = data.currency.trim().toUpperCase();
            if(data.cgl==null) data.cgl="";
        } catch(Exception e) { data.errors.add("Parse Error"); }
        return data;
    }

    private void parseAmount(ExcelRowData d, String amt, String type) {
        try {
            if(amt != null) {
                if (amt.contains("-") || amt.contains("(") || amt.contains(")")) d.errors.add("Amount cannot be negative");
                String clean = CLEAN_AMOUNT_REGEX.matcher(amt).replaceAll("");
                if(clean.isEmpty()) d.amount = BigDecimal.ZERO;
                else d.amount = new BigDecimal(clean);
            } else {
                d.amount = BigDecimal.ZERO;
                d.errors.add("Amount Missing");
            }
            
            if(type != null && (type.toUpperCase().contains("C") || type.toUpperCase().contains("CR"))) d.txnType = "Credit";
            else d.txnType = "Debit";
            
        } catch(Exception e) { d.amount = BigDecimal.ZERO; d.errors.add("Invalid Amount Format"); }
    }

    // --- 4. VALIDATION LOGIC ---
    private void validateRow(ExcelRowData d, Set<String> validBranches, Set<String> validCurrencies, Set<String> validCgls, LocalDate postingDate) {
        // Format Checks
        if (d.amount == null || d.amount.compareTo(BigDecimal.ZERO) == 0) d.errors.add("Amount cannot be Zero or Null");
        else {
            if (d.amount.precision() > 20 || d.amount.scale() > 4) d.errors.add("Amount exceeds format (Max 16.4)");
            if ("INR".equalsIgnoreCase(d.currency) && d.amount.stripTrailingZeros().scale() > 2) d.errors.add("INR Amount decimals > 2");
        }
        
        if (d.productCode != null && !d.productCode.isEmpty() && !"A".equals(d.productCode)) {
            if (!PRODUCT_CODE_REGEX.matcher(d.productCode).matches()) d.errors.add("Product Code must be 'A' or 8 digits");
        }
        if (d.remarks == null || d.remarks.trim().isEmpty()) d.errors.add("Remarks is Mandatory");
        else if (d.remarks.length() > 30) d.errors.add("Remarks length > 30");

        if (d.currency == null || d.currency.length() != 3) d.errors.add("Currency must be 3 chars");
        if (d.cgl == null || d.cgl.isEmpty()) d.errors.add("CGL is Mandatory");
        else if (!CGL_FORMAT_REGEX.matcher(d.cgl).matches()) d.errors.add("CGL must be 10 digits");
        if (d.branch == null || d.branch.trim().isEmpty()) d.errors.add("Branch is Mandatory");

        // DB Checks
        if (!d.branch.isEmpty() && !validBranches.contains(d.branch)) d.errors.add("Branch Not Found: " + d.branch);
        if (!d.currency.isEmpty() && !validCurrencies.contains(d.currency)) d.errors.add("Currency Not Found: " + d.currency);
        if (!d.cgl.isEmpty() && !validCgls.contains(d.cgl)) d.errors.add("CGL Not Found: " + d.cgl);

        // System Date Check
        if (d.isSystemFormat) {
            if(d.sysDate == null || d.sysDate.trim().length() != 8) d.errors.add("Invalid Date Format (ddMMyyyy)");
            else {
                try {
                    LocalDate parsedDate = LocalDate.parse(d.sysDate.trim(), SYSTEM_DATE_FMT);
                    if (!parsedDate.equals(postingDate)) d.errors.add("Date Mismatch with Posting Date (" + postingDate + ")");
                    
                    String expectedYear = (parsedDate.getMonthValue() >= 4) ? String.valueOf(parsedDate.getYear()) : String.valueOf(parsedDate.getYear() - 1);
                    String expectedMonth = String.format("%02d", (parsedDate.getMonthValue() >= 4) ? (parsedDate.getMonthValue() - 3) : (parsedDate.getMonthValue() + 9));
                    if (!expectedYear.equals(d.sysYear)) d.errors.add("Invalid Fin Year");
                    if (!expectedMonth.equals(d.sysPeriod)) d.errors.add("Invalid Fin Month");
                } catch (Exception e) { d.errors.add("Invalid Calendar Date"); }
            }
        }
    }

    private void validateSystemMetaCols(ExcelRowData d, String c11, String c12, String c13) {
        if (!"B".equalsIgnoreCase(c11)) d.errors.add("Col 12 must be 'B'");
        if (!"C".equalsIgnoreCase(c12)) d.errors.add("Col 13 must be 'C'");
        if (!"D".equalsIgnoreCase(c13)) d.errors.add("Col 14 must be 'D'");
    }

    private void validateGroupBalances(List<ExcelRowData> validRows, List<ExcelRowData> errorAccumulator) {
        ConcurrentHashMap<String, LongAdder> balanceMap = new ConcurrentHashMap<>();
        validRows.parallelStream().forEach(d -> {
            if (d.amount != null) {
                BigDecimal val = d.amount;
                if ("Credit".equals(d.txnType)) val = val.negate();
                String type = (d.cgl != null && d.cgl.startsWith("5")) ? "MEMO" : "NORMAL";
                String key = d.branch + "_" + d.currency + "_" + type;
                balanceMap.computeIfAbsent(key, k -> new LongAdder()).add(val.multiply(new BigDecimal("10000")).longValue());
            }
        });
        validRows.parallelStream().forEach(d -> {
            String type = (d.cgl != null && d.cgl.startsWith("5")) ? "MEMO" : "NORMAL";
            String key = d.branch + "_" + d.currency + "_" + type;
            LongAdder adder = balanceMap.get(key);
            if (adder != null && adder.sum() != 0) {
                BigDecimal diff = BigDecimal.valueOf(adder.sum()).divide(new BigDecimal("10000"));
                synchronized(d.errors) { if (d.errors.isEmpty()) d.errors.add(type + " Balance Mismatch: " + diff.toPlainString()); }
                synchronized(errorAccumulator) { errorAccumulator.add(d); }
            }
        });
    }

    // --- HELPERS ---
    private String getStr(Row row, int idx) { Cell c = row.getCell(idx); return c == null ? null : c.getStringCellValue().trim(); }
    private String getArr(String[] arr, int idx) { return (arr != null && idx < arr.length) ? arr[idx].trim() : null; }
    
    // Redis
    public void clearCache(String r) { redisTemplate.delete(Arrays.asList(KEY_DATA+r, KEY_STATUS+r, KEY_ERR+r)); }
    private void updateStatus(String id, String s, String m, int valid, int error, String preview) { 
        try { 
            BulkUploadStateDto dto = BulkUploadStateDto.builder().requestId(id).status(s).message(m).totalRows(valid + error).errorCount((long) error).currentStage(s.equals("SUCCESS")?4:2).previewDataJson(preview).hasErrorFile(error>0).hasSuccessFile(error==0&&valid>0).build();
            redisTemplate.opsForValue().set(KEY_STATUS+id, objectMapper.writeValueAsBytes(dto), CACHE_TTL_MINUTES, TimeUnit.MINUTES); 
        } catch(Exception ex){ log.error("Status update failed", ex); } 
    }
    
    // Preview
    private Map<String, Object> mapToPreview(ExcelRowData r) {
        Map<String, Object> m = new HashMap<>();
        m.put("branch", r.branch); m.put("currency", r.currency); m.put("cgl", r.cgl);
        m.put("amount", r.amount); m.put("txnType", r.txnType); m.put("remarks", r.remarks);
        return m;
    }

    // Compression & Reports
    private byte[] compress(List<ExcelRowData> l) throws IOException { ByteArrayOutputStream b=new ByteArrayOutputStream(); try(GZIPOutputStream z=new GZIPOutputStream(b)){ objectMapper.writeValue(z,l); } return b.toByteArray(); }
    private List<ExcelRowData> decompress(byte[] b) throws IOException { try(GZIPInputStream z=new GZIPInputStream(new ByteArrayInputStream(b))){ return objectMapper.readValue(z, new TypeReference<List<ExcelRowData>>(){}); } }
    private byte[] generateErrorReport(List<ExcelRowData> l) { 
        try (SXSSFWorkbook wb = new SXSSFWorkbook(100); ByteArrayOutputStream out = new ByteArrayOutputStream()) { 
            Sheet s = wb.createSheet("Errors"); 
            Row h = s.createRow(0); h.createCell(0).setCellValue("Row"); h.createCell(1).setCellValue("Error"); h.createCell(2).setCellValue("Data");
            int i=1; for(ExcelRowData r : l) { Row row = s.createRow(i++); row.createCell(0).setCellValue(r.rowIndex); row.createCell(1).setCellValue(String.join(" | ", r.errors)); row.createCell(2).setCellValue(r.branch + "/" + r.cgl + "/" + r.amount); } 
            wb.write(out); return out.toByteArray(); 
        } catch(IOException e) { return null; } 
    }
    
    // Public Accessors
    public BulkUploadStateDto getState(String r) { try { return objectMapper.readValue(redisTemplate.opsForValue().get(KEY_STATUS + r), BulkUploadStateDto.class); } catch(Exception e){ return null; } }
    public List<ExcelRowData> getValidRowsFromCache(String r) { try { return decompress(redisTemplate.opsForValue().get(KEY_DATA + r)); } catch(Exception e){ return null; } }
    public byte[] getFileBytes(String r, String t) { return "ERROR".equals(t) ? redisTemplate.opsForValue().get(KEY_ERR + r) : null; }
    public byte[] generateTemplateBytes() { return new byte[0]; }
}


