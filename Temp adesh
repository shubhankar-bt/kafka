package com.fincore.process_status_service.controller;

import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fincore.process_status_service.ResponseVO;
import com.fincore.process_status_service.dto.InsertDTO;
import com.fincore.process_status_service.dto.UpdateDTO;
import com.fincore.process_status_service.model.ProcessStatus;
import com.fincore.process_status_service.service.ProcessStatusService;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping("/api")
public class ProcessStatusController {

	private final ProcessStatusService processStatusService;

	@PostMapping("/processes")
	public ResponseEntity<ResponseVO<ProcessStatus>> insert(
			@Valid @RequestBody InsertDTO insertDTO
	) {
		ResponseEntity<ResponseVO<ProcessStatus>> responseEntity = processStatusService.insert(insertDTO);
		return responseEntity;
	}

	@PatchMapping("/processes")
	public ResponseEntity<ResponseVO<ProcessStatus>> update(@Valid @RequestBody UpdateDTO updateDTO) {
		ResponseEntity<ResponseVO<ProcessStatus>> responseEntity = processStatusService.update(updateDTO);
		return responseEntity;
	}

    // FIX: Added produces = MediaType.TEXT_EVENT_STREAM_VALUE
	@GetMapping(path = "/processes", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	public SseEmitter getProcessData() throws JsonProcessingException {
		return processStatusService.getProcessDataSSE();
	}
}




















import dayjs from "dayjs";
import { useEffect, useState } from "react";
import { fetchEventSource } from "@microsoft/fetch-event-source";
import useCustomSnackbar from "../../utils/useCustomSnackbar";
import ProcessDetailsDialog from "./components/ProcessDetailsDialog";
import ProcessStatusTable from "./components/ProcessStatusTable";
import { resolveConfig } from "../../config/EnvironmentConfig";
import { useSelector } from "react-redux";

/* ------------------ Data Transformer ------------------ */
const processResponseData = (data) => {
  const processes = data?.map((process) => ({
    ...process,
    stageDetails: process.stageDetails.map((stageDetail) => ({
      ...stageDetail,
      START_TIME:
        stageDetail?.START_TIME != null
          ? dayjs.unix(stageDetail.START_TIME / 1000)
          : null,
      END_TIME:
        stageDetail?.END_TIME != null
          ? dayjs.unix(stageDetail.END_TIME / 1000)
          : null,
    })),
  }));

  const empty = processes
    ?.map((p) => p.stageDetails)
    ?.every((sd) => sd.length === 0);

  return empty ? [] : processes;
};

/* ------------------ Component ------------------ */
const ProcessStatusPage = () => {
  const [processes, setProcesses] = useState([]);
  const [process, setProcess] = useState(null);

  const snackbar = useCustomSnackbar();

  const url = "/processes";
  const service = resolveConfig("/PS");
  const finalURL = service + url;
  const token = useSelector((state) => state.auth.token);

  useEffect(() => {
    const controller = new AbortController();

    fetchEventSource(finalURL, {
      method: "GET",
      signal: controller.signal,

      /* HEADERS SUPPORTED */
      headers: {
        Authorization: `Bearer ${token}`,
        // FIX: Explicitly request text/event-stream to avoid 406 Not Acceptable
        Accept: "text/event-stream", 
      },

      /* Called when connection opens */
      onopen(response) {
        if (
          !response.ok &&
          response.headers.get("content-type") !== "text/event-stream"
        ) {
          throw new Error(
            `SSE connection failed for process status: ${response.status}`
          );
        }
      },

      /* Called on each SSE message */
      onmessage(event) {
        // Ignore the initial "connected" message if it's just a string, 
        // or ensure your JSON parser handles it gracefully.
        if (event.event === 'connected') {
             console.log("SSE Connected: ", event.data);
             return;
        }

        try {
          const response = JSON.parse(event.data);
          if (Array.isArray(response) && response.length > 0) {
            setProcesses(processResponseData(response));
          }
        } catch (e) {
          console.error("Error parsing SSE data for process status", e);
        }
      },

      /* Called on server-side errors */
      onerror(err) {
        // console.error("SSE error:", err);
        // snackbar("Error fetching the processes!"); 
        // Note: fetchEventSource retries automatically on error. 
        // Showing a snackbar on every retry attempt might be spammy.
        throw err; // triggers retry
      },

      /* Retry logic */
      retryDelay(attempt) {
        return Math.min(1000 * 2 ** attempt, 15000);
      },
    });

    return () => {
      controller.abort(); // clean close
    };
  }, [snackbar, finalURL, token]); // Added dependencies for safety

  return (
    <>
      <ProcessDetailsDialog
        process={process}
        onClose={() => setProcess(null)}
      />

      <ProcessStatusTable
        processes={processes}
        actions={{
          onStop: () => {},
          onRestart: () => {},
          onView: (process) => setProcess(process),
        }}
      />
    </>
  );
};

export default ProcessStatusPage;

