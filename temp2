package com.fincore.UserService.service;

import com.fincore.UserService.model.Permissions;
import com.fincore.UserService.repository.PermissionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor
@Slf4j
public class PermissionCacheService {

    private final PermissionRepository permissionRepository;
    private final StringRedisTemplate redisTemplate;

    @Transactional(readOnly = true)
    public void refreshRolePermissions(Long roleId) {
        log.info("♻️ Refreshing Redis Permissions for Role ID: {}", roleId);
        
        List<Permissions> perms = permissionRepository.findAllByRoleId(roleId);
        String redisKey = "RBAC::PERMISSIONS::" + roleId;
        
        redisTemplate.delete(redisKey);

        Set<String> redisValues = new HashSet<>();

        for (Permissions p : perms) {
            String url = p.getMenuUrl(); 
            String action = p.getMenuAction(); 
            String context = p.getMappedRequestType(); 

            String contextSuffix = (context == null || context.trim().isEmpty()) ? "*" : context;

            // --- A. GENERIC CRS MAPPING ---
            if ((context != null && !context.isEmpty()) || url.contains("-requests")) {
                // MAKER
                if (containsAny(action, "create", "modify", "delete", "cancel")) {
                    redisValues.add("POST:/create-request|" + contextSuffix);
                    redisValues.add("POST:/update-request|" + contextSuffix); 
                }
                // CHECKER
                if (containsAny(action, "approve", "reject")) {
                    redisValues.add("PATCH:/update-request|" + contextSuffix);
                    redisValues.add("POST:/pending-requests|" + contextSuffix);
                }
                // VIEW
                if (containsAny(action, "view", "create")) {
                    redisValues.add("POST:/my-requests|" + contextSuffix);
                    redisValues.add("GET:/all-requests|" + contextSuffix);
                }
            } 
            
            // --- B. STANDARD REST MAPPING (Notifications, Reports, etc.) ---
            else {
                // OPTIMIZATION 1: Auto-Wildcard
                // If the URL is "/notifications", we treat it as "/notifications/**" 
                // to allow access to sub-resources like /notifications/stream
                String effectiveUrl = url.endsWith("/**") ? url : url + "/**";

                // CREATE -> POST
                if (action.contains("create")) {
                    redisValues.add("POST:" + effectiveUrl + "|*");
                }
                
                // MODIFY -> PUT, PATCH, AND POST (Fix for NotificationController)
                if (action.contains("modify")) {
                    redisValues.add("PUT:" + effectiveUrl + "|*");
                    redisValues.add("PATCH:" + effectiveUrl + "|*");
                    redisValues.add("POST:" + effectiveUrl + "|*"); // Added to support POST updates
                }
                
                // DELETE -> DELETE
                if (action.contains("delete")) {
                    redisValues.add("DELETE:" + effectiveUrl + "|*");
                }
                
                // VIEW -> GET
                if (action.contains("view")) {
                    redisValues.add("GET:" + effectiveUrl + "|*");
                }
                
                // DOWNLOAD -> POST (For Reports)
                if (action.contains("download")) {
                    redisValues.add("POST:" + effectiveUrl + "|*");
                }
            }
        }

        if (!redisValues.isEmpty()) {
            redisTemplate.opsForSet().add(redisKey, redisValues.toArray(new String[0]));
        }
        log.info("✅ Cached {} permissions for Role {}", redisValues.size(), roleId);
    }

    private boolean containsAny(String input, String... keywords) {
        if (input == null) return false;
        for (String keyword : keywords) {
            if (input.contains(keyword)) return true;
        }
        return false;
    }
    
    /**
     * Called when a PERMISSION definition changes (e.g. URL update).
     * Finds all roles using this permission and refreshes them.
     */
    @Transactional(readOnly = true)
    public void refreshRolesByPermissionId(Long permissionId) {
       // Assuming you have this method in RolePermissionRepository
       // List<Long> affectedRoleIds = rolePermissionRepository.findRoleIdsByPermissionId(permissionId);
       // for (Long roleId : affectedRoleIds) refreshRolePermissions(roleId);
       // (Placeholder to remind you to keep this logic if implemented)
    }
}


