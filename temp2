package com.fincore.commonutilities.security;

import com.fincore.commonutilities.jwt.JwtUtil;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;
import java.util.Set;

@Slf4j
@RequiredArgsConstructor
public class ContextRbacFilter extends OncePerRequestFilter {

    private final StringRedisTemplate redisTemplate;
    private final JwtUtil jwtUtil;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    private static final Set<String> GENERIC_ENDPOINTS = Set.of(
            "/create-request", "/update-request", "/my-requests", "/pending-requests", "/all-requests"
    );

    private static final Set<String> WHITELIST = Set.of(
            "/auth/**", "/actuator/**", "/error", "/swagger-ui/**", "/v3/api-docs/**", "/login"
    );

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        String uri = request.getRequestURI();
        String method = request.getMethod().toUpperCase();

        // 1. SKIP WHITELIST
        for (String pattern : WHITELIST) {
            if (pathMatcher.match(pattern, uri)) {
                filterChain.doFilter(request, response);
                return;
            }
        }

        // 2. EXTRACT & VALIDATE TOKEN
        String token = request.getHeader("Authorization");
        try {
            if (token == null || !jwtUtil.isTokenValid(token)) {
                filterChain.doFilter(request, response);
                return;
            }
        } catch (Exception e) {
            // Handle ExpiredJwtException or others gracefully
            filterChain.doFilter(request, response);
            return;
        }

        // 3. SET SECURITY CONTEXT
        String userId = jwtUtil.getUserIdFromToken(token);
        int roleIdInt = jwtUtil.getUserRoleFromToken(token);
        String roleId = String.valueOf(roleIdInt);

        if (SecurityContextHolder.getContext().getAuthentication() == null) {
            UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                    userId, null, List.of(new SimpleGrantedAuthority("ROLE_" + roleId))
            );
            SecurityContextHolder.getContext().setAuthentication(authToken);
        }

        // 4. DETERMINE CONTEXT
        String contextHeader = request.getHeader("X-Request-Type");
        String requestContext = (contextHeader == null || contextHeader.trim().isEmpty()) ? "*" : contextHeader;

        // 5. VALIDATE GENERIC ENDPOINTS
        boolean isGenericEndpoint = GENERIC_ENDPOINTS.stream().anyMatch(uri::endsWith);
        if (isGenericEndpoint && requestContext.equals("*")) {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing Header: X-Request-Type is required");
            return;
        }

        // 6. REDIS LOOKUP (PATTERN MATCHING FIX)
        String redisKey = "RBAC::PERMISSIONS::" + roleId;
        
        // Fetch ALL permissions for this role
        Set<String> permissions = redisTemplate.opsForSet().members(redisKey);
        boolean isAuthorized = false;

        if (permissions != null) {
            for (String perm : permissions) {
                // Format: "METHOD:URL_PATTERN|CONTEXT"
                // Example: "GET:/notifications/**|*"
                
                String[] parts = perm.split("\\|"); // Split by pipe first
                if (parts.length < 2) continue;

                String methodAndUrl = parts[0]; // "GET:/notifications/**"
                String allowedContext = parts[1]; // "*" or "SEGMENT_CODE"

                // 1. Check Context Match
                if (!allowedContext.equals("*") && !allowedContext.equals(requestContext)) {
                    continue; // Context mismatch
                }

                String[] muParts = methodAndUrl.split(":", 2);
                if (muParts.length < 2) continue;
                
                String allowedMethod = muParts[0];
                String allowedUrlPattern = muParts[1];

                // 2. Check Method Match
                if (!allowedMethod.equals(method)) {
                    continue;
                }

                // 3. Check URL Pattern Match (CRITICAL FIX)
                // /notifications/stream matches /notifications/**
                if (pathMatcher.match(allowedUrlPattern, uri)) {
                    isAuthorized = true;
                    break; // Found a match, stop looping
                }
            }
        }

        // 7. ENFORCE DECISION
        if (isAuthorized) {
            filterChain.doFilter(request, response);
        } else {
            log.warn("â›” RBAC Deny: User {} (Role {}) -> {} {} (Context: {})", userId, roleId, method, uri, requestContext);
            response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
        }
    }
}

Action: Update this file in common-utilities and run mvn clean install. Then update the common-utilities dependency in Notification Service (rebuild it).
Step 2: Fix PermissionCacheService in UserService
We need to make the logic case-insensitive to ensure view, View, or VIEW all generate the GET key.
File: com/fincore/UserService/service/PermissionCacheService.java
    // ... inside refreshRolePermissions method ...

    for (Permissions p : perms) {
        String dbUrl = p.getMenuUrl(); 
        String actionRaw = p.getMenuAction(); // Raw from DB
        String action = (actionRaw != null) ? actionRaw.toLowerCase() : ""; // FORCE LOWERCASE
        String context = p.getMappedRequestType(); 

        // ... normalization logic ...

        // --- LOGIC B: STANDARD REST MAPPING ---
        else {
            String effectiveUrl = apiPath.endsWith("/**") ? apiPath : apiPath + "/**";

            // Using lowercase 'action' variable here guarantees matches
            if (action.contains("view")) {
                redisValues.add("GET:" + effectiveUrl + "|*");
                redisValues.add("POST:" + effectiveUrl + "|*"); 
            }
            
            // ... rest of your logic ...
        }
    }


