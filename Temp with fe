Right now      


import { useState } from "react";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import IconButton from "@mui/material/IconButton";
import Button from "@mui/material/Button";
import Fade from "@mui/material/Fade";
import ThumbUpOutlinedIcon from "@mui/icons-material/ThumbUpOutlined";
import ThumbUpIcon from "@mui/icons-material/ThumbUp";
import ThumbDownOutlinedIcon from "@mui/icons-material/ThumbDownOutlined";
import ThumbDownIcon from "@mui/icons-material/ThumbDown";
import OpenInNewIcon from "@mui/icons-material/OpenInNew";
import SearchIcon from "@mui/icons-material/Search";
import WarningAmberIcon from "@mui/icons-material/WarningAmber";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import CheckIcon from "@mui/icons-material/Check";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import FinCoreIcon from "./FinCoreIcon";
import { submitFeedback } from "../lib/chatMockService";

const formatTime = (date) =>
  date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });

const markdownComponents = {
  p: ({ children }) => (
    <Typography
      component="p"
      sx={{
        fontSize: "14px",
        lineHeight: 1.6,
        mb: 0.5,
        "&:last-child": { mb: 0 },
      }}
    >
      {children}
    </Typography>
  ),
  strong: ({ children }) => (
    <Box component="strong" sx={{ fontWeight: 600, color: "inherit" }}>
      {children}
    </Box>
  ),
  ul: ({ children }) => (
    <Box
      component="ul"
      sx={{
        pl: 2,
        mb: 0.5,
        "& li": { fontSize: "14px", lineHeight: 1.6, mb: 0.25 },
      }}
    >
      {children}
    </Box>
  ),
  ol: ({ children }) => (
    <Box
      component="ol"
      sx={{
        pl: 2,
        mb: 0.5,
        "& li": { fontSize: "14px", lineHeight: 1.6, mb: 0.25 },
      }}
    >
      {children}
    </Box>
  ),
  li: ({ children }) => <li>{children}</li>,
  a: ({ href, children }) => (
    <Box
      component="a"
      href={href}
      target="_blank"
      rel="noopener noreferrer"
      sx={{
        color: "primary.main",
        textDecoration: "underline",
        "&:hover": { opacity: 0.8 },
      }}
    >
      {children}
    </Box>
  ),
  code: ({ children }) => (
    <Box
      component="code"
      sx={{
        fontSize: "12px",
        px: 0.5,
        py: 0.25,
        borderRadius: 1,
        bgcolor: "hsla(220,18%,90%,0.5)",
        fontFamily: "monospace",
      }}
    >
      {children}
    </Box>
  ),
};

// Streaming dots indicator shown inside the bubble while waiting for first token
const StreamingDots = () => (
  <Box sx={{ display: "flex", alignItems: "center", gap: 0.5, py: 0.5 }}>
    <Box
      className="typing-dot"
      sx={{ width: 5, height: 5, borderRadius: "50%", bgcolor: "primary.main" }}
    />
    <Box
      className="typing-dot"
      sx={{ width: 5, height: 5, borderRadius: "50%", bgcolor: "primary.main" }}
    />
    <Box
      className="typing-dot"
      sx={{ width: 5, height: 5, borderRadius: "50%", bgcolor: "primary.main" }}
    />
  </Box>
);

const ChatBubble = ({ message, onSuggestionClick, onFeedback }) => {
  const isUser = message.role === "user";
  const response = message.response;
  const isStreaming = message.isStreaming;
  const [copied, setCopied] = useState(false);

  const handleFeedback = (type) => {
    if (response?.logId) submitFeedback(response.logId, type);
    onFeedback(message.id, type);
  };

  const handleCopy = () => {
    const text = message.content.replace(/[*#_~`]/g, "");
    navigator.clipboard.writeText(text);
    setCopied(true);
    setTimeout(() => setCopied(false), 1500);
  };

  // â”€â”€â”€ User Bubble â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (isUser) {
    return (
      <Box
        className="animate-slide-in-right"
        sx={{ display: "flex", justifyContent: "flex-end", mb: 2 }}
      >
        <Box sx={{ maxWidth: "80%" }}>
          <Box
            sx={{
              px: 2,
              py: 1.25,
              borderRadius: "16px 16px 4px 16px",
              background:
                "linear-gradient(135deg, hsl(217,71%,45%), hsla(217,71%,45%,0.85))",
              color: "#fff",
              fontSize: "14px",
              lineHeight: 1.6,
              boxShadow: "0 2px 8px hsla(217,71%,45%,0.2)",
            }}
          >
            {message.content}
          </Box>
          <Typography
            sx={{
              fontSize: "10px",
              color: "hsla(215,14%,55%,0.4)",
              textAlign: "right",
              mt: 0.5,
              mr: 0.5,
            }}
          >
            {formatTime(message.timestamp)}
          </Typography>
        </Box>
      </Box>
    );
  }

  // â”€â”€â”€ Bot Bubble â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const isEscalation = response?.responseType === "ESCALATION_OFFER";
  const showActions = !isStreaming; // Hide all actions during streaming

  return (
    <Box
      className="animate-slide-in-left"
      sx={{ display: "flex", justifyContent: "flex-start", mb: 2, gap: 1.25 }}
    >
      <Box sx={{ flexShrink: 0, mt: 0.5 }}>
        <FinCoreIcon size={26} variant="mini" animated={isStreaming} />
      </Box>
      <Box sx={{ maxWidth: "82%" }}>
        <Box
          sx={{
            px: 2,
            py: 1.5,
            borderRadius: "16px 16px 16px 4px",
            fontSize: "14px",
            lineHeight: 1.6,
            boxShadow: "0 1px 3px rgba(0,0,0,0.08)",
            ...(isEscalation
              ? {
                  bgcolor: "#fffbeb",
                  color: "#78350f",
                  border: "1px solid hsla(45,93%,47%,0.3)",
                }
              : {
                  bgcolor: "chat.botBubble",
                  color: "chat.botText",
                  border: "1px solid hsla(214,20%,88%,0.3)",
                }),
          }}
        >
          {/* Show streaming dots when content is empty and streaming */}
          {isStreaming && !message.content ? (
            <StreamingDots />
          ) : (
            <ReactMarkdown
              remarkPlugins={[remarkGfm]}
              components={markdownComponents}
            >
              {message.content}
            </ReactMarkdown>
          )}

          {/* Streaming cursor */}
          {isStreaming && message.content && (
            <Box
              component="span"
              sx={{
                display: "inline-block",
                width: 2,
                height: 14,
                bgcolor: "primary.main",
                ml: "1px",
                verticalAlign: "text-bottom",
                animation: "icon-glow-pulse 0.8s ease-in-out infinite",
              }}
            />
          )}

          {/* Navigation button - only after streaming ends */}
          <Fade in={showActions && !!response?.navigationLink} timeout={400}>
            <Box>
              {showActions &&
                (response?.responseType === "TEXT_REPLY" ||
                  response?.responseType === "NO_MATCH") &&
                response?.navigationLink && (
                  <Button
                    onClick={() =>
                      window.open(response.navigationLink, "_blank")
                    }
                    variant="contained"
                    size="small"
                    startIcon={<OpenInNewIcon sx={{ fontSize: 14 }} />}
                    fullWidth
                    sx={{
                      mt: 1.5,
                      borderRadius: 3,
                      textTransform: "none",
                      fontWeight: 500,
                      background:
                        "linear-gradient(135deg, hsl(217,71%,45%), hsla(217,71%,45%,0.85))",
                      boxShadow: "0 2px 8px hsla(217,71%,45%,0.2)",
                      "&:hover": {
                        boxShadow: "0 4px 12px hsla(217,71%,45%,0.3)",
                      },
                    }}
                  >
                    {response.navigationLabel}
                  </Button>
                )}
            </Box>
          </Fade>

          {/* Suggestion pills */}
          {showActions &&
            response?.responseType === "SUGGESTION" &&
            response.items && (
              <Box
                sx={{
                  mt: 1.5,
                  display: "flex",
                  flexDirection: "column",
                  gap: 0.75,
                }}
              >
                {response.items.map((item, idx) => (
                  <Button
                    key={idx}
                    onClick={(e) => {
                      e.stopPropagation();
                      onSuggestionClick(item);
                    }}
                    variant="outlined"
                    size="small"
                    fullWidth
                    sx={{
                      justifyContent: "flex-start",
                      borderRadius: 3,
                      textTransform: "none",
                      fontSize: "13px",
                      color: "chat.botText",
                      borderColor: "hsla(214,20%,88%,0.4)",
                      "&:hover": {
                        borderColor: "hsla(217,71%,45%,0.3)",
                        bgcolor: "hsla(214,20%,92%,1)",
                      },
                    }}
                  >
                    {item}
                  </Button>
                ))}
              </Box>
            )}

          {/* Escalation */}
          {showActions && isEscalation && (
            <Box sx={{ mt: 1.5, display: "flex", gap: 1 }}>
              <Button
                onClick={() => onSuggestionClick("Yes, please create a ticket")}
                variant="contained"
                size="small"
                startIcon={<WarningAmberIcon sx={{ fontSize: 14 }} />}
                sx={{
                  borderRadius: 3,
                  textTransform: "none",
                  fontWeight: 500,
                  bgcolor: "error.main",
                  "&:hover": { bgcolor: "error.dark" },
                }}
              >
                Raise IT Ticket
              </Button>
              <Button
                onClick={() => onSuggestionClick("No, I'll figure it out")}
                variant="outlined"
                size="small"
                sx={{
                  borderRadius: 3,
                  textTransform: "none",
                  borderColor: "hsla(45,93%,47%,0.4)",
                  color: "#92400e",
                  "&:hover": { bgcolor: "hsla(45,93%,47%,0.1)" },
                }}
              >
                No thanks
              </Button>
            </Box>
          )}

          {/* No match */}
          {showActions &&
            response?.responseType === "NO_MATCH" &&
            !response?.navigationLink && (
              <Button
                onClick={() => onSuggestionClick("Search the manual")}
                size="small"
                startIcon={<SearchIcon sx={{ fontSize: 12 }} />}
                sx={{
                  mt: 1,
                  textTransform: "none",
                  fontSize: "11px",
                  color: "hsla(215,14%,50%,0.7)",
                  "&:hover": { color: "chat.botText" },
                }}
              >
                Search the manual
              </Button>
            )}
        </Box>

        {/* Action bar - only after streaming ends */}
        <Fade in={showActions} timeout={400}>
          <Box
            sx={{
              display: "flex",
              alignItems: "center",
              gap: 0.25,
              mt: 0.75,
              ml: 1,
            }}
          >
            <IconButton
              onClick={() => handleFeedback("up")}
              size="small"
              sx={{
                p: 0.5,
                color:
                  message.feedback === "up"
                    ? "primary.main"
                    : "hsla(215,14%,55%,0.6)",
                bgcolor:
                  message.feedback === "up"
                    ? "hsla(217,71%,45%,0.1)"
                    : "transparent",
                "&:hover": { color: "chat.botText" },
              }}
            >
              {message.feedback === "up" ? (
                <ThumbUpIcon sx={{ fontSize: 14 }} />
              ) : (
                <ThumbUpOutlinedIcon sx={{ fontSize: 14 }} />
              )}
            </IconButton>
            <IconButton
              onClick={() => handleFeedback("down")}
              size="small"
              sx={{
                p: 0.5,
                color:
                  message.feedback === "down"
                    ? "error.main"
                    : "hsla(215,14%,55%,0.6)",
                bgcolor:
                  message.feedback === "down"
                    ? "hsla(0,72%,51%,0.1)"
                    : "transparent",
                "&:hover": { color: "chat.botText" },
              }}
            >
              {message.feedback === "down" ? (
                <ThumbDownIcon sx={{ fontSize: 14 }} />
              ) : (
                <ThumbDownOutlinedIcon sx={{ fontSize: 14 }} />
              )}
            </IconButton>
            <IconButton
              onClick={handleCopy}
              size="small"
              sx={{
                p: 0.5,
                color: "hsla(215,14%,55%,0.6)",
                "&:hover": { color: "chat.botText" },
              }}
            >
              {copied ? (
                <CheckIcon sx={{ fontSize: 14, color: "success.main" }} />
              ) : (
                <ContentCopyIcon sx={{ fontSize: 14 }} />
              )}
            </IconButton>
            <Typography
              sx={{ fontSize: "9px", color: "hsla(215,14%,55%,0.4)", ml: 0.5 }}
            >
              {formatTime(message.timestamp)}
            </Typography>
          </Box>
        </Fade>
      </Box>
    </Box>
  );
};

export default ChatBubble;















import Box from "@mui/material/Box";
import IconButton from "@mui/material/IconButton";
import Typography from "@mui/material/Typography";
import Stack from "@mui/material/Stack";
import Chip from "@mui/material/Chip";
import RemoveIcon from "@mui/icons-material/Remove";
import AddCommentOutlinedIcon from "@mui/icons-material/AddCommentOutlined";
import AutoAwesomeIcon from "@mui/icons-material/AutoAwesome";
import FinCoreIcon from "./FinCoreIcon";

const ChatHeader = ({ onMinimize, onClearChat }) => {
  return (
    <Stack
      direction="row"
      alignItems="center"
      justifyContent="space-between"
      sx={{
        px: 2,
        py: 1.5,
        // bgcolor: 'chat.headerBg',
        borderBottom: "1px solid hsla(220, 18%, 22%, 0.5)",
        backdropFilter: "blur(20px)",
      }}
    >
      <Stack direction="row" alignItems="center" spacing={1.5}>
        <FinCoreIcon size={34} glow animated />
        <Box>
          <Stack direction="row" alignItems="center" spacing={1}>
            <Typography
              variant="subtitle2"
              sx={{
                color: "chat.inputText",
                fontWeight: 600,
                letterSpacing: "-0.01em",
              }}
            >
              FinCore AI
            </Typography>
            <Chip
              icon={<AutoAwesomeIcon sx={{ fontSize: 10 }} />}
              label="Beta"
              size="small"
              sx={{
                height: 18,
                fontSize: "9px",
                fontWeight: 700,
                letterSpacing: "0.05em",
                textTransform: "uppercase",
                background:
                  "linear-gradient(135deg, hsla(217, 100%, 92%, 0.57), rgb(92, 149, 255))",
                color: "chat.pillText",
                border: "none",
                "& .MuiChip-icon": { fontSize: 10, color: "chat.pillText" },
              }}
            />
          </Stack>
          <Typography
            variant="caption"
            sx={{ color: "chat.inputPlaceholder", fontSize: "11px" }}
          >
            with Llama3-Q5
          </Typography>
        </Box>
      </Stack>

      <Stack direction="row" spacing={0.25}>
        <IconButton
          onClick={onClearChat}
          size="small"
          title="New chat"
          // sx={{
          //   color: "chat.inputPlaceholder",
          //   "&:hover": {
          //     color: "chat.inputText",
          //     bgcolor: "hsla(220,22%,16%,0.6)",
          //   },
          // }}
        >
          <AddCommentOutlinedIcon sx={{ fontSize: 18 }} />
        </IconButton>
        <IconButton
          onClick={onMinimize}
          size="small"
          title="Minimize"
          // sx={{
          //   color: "chat.inputPlaceholder",
          //   "&:hover": {
          //     color: "chat.inputText",
          //     bgcolor: "hsla(220,22%,16%,0.6)",
          //   },
          // }}
        >
          <RemoveIcon sx={{ fontSize: 18 }} />
        </IconButton>
      </Stack>
    </Stack>
  );
};

export default ChatHeader;

























import { useState, useRef, useEffect } from "react";
import Box from "@mui/material/Box";
import IconButton from "@mui/material/IconButton";
import CircularProgress from "@mui/material/CircularProgress";
import Typography from "@mui/material/Typography";
import SendIcon from "@mui/icons-material/Send";
import useApi from "../../../hooks/useApi";

const MAX_CHARS = 500;

const ChatInput = ({ onSend, isLoading }) => {
  const [value, setValue] = useState("");
  const textareaRef = useRef(null);
  const { callApi } = useApi();

  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = "auto";
      textareaRef.current.style.height =
        Math.min(textareaRef.current.scrollHeight, 120) + "px";
    }
  }, [value]);

  const handleSend = () => {
    const trimmed = value.trim();
    if (!trimmed || isLoading || trimmed.length > MAX_CHARS) return;
    onSend(trimmed);
    setValue("");
    if (textareaRef.current) textareaRef.current.style.height = "auto";
  };

  const handleKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const charCount = value.length;
  const isNearLimit = charCount > MAX_CHARS * 0.85;
  const isOverLimit = charCount > MAX_CHARS;

  return (
    <Box
      sx={{
        borderTop: "1px solid hsla(220, 18%, 22%, 0.4)",
        // bgcolor: 'hsla(220, 28%, 9%, 0.8)',
        backdropFilter: "blur(20px)",
        px: 1.5,
        py: 1.5,
      }}
    >
      <Box
        sx={{
          display: "flex",
          alignItems: "flex-end",
          gap: 1,
          bgcolor: "hsla(215, 100%, 94%, 0.27)",
          borderRadius: 1,
          px: 2,
          py: 1.25,
          border: "1px solid hsla(0, 0%, 0%, 0.42)",
          transition: "all 0.3s",
          "&:focus-within": { borderColor: "hsl(217, 100%, 31%)" },
        }}
      >
        <textarea
          ref={textareaRef}
          value={value}
          onChange={(e) => setValue(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="Ask me anything..."
          rows={1}
          style={{
            flex: 1,
            background: "transparent",
            color: "hsl(0, 0%, 0%)",
            fontSize: "14px",
            resize: "none",
            outline: "none",
            border: "none",
            maxHeight: 100,
            lineHeight: 1.6,
            fontFamily: "Inter, sans-serif",
          }}
        />
        <IconButton
          onClick={handleSend}
          disabled={!value.trim() || isLoading || isOverLimit}
          size="small"
          sx={{
            width: 32,
            height: 32,
            borderRadius: 2,
            background:
              "linear-gradient(135deg, hsl(217,71%,45%), hsla(217,71%,45%,0.8))",
            color: "#fff",
            "&:disabled": { opacity: 0.5 },
            "&:hover": {
              opacity: 0.9,
              boxShadow: "0 4px 12px hsla(217, 100%, 56%, 0.81)",
            },
            transition: "all 0.2s",
          }}
        >
          {isLoading ? (
            <CircularProgress size={16} sx={{ color: "#fff" }} />
          ) : (
            <SendIcon sx={{ fontSize: 16 }} />
          )}
        </IconButton>
      </Box>

      <Box
        sx={{
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          mt: 1,
          px: 0.5,
        }}
      >
        <Typography
          variant="caption"
          sx={{
            fontSize: "10.5px",
            color: "hsl(240, 1%, 14%)",
            letterSpacing: "0.02em",
          }}
        >
          Warning: AI can make mistakes. Verify important info.
        </Typography>
        {isNearLimit && (
          <Typography
            variant="caption"
            sx={{
              fontSize: "10px",
              fontWeight: 500,
              color: isOverLimit ? "error.main" : "hsla(215,14%,50%,0.7)",
            }}
          >
            {charCount}/{MAX_CHARS}
          </Typography>
        )}
      </Box>
    </Box>
  );
};

export default ChatInput;























import { useState, useRef, useEffect, useCallback } from "react";
import Box from "@mui/material/Box";
import Fab from "@mui/material/Fab";
import ChatHeader from "./ChatHeader";
import WelcomeScreen from "./WelcomeScreen";
import ChatBubble from "./ChatBubble";
import TypingIndicator from "./TypingIndicator";
import ChatInput from "./ChatInput";
import FinCoreIcon from "./FinCoreIcon";
import {
  sendMessageSSE,
  generateId,
  getCurrentScreen,
} from "../lib/chatSSEServices";
import { useSelector } from "react-redux";

const ChatWidget = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isClosing, setIsClosing] = useState(false);
  const [hasLaunched, setHasLaunched] = useState(false);
  const [streamingMessageId, setStreamingMessageId] = useState(null);
  const scrollRef = useRef(null);
  const abortRef = useRef(null);
  const token = useSelector((state) => state.auth.token);

  const scrollToBottom = useCallback(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTo({
        top: scrollRef.current.scrollHeight,
        behavior: "smooth",
      });
    }
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [messages, isLoading, scrollToBottom]);

  const handleStreamMessage = useCallback(
    async (apiMessage, displayMessage) => {
      const userMsg = {
        id: generateId(),
        role: "user",
        content: displayMessage || apiMessage,
        timestamp: new Date(),
        feedback: null,
      };
      setMessages((prev) => [...prev, userMsg]);
      setIsLoading(true);

      // Abort any existing stream
      if (abortRef.current) abortRef.current.abort();
      abortRef.current = new AbortController();

      const botId = generateId();

      const handlers = {
        onStart: () => {
          // Create empty bot bubble in streaming state
          setIsLoading(false);
          setStreamingMessageId(botId);
          setMessages((prev) => [
            ...prev,
            {
              id: botId,
              role: "bot",
              content: "",
              timestamp: new Date(),
              feedback: null,
              isStreaming: true,
              response: null,
            },
          ]);
        },

        onToken: (token) => {
          setMessages((prev) =>
            prev.map((msg) =>
              msg.id === botId ? { ...msg, content: msg.content + token } : msg,
            ),
          );
        },

        onEnd: (data) => {
          setStreamingMessageId(null);
          setMessages((prev) =>
            prev.map((msg) =>
              msg.id === botId
                ? {
                    ...msg,
                    isStreaming: false,
                    response: {
                      responseType: "TEXT_REPLY",
                      logId: data.logId,
                      navigationLink: data.navigationLink,
                      navigationLabel: data.navigationLabel,
                    },
                  }
                : msg,
            ),
          );
        },

        onSuggestion: (data) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => [
            ...prev,
            {
              id: botId,
              role: "bot",
              content: data.botReply,
              timestamp: new Date(),
              feedback: null,
              isStreaming: false,
              response: {
                responseType: "SUGGESTION",
                items: data.items,
                logId: data.logId,
              },
            },
          ]);
        },

        onEscalation: (data) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => [
            ...prev,
            {
              id: botId,
              role: "bot",
              content: data.botReply,
              timestamp: new Date(),
              feedback: null,
              isStreaming: false,
              response: { responseType: "ESCALATION_OFFER", logId: data.logId },
            },
          ]);
        },

        onError: (errorMsg) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
            // If bot bubble already exists, update it
            const existing = prev.find((m) => m.id === botId);
            if (existing) {
              return prev.map((msg) =>
                msg.id === botId
                  ? {
                      ...msg,
                      content: "Sorry, something went wrong. Please try again.",
                      isStreaming: false,
                    }
                  : msg,
              );
            }
            return [
              ...prev,
              {
                id: botId,
                role: "bot",
                content: "Sorry, something went wrong. Please try again.",
                timestamp: new Date(),
                feedback: null,
                isStreaming: false,
              },
            ];
          });
        },
      };

      try {
        await sendMessageSSE(
          {
            userMessage: apiMessage,
            currentScreen: getCurrentScreen(),
            token: token,
          },
          handlers,
          abortRef.current,
        );
      } catch {
        // handled by onError
      }
    },
    [],
  );

  const handleSend = (text) => handleStreamMessage(text);

  const handleQuickAction = (label, slashCommand) => {
    const currentScreen = getCurrentScreen();
    const apiMessage = slashCommand
      ? `${slashCommand} ${currentScreen}`.trim()
      : label;
    handleStreamMessage(apiMessage, label);
  };

  const handleFeedback = (messageId, feedback) => {
    setMessages((prev) =>
      prev.map((msg) =>
        msg.id === messageId
          ? { ...msg, feedback: msg.feedback === feedback ? null : feedback }
          : msg,
      ),
    );
  };

  const handleClearChat = () => {
    if (abortRef.current) abortRef.current.abort();
    setMessages([]);
    setStreamingMessageId(null);
    setIsLoading(false);
  };

  const handleOpen = () => {
    setIsOpen(true);
    if (!hasLaunched) setHasLaunched(true);
  };

  const handleClose = () => {
    setIsClosing(true);
    setTimeout(() => {
      setIsOpen(false);
      setIsClosing(false);
    }, 250);
  };

  if (!isOpen) {
    return (
      <Fab
        onClick={handleOpen}
        className="fab-pulse"
        aria-label="Open FinCore AI Assistant"
        sx={{
          position: "fixed",
          bottom: 24,
          right: 24,
          zIndex: 50,
          width: 60,
          height: 60,
          background:
            "linear-gradient(135deg, hsla(217, 71%, 45%, 0.78), hsl(217,71%,35%))",
          "&:hover": {
            transform: "scale(1.1)",
            background:
              "linear-gradient(135deg, hsl(217,71%,50%), hsl(217,71%,40%))",
          },
          transition: "all 0.3s",
          boxShadow: "0 8px 32px hsla(217,71%,35%,0.4)",
        }}
      >
        <FinCoreIcon size={58} glow animated />
      </Fab>
    );
  }

  const showWelcome = messages.length === 0;
  const isFirstLaunch = showWelcome && hasLaunched;

  return (
    <Box
      className={isClosing ? "animate-chat-close" : "animate-chat-open"}
      sx={{
        position: "fixed",
        bottom: 24,
        right: 24,
        zIndex: 50,
        width: 390,
        height: 650,
        display: "flex",
        flexDirection: "column",
        borderRadius: 1,
        overflow: "hidden",
        boxShadow: "0 24px 48px rgb(43, 42, 42)",
        border: "0 24px 48px rgb(148, 127, 127)",
        // bgcolor: "hsl(221, 100%, 33%)",
        backdropFilter: "blur(80px)",
      }}
    >
      <ChatHeader onMinimize={handleClose} onClearChat={handleClearChat} />

      <Box
        ref={scrollRef}
        className="chat-scrollbar"
        sx={{ flex: 1, overflowY: "auto" }}
      >
        {showWelcome ? (
          <WelcomeScreen
            onQuickAction={handleQuickAction}
            showTypewriter={isFirstLaunch}
          />
        ) : (
          <Box sx={{ px: 2, py: 2 }}>
            {messages.map((msg) => (
              <ChatBubble
                key={msg.id}
                message={msg}
                onSuggestionClick={handleSend}
                onFeedback={handleFeedback}
              />
            ))}
            {isLoading && <TypingIndicator />}
          </Box>
        )}
      </Box>

      <ChatInput
        onSend={handleSend}
        isLoading={isLoading || !!streamingMessageId}
      />
    </Box>
  );
};

export default ChatWidget;




















const FinCoreIcon = ({ size = 24, className = "", glow = false, animated = false, variant = "full", active = false }) => {
  const id = `fc-${size}-${Math.random().toString(36).slice(2, 6)}`;

  if (variant === "mini") {
    return (
      <div style={{ position: 'relative', display: 'inline-flex', alignItems: 'center', justifyContent: 'center' }} className={active ? "thinking-icon-active" : ""}>
        {active && (
          <>
            <div style={{
              position: 'absolute', inset: -4, borderRadius: '50%',
              border: '2px solid hsl(217, 71%, 53%)', opacity: 0.7,
            }} className="animate-spin-slow" />
            <div style={{
              position: 'absolute', inset: -3, borderRadius: '50%',
              background: 'hsla(217, 71%, 45%, 0.2)',
              animation: 'icon-glow-pulse 1.5s ease-in-out infinite',
            }} />
          </>
        )}
        <svg
          width={active ? size * 1.1 : size}
          height={active ? size * 1.1 : size}
          viewBox="0 0 24 24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
          className={className}
          style={{ transition: 'all 0.3s', filter: active ? 'drop-shadow(0 0 8px hsl(217,71%,53%))' : 'none' }}
        >
          <defs>
            <linearGradient id={`${id}-mini-bg`} x1="0" y1="0" x2="24" y2="24" gradientUnits="userSpaceOnUse">
              <stop offset="0%" stopColor="hsl(217, 71%, 53%)" />
              <stop offset="100%" stopColor="hsl(260, 85%, 38%)" />
            </linearGradient>
            <linearGradient id={`${id}-mini-spark`} x1="8" y1="4" x2="16" y2="20" gradientUnits="userSpaceOnUse">
              <stop offset="0%" stopColor="white" />
              <stop offset="100%" stopColor="hsl(210, 80%, 88%)" />
            </linearGradient>
          </defs>
          <circle cx="12" cy="12" r="11" fill={`url(#${id}-mini-bg)`} />
          {active && (
            <circle cx="12" cy="12" r="9.5" fill="none" stroke="white" strokeWidth="0.5" strokeDasharray="3 4" strokeOpacity="0.5">
              <animateTransform attributeName="transform" type="rotate" from="0 12 12" to="360 12 12" dur="1.5s" repeatCount="indefinite" />
            </circle>
          )}
          <path d="M12 4 L13.2 10.5 L12 20 L10.8 10.5 Z" fill={`url(#${id}-mini-spark)`} fillOpacity="0.9">
            <animate attributeName="fill-opacity" values={active ? "0.5;1;0.5" : "0.6;1;0.6"} dur={active ? "0.8s" : "2s"} repeatCount="indefinite" />
          </path>
          <path d="M4 12 L10.5 10.8 L20 12 L10.5 13.2 Z" fill={`url(#${id}-mini-spark)`} fillOpacity="0.8">
            <animate attributeName="fill-opacity" values={active ? "0.4;1;0.4" : "0.5;0.95;0.5"} dur={active ? "0.8s" : "2s"} begin="0.2s" repeatCount="indefinite" />
          </path>
          <circle cx="12" cy="12" r="2.2" fill="white" fillOpacity="0.95">
            <animate attributeName="r" values={active ? "1.5;3;1.5" : "1.8;2.5;1.8"} dur={active ? "0.6s" : "1.8s"} repeatCount="indefinite" />
            <animate attributeName="fill-opacity" values="0.8;1;0.8" dur={active ? "0.6s" : "1.8s"} repeatCount="indefinite" />
          </circle>
        </svg>
      </div>
    );
  }

  return (
    <svg width={size} height={size} viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" className={className}>
      <defs>
        <linearGradient id={`${id}-bg`} x1="0" y1="0" x2="40" y2="40" gradientUnits="userSpaceOnUse">
          <stop offset="0%" stopColor="hsl(217, 71%, 53%)" />
          <stop offset="50%" stopColor="hsl(230, 80%, 42%)" />
          <stop offset="100%" stopColor="hsl(260, 85%, 38%)" />
        </linearGradient>
        <linearGradient id={`${id}-spark`} x1="12" y1="8" x2="28" y2="34" gradientUnits="userSpaceOnUse">
          <stop offset="0%" stopColor="white" />
          <stop offset="100%" stopColor="hsl(210, 80%, 88%)" />
        </linearGradient>
        <linearGradient id={`${id}-orbit`} x1="8" y1="8" x2="32" y2="32" gradientUnits="userSpaceOnUse">
          <stop offset="0%" stopColor="hsl(200, 100%, 80%)">
            {animated && <animate attributeName="stop-color" values="hsl(200,100%,80%);hsl(260,100%,80%);hsl(200,100%,80%)" dur="4s" repeatCount="indefinite" />}
          </stop>
          <stop offset="100%" stopColor="hsl(260, 100%, 75%)">
            {animated && <animate attributeName="stop-color" values="hsl(260,100%,75%);hsl(200,100%,75%);hsl(260,100%,75%)" dur="4s" repeatCount="indefinite" />}
          </stop>
        </linearGradient>
        <radialGradient id={`${id}-inner`} cx="35%" cy="30%" r="65%">
          <stop offset="0%" stopColor="white" stopOpacity="0.18" />
          <stop offset="100%" stopColor="white" stopOpacity="0" />
        </radialGradient>
        <radialGradient id={`${id}-core-glow`} cx="50%" cy="50%" r="50%">
          <stop offset="0%" stopColor="white" stopOpacity="0.6" />
          <stop offset="40%" stopColor="hsl(217, 80%, 70%)" stopOpacity="0.3" />
          <stop offset="100%" stopColor="hsl(260, 80%, 50%)" stopOpacity="0" />
        </radialGradient>
        {glow && (
          <filter id={`${id}-glow`}>
            <feGaussianBlur stdDeviation="1.5" result="blur" />
            <feMerge><feMergeNode in="blur" /><feMergeNode in="SourceGraphic" /></feMerge>
          </filter>
        )}
      </defs>
      <circle cx="20" cy="20" r="19" fill={`url(#${id}-bg)`} />
      <circle cx="20" cy="20" r="19" fill={`url(#${id}-inner)`} />
      <circle cx="20" cy="20" r="12" fill={`url(#${id}-core-glow)`}>
        {animated && <animate attributeName="r" values="10;14;10" dur="3s" repeatCount="indefinite" />}
      </circle>
      <ellipse cx="20" cy="20" rx="16" ry="10" fill="none" stroke={`url(#${id}-orbit)`} strokeWidth="0.7" strokeDasharray="3 4" strokeLinecap="round" transform="rotate(-25 20 20)">
        {animated && <animateTransform attributeName="transform" type="rotate" from="-25 20 20" to="335 20 20" dur="12s" repeatCount="indefinite" />}
      </ellipse>
      <ellipse cx="20" cy="20" rx="14" ry="7" fill="none" stroke={`url(#${id}-orbit)`} strokeWidth="0.55" strokeDasharray="2 5" strokeLinecap="round" strokeOpacity="0.6" transform="rotate(55 20 20)">
        {animated && <animateTransform attributeName="transform" type="rotate" from="415 20 20" to="55 20 20" dur="16s" repeatCount="indefinite" />}
      </ellipse>
      <ellipse cx="20" cy="20" rx="11" ry="5" fill="none" stroke={`url(#${id}-orbit)`} strokeWidth="0.4" strokeDasharray="1.5 3.5" strokeLinecap="round" strokeOpacity="0.35" transform="rotate(110 20 20)">
        {animated && <animateTransform attributeName="transform" type="rotate" from="110 20 20" to="470 20 20" dur="8s" repeatCount="indefinite" />}
      </ellipse>
      <g filter={glow ? `url(#${id}-glow)` : undefined}>
        <path d="M20 11 L22.2 18 L20 30 L17.8 18 Z" fill={`url(#${id}-spark)`} fillOpacity="0.9">
          {animated && <animate attributeName="fill-opacity" values="0.7;1;0.7" dur="2.5s" repeatCount="indefinite" />}
        </path>
        <path d="M11 20 L18 17.8 L29 20 L18 22.2 Z" fill={`url(#${id}-spark)`} fillOpacity="0.8">
          {animated && <animate attributeName="fill-opacity" values="0.6;0.95;0.6" dur="2.5s" begin="0.6s" repeatCount="indefinite" />}
        </path>
        <path d="M13.5 13.5 L18.5 18 L26.5 26.5 L18 18.5 Z" fill={`url(#${id}-spark)`} fillOpacity="0.35">
          {animated && <animate attributeName="fill-opacity" values="0.2;0.5;0.2" dur="3s" begin="0.3s" repeatCount="indefinite" />}
        </path>
        <path d="M26.5 13.5 L18.5 18 L13.5 26.5 L18 18.5 Z" fill={`url(#${id}-spark)`} fillOpacity="0.35">
          {animated && <animate attributeName="fill-opacity" values="0.2;0.5;0.2" dur="3s" begin="0.9s" repeatCount="indefinite" />}
        </path>
        <circle cx="20" cy="20" r="3.2" fill="white" fillOpacity="0.95">
          {animated && (
            <>
              <animate attributeName="r" values="2.8;3.8;2.8" dur="2s" repeatCount="indefinite" />
              <animate attributeName="fill-opacity" values="0.85;1;0.85" dur="2s" repeatCount="indefinite" />
            </>
          )}
        </circle>
        <circle cx="20" cy="20" r="1.6" fill="white">
          {animated && <animate attributeName="r" values="1.4;2;1.4" dur="1.5s" repeatCount="indefinite" />}
        </circle>
      </g>
      <circle cx="8" cy="17" r="1.1" fill="hsl(200, 100%, 85%)" fillOpacity="0.8">
        {animated && (
          <>
            <animate attributeName="cx" values="8;12;32;28;8" dur="12s" repeatCount="indefinite" />
            <animate attributeName="cy" values="17;10;16;28;17" dur="12s" repeatCount="indefinite" />
            <animate attributeName="fillOpacity" values="0.3;0.9;0.5;0.9;0.3" dur="12s" repeatCount="indefinite" />
          </>
        )}
      </circle>
      <circle cx="32" cy="24" r="0.9" fill="hsl(260, 100%, 82%)" fillOpacity="0.7">
        {animated && (
          <>
            <animate attributeName="cx" values="32;28;8;12;32" dur="16s" repeatCount="indefinite" />
            <animate attributeName="cy" values="24;30;24;12;24" dur="16s" repeatCount="indefinite" />
            <animate attributeName="fillOpacity" values="0.2;0.8;0.4;0.8;0.2" dur="16s" repeatCount="indefinite" />
          </>
        )}
      </circle>
      <circle cx="14" cy="30" r="0.7" fill="hsl(210, 90%, 88%)" fillOpacity="0.5">
        {animated && (
          <>
            <animate attributeName="cx" values="14;26;26;14;14" dur="8s" repeatCount="indefinite" />
            <animate attributeName="cy" values="30;28;12;14;30" dur="8s" repeatCount="indefinite" />
            <animate attributeName="fillOpacity" values="0.3;0.7;0.3;0.7;0.3" dur="8s" repeatCount="indefinite" />
          </>
        )}
      </circle>
    </svg>
  );
};

export default FinCoreIcon;

















import { useState, useEffect } from "react";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import FinCoreIcon from "./FinCoreIcon";
import { keyframes } from "framer-motion";

const thinkingStages = [
  { text: "Thinking", icon: "ðŸ§ " },
  { text: "Searching knowledge base", icon: "ðŸ”" },
  { text: "Analyzing results", icon: "âš¡" },
  { text: "Generating response", icon: "âœ¨" },
];

const bounce = {
  "@keyframes bounce": {
    "0%, 44%, 100%": { transform: "translateY(0)", opacity: 0.4 },
    "22%": { transform: "translateY(-6px)", opacity: 1 },
  },
};

const TypingIndicator = () => {
  const [stageIdx, setStageIdx] = useState(0);
  const [displayedText, setDisplayedText] = useState("");
  const [isTyping, setIsTyping] = useState(true);

  // Cycle through stages
  useEffect(() => {
    const interval = setInterval(() => {
      setStageIdx((prev) => (prev + 1) % thinkingStages.length);
      setDisplayedText("");
      setIsTyping(true);
    }, 2000);
    return () => clearInterval(interval);
  }, []);

  // Typewriter effect for each stage text
  useEffect(() => {
    const text = thinkingStages[stageIdx].text;
    if (!isTyping) return;
    let i = 0;
    const interval = setInterval(() => {
      i++;
      setDisplayedText(text.slice(0, i));
      if (i >= text.length) {
        clearInterval(interval);
        setIsTyping(false);
      }
    }, 40);
    return () => clearInterval(interval);
  }, [stageIdx, isTyping]);

  const stage = thinkingStages[stageIdx];

  return (
    <Box
      className="animate-slide-in-left"
      sx={{ display: "flex", justifyContent: "flex-start", mb: 1.5, gap: 1.25 }}
    >
      <Box sx={{ flexShrink: 0, mt: 0.5 }}>
        <div className="thinking-icon-wrapper">
          <FinCoreIcon size={28} variant="mini" animated active />
        </div>
      </Box>

      <Box
        sx={{
          px: 2,
          py: 1.5,
          borderRadius: "16px 16px 16px 4px",
          // bgcolor: "hsla(220, 18%, 96%, 0.95)",
          boxShadow: "0 1px 3px rgba(0,0,0,0.08)",
          border: "1px solid hsla(220, 2%, 27%, 0.25)",
          backdropFilter: "blur(8px)",
          minWidth: 180,
        }}
      >
        {/* Stage text with typewriter */}
        <Box sx={{ display: "flex", alignItems: "center", gap: 1, mb: 0.75 }}>
          <span style={{ fontSize: 14 }}>{stage.icon}</span>
          <Typography
            sx={{
              fontSize: "12px",
              color: "hsla(220,25%,12%,0.8)",
              fontWeight: 600,
              fontFamily: "monospace",
            }}
          >
            {displayedText}
            {isTyping && (
              <Box
                component="span"
                sx={{
                  display: "inline-block",
                  width: 2,
                  height: 12,
                  bgcolor: "primary.main",
                  ml: "2px",
                  verticalAlign: "middle",
                  animation: "icon-glow-pulse 0.8s ease-in-out infinite",
                }}
              />
            )}
          </Typography>
        </Box>

        {/* Bouncing dots */}
        <Box sx={{ display: "flex", alignItems: "center", gap: 0.75 }}>
          <Box
            className="typing-dot"
            sx={{
              width: 6,
              height: 6,
              borderRadius: "50%",
              bgcolor: "primary.main",
              animation: `${bounce} 1.4s ease-in-out infinite`,
              animationDelay: "0ms",
            }}
          />
          <Box
            className="typing-dot"
            sx={{
              width: 6,
              height: 6,
              borderRadius: "50%",
              bgcolor: "primary.main",
              animation: `${bounce} 1.4s ease-in-out infinite`,
              animationDelay: "200ms",
            }}
          />
          <Box
            className="typing-dot"
            sx={{
              width: 6,
              height: 6,
              borderRadius: "50%",
              bgcolor: "primary.main",
              animation: `${bounce} 1.4s ease-in-out infinite`,
              animationDelay: "400ms",
            }}
          />
        </Box>
      </Box>
    </Box>
  );
};

export default TypingIndicator;



















import { useState, useEffect } from "react";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import Chip from "@mui/material/Chip";
import ButtonBase from "@mui/material/ButtonBase";
import GridViewIcon from "@mui/icons-material/GridView";
import PeopleOutlineIcon from "@mui/icons-material/PeopleOutline";
import MenuBookIcon from "@mui/icons-material/MenuBook";
import HelpOutlineIcon from "@mui/icons-material/HelpOutline";
import DescriptionOutlinedIcon from "@mui/icons-material/DescriptionOutlined";
import AutoAwesomeIcon from "@mui/icons-material/AutoAwesome";
import BoltIcon from "@mui/icons-material/Bolt";
import PsychologyIcon from "@mui/icons-material/Psychology";
import FinCoreIcon from "./FinCoreIcon";

const quickActions = [
  { label: "CGL Management", icon: GridViewIcon, command: "/action module" },
  {
    label: "User Management",
    icon: PeopleOutlineIcon,
    command: "/action module",
  },
  { label: "Journal Posting", icon: MenuBookIcon, command: "/action module" },
  { label: "Global FAQs", icon: HelpOutlineIcon, command: "/action faq" },
  {
    label: "Reports & Analytics",
    icon: DescriptionOutlinedIcon,
    command: "/action module",
  },
];

const capabilities = [
  { icon: PsychologyIcon, label: "RAG-Powered" },
  { icon: BoltIcon, label: "Instant Answers" },
  { icon: AutoAwesomeIcon, label: "Context-Aware" },
];

const GREETING =
  "Hi there, I am the FinCore Smart Assistant. How can I help you today?";

const WelcomeScreen = ({ onQuickAction, showTypewriter = true }) => {
  const [displayedText, setDisplayedText] = useState(
    showTypewriter ? "" : GREETING,
  );
  const [isTypingDone, setIsTypingDone] = useState(!showTypewriter);
  const [showActions, setShowActions] = useState(!showTypewriter);

  useEffect(() => {
    if (!showTypewriter) return;
    let i = 0;
    const interval = setInterval(() => {
      i++;
      setDisplayedText(GREETING.slice(0, i));
      if (i >= GREETING.length) {
        clearInterval(interval);
        setIsTypingDone(true);
        setTimeout(() => setShowActions(true), 200);
      }
    }, 28);
    return () => clearInterval(interval);
  }, [showTypewriter]);

  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        height: "100%",
        px: 3,
        py: 4,
      }}
    >
      {/* Hero icon */}
      <Box sx={{ position: "relative", mb: 3 }}>
        <Box
          sx={{
            position: "absolute",
            inset: 0,
            borderRadius: "50%",
            bgcolor: "hsla(217,71%,45%,0.15)",
            filter: "blur(24px)",
            transform: "scale(2)",
            animation: "icon-glow-pulse 3s ease-in-out infinite",
          }}
        />
        <Box
          sx={{
            position: "absolute",
            inset: 0,
            borderRadius: "50%",
            //bgcolor: "hsla(217,71%,45%,0.1)",
            filter: "blur(12px)",
            transform: "scale(1.5)",
          }}
        />
        <Box sx={{ position: "relative", zIndex: 1 }}>
          <FinCoreIcon size={60} glow animated />
        </Box>
      </Box>

      {/* Greeting - embedded robotic terminal style */}
      <Box
        sx={{
          minHeight: 72,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          mb: 1.5,
          maxWidth: 310,
          px: 0,
          py: 1.5,
          borderRadius: 2,
          // bgcolor: "hsla(218, 27%, 8%, 0.25)",
          // border: "1px solid hsla(217,71%,45%,0.2  )",
          // boxShadow:
          //   "inset 0 2px 8px hsla(220,25%,5%,0.4), 0 0 20px hsla(217,71%,45%,0.05)",
          position: "relative",
          overflow: "hidden",
          "&::before": {
            content: '""',
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            height: "1px",
            // background:
            //   "linear-gradient(90deg, transparent, hsla(217,71%,45%,0.4), transparent)",
          },
        }}
      >
        <Typography
          sx={{
            fontSize: "12 px",
            //color: "hsla(217, 92%, 14%, 0.95)",
            textAlign: "center",
            lineHeight: 1.7,
            fontWeight: 500,
            fontFamily: '"Share Tech Mono", monospace',
            letterSpacing: "0.03em",
            //textShadow: "0 0 8px hsla(228, 12%, 8%, 0.51)",
          }}
        >
          {displayedText}
          {showTypewriter && !isTypingDone && (
            <Box
              component="span"
              sx={{
                display: "inline-block",
                width: 10, // Slightly bigger cursor
                height: 20,
                bgcolor: "currentColor", // Matches font color automatically
                ml: "4px",
                verticalAlign: "middle",
                animation: "cursor-blink 1s step-end infinite",
                "@keyframes cursor-blink": {
                  "0%, 100%": { opacity: 1 },
                  "50%": { opacity: 0 },
                },
              }}
            />
          )}
        </Typography>
      </Box>

      {/* Capability badges */}
      <Box
        sx={{
          display: "flex",
          gap: 1,
          mb: 3,
          transition: "all 0.5s",
          opacity: isTypingDone ? 1 : 0,
          transform: isTypingDone ? "translateY(0)" : "translateY(8px)",
        }}
      >
        {capabilities.map(({ icon: Icon, label }) => (
          <Chip
            key={label}
            icon={<Icon sx={{ fontSize: 12, color: "primary.main" }} />}
            label={label}
            size="small"
            sx={{
              height: 22,
              fontSize: "10px",
              // bgcolor: "hsla(204, 63%, 67%, 0.44)",
              border: "1px solid hsla(276, 64%, 37%, 0.43)",
              color: "chat.inputPlaceholder",
              backdropFilter: "blur(8px)",
              "& .MuiChip-icon": { ml: 0.5 },
            }}
          />
        ))}
      </Box>

      {/* Quick actions */}
      <Box
        sx={{
          width: "100%",
          transition: "all 0.5s",
          opacity: showActions ? 1 : 0,
          transform: showActions ? "translateY(0)" : "translateY(16px)",
          pointerEvents: showActions ? "auto" : "none",
        }}
      >
        <Typography
          sx={{
            fontSize: "10px",
            textTransform: "uppercase",
            letterSpacing: "0.2em",
            //color: "hsla(213, 69%, 27%, 0.78)",
            fontWeight: 600,
            px: 0.5,
            mb: 1.25,
          }}
        >
          Quick Access
        </Typography>
        <Box sx={{ display: "flex", flexWrap: "wrap", gap: 1 }}>
          {quickActions.map(({ label, icon: Icon, command }) => (
            <ButtonBase
              key={label}
              onClick={() => onQuickAction(label, command)}
              sx={{
                display: "flex",
                alignItems: "center",
                gap: 1,
                px: 1.5,
                py: 1,
                borderRadius: 3,
                // Changed from invalid hsla to rgba for white transparency
                //bgcolor: "rgba(255, 255, 255, 0.05)",
                color: "chat.pillText",
                fontSize: "13px",
                fontWeight: 500,
                // Fixed border color
                border: "1px solid rgba(0, 0, 0, 0.42)",
                backdropFilter: "blur(8px)",
                transition: "all 0.2s",
                "&:hover": {
                  bgcolor: "chat.pillHover",
                  //color: "#0b0072",
                  // Fixed hover border and shadow using valid HSL (Blue hue is ~217)
                  borderColor: "hsla(217, 100%, 17%, 0.91)",
                  boxShadow: "0 4px 12px hsla(217, 71%, 45%, 0.1)",
                  transform: "scale(1.02)",
                },
                "&:active": { transform: "scale(0.98)" },
              }}
            >
              <Icon sx={{ fontSize: 16, opacity: 0.6 }} />
              {label}
            </ButtonBase>
          ))}
        </Box>
      </Box>
    </Box>
  );
};

export default WelcomeScreen;

















// â”€â”€â”€ Mock Response Database (Markdown format) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const mockResponses = {
  "CGL Management": {
    logId: "log-001",
    responseType: "TEXT_REPLY",
    botReply:
      "The **CGL Management** module allows you to configure and manage your **Chart of General Ledger** accounts.\n\nYou can create, edit, and deactivate GL accounts, assign them to categories, and set up hierarchical structures for reporting.",
    navigationLink: "/cgl-management",
    navigationLabel: "Go to CGL Management",
  },
  "User Management": {
    logId: "log-002",
    responseType: "SUGGESTION",
    botReply:
      "I can help you with **User Management**. What would you like to do?",
    items: [
      "Create a new user account",
      "Reset a user's password",
      "Update user roles and permissions",
      "Deactivate a user account",
      "View user activity logs",
    ],
  },
  "Journal Posting": {
    logId: "log-003",
    responseType: "TEXT_REPLY",
    botReply:
      "The **Journal Posting** module lets you create manual journal entries, review pending entries, and post approved journals to the general ledger.\n\nAll entries require **dual authorization** before posting.",
    navigationLink: "/journal-posting",
    navigationLabel: "Go to Journal Posting",
  },
  "Reports & Analytics": {
    logId: "log-010",
    responseType: "TEXT_REPLY",
    botReply:
      "The **Reports & Analytics** module provides comprehensive financial reporting capabilities.\n\nYou can generate **Balance Sheets**, **P&L Statements**, **Trial Balance**, and custom analytical reports with drill-down support.",
    navigationLink: "/reports",
    navigationLabel: "Go to Reports",
  },
  "Global FAQs": {
    logId: "log-004",
    responseType: "SUGGESTION",
    botReply:
      "Here are some **frequently asked questions**. Select one to learn more:",
    items: [
      "How do I reset my password?",
      "What are the system requirements?",
      "How do I export reports to Excel?",
      "What is the data retention policy?",
      "How do I set up two-factor authentication?",
    ],
  },
  "How do I reset my password?": {
    logId: "log-005",
    responseType: "TEXT_REPLY",
    botReply:
      'To reset your password:\n\n1. Click on **"Forgot Password"** on the login screen.\n2. Enter your registered email address.\n3. Check your inbox for a reset link (valid for 30 minutes).\n4. Create a new password meeting the security requirements.\n\nIf you don\'t receive the email, contact your system administrator.',
  },
  "What are the system requirements?": {
    logId: "log-011",
    responseType: "TEXT_REPLY",
    botReply:
      "FinCore supports the following browsers:\n\n- **Google Chrome** (latest 2 versions)\n- **Mozilla Firefox** (latest 2 versions)\n- **Microsoft Edge** (latest 2 versions)\n\nMinimum screen resolution: **1280Ã—720**. A stable internet connection of at least **5 Mbps** is recommended.",
  },
  "How do I export reports to Excel?": {
    logId: "log-012",
    responseType: "TEXT_REPLY",
    botReply:
      'To export reports:\n\n1. Navigate to the **Reports** module.\n2. Generate your desired report.\n3. Click the **"Export"** button in the top-right corner.\n4. Select **Excel (.xlsx)** or **CSV** format.\n5. The file will download automatically.',
    navigationLink: "/reports",
    navigationLabel: "Go to Reports",
  },
  "What is the data retention policy?": {
    logId: "log-013",
    responseType: "TEXT_REPLY",
    botReply:
      "FinCore's data retention policy:\n\n- **Transaction data**: Retained for 7 years (regulatory compliance).\n- **Audit logs**: Retained for 5 years.\n- **Session logs**: Retained for 90 days.\n- **Archived data**: Available upon request from IT support.",
  },
  "How do I set up two-factor authentication?": {
    logId: "log-014",
    responseType: "TEXT_REPLY",
    botReply:
      'To enable 2FA:\n\n1. Go to **Settings â†’ Security**.\n2. Click **"Enable Two-Factor Authentication"**.\n3. Scan the QR code with your authenticator app (Google Authenticator, Microsoft Authenticator).\n4. Enter the 6-digit code to verify.\n5. Save your **backup codes** securely.',
    navigationLink: "/settings/security",
    navigationLabel: "Go to Security Settings",
  },
  "Create a new user account": {
    logId: "log-015",
    responseType: "TEXT_REPLY",
    botReply:
      'To create a new user:\n\n1. Navigate to **Admin â†’ User Management**.\n2. Click **"Add New User"**.\n3. Fill in the required fields: Name, Email, Role, Department.\n4. Set initial permissions based on the role template.\n5. Click **"Create"** â€” the user will receive an activation email.',
    navigationLink: "/admin/users/new",
    navigationLabel: "Create New User",
  },
  "Reset a user's password": {
    logId: "log-016",
    responseType: "TEXT_REPLY",
    botReply:
      'To reset another user\'s password (Admin only):\n\n1. Go to **Admin â†’ User Management**.\n2. Search for the user.\n3. Click the **â‹®** menu â†’ **"Reset Password"**.\n4. A temporary password will be sent to their registered email.\n\nThe user must change it on their next login.',
  },
  "Update user roles and permissions": {
    logId: "log-017",
    responseType: "TEXT_REPLY",
    botReply:
      'To update roles:\n\n1. Go to **Admin â†’ User Management**.\n2. Select the user.\n3. Click **"Edit Roles"**.\n4. Assign or remove roles from the available templates.\n5. For custom permissions, toggle individual access rights.\n6. Click **"Save"** â€” changes take effect immediately.',
  },
  "Deactivate a user account": {
    logId: "log-018",
    responseType: "TEXT_REPLY",
    botReply:
      'To deactivate a user:\n\n1. Go to **Admin â†’ User Management**.\n2. Select the user.\n3. Click **"Deactivate Account"**.\n4. Confirm the action.\n\nâš ï¸ Deactivated users cannot log in but their data and history are preserved for audit purposes.',
  },
  "View user activity logs": {
    logId: "log-019",
    responseType: "TEXT_REPLY",
    botReply:
      'To view activity logs:\n\n1. Go to **Admin â†’ User Management**.\n2. Select the user.\n3. Click the **"Activity Log"** tab.\n\nYou can filter by date range, action type, and module. Logs include login history, data modifications, and approval actions.',
    navigationLink: "/admin/users",
    navigationLabel: "Go to User Management",
  },
  "Search the manual": {
    logId: "log-020",
    responseType: "TEXT_REPLY",
    botReply:
      "You can access the **FinCore User Manual** from the Help menu in the top navigation bar, or visit the documentation portal directly.\n\nThe manual covers all modules, workflows, and troubleshooting guides.",
    navigationLink: "/help/manual",
    navigationLabel: "Open User Manual",
  },
  "Yes, please create a ticket": {
    logId: "log-021",
    responseType: "TEXT_REPLY",
    botReply:
      "âœ… I've created an **IT Support Ticket** for your issue.\n\nðŸ“‹ **Ticket ID**: INC-2024-00847\nðŸ“§ You'll receive a confirmation email shortly.\nâ±ï¸ **Expected response time**: Within 4 business hours.\n\nIs there anything else I can help with?",
  },
  "No, I'll figure it out": {
    logId: "log-022",
    responseType: "TEXT_REPLY",
    botReply:
      "No problem! Feel free to ask me anything else. I'm here to help whenever you need me. ðŸ˜Š",
  },
  escalation: {
    logId: "log-006",
    responseType: "ESCALATION_OFFER",
    botReply:
      "I'm having trouble finding the right answer for your query. Would you like me to **raise an IT support ticket** so our team can assist you directly?",
  },
  default: {
    logId: "log-007",
    responseType: "NO_MATCH",
    botReply:
      "I'm sorry, I couldn't find relevant information for your query. You might find the answer in the **FinCore User Manual**.",
  },
};

// â”€â”€â”€ Small Talk Responses â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const smallTalkResponses = [
  {
    keywords: [
      "hello",
      "hi",
      "hey",
      "howdy",
      "greetings",
      "good morning",
      "good afternoon",
      "good evening",
    ],
    response: {
      logId: "st-001",
      responseType: "TEXT_REPLY",
      botReply:
        "Hello! ðŸ‘‹ I'm the **FinCore Smart Assistant**. How can I help you today? You can ask me about any module, process, or feature in FinCore.",
    },
  },
  {
    keywords: ["thank", "thanks", "thank you", "thx", "ty", "appreciated"],
    response: {
      logId: "st-002",
      responseType: "TEXT_REPLY",
      botReply:
        "You're welcome! ðŸ˜Š Happy to help. Is there anything else you'd like to know?",
    },
  },
  {
    keywords: ["bye", "goodbye", "see you", "cya", "later", "quit"],
    response: {
      logId: "st-003",
      responseType: "TEXT_REPLY",
      botReply:
        "Goodbye! ðŸ‘‹ Feel free to come back anytime you need assistance. Have a great day!",
    },
  },
  {
    keywords: [
      "who are you",
      "what are you",
      "your name",
      "about you",
      "what can you do",
    ],
    response: {
      logId: "st-004",
      responseType: "SUGGESTION",
      botReply:
        "I'm the **FinCore Smart Assistant**, powered by an AI-driven **RAG pipeline**. I can help you with:",
      items: [
        "Navigate FinCore modules",
        "Answer process-related questions",
        "Guide you through workflows",
        "Raise IT support tickets",
      ],
    },
  },
  {
    keywords: [
      "how are you",
      "how's it going",
      "what's up",
      "how do you do",
      "sup",
    ],
    response: {
      logId: "st-005",
      responseType: "TEXT_REPLY",
      botReply:
        "I'm running at full capacity! âš¡ All systems operational. How can I assist you with FinCore today?",
    },
  },
  {
    keywords: [
      "help",
      "assist",
      "support",
      "stuck",
      "issue",
      "problem",
      "not working",
      "error",
      "bug",
      "broken",
    ],
    response: {
      logId: "st-006",
      responseType: "SUGGESTION",
      botReply:
        "I'd be happy to help! Could you tell me more about what you need?",
      items: [
        "I need help with a specific module",
        "I'm getting an error message",
        "I need to reset my credentials",
        "I want to raise an IT ticket",
      ],
    },
  },
  {
    keywords: ["I need help with a specific module"],
    response: {
      logId: "st-006a",
      responseType: "SUGGESTION",
      botReply: "Which module do you need help with?",
      items: [
        "CGL Management",
        "User Management",
        "Journal Posting",
        "Reports & Analytics",
      ],
    },
  },
  {
    keywords: ["I'm getting an error message", "error message"],
    response: {
      logId: "st-006b",
      responseType: "TEXT_REPLY",
      botReply:
        "I'm sorry to hear that! Please share the **exact error message** or describe what happened, and I'll try to help troubleshoot.\n\nIf it's a system error, I can also **raise an IT ticket** for you.",
    },
  },
  {
    keywords: [
      "I need to reset my credentials",
      "reset credentials",
      "forgot password",
      "locked out",
      "can't login",
      "cannot login",
      "login issue",
    ],
    response: {
      logId: "st-006c",
      responseType: "TEXT_REPLY",
      botReply:
        'To reset your credentials:\n\n1. Go to the **login page**.\n2. Click **"Forgot Password"**.\n3. Enter your registered email.\n4. Follow the link in the email (valid for 30 minutes).\n\nIf your account is locked, please contact your **system administrator**.',
    },
  },
  {
    keywords: [
      "I want to raise an IT ticket",
      "raise ticket",
      "create ticket",
      "open ticket",
      "submit ticket",
    ],
    response: {
      logId: "st-006d",
      responseType: "ESCALATION_OFFER",
      botReply:
        "I can help you raise an IT support ticket. Please describe your issue briefly, and I'll create the ticket for you. Would you like to proceed?",
    },
  },
  {
    keywords: [
      "approval",
      "approve",
      "authorize",
      "authorization",
      "pending approval",
    ],
    response: {
      logId: "st-007",
      responseType: "TEXT_REPLY",
      botReply:
        "FinCore uses a **maker-checker** workflow for critical operations.\n\n- **Maker**: Creates/submits the request.\n- **Checker**: Reviews and approves/rejects.\n\nPending approvals can be found in the **Approval Queue** on your dashboard.",
      navigationLink: "/dashboard/approvals",
      navigationLabel: "View Pending Approvals",
    },
  },
  {
    keywords: ["dashboard", "home", "overview", "summary"],
    response: {
      logId: "st-008",
      responseType: "TEXT_REPLY",
      botReply:
        "Your **Dashboard** provides a real-time overview of:\n\n- ðŸ“Š Key financial metrics\n- â³ Pending approvals\n- ðŸ“‹ Recent transactions\n- ðŸ”” System notifications\n\nYou can customize the dashboard widgets from Settings.",
      navigationLink: "/dashboard",
      navigationLabel: "Go to Dashboard",
    },
  },
  {
    keywords: ["audit", "audit trail", "audit log", "compliance"],
    response: {
      logId: "st-009",
      responseType: "TEXT_REPLY",
      botReply:
        "FinCore maintains a comprehensive **audit trail** for all transactions and system actions.\n\nYou can access audit logs from **Admin â†’ Audit Trail**. Logs are immutable and retained per the regulatory compliance requirements.",
      navigationLink: "/admin/audit",
      navigationLabel: "View Audit Trail",
    },
  },
  {
    keywords: [
      "report",
      "generate report",
      "financial report",
      "export",
      "download",
    ],
    response: {
      logId: "st-010",
      responseType: "SUGGESTION",
      botReply: "I can help you with reports. What type of report do you need?",
      items: [
        "Balance Sheet",
        "Profit & Loss Statement",
        "Trial Balance",
        "How do I export reports to Excel?",
      ],
    },
  },
  {
    keywords: ["balance sheet"],
    response: {
      logId: "st-010a",
      responseType: "TEXT_REPLY",
      botReply:
        'To generate a **Balance Sheet**:\n\n1. Go to **Reports â†’ Financial Statements**.\n2. Select **"Balance Sheet"**.\n3. Choose the reporting period and entity.\n4. Click **"Generate"**.\n\nYou can export it in PDF or Excel format.',
      navigationLink: "/reports/balance-sheet",
      navigationLabel: "Generate Balance Sheet",
    },
  },
  {
    keywords: ["profit", "loss", "p&l", "income statement"],
    response: {
      logId: "st-010b",
      responseType: "TEXT_REPLY",
      botReply:
        'To generate a **P&L Statement**:\n\n1. Go to **Reports â†’ Financial Statements**.\n2. Select **"Profit & Loss"**.\n3. Choose the period, entity, and comparison options.\n4. Click **"Generate"**.',
      navigationLink: "/reports/pnl",
      navigationLabel: "Generate P&L Report",
    },
  },
  {
    keywords: ["trial balance"],
    response: {
      logId: "st-010c",
      responseType: "TEXT_REPLY",
      botReply:
        'To generate a **Trial Balance**:\n\n1. Go to **Reports â†’ Financial Statements**.\n2. Select **"Trial Balance"**.\n3. Choose the as-of date and entity.\n4. Click **"Generate"**.\n\nYou can drill down into individual GL accounts from the report.',
      navigationLink: "/reports/trial-balance",
      navigationLabel: "Generate Trial Balance",
    },
  },
  {
    keywords: [
      "settings",
      "preferences",
      "configure",
      "setup",
      "configuration",
    ],
    response: {
      logId: "st-011",
      responseType: "SUGGESTION",
      botReply: "What settings would you like to configure?",
      items: [
        "How do I set up two-factor authentication?",
        "Update user roles and permissions",
        "Change notification preferences",
        "System configuration",
      ],
    },
  },
  {
    keywords: [
      "notification",
      "alert",
      "email notification",
      "change notification",
    ],
    response: {
      logId: "st-012",
      responseType: "TEXT_REPLY",
      botReply:
        'To manage notifications:\n\n1. Go to **Settings â†’ Notifications**.\n2. Toggle email/in-app notifications per event type.\n3. Set frequency: **Instant**, **Daily digest**, or **Weekly summary**.\n4. Click **"Save Preferences"**.',
      navigationLink: "/settings/notifications",
      navigationLabel: "Notification Settings",
    },
  },
  {
    keywords: ["system configuration", "admin settings", "system setup"],
    response: {
      logId: "st-013",
      responseType: "TEXT_REPLY",
      botReply:
        "System configuration is available to administrators only. It includes:\n\n- **Organization settings** (name, timezone, fiscal year)\n- **Module activation**\n- **Integration settings** (API keys, webhooks)\n- **Security policies** (password rules, session timeout)",
      navigationLink: "/admin/system",
      navigationLabel: "System Configuration",
    },
  },
];

// â”€â”€â”€ Fuzzy Matching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function findBestSmallTalkMatch(input) {
  let bestMatch = null;

  for (const entry of smallTalkResponses) {
    const normalizedInput = input.toLowerCase().trim();
    let score = 0;

    for (const kw of entry.keywords) {
      const kwLower = kw.toLowerCase();
      if (normalizedInput === kwLower) {
        score = Math.max(score, 100);
      } else if (normalizedInput.includes(kwLower)) {
        score = Math.max(score, 80);
      } else if (
        kwLower.includes(normalizedInput) &&
        normalizedInput.length > 3
      ) {
        score = Math.max(score, 60);
      } else {
        const inputWords = normalizedInput.split(/\s+/);
        const kwWords = kwLower.split(/\s+/);
        const overlap = kwWords.filter((w) =>
          inputWords.some(
            (iw) =>
              iw === w || (iw.length > 3 && (iw.includes(w) || w.includes(iw))),
          ),
        ).length;
        if (overlap > 0) {
          score = Math.max(score, (overlap / kwWords.length) * 50);
        }
      }
    }

    if (score > 0 && (!bestMatch || score > bestMatch.score)) {
      bestMatch = { response: entry.response, score };
    }
  }

  return bestMatch && bestMatch.score >= 30 ? bestMatch.response : null;
}

// â”€â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let messageCounter = 0;

export function generateId() {
  return `msg-${Date.now()}-${++messageCounter}`;
}

export function getCurrentScreen() {
  return window.location.pathname;
}

export async function sendMessage(userMessage) {
  await new Promise((resolve) =>
    setTimeout(resolve, 1200 + Math.random() * 1200),
  );

  const lookupKey = userMessage.startsWith("/action ")
    ? userMessage
        .replace(/^\/action\s+(module|faq)\s*/, "")
        .replace(/^\/.*/, "")
        .trim()
    : userMessage.trim();

  // 1. Direct match
  if (mockResponses[lookupKey]) {
    return { ...mockResponses[lookupKey], logId: `log-${Date.now()}` };
  }

  // 2. Small talk / fuzzy match
  const smallTalkMatch = findBestSmallTalkMatch(lookupKey);
  if (smallTalkMatch) {
    return { ...smallTalkMatch, logId: `log-${Date.now()}` };
  }

  // 3. Keyword-based escalation
  const lower = lookupKey.toLowerCase();
  if (
    lower.includes("ticket") ||
    lower.includes("support") ||
    lower.includes("urgent") ||
    lower.includes("critical")
  ) {
    return { ...mockResponses["escalation"], logId: `log-${Date.now()}` };
  }

  // 4. Default fallback
  return { ...mockResponses["default"], logId: `log-${Date.now()}` };
}

export function submitFeedback(logId, feedback) {
  console.log(`[Feedback] logId=${logId}, feedback=${feedback}`);
}













import { fetchEventSource } from "@microsoft/fetch-event-source";
import {
  sendMessage,
  generateId,
  getCurrentScreen,
  submitFeedback,
} from "./chatMockService";
import { useSelector } from "react-redux";

// â”€â”€â”€ SSE Chat Service â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// In production, this connects to POST /api/help/chat via SSE.
// For development/demo, we simulate SSE events using the mock service.

const API_URL = "/HS/api/help/chat";

// /**
//  * Sends a message via SSE and calls handlers for each event type.
//  *
//  * @param {Object} params
//  * @param {string} params.userMessage - The user's message text
//  * @param {string} params.currentScreen - Current route/screen
//  * @param {string} params.token - JWT auth token
//  * @param {Object} handlers - Event handlers
//  * @param {function} handlers.onStart - Called when stream starts
//  * @param {function(string)} handlers.onToken - Called for each token chunk
//  * @param {function(Object)} handlers.onEnd - Called with end payload (navigationLink, logId, etc.)
//  * @param {function(Object)} handlers.onSuggestion - Called for suggestion events
//  * @param {function(Object)} handlers.onEscalation - Called for escalation events
//  * @param {function(string)} handlers.onError - Called on error
//  * @param {AbortController} abortController - To cancel the stream
//  */
// export async function sendMessageSSE(
//   { userMessage, currentScreen, token },
//   handlers,
//   abortController,
// ) {
//   // â”€â”€â”€ MOCK MODE: Simulate SSE events locally â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//   // Replace this block with the real fetchEventSource call when backend is ready.

//   try {
//     // Simulate start event
//     handlers.onStart?.();

//     // Get mock response
//     const response = await sendMessage(userMessage);

//     // Handle non-streaming types immediately
//     if (response.responseType === "SUGGESTION") {
//       handlers.onSuggestion?.({
//         botReply: response.botReply,
//         items: response.items,
//         logId: response.logId,
//       });
//       return;
//     }

//     if (response.responseType === "ESCALATION_OFFER") {
//       handlers.onEscalation?.({
//         botReply: response.botReply,
//         logId: response.logId,
//       });
//       return;
//     }

//     // Simulate token-by-token streaming for TEXT_REPLY and NO_MATCH
//     const text = response.botReply;
//     const words = text.split(/(\s+)/); // Split keeping whitespace

//     for (let i = 0; i < words.length; i++) {
//       if (abortController?.signal?.aborted) return;
//       await new Promise((r) => setTimeout(r, 20 + Math.random() * 30));
//       handlers.onToken?.(words[i]);
//     }

//     // Simulate end event
//     handlers.onEnd?.({
//       status: "complete",
//       navigationLink: response.navigationLink || null,
//       navigationLabel: response.navigationLabel || null,
//       logId: response.logId,
//     });
//   } catch (err) {
//     if (err.name !== "AbortError") {
//       handlers.onError?.(err.message || "Something went wrong");
//     }
//   }
// }

// â”€â”€â”€ PRODUCTION SSE Implementation (uncomment when backend is ready) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function sendMessageSSE(
  { userMessage, currentScreen, token },
  handlers,
  abortController,
) {
  await fetchEventSource(API_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({ userMessage, currentScreen }),
    signal: abortController?.signal,

    onopen(response) {
      if (!response.ok) {
        throw new Error(`Server error: ${response.status}`);
      }
    },

    onmessage(event) {
      switch (event.event) {
        case "start":
          handlers.onStart?.();
          break;

        case "token": {
          const data = JSON.parse(event.data);
          handlers.onToken?.(data.token);
          break;
        }

        case "end": {
          const data = JSON.parse(event.data);
          handlers.onEnd?.(data);
          break;
        }

        case "suggestion": {
          const data = JSON.parse(event.data);
          handlers.onSuggestion?.(data);
          break;
        }

        case "escalation": {
          const data = JSON.parse(event.data);
          handlers.onEscalation?.(data);
          break;
        }

        case "error": {
          const data = JSON.parse(event.data);
          handlers.onError?.(data.message || "An error occurred");
          break;
        }

        default:
          break;
      }
    },

    onerror(err) {
      handlers.onError?.(err.message || "Connection lost");
      throw err; // Stop retrying
    },
  });
}

export { generateId, getCurrentScreen, submitFeedback };




import React, { useMemo, useState, useCallback } from "react";
import { Box, Paper, Typography } from "@mui/material";
import { Outlet } from "react-router-dom";
import { useSelector } from "react-redux";

import LayoutHeader from "../components/LayoutHeader";
import SideBar from "../components/SideBar/SideBar";
import { getParentMenu } from "../utils/CommonUtilities";
import { getIconComponent } from "../utils/IconUtils";
import useNavigateToPage from "../hooks/useNavigateToPage";
import AppBreadcrumbs from "./AppBreadcrumbs";
import ChatWidget from "../components/ai-assistant/chat/ChatWidget";

const drawerWidth = 270;

const CommonLayout = () => {
  const selectedMenuItem = useSelector((state) => state.menus.selectedMenuItem);
  const menus = useSelector((state) => state.menus.menus);

  const [mobileOpen, setMobileOpen] = useState(false);
  const [showComponentTitle, setShowComponentTitle] = useState(true);
  const { navigateToPage } = useNavigateToPage();

  const handleDrawerToggle = useCallback(() => {
    setMobileOpen((prev) => !prev);
  }, []);

  const title = useMemo(() => {
    if (!selectedMenuItem) return "";

    if (Object.hasOwn(selectedMenuItem, "hasChildren")) {
      // Top-level menu
      return selectedMenuItem.title;
    }

    const parentMenu = getParentMenu(selectedMenuItem, menus);

    if (!parentMenu) return selectedMenuItem.title;

    return `${parentMenu.title} > ${selectedMenuItem.title}`;
  }, [menus, selectedMenuItem]);

  const outletContextValue = useMemo(() => ({ setShowComponentTitle }), []);

  return (
    <Box
      sx={{
        display: "flex",
        minHeight: "100vh",
      }}
    >
      {/* Header */}
      <LayoutHeader
        drawerWidth={drawerWidth}
        title={title}
        navigateToPage={navigateToPage}
        handleDrawerToggle={handleDrawerToggle}
      />

      {/* Sidebar */}
      <SideBar
        drawerWidth={drawerWidth}
        getIconComponent={getIconComponent}
        mobileOpen={mobileOpen}
        handleDrawerToggle={handleDrawerToggle}
      />

      {/* Main Content */}
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          width: { xs: "100%", md: `calc(100% - ${drawerWidth}px)` },
          p: 3,
          pt: 11,
          minHeight: "calc(100vh - 88px)",
        }}
      >
        <Box>
          {showComponentTitle && (
            <Paper
              elevation={2}
              sx={{
                p: 2,
                mb: 4,
                borderRadius: 1,
              }}
            >
              {/* Breadcrumbs */}
              <AppBreadcrumbs />
            </Paper>
          )}

          <Box>
            <Outlet context={outletContextValue} />
          </Box>
        </Box>
      </Box>
      <ChatWidget />
    </Box>
  );
};

export default CommonLayout;














import React, { useMemo, Suspense } from "react";
import { createBrowserRouter, RouterProvider } from "react-router-dom";
import { useSelector } from "react-redux";
import PrivateRouter from "./PrivateRouter";

// Page Components
import Login from "../features/auth/pages/Login";
import Home from "../pages/Home";
import NotFound from "../pages/NotFound";
import ServerError from "../pages/ServerError";
import CommonLayout from "../layout/CommonLayout";
import FullscreenLayout from "../layout/FullscreenLayout";
import SubmenuSelectionPage from "../pages/SubmenuSelectionPage";

import { generateRouteObjects } from "./RouteGenerator";
import Help from "../features/help/Help";

const PageLoader = () => (
  <div
    style={{
      display: "flex",
      height: "100vh",
      justifyContent: "center",
      alignItems: "center",
    }}
  >
    Loading...
  </div>
);

const DynamicLayout = () => {
  const isComponentFullscreen = useSelector(
    (state) => state.ui.isComponentFullscreen
  );
  return !isComponentFullscreen ? <CommonLayout /> : <FullscreenLayout />;
};

const AppRouter = () => {
  const menus = useSelector((state) => state.menus.menus);

  const router = useMemo(() => {
    const dynamicRoutes = generateRouteObjects(menus || []);

    const routeConfig = [
      {
        path: "/",
        element: <Login />,
        errorElement: <ServerError />,
      },
      {
        path: "/server-error",
        element: <ServerError />,
      },
      // Protected Routes
      {
        element: <PrivateRouter />,
        children: [
          {
            element: <DynamicLayout />,
            children: [
              { path: "/home", element: <Home /> },
              { path: "/help", element: <Help /> },
              {
                path: "/choose-option/:mainMenuTitle",
                element: <SubmenuSelectionPage />,
              },
              ...dynamicRoutes,
            ],
          },
        ].filter(Boolean),
      },
      {
        path: "*",
        element: <NotFound />,
      },
    ];

    return createBrowserRouter(routeConfig);
  }, [menus]);

  return (
    <Suspense fallback={<PageLoader />}>
      <RouterProvider router={router} />
    </Suspense>
  );
};

export default AppRouter;












import React, { useEffect, useContext } from "react";
import { Navigate, Outlet } from "react-router-dom";
import { useSelector } from "react-redux";
import { AuthContext } from "../context/AuthContext";

const PrivateRouter = () => {
  const { token, user } = useSelector((state) => state.auth);
  const tabId = useSelector((state) => state.tab.tabId);

  // Use the global context trigger
  const { triggerSessionDialog } = useContext(AuthContext);

  useEffect(() => {
    // Only listen if logged in
    if (!user?.userId || !tabId) return;

    const bc = new BroadcastChannel("auth");

    const handleMessage = (event) => {
      const { type, userId: eventUserId, tabId: eventTabId } = event.data || {};

      // If same user logs in on a different tab
      if (
        type === "USER_LOGGED_IN" &&
        eventUserId === user.userId &&
        eventTabId !== tabId
      ) {
        // Trigger the global dialog with the correct reason
        triggerSessionDialog("CONCURRENT_LOGIN");
      }
    };

    bc.onmessage = handleMessage;

    return () => {
      bc.close();
    };
  }, [user, tabId, triggerSessionDialog]);

  if (!token) {
    return <Navigate to="/" replace />;
  }

  // No local dialogs here! Just the content.
  return <Outlet />;
};

export default PrivateRouter;














import React, { Suspense } from "react";
import ComponentLoadError from "../pages/ComponentLoadError";
const components = import.meta.glob("../features/**/*.jsx");

const lazyLoadComponent = (componentPath) => {
  const componentImport = components[componentPath];

  if (!componentImport) {
    console.error(`Component not found for path: ${componentPath}`);
    return () => (
      <ComponentLoadError path={componentPath} error="Component not found." />
    );
  }

  const LazyComponent = React.lazy(componentImport);

  return LazyComponent;
};

/**
 * Recursively generates an array of route objects for React Router v7.
 * @param {Array} menuItems - The menu array from the API.
 * @returns {Array<Object>} An array of route configuration objects.
 */
export const generateRouteObjects = (menuItems) => {
  const routes = [];

  for (const item of menuItems) {
    // Only create a route if it has screen details and a component path
    if (item && item.componentPath) {
      const Component = lazyLoadComponent(
        "../features/" + item.componentPath + ".jsx"
      );

      routes.push({
        path: item.route,
        element: (
          <Suspense fallback={<div>Loading...</div>}>
            <Component />
          </Suspense>
        ),
      });
    }

    // Recursively add children routes if they exist
    if (item.hasChildren && Array.isArray(item.children)) {
      routes.push(...generateRouteObjects(item.children));
    }
  }

  return routes;
};










import React, { useCallback, useEffect } from "react";
import {
  Box,
  Button,
  Card,
  CardContent,
  Drawer,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Typography,
  useMediaQuery,
  useTheme,
} from "@mui/material";
import LinkIcon from "@mui/icons-material/Link";
import { useLocation } from "react-router-dom";
import { useDispatch, useSelector } from "react-redux";
import { setSelectedMenuItem } from "../../store/slices/menuSlice";
import fLogo from "../../assets/Logos/Fincore_transperent.svg";
import useNavigateToPage from "../../hooks/useNavigateToPage";
import { convertToKebabCase } from "../../utils/CommonUtilities";

// ====== Memoized Menu Item (pure presentational) ======
const MemoizedMenuItem = React.memo(
  ({ item, currentSelectedId, getIconComponent, onClick }) => {
    const IconComponent = getIconComponent(item.icon);

    const selectedOption =
      currentSelectedId === item.id ||
      item?.children?.some((suboption) => suboption.id === currentSelectedId);

    return (
      <ListItem disablePadding>
        <ListItemButton selected={selectedOption} onClick={() => onClick(item)}>
          <ListItemIcon sx={{ minWidth: 40 }}>
            <IconComponent />
          </ListItemIcon>
          <ListItemText
            primary={item.title}
            sx={{
              "& .MuiTypography-root": {
                fontWeight: selectedOption ? 600 : 400,
                color: selectedOption ? "primary.main" : "text.primary",
              },
            }}
          />
        </ListItemButton>
      </ListItem>
    );
  },
);

// ====== Drawer Header ======
const DrawerHeader = React.memo(() => (
  <Box
    sx={{
      p: 2,
      borderBottom: "1px solid #E2E8F0",
      display: "flex",
      alignItems: "center",
      gap: 2,
    }}
  >
    <img src={fLogo} alt="Logo" style={{ width: 75, height: 75 }} />
    <Box>
      <Typography variant="h6" sx={{ fontWeight: 700 }}>
        FinCore
      </Typography>
      <Typography variant="caption" color="text.secondary">
        Empowering Data
      </Typography>
    </Box>
  </Box>
));

// ====== Main Sidebar Component ======
const SideBar = ({
  drawerWidth,
  getIconComponent,
  mobileOpen,
  handleDrawerToggle,
}) => {
  const location = useLocation();
  const dispatch = useDispatch();
  const menus = useSelector((state) => state.menus.menus);
  const selectedMenuItem = useSelector((state) => state.menus.selectedMenuItem);
  const { navigateToPage } = useNavigateToPage();

  const theme = useTheme();
  const isSmallScreen = useMediaQuery(theme.breakpoints.down("lg"));

  // Recursive function to find menu item based on route
  const findMenuItem = useCallback((items, route) => {
    for (const item of items) {
      // Direct route match
      if (item.route === route) return item;

      // Check children
      if (item.children && item.children.length > 0) {
        const isSubmenuSelectionPage = route.includes("/choose-option");

        if (isSubmenuSelectionPage) {
          const prefix = "/choose-option/";
          const startIndex = route.indexOf(prefix) + prefix.length;
          const parameter = route.substring(startIndex);
          if (parameter === convertToKebabCase(item.title)) {
            return item;
          }
        }

        const childMatch = findMenuItem(item.children, route);
        if (childMatch) return childMatch;
      }
    }
    return null;
  }, []);

  // 1) Compute current selected item purely from URL for immediate UI highlight
  const currentSelectedFromRoute =
    menus.length > 0 ? findMenuItem(menus, location.pathname) : null;
  const currentSelectedId = currentSelectedFromRoute?.id ?? null;

  // 2) Sync Redux.selectedMenuItem with URL (used elsewhere in app)
  //    Only dispatch when ID actually changes (prevents extra toggles)
  useEffect(() => {
    if (!menus.length) return;

    const foundItem = findMenuItem(menus, location.pathname);

    if (foundItem && foundItem.id !== selectedMenuItem?.id) {
      dispatch(setSelectedMenuItem(foundItem));
    }
  }, [
    dispatch,
    findMenuItem,
    location.pathname,
    menus,
    selectedMenuItem?.id, // only compare by id
  ]);

  // 3) Handle menu click:
  //    - DO NOT dispatch setSelectedMenuItem here (to avoid new â†’ old â†’ new)
  //    - Just navigate; URL changes will drive state via the effect above
  const handleMenuClick = (item) => {
    navigateToPage(item);

    // Close drawer on small screens
    if (isSmallScreen) {
      handleDrawerToggle();
    }
  };

  const drawerContent = (
    <Box sx={{ display: "flex", flexDirection: "column", height: "100%" }}>
      <DrawerHeader />

      <Box sx={{ flexGrow: 1, overflow: "auto" }}>
        <List sx={{ py: 1 }}>
          {menus.length > 0 ? (
            menus.map((item) => (
              <MemoizedMenuItem
                key={item.id}
                item={item}
                currentSelectedId={currentSelectedId}
                getIconComponent={getIconComponent}
                onClick={handleMenuClick}
              />
            ))
          ) : (
            <Typography
              variant="body2"
              color="text.secondary"
              sx={{ textAlign: "center", mt: 3 }}
            >
              No menu available
            </Typography>
          )}
        </List>
      </Box>

      <Box sx={{ p: 2, borderTop: "1px solid #E2E8F0" }}>
        <Card>
          <CardContent sx={{ p: 2 }}>
            <Typography variant="subtitle2" sx={{ fontWeight: 600, mb: 1 }}>
              Need Help?
            </Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
              Contact our support team
            </Typography>
            <a
              href="https://score.sbi/"
              target="_blank"
              rel="noopener noreferrer"
            >
              <Button
                startIcon={<LinkIcon />}
                size="small"
                variant="contained"
                fullWidth
              >
                Connect to SCORE
              </Button>
            </a>
          </CardContent>
        </Card>
      </Box>
    </Box>
  );

  return (
    <Box
      component="nav"
      sx={{ width: { lg: drawerWidth }, flexShrink: { lg: 0 } }}
    >
      {/* Temporary Drawer for small screens */}
      <Drawer
        variant="temporary"
        open={mobileOpen}
        onClose={handleDrawerToggle}
        ModalProps={{ keepMounted: true }}
        sx={{
          display: { xs: "block", lg: "none" },
          "& .MuiDrawer-paper": {
            width: drawerWidth,
            backgroundColor: (theme) => theme.palette.background.paper,
          },
        }}
      >
        {drawerContent}
      </Drawer>

      {/* Permanent Drawer for large screens */}
      <Drawer
        variant="permanent"
        sx={{
          display: { xs: "none", lg: "block" },
          "& .MuiDrawer-paper": {
            width: drawerWidth,
            boxSizing: "border-box",
            display: "flex",
            flexDirection: "column",
          },
        }}
        open
      >
        {drawerContent}
      </Drawer>
    </Box>
  );
};

export default React.memo(SideBar);












import React, { useState } from "react";
import {
  Avatar,
  Badge,
  Box,
  IconButton,
  Toolbar,
  Typography,
  useTheme,
  useMediaQuery,
  CircularProgress,
} from "@mui/material";
import { Notifications, Menu as MenuIcon } from "@mui/icons-material";
import { useSelector } from "react-redux";
import { userAvatarCreator } from "../utils/userUtilities";
import NotificationDrawer from "./NotificationDrawer";
import ProfileDrawer from "./ProfileDrawer";
import SearchBar from "./search/SearchBar";
import fLogo from "../assets/Logos/Fincore_transperent.svg";
import useNotifications from "../hooks/useNotifications";
import NotificationPopup from "./NotificationPopup";
import AutorenewIcon from "@mui/icons-material/Autorenew";
import TaskProgressDrawer from "./TaskProgressDrawer";

const LayoutHeader = ({ drawerWidth, navigateToPage, handleDrawerToggle }) => {
  const [notificationDrawerOpen, setNotificationDrawerOpen] = useState(false);
  const [profileDrawerOpen, setProfileDrawerOpen] = useState(false);
  const [taskDrawerOpen, setTaskDrawerOpen] = useState(false);

  const {
    notifications,
    markAsRead,
    markAllAsRead,
    loadMore,
    hasMore,
    unreadCount,
    popNotification,
    setPopNotification,
    tasks,
    activeCount,
  } = useNotifications();

  const user = useSelector((state) => state.auth.user);
  const theme = useTheme();
  const isSmallScreen = useMediaQuery(theme.breakpoints.down("lg"));

  return (
    <Box
      position="fixed"
      sx={{
        width: { xs: "100%", lg: `calc(100% - ${drawerWidth}px)` },
        right: 0,
        top: 0,
        zIndex: 1200,
        background:
          "linear-gradient(90deg, rgba(162,141,240,0.3), rgba(93,63,211,0.8))",
      }}
    >
      <Toolbar sx={{ display: "flex", justifyContent: "space-between" }}>
        {/* Left side section */}
        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
          {isSmallScreen && (
            <IconButton
              onClick={handleDrawerToggle}
              sx={{ color: "text.primary" }}
            >
              <MenuIcon />
            </IconButton>
          )}

          {isSmallScreen && (
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              <img src={fLogo} alt="Logo" style={{ width: 40, height: 40 }} />
              <Typography variant="h6" sx={{ fontWeight: 700 }}>
                FinCore
              </Typography>
            </Box>
          )}
        </Box>

        {/* Right side section */}
        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
          <SearchBar navigateToPage={navigateToPage} />

          {activeCount > 0 && (
            <IconButton onClick={() => setTaskDrawerOpen(true)}>
              <Badge badgeContent={activeCount} color="warning">
                <Box sx={{ position: "relative" }}>
                  <AutorenewIcon
                    sx={{ animation: "spin 1.2s linear infinite" }}
                  />
                  <CircularProgress
                    size={36}
                    sx={{
                      position: "absolute",
                      top: -6,
                      left: -6,
                      zIndex: -1,
                    }}
                  />
                </Box>
              </Badge>

              <style>
                {`@keyframes spin { 100% { transform: rotate(360deg); } }`}
              </style>
            </IconButton>
          )}
          <IconButton
            color="inherit"
            onClick={() => setNotificationDrawerOpen(true)}
          >
            {unreadCount > 0 ? (
              <Badge badgeContent={unreadCount || ""} color="error">
                <Notifications />
              </Badge>
            ) : (
              <Notifications />
            )}
          </IconButton>

          <Avatar
            onClick={() => setProfileDrawerOpen(true)}
            sx={{
              width: 32,
              height: 32,
              color: "primary.contrastText",
              backgroundColor: "primary.main",
              cursor: "pointer",
              ml: 1,
            }}
          >
            {userAvatarCreator(user)}
          </Avatar>
        </Box>
      </Toolbar>

      {taskDrawerOpen && (
        <TaskProgressDrawer
          open={taskDrawerOpen}
          onClose={() => setTaskDrawerOpen(false)}
          tasks={tasks}
        />
      )}

      <NotificationDrawer
        notificationDrawerOpen={notificationDrawerOpen}
        setNotificationDrawerOpen={setNotificationDrawerOpen}
        notifications={notifications}
        markAsRead={markAsRead}
        markAllAsRead={markAllAsRead}
        loadMore={loadMore}
        hasMore={hasMore}
      />

      <ProfileDrawer
        profileDrawerOpen={profileDrawerOpen}
        setProfileDrawerOpen={setProfileDrawerOpen}
      />

      {popNotification && (
        <NotificationPopup
          popup={popNotification}
          handleNotificationClick={() => {
            setNotificationDrawerOpen(true);
            setPopNotification(null);
          }}
          onClose={() => {
            setPopNotification(null);
          }}
        />
      )}
    </Box>
  );
};

export default React.memo(LayoutHeader);
















import React, {
  createContext,
  useEffect,
  useRef,
  useCallback,
  useState,
} from "react";

import { useDispatch, useSelector } from "react-redux";
import { throttle } from "lodash";
import SessionDialog from "../components/SessionDialog";
import SessionWarningDialog from "../components/SessionWarningDialog";
import { logoutSuccess } from "../store/slices/authSlice";
import api from "../config/axiosConfig";
import { resolveConfig } from "../config/EnvironmentConfig";

export const AuthContext = createContext();

const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 min
const WARNING_SECONDS = 30;
const WARNING_TIME = INACTIVITY_TIMEOUT - WARNING_SECONDS * 1000; // 30s

export const AuthProvider = ({ children }) => {
  const dispatch = useDispatch();
  const isAuthenticated = useSelector((state) => state.auth.isAuthenticated);
  const [warningOpen, setWarningOpen] = useState(false);
  const [secondsLeft, setSecondsLeft] = useState(WARNING_SECONDS);
  const [sessionDialogOpen, setSessionDialogOpen] = useState(false);
  const [sessionReason, setSessionReason] = useState("");
  const inactivityTimerRef = useRef(null);
  const warningTimerRef = useRef(null);
  const countdownRef = useRef(null);

  // --- Clear all timers ---
  const clearAllTimers = useCallback(() => {
    if (inactivityTimerRef.current) clearTimeout(inactivityTimerRef.current);
    if (warningTimerRef.current) clearTimeout(warningTimerRef.current);
    if (countdownRef.current) clearInterval(countdownRef.current);
  }, []);

  // --- Perform Logout ---
  const performLogout = useCallback(
    async (reason = "USER_INITIATED") => {
      clearAllTimers();
      if (reason !== "USER_INITIATED") {
        setSessionReason(reason);
        setSessionDialogOpen(true);
      }
      try {
        await api.post(`${resolveConfig("/LS")}/auth/logout`);
      } catch (e) {
        console.error(e);
      } finally {
        localStorage.clear();
        dispatch(logoutSuccess());
        setWarningOpen(false);
      }
    },
    [dispatch, clearAllTimers],
  );

  // --- Start inactivity timers ---
  const startInactivityTimer = useCallback(() => {
    clearAllTimers();
    if (!isAuthenticated) return;
    //  Warning timer (fires at 30s)
    warningTimerRef.current = setTimeout(() => {
      setSecondsLeft(WARNING_SECONDS);
      setWarningOpen(true);
      //  Start countdown immediately
      countdownRef.current = setInterval(() => {
        setSecondsLeft((prev) => {
          if (prev <= 1) {
            clearInterval(countdownRef.current);
            performLogout("SESSION_TIMEOUT");
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }, WARNING_TIME);
    //  Hard logout backup (optional safety)
    inactivityTimerRef.current = setTimeout(() => {
      performLogout("SESSION_TIMEOUT");
    }, INACTIVITY_TIMEOUT);
  }, [isAuthenticated, clearAllTimers, performLogout]);

  // --- User Activity Listener ---
  const onActivity = useCallback(
    throttle(() => {
      if (!isAuthenticated || sessionDialogOpen) return;
      setWarningOpen(false);
      startInactivityTimer();
    }, 2000),
    [isAuthenticated, sessionDialogOpen, startInactivityTimer],
  );

  // --- Main Effect (FIXED DEPENDENCIES) ---
  useEffect(() => {
    if (!isAuthenticated) {
      clearAllTimers();
      setWarningOpen(false);
      return;
    }
    startInactivityTimer();
    const events = ["mousemove", "keydown", "click", "scroll", "touchstart"];
    events.forEach((e) => window.addEventListener(e, onActivity));
    return () => {
      events.forEach((e) => window.removeEventListener(e, onActivity));
      onActivity.cancel();
      clearAllTimers();
    };
  }, [isAuthenticated]); //  FIXED: removed unstable deps
  
  // --- Cross-tab / forced logout ---
  useEffect(() => {
    const handleSessionEvent = (e) => {
      performLogout(e.detail?.reason || "SESSION_EXPIRED");
    };
    window.addEventListener("auth:session-expired", handleSessionEvent);
    return () =>
      window.removeEventListener("auth:session-expired", handleSessionEvent);
  }, [performLogout]);
  return (
    <AuthContext.Provider
      value={{
        logout: () => performLogout("USER_INITIATED"),
        triggerSessionDialog: (reason) => performLogout(reason),
      }}
    >
      {children}
      <SessionWarningDialog
        open={warningOpen}
        secondsLeft={secondsLeft}
        onContinue={() => {
          setWarningOpen(false);
          startInactivityTimer();
        }}
      />
      <SessionDialog
        open={sessionDialogOpen}
        reason={sessionReason}
        onConfirm={() => setSessionDialogOpen(false)}
      />
    </AuthContext.Provider>
  );
};










import React, { useEffect, useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { useNavigate } from "react-router-dom";
import { InputAdornment, IconButton } from "@mui/material";
import LockIcon from "@mui/icons-material/Lock";
import Visibility from "@mui/icons-material/Visibility";
import VisibilityOff from "@mui/icons-material/VisibilityOff";
import api from "../../../config/axiosConfig"; // Use Singleton
import { parseJwt } from "../../../utils/EncryptionUtilities";
import { loginSuccess } from "../../../store/slices/authSlice";
import { setMenus, setSelectedMenuItem } from "../../../store/slices/menuSlice";
import { setTabId } from "../../../store/slices/tabSlice";
import { resolveConfig } from "../../../config/EnvironmentConfig";
import {
  StyledTextField,
  PrimaryButton,
  PasswordErrorText,
} from "./LoginStyles";

const LoginWithPassword = ({ userId, openLoginErrorDialog }) => {
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [passwordInvalidMessage, setPasswordInvalidMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const navigate = useNavigate();
  const dispatch = useDispatch();
  const menus = useSelector((state) => state.menus.menus);

  // Navigate after successful login and menu loading
  useEffect(() => {
    if (menus && menus.length > 0 && menus[0]?.route) {
      if (menus[0].hasChildren) {
        navigate("/choose-option" + menus[0]?.route);
      } else {
        navigate(menus[0]?.route);
      }
    }
  }, [menus, navigate]);

  const validateUserCredentials = async () => {
    setIsLoading(true);
    setPasswordInvalidMessage("");

    try {
      const response = await api.post(
        `${resolveConfig("/LS") || ""}/auth/login`,
        {
          userId: userId,
          password: password,
        }
      );

      const result = response?.data?.data || {};

      if (result.validCredentials === true) {
        if (result?.roleData?.root_menus?.length == 0) {
          openLoginErrorDialog(
            "Access Denied",
            "You don't have enough permissions to access this application, kindly contact Support."
          );
          return;
        }

        // 2. Decode Token
        const user = parseJwt(result.accessToken);
        const tabId = crypto.randomUUID();

        // 3. Update Redux (Auth & Menus)
        dispatch(
          loginSuccess({
            token: result.accessToken,
            user: user,
          })
        );

        dispatch(setTabId(tabId));
        dispatch(setMenus(result.roleData.root_menus));
        dispatch(setSelectedMenuItem(result.roleData.root_menus[0]));

        // 4. Broadcast to other tabs (Optional)
        const bc = new BroadcastChannel("auth");
        setTimeout(() => {
          bc.postMessage({
            type: "USER_LOGGED_IN",
            tabId,
            userId: user.userId,
          });
        }, 1000);
      } else {
        if (!result.validCredentials) {
          openLoginErrorDialog(
            "Login Failed",
            "Invalid credentials, Kindly check and try again."
          );
        }
        if (result.userStatus === "ACTIVE" && result.loginMethod === "P") {
          if (result.attemptsLeft > 0) {
            setPasswordInvalidMessage(
              `Invalid credentials. ${result.attemptsLeft} attempts left.`
            );
            openLoginErrorDialog("Invalid password", "Password incorrect.");
          } else {
            openLoginErrorDialog(
              "Account locked",
              "You are out of attempts and your account has been locked"
            );
          }
        }
      }
    } catch (e) {
      console.error("Login Error:", e);

      const msg =
        e.response?.data?.message ||
        "Failed to log into FinCore, please try again later";
      openLoginErrorDialog("Login Failed", msg);
    } finally {
      setIsLoading(false);
    }
  };

const handlePasswordKeyDown=(e)=>{
  if(e.key==="Enter"){
    e.preventDefault();
    e.stopPropagation();
    if(!isLoading && password){
      validateUserCredentials();
    }
  }
}
  return (
    <>
      <StyledTextField
        fullWidth
        label="Password"
        type={showPassword ? "text" : "password"}
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        onKeyDown={handlePasswordKeyDown}
        variant="outlined"
        error={!!passwordInvalidMessage}
        margin="normal"
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <LockIcon />
            </InputAdornment>
          ),
          endAdornment: (
            <InputAdornment position="end">
              <IconButton
                onClick={() => setShowPassword(!showPassword)}
                edge="end"
              >
                {showPassword ? <Visibility /> : <VisibilityOff />}
              </IconButton>
            </InputAdornment>
          ),
        }}
      />
      {passwordInvalidMessage && (
        <PasswordErrorText>{passwordInvalidMessage}</PasswordErrorText>
      )}

      <PrimaryButton
        fullWidth
        variant="contained"
        onClick={validateUserCredentials}
        disabled={!userId || isLoading}
      >
        {isLoading ? "Signing in..." : "Sign In"}
      </PrimaryButton>
    </>
    
  );
};

export default LoginWithPassword;







// theme section :


import * as React from "react";
import PropTypes from "prop-types";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import { colorSchemes, typography, shadows, shape } from "./themePrimitives";
import { inputsCustomizations } from "./customizations/inputs";
import { dataDisplayCustomizations } from "./customizations/dataDisplay";
import { feedbackCustomizations } from "./customizations/feedback";
import { navigationCustomizations } from "./customizations/navigation";
import { surfacesCustomizations } from "./customizations/surfaces";
// import { IconButton, useColorScheme } from "@mui/material";

function AppTheme(props) {
  const { children, disableCustomTheme, themeComponents } = props;

  const theme = React.useMemo(() => {
    if (disableCustomTheme) return {};
    return createTheme({
      cssVariables: {
        colorSchemeSelector: "data-mui-color-scheme",
        cssVarPrefix: "template",
      },
      colorSchemes, // light & dark
      // defaultColorScheme: "light",
      typography,
      shadows,
      shape,
      components: {
        ...inputsCustomizations,
        ...dataDisplayCustomizations,
        ...feedbackCustomizations,
        ...navigationCustomizations,
        ...surfacesCustomizations,
        ...themeComponents,
      },
    });
  }, [disableCustomTheme, themeComponents]);

  if (disableCustomTheme) return <>{children}</>;

  return (
    <ThemeProvider theme={theme} disableTransitionOnChange>
      {children}
    </ThemeProvider>
  );
}

AppTheme.propTypes = {
  children: PropTypes.node,
  disableCustomTheme: PropTypes.bool,
  themeComponents: PropTypes.object,
};

export default AppTheme;













import React from "react";
import { Box, useColorScheme } from "@mui/material";
// Import your background images
import lightModeBgImg from "../assets/BackGrounds/bg1.png";
import darkModeBgImg from "../assets/BackGrounds/dark-bg.png";

const GlobalBackground = () => {
  const { mode } = useColorScheme();
  const isLightMode = mode === "light";

  // Determine which background image to use
  const backgroundImage = isLightMode ? lightModeBgImg : darkModeBgImg;

  return (
    <Box
      id="global-bg"
      sx={{
        position: "fixed",
        inset: 0,
        zIndex: -1,
        backgroundImage: `url(${backgroundImage})`,
        backgroundSize: "cover",
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
        backgroundAttachment: "fixed",
        width: "100vw",
        height: "100vh",
        overflow: "hidden",
        transition:
          "filter 0.6s ease-in-out, background-image 0.6s ease-in-out",
        // Optional subtle filter adjusted for dark mode if needed
        filter: isLightMode
          ? "brightness(0.98)"
          : "brightness(0.8) contrast(1.1)",
      }}
    />
  );
};

export default GlobalBackground;













import { createTheme, alpha } from "@mui/material/styles";

const purple = {
  50: "#EDE8FF",
  100: "#D8CCFF",
  200: "#A28DF0", // light
  300: "#7C63E6",
  400: "#58469f", // main
  500: "#4F30C1",
  600: "#3E2C70", // dark
  700: "#2F2157",
  800: "#241A44",
  900: "#1B1435",
};

const gold = {
  50: "#FFF4CC",
  100: "#FFE580", // light
  200: "#FFD659",
  300: "#FCCC3D",
  400: "#F5C542", // main
  500: "#E6B51F",
  600: "#B48B00", // dark
  700: "#8A6B00",
  800: "#5C4800",
  900: "#3C2F00",
};

const gray = {
  50: "#F7F7F7",
  100: "#EDEDED",
  200: "#E0E0E0",
  300: "#C7C7C7",
  400: "#9E9E9E",
  500: "#6F6F6F",
  600: "#4F4F4F",
  700: "#424242",
  800: "#2E2E2E",
  900: "#1E1E1E",
};

// Semantic aliases for glassmorphism
export const glass = {
  panel: (opacity = 0.25) => `rgba(255,255,255,${opacity})`,
  border: "rgba(255,255,255,0.3)",
  chip: "rgba(255,255,255,0.35)",
  snackbar: "rgba(255,255,255,0.4)",
};

export const glassmorphismBaseStyles = (theme) => ({
  background: "rgba(255, 255, 255, 0.1)", // Semi-transparent white
  backdropFilter: "blur(20px) saturate(180%)", // Frosted glass effect
  WebkitBackdropFilter: "blur(10px) saturate(180%)", // For Safari support
  border: "1px solid rgba(255, 255, 255, 0.125)", // Subtle white border
  boxShadow: theme.shadows[10], // Stronger shadow for depth
  // borderRadius: "12px",
});

const base = createTheme();

export const typography = {
  fontFamily:
    "Poppins, Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif",
  button: { textTransform: "none", fontWeight: 600 },
  h1: { fontWeight: 600, fontSize: "clamp(2rem, 2.4vw, 2.5rem)" },
  h2: { fontWeight: 600, fontSize: "clamp(1.6rem, 1.9vw, 2rem)" },
  h3: { fontWeight: 500, fontSize: base.typography.pxToRem(24) },
  h4: { fontWeight: 500, fontSize: base.typography.pxToRem(20) },
  h5: { fontWeight: 500, fontSize: base.typography.pxToRem(16) },
  body1: { fontSize: base.typography.pxToRem(16) },
  body2: { fontSize: base.typography.pxToRem(14) },
};

export const shape = { borderRadius: 12 };

// Use CSS variables color schemes (MUI v7) like your other project. ?filecite?turn0file0?
export const colorSchemes = {
  light: {
    palette: {
      mode: "light",
      primary: {
        light: purple[200],
        main: purple[400],
        dark: purple[600],
        contrastText: "#fff",
      },
      secondary: {
        light: gold[100],
        main: gold[400],
        dark: gold[600],
        contrastText: gray[900],
      },
      success: {
        light: "#81C784",
        main: "#006304",
        dark: "#2E7D32",
        contrastText: "#fff",
      },
      warning: {
        light: "#ffcb95",
        main: "#F57C00",
        dark: "#E65100",
        contrastText: "#fff",
      },
      error: {
        light: "#EF5350",
        main: "#9f0400",
        dark: "#B71C1C",
        contrastText: "#fff",
      },
      info: {
        light: "#64B5F6",
        main: "#2196F3",
        dark: "#1565C0",
        contrastText: "#fff",
      },
      // spacing: {
      //  marginTop:"10px"
      // },

      grey: { ...gray },
      divider: alpha(purple[400], 0.2),
      background: {
        default: glass.panel(0.25),
        paper: glass.panel(0.25),
        glass: glass.panel(0.18),
      },
      text: { primary: "#402b7f", secondary: "#3E2C70", disabled: gray[400] },
      baseShadow: "0 8px 25px rgba(0,0,0,0.1)",
    },
  },
  dark: {
    palette: {
      mode: "dark",
      primary: {
        light: purple[300],
        main: purple[400],
        dark: purple[700],
        contrastText: "#fff",
      },
      secondary: {
        light: alpha(gold[100], 0.9),
        main: gold[400],
        dark: gold[700],
        contrastText: "#000",
      },
      success: {
        light: "#66BB6A",
        main: "#006304",
        dark: "#1B5E20",
        contrastText: "#fff",
      },
      warning: {
        light: "#FFA726",
        main: "#F57C00",
        dark: "#E65100",
        contrastText: "#fff",
      },
      error: {
        light: "#EF5350",
        main: "#9f0400",
        dark: "#B71C1C",
        contrastText: "#fff",
      },
      info: {
        light: "#64B5F6",
        main: "#2196F3",
        dark: "#1565C0",
        contrastText: "#fff",
      },
      grey: { ...gray },
      divider: alpha(gray[700], 0.5),
      background: {
        default: "#0E0E12",
        paper: alpha("#0E0E12", 0.8),
        glass: alpha("#0E0E12", 0.5),
      },
      text: {
        primary: "#F5F6FA",
        secondary: alpha("#F5F6FA", 0.7),
        disabled: alpha("#F5F6FA", 0.4),
      },
      baseShadow: "0 8px 40px rgba(0,0,0,0.35)",
    },
  },

  //   leaf: {
  //     palette: {
  //       mode: "light",

  //       primary: {
  //         light: "#A5F5B2",  // soft mint
  //         main:  "#4EC96F",  // main green
  //         dark:  "#1E7C3A",
  //         contrastText: "#ffffff",
  //       },

  //       secondary: {
  //         light: "#D4FFD6",
  //         main:  "#8DE19A",
  //         dark:  "#3E8A4E",
  //         contrastText: "#003300",
  //       },

  //       success: {
  //         light: "#B6F6C0",
  //         main:  "#4CAF50",
  //         dark:  "#1E7C3A",
  //         contrastText: "#ffffff",
  //       },

  //       warning: {
  //         light: "#FFE7B5",
  //         main:  "#FFC047",
  //         dark:  "#B77706",
  //         contrastText: "#3B2800",
  //       },

  //       error: {
  //         light: "#FFB3B3",
  //         main:  "#F44336",
  //         dark:  "#AA2017",
  //         contrastText: "#ffffff",
  //       },

  //       info: {
  //         light: "#B3E5FC",
  //         main:  "#29B6F6",
  //         dark:  "#0277BD",
  //         contrastText: "#ffffff",
  //       },

  //       // use the same grey + alpha helpers you already import
  //       grey: {
  //         ...grey,
  //       },

  //       background: {
  //         // light green base similar to your image
  //         default: "#E6FBD9",
  //         paper:   "rgba(255,255,255,0.88)",
  //         glass:   "rgba(230,251,217,0.7)",   // if you use 'glass' in your layouts
  //       },

  //       text: {
  //         primary:   "#103B1B",
  //         secondary: alpha("#103B1B", 0.7),
  //         disabled:  alpha("#103B1B", 0.4),
  //       },

  //       baseShadow: "0 8px 40px rgba(0, 0, 0, 0.18)",
  //     },

  // },
};

// Shadows: keep default but use palette.baseShadow for level 1 like your prior approach
const defaultTheme = createTheme();
export const shadows = [
  "none",
  "var(--template-palette-baseShadow)",
  ...defaultTheme.shadows.slice(2),
];









































not used theme.js lovable gave this but i did not understand in my project how to use this as the project is having large  codebase :

import { createTheme } from "@mui/material/styles";

const theme = createTheme({
  palette: {
    mode: "light",
    primary: {
      main: "hsl(217, 71%, 45%)",
      light: "hsl(217, 71%, 53%)",
      dark: "hsl(230, 80%, 42%)",
      contrastText: "#fff",
    },
    secondary: {
      main: "hsl(214, 20%, 92%)",
      contrastText: "hsl(215, 25%, 27%)",
    },
    error: {
      main: "hsl(0, 72%, 51%)",
      contrastText: "#fff",
    },
    warning: {
      main: "#f59e0b",
      light: "#fef3c7",
      dark: "#92400e",
    },
    success: {
      main: "hsl(152, 69%, 53%)",
    },
    background: {
      default: "hsl(210, 20%, 98%)",
      paper: "#fff",
    },
    text: {
      primary: "hsl(215, 25%, 15%)",
      secondary: "hsl(215, 14%, 50%)",
    },
    divider: "hsl(214, 20%, 88%)",
    chat: {
      bg: "hsl(220, 25%, 12%)",
      surface: "hsl(220, 22%, 16%)",
      userBubble: "hsl(217, 71%, 45%)",
      userText: "#fff",
      botBubble: "hsl(220, 18%, 96%)",
      botText: "hsl(220, 25%, 12%)",
      inputBg: "hsl(220, 22%, 18%)",
      inputText: "hsl(210, 20%, 92%)",
      inputPlaceholder: "hsl(215, 14%, 55%)",
      headerBg: "hsl(220, 28%, 9%)",
      border: "hsl(220, 18%, 22%)",
      pillBg: "hsl(220, 20%, 20%)",
      pillText: "hsl(210, 20%, 85%)",
      pillHover: "hsl(217, 71%, 45%)",
      disclaimer: "hsl(215, 14%, 50%)",
      fabBg: "hsl(217, 71%, 45%)",
      online: "hsl(152, 69%, 53%)",
      scrollbar: "hsl(220, 18%, 25%)",
    },
  },
  typography: {
    fontFamily:
      "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
    fontSize: 14,
  },
  shape: {
    borderRadius: 10,
  },
  components: {
    MuiCssBaseline: {
      styleOverrides: `
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body {
          font-family: 'Inter', sans-serif;
        }

        /* Chat scrollbar */
        .chat-scrollbar::-webkit-scrollbar {
          width: 6px;
        }
        .chat-scrollbar::-webkit-scrollbar-track {
          background: transparent;
        }
        .chat-scrollbar::-webkit-scrollbar-thumb {
          background: hsl(220, 18%, 25%);
          border-radius: 3px;
        }
        .chat-scrollbar::-webkit-scrollbar-thumb:hover {
          background: hsl(220, 18%, 22%);
        }

        /* Typing dots */
        @keyframes typing-dot {
          0%, 60%, 100% { opacity: 0.3; transform: translateY(0) scale(0.85); }
          30% { opacity: 1; transform: translateY(-5px) scale(1.15); }
        }
        .typing-dot:nth-of-type(1) { animation: typing-dot 1.4s infinite 0s; }
        .typing-dot:nth-of-type(2) { animation: typing-dot 1.4s infinite 0.2s; }
        .typing-dot:nth-of-type(3) { animation: typing-dot 1.4s infinite 0.4s; }

        /* Chat widget entrance */
        @keyframes chat-slide-up {
          from { opacity: 0; transform: translateY(20px) scale(0.95); }
          to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .animate-chat-open {
          animation: chat-slide-up 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }
        @keyframes chat-slide-down {
          from { opacity: 1; transform: translateY(0) scale(1); }
          to { opacity: 0; transform: translateY(16px) scale(0.96); }
        }
        .animate-chat-close {
          animation: chat-slide-down 0.25s cubic-bezier(0.4, 0, 1, 1) forwards;
        }

        /* FAB pulse */
        @keyframes fab-pulse {
          0%, 100% { box-shadow: 0 0 0 0 hsla(217, 71%, 45%, 0.4); }
          50% { box-shadow: 0 0 0 14px hsla(217, 71%, 45%, 0); }
        }
        .fab-pulse {
          animation: fab-pulse 2.5s ease-in-out infinite;
        }

        /* Message slide animations */
        @keyframes slide-in-left {
          from { opacity: 0; transform: translateX(-12px); }
          to { opacity: 1; transform: translateX(0); }
        }
        @keyframes slide-in-right {
          from { opacity: 0; transform: translateX(12px); }
          to { opacity: 1; transform: translateX(0); }
        }
        .animate-slide-in-left {
          animation: slide-in-left 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .animate-slide-in-right {
          animation: slide-in-right 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        /* Fade in */
        @keyframes fade-in-text {
          from { opacity: 0; transform: translateY(4px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
          animation: fade-in-text 0.3s ease-out;
        }

        /* Spin slow */
        @keyframes spin-slow {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        .animate-spin-slow {
          animation: spin-slow 1.2s linear infinite;
        }

        /* Thinking icon wrapper */
        .thinking-icon-wrapper {
          position: relative;
          display: inline-flex;
        }
        .thinking-icon-wrapper::before {
          content: '';
          position: absolute;
          inset: -3px;
          border-radius: 50%;
          border: 2px solid transparent;
          border-top-color: hsl(217, 71%, 45%);
          border-right-color: hsla(217, 71%, 45%, 0.4);
          animation: spin-slow 1s linear infinite;
        }
        .thinking-icon-wrapper::after {
          content: '';
          position: absolute;
          inset: -6px;
          border-radius: 50%;
          border: 1.5px solid transparent;
          border-bottom-color: hsla(217, 71%, 53%, 0.5);
          border-left-color: hsla(217, 71%, 53%, 0.2);
          animation: spin-slow 2s linear infinite reverse;
        }

        /* Thinking icon active glow */
        .thinking-icon-active {
          animation: icon-glow-pulse 1s ease-in-out infinite;
        }
        @keyframes icon-glow-pulse {
          0%, 100% { filter: drop-shadow(0 0 4px hsl(217, 71%, 53%)); }
          50% { filter: drop-shadow(0 0 12px hsl(217, 71%, 63%)); }
        }

        /* Cursor blink for typewriter */
        @keyframes cursor-blink {
          0%, 100% { opacity: 1; }
          50% { opacity: 0; }
        }
      `,
    },
  },
});

export default theme;










































// ##############################################################################################################################################################################








See this below file where sse were implmented for different purpose notification in our application :
go through to check possibility to integrete in our chat the use stream hook :


// useNotifications.js
import { useState, useEffect, useCallback } from "react";
import useApi from "./useApi";
import useStreamApi from "./useStreamApi";
import useCustomSnackbar from "../utils/useCustomSnackbar";

const BASE_URL = "/NS/notifications";

const useNotifications = () => {
  const { callApi } = useApi();
  const { showSnackbar } = useCustomSnackbar();
  const { startStream, stopStream, lastMessage, connected } = useStreamApi();

  const [pageNumber, setPageNumber] = useState(0);
  const [notifications, setNotifications] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  const [popNotification, setPopNotification] = useState(null);
  const size = 10;

  /* Handles Task Progess in FinCore */
  const [tasks, setTasks] = useState({});

  const upsertTask = useCallback((task) => {
    setTasks((prev) => ({
      ...prev,
      [task.taskId]: task,
    }));
  }, []);

  const removeTask = useCallback((taskId) => {
    setTasks((prev) => {
      const copy = { ...prev };
      delete copy[taskId];
      return copy;
    });
  }, []);

  const activeCount = Object.values(tasks).filter(
    (t) => t.percentage < 100
  ).length;

  /** --- Fetch unread count --- **/
  const fetchUnreadCount = useCallback(async () => {
    try {
      const data = await callApi(`${BASE_URL}/unread-count`);
      if (data?.count !== undefined) setUnreadCount(data.count);
    } catch (err) {
      console.error("Failed to fetch unread count:", err);
    }
  }, [callApi]);

  /** --- Fetch notification history (paged) --- **/
  const fetchHistory = useCallback(
    async (page = 0) => {
      try {
        const data = await callApi(`${BASE_URL}?page=${page}&size=${size}`);
        const newItems = data?.content || [];

        setNotifications((prev) =>
          page === 0 ? newItems : [...prev, ...newItems]
        );
        setHasMore(!data?.last);
        setPageNumber(page);
      } catch (err) {
        console.error("Failed to fetch notifications:", err);
      }
    },
    [callApi, size]
  );

  /** --- Mark as read --- **/
  const markAsRead = useCallback(
    async (id) => {
      try {
        const response = await callApi(`${BASE_URL}/${id}/read`, {}, "POST");
        if (response) {
          setNotifications((prev) =>
            prev.map((n) => (n.id === id ? { ...n, read: true } : n))
          );
          setUnreadCount((prev) => Math.max(prev - 1, 0));
        } else {
          showSnackbar("Failed to mark as read", "error");
        }
      } catch (err) {
        console.error("Mark as read failed:", err);
      }
    },
    [callApi, showSnackbar]
  );

  /** --- Mark all as read --- **/
  const markAllAsRead = useCallback(async () => {
    try {
      const response = await callApi(`${BASE_URL}/read-all`, {}, "POST");
      if (response) {
        setNotifications((prev) => prev.map((n) => ({ ...n, read: true })));
        setUnreadCount(0);
      } else {
        showSnackbar("Failed to mark all notifications as read", "error");
      }
    } catch (err) {
      console.error("Mark all as read failed:", err);
    }
  }, [callApi, showSnackbar]);

  /** --- SSE stream + initial load (run once, not on each menu change) --- **/
  useEffect(() => {
    // Initial load
    fetchUnreadCount();
    fetchHistory(0); // first page

    // Start live stream
    startStream(`${BASE_URL}/stream`, {
      onMessage: (newNotification) => {
        console.log("New Notification Found", newNotification);
      },

      onTaskProgress: (data) => {
        upsertTask({
          taskId: data.taskId,
          percentage: data.percentage,
          status: data.status,
          message: data.message,
        });

        if (data.percentage === 100) {
          setTimeout(() => removeTask(data.taskId), 5000);
        }
      },
    });

    // Cleanup on unmount
    return () => {
      stopStream();
    };
    // We intentionally do NOT add fetchUnreadCount / fetchHistory to deps,
    // to avoid re-running this effect on every callApi/xRequestType/menu change.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [startStream, stopStream]);

  /** --- Show popup for 5 seconds --- **/
  const triggerPopup = useCallback((notif) => {
    setPopNotification(notif);
    if (triggerPopup.timer) clearTimeout(triggerPopup.timer);
    triggerPopup.timer = setTimeout(() => setPopNotification(null), 5000);
  }, []);

  /** --- When new message arrives via SSE --- **/
  useEffect(() => {
    if (lastMessage) {
      setNotifications((prev) => [lastMessage, ...prev]);
      setUnreadCount((prev) => prev + 1);
      triggerPopup(lastMessage);
    }
  }, [lastMessage, triggerPopup]);

  /** --- Pagination helper --- **/
  const loadMore = useCallback(() => {
    if (hasMore) fetchHistory(pageNumber + 1);
  }, [hasMore, fetchHistory, pageNumber]);

  return {
    connected,
    notifications,
    unreadCount,
    fetchUnreadCount,
    fetchHistory,
    markAsRead,
    markAllAsRead,
    stopStream,
    loadMore,
    hasMore,
    popNotification,
    setPopNotification,
    tasks,
    upsertTask,
    removeTask,
    activeCount,
  };
};

export default useNotifications;







useStreamApi hook :



import { useEffect, useRef, useState, useCallback } from "react";
import { fetchEventSource } from "@microsoft/fetch-event-source";
import { useDispatch, useSelector } from "react-redux";
import { resolveConfig } from "../config/EnvironmentConfig";
import { logoutSuccess } from "../store/slices/authSlice";
import { refreshAccessToken } from "../utils/AuthHelpers";

const useStreamApi = () => {
  const dispatch = useDispatch();
  const token = useSelector((state) => state.auth.token);

  const controllerRef = useRef(null);
  const retryingRef = useRef(false);

  const [connected, setConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState(null);

  const startStream = useCallback(
    async (url, handlers = {}) => {
      const {
        onOpen,
        onMessage,
        onTaskProgress,
        onError,
        //onConnected,
      } = handlers;

      if (!token) {
        console.warn("No token available for SSE");
        return;
      }

      // Resolve microservice URL
      const parts = url.split("/");
      const service = parts[1];
      parts[1] = resolveConfig(`/${service}`);
      const finalUrl = parts.slice(1).join("/");

      // Close old stream
      if (controllerRef.current) {
        controllerRef.current.abort();
      }

      const controller = new AbortController();
      controllerRef.current = controller;

      fetchEventSource(finalUrl, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token}`,
        },
        signal: controller.signal,

        async onopen(response) {
          // ======================
          // HANDLE 401
          // ======================
          if (response.status === 401) {
            let errorCode = "TOKEN_EXPIRED";

            try {
              const data = await response.clone().json();
              errorCode = data?.error;
            } catch (e) {}

            // TOKEN EXPIRED â†’ REFRESH
            if (errorCode === "TOKEN_EXPIRED" && !retryingRef.current) {
              retryingRef.current = true;
              controller.abort();

              try {
                await refreshAccessToken(dispatch);
                retryingRef.current = false;

                // Restart stream with new token
                startStream(url, handlers);
              } catch (err) {
                dispatch(logoutSuccess());
              }

              return;
            }

            // Hard logout cases
            if (
              errorCode === "SESSION_EXPIRED" ||
              errorCode === "INVALID_TOKEN" ||
              errorCode === "CONCURRENT_LOGIN"
            ) {
              dispatch(logoutSuccess());

              window.dispatchEvent(
                new CustomEvent("auth:session-expired", {
                  detail: { reason: errorCode },
                })
              );

              controller.abort();
              return;
            }
          }

          // ======================
          // SUCCESS
          // ======================
          retryingRef.current = false;
          setConnected(true);
          onOpen?.(response);
          //onConnected?.();
        },

        onmessage(event) {
          if (event.event === "connected") return;

          try {
            const data = JSON.parse(event.data);
            setLastMessage(data);

            // Global event router
            switch (event.event) {
              case "new_notification":
                onMessage?.(data);
                break;

              case "task_progress":
                onTaskProgress?.(data);
                break;

              default:
                onMessage?.(data);
            }
          } catch (err) {
            console.error("SSE parse error:", err);
          }
        },

        onerror(err) {
          setConnected(false);
          onError?.(err);
        },
      });
    },
    [token, dispatch]
  );

  const stopStream = useCallback(() => {
    if (controllerRef.current) {
      controllerRef.current.abort();
      controllerRef.current = null;
      retryingRef.current = false;
      setConnected(false);
    }
  }, []);

  useEffect(() => {
    return () => stopStream();
  }, [stopStream]);

  return {
    connected,
    lastMessage,
    startStream,
    stopStream,
  };
};

export default useStreamApi;

















now check the be :



package com.fincore.helpservice.config;

import dev.langchain4j.model.chat.ChatLanguageModel;
import dev.langchain4j.model.chat.StreamingChatLanguageModel;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.ollama.OllamaChatModel;
import dev.langchain4j.model.ollama.OllamaEmbeddingModel;
import dev.langchain4j.model.ollama.OllamaStreamingChatModel;
import dev.langchain4j.store.embedding.EmbeddingStore;
import dev.langchain4j.store.embedding.redis.RedisEmbeddingStore;
import dev.langchain4j.data.segment.TextSegment;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import java.time.Duration;
import java.util.Arrays;

/**
 * Enterprise AI Configuration.
 * Connects the JVM to the offline Docker LLMs and Vector Database.
 */
@Configuration
public class AiConfiguration {

    @Value("${langchain4j.ollama.base-url}")
    private String ollamaBaseUrl;

    @Value("${langchain4j.ollama.chat-model.name}")
    private String chatModelName;

    @Value("${langchain4j.ollama.embedding-model.name}")
    private String embeddingModelName;

    @Value("${langchain4j.vector-store.redis.host}")
    private String redisHost;

    @Value("${langchain4j.vector-store.redis.port}")
    private Integer redisPort;

    @Value("${langchain4j.vector-store.redis.index-name}")
    private String indexName;

    @Value("${langchain4j.vector-store.redis.prefix}")
    private String prefix;

    @Value("${langchain4j.vector-store.redis.dimension:1024}")
    private Integer dimension;

    // The Generative Model (The Talker)
    @Bean
    public ChatLanguageModel chatLanguageModel() {
        return OllamaChatModel.builder()
                .baseUrl(ollamaBaseUrl)
                .modelName(chatModelName)
                .temperature(0.1) // Low temp = faster, more deterministic
                .numPredict(200) // OPTIMIZATION: Hard cap output to ~250 words maximum
                .timeout(java.time.Duration.ofSeconds(180))
                .maxRetries(1) // Once Keep-Alive is set, you don't need heavy retries
                .build();
    }

    // THE NEW STREAMING BEAN: Handles real-time token generation
    @Bean
    public StreamingChatLanguageModel streamingChatLanguageModel() {
        return OllamaStreamingChatModel.builder()
                .baseUrl(ollamaBaseUrl)
                .modelName(chatModelName)
                .temperature(0.1)
                .numPredict(250)
                .timeout(Duration.ofSeconds(180))
                .build();
    }

    // The Embedding Model (The Searcher)
    @Bean
    @Primary
    public EmbeddingModel embeddingModel() {
        return OllamaEmbeddingModel.builder()
                .baseUrl(ollamaBaseUrl)
                .modelName(embeddingModelName)
                .timeout(Duration.ofSeconds(15))
                .build();
    }

    // The Vector Database (Redis Stack on Port 6380)
    @Bean
    public EmbeddingStore<TextSegment> embeddingStore() {
        return RedisEmbeddingStore.builder()
                .host(redisHost)
                .port(redisPort)
                .dimension(dimension)
                .indexName(indexName)
                .prefix(prefix)
                .metadataKeys(Arrays.asList("permissionId", "actionLink", "actionLabel", "dataType"))
                .build();
    }
}












package com.fincore.helpservice.controller;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.fincore.helpservice.dto.HelpRequestDTO;
import com.fincore.helpservice.dto.HelpResponseDTO;
import com.fincore.helpservice.model.HelpQuestionEntity;
import com.fincore.helpservice.repository.HelpFaqRepository;
import com.fincore.helpservice.repository.HelpQuestionRepository;
import com.fincore.helpservice.service.FinCoreChatAgent;
import com.fincore.helpservice.service.HelpAnalyticsService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.List;
import java.util.Map;

/**
 * Primary REST Controller for the FinCore Help & AI Assistant.
 * Orchestrates Generative AI Chat, Static Module Help, and Global FAQs.
 */
@RestController
@RequestMapping("/api/help")
@RequiredArgsConstructor
@Slf4j
public class HelpController {

    private final JwtUtil jwtUtil;

    // 1. The New AI Brain
    private final FinCoreChatAgent chatAgent;

    // 2. The Traditional DB Repositories (For fast, non-AI queries)
    private final HelpQuestionRepository questionRepository;

    // 3. Analytics (For Thumbs Up / Thumbs Down feedback)
    private final HelpAnalyticsService analyticsService;

    // ========================================================================
    // 1. THE AI CHAT ENDPOINT (Powered by llama & Mxbai)
    // ========================================================================
//    @PostMapping("/chat")
//    public ResponseEntity<HelpResponseDTO> handleChatQuery(
//            @RequestHeader("Authorization") String token,
//            @RequestBody HelpRequestDTO request) {
//
//        log.info("[API] Chat request received from User: {} | Role: {} | Message: '{}'", "2488766", "51", request.getUserMessage());
//
//        // Route the query through our LangChain4j RAG pipeline
//        HelpResponseDTO response = chatAgent.handleChat("2488766", "51", request.getUserMessage(), request.getCurrentScreen());
//
//        return ResponseEntity.ok(response);
//    }

    // ========================================================================
    // 3. GLOBAL FAQS (Powered by fast SQL - No AI required)
    // ========================================================================
    @GetMapping("/faqs")
    public ResponseEntity<List<HelpQuestionEntity>> getGlobalFaqs(@RequestHeader("Authorization") String token) {
        log.info("[API] Fetching global FAQs");

        // Flow: Fetch predefined global questions (where permission_id is null/GLOBAL)
        List<HelpQuestionEntity> globalFaqs = questionRepository.findGlobalFaqs();

        return ResponseEntity.ok(globalFaqs);
    }

    // ========================================================================
    // 4. CHAT FEEDBACK ENDPOINT (For UI Thumbs Up / Thumbs Down)
    // ========================================================================
    @PostMapping("/feedback")
    public ResponseEntity<Void> submitChatFeedback(
            @RequestHeader("Authorization") String token,
            @RequestBody Map<String, Object> feedbackPayload) {

        // Expected payload: { "logId": 12345, "isHelpful": true }
        Long logId = Long.valueOf(feedbackPayload.get("logId").toString());
        boolean isHelpful = (Boolean) feedbackPayload.get("isHelpful");

        log.info("[API] Feedback received for Log ID: {} | Helpful: {}", logId, isHelpful);

        // Update the audit trail in Oracle to reflect user satisfaction
        analyticsService.updateFeedback(logId, isHelpful);

        return ResponseEntity.ok().build();
    }

    // Allows UI to increment the Popularity of an FAQ when a user clicks the suggestion bubble
    @PostMapping("/faqs/track")
    public ResponseEntity<Void> trackFaqClick(@RequestBody Map<String, String> payload) {
        String question = payload.get("questionText");
        chatAgent.incrementFaqPopularity(question);
        return ResponseEntity.ok().build();
    }


    // Note the produces = MediaType.TEXT_EVENT_STREAM_VALUE
    @PostMapping(value = "/chat", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter handleChatQuery(
            @RequestHeader("Authorization") String token,
            @RequestBody HelpRequestDTO request) {

        String userId = jwtUtil.getUserIdFromToken(token);
        String roleId = String.valueOf(jwtUtil.getUserRoleFromToken(token));

        log.info("[API] Streaming Chat request received from User: {} | Role: {} | Message: '{}'", userId, roleId, request.getUserMessage());

        // Pass to the agent, which will return the active connection
        return chatAgent.handleStreamChat(userId, roleId, request.getUserMessage(), request.getCurrentScreen());
    }
}
















package com.fincore.helpservice.service;

import com.fincore.helpservice.dto.HelpResponseDTO;
import com.fincore.helpservice.model.HelpFaqEntity;
import com.fincore.helpservice.model.HelpQuestionEntity;
import com.fincore.helpservice.repository.HelpFaqRepository;
import com.fincore.helpservice.repository.HelpQuestionRepository;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import dev.langchain4j.data.embedding.Embedding;
import dev.langchain4j.data.message.AiMessage;
import dev.langchain4j.data.message.ChatMessage;
import dev.langchain4j.data.message.SystemMessage;
import dev.langchain4j.data.message.UserMessage;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.memory.ChatMemory;
import dev.langchain4j.memory.chat.MessageWindowChatMemory;
import dev.langchain4j.model.StreamingResponseHandler;
import dev.langchain4j.model.chat.ChatLanguageModel;
import dev.langchain4j.model.chat.StreamingChatLanguageModel;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.output.Response;
import dev.langchain4j.store.embedding.EmbeddingMatch;
import dev.langchain4j.store.embedding.EmbeddingSearchRequest;
import dev.langchain4j.store.embedding.EmbeddingSearchResult;
import dev.langchain4j.store.embedding.EmbeddingStore;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class FinCoreChatAgent {

    private static final String FAILURE_MSG = "I cannot find this information in your authorized FinCore manuals. Please check your permissions or contact Fincore support.";

    private final StreamingChatLanguageModel streamingChatClient;
    private final EmbeddingModel embeddingModel;
    private final EmbeddingStore<TextSegment> vectorStore;
    private final PermissionService permissionService;
    private final ChatSessionService sessionService;
    private final HelpAnalyticsService analyticsService;
    private final HelpQuestionRepository questionRepository;
    private final HelpFaqRepository faqRepository;
    private final ChatLanguageModel chatClient;

    private final Cache<String, ChatMemory> userMemories = Caffeine.newBuilder()
            .expireAfterAccess(30, TimeUnit.MINUTES)
            .maximumSize(10000)
            .build();


    public SseEmitter handleStreamChat(String userId, String roleId, String userMessage, String currentScreen) {
        // Create an Emitter with a 3-minute timeout to allow heavy LLMs to think
        SseEmitter emitter = new SseEmitter(180000L);
        log.info("==================================================================");
        log.info("[AI-STREAM-INIT] User: {} | Msg: '{}'", userId, userMessage);

        try {
            // ========================================================================
            // 1. GUIDED MENUS (Fast DB Fetch - No LLM Needed)
            // ========================================================================
            if ("/action faq".equalsIgnoreCase(userMessage.trim())) {
                List<String> faqQuestions = faqRepository.findTop10ByIsActiveOrderByViewCountDesc("Y")
                        .stream().map(HelpFaqEntity::getQuestionText).collect(Collectors.toList());
                emitSuggestionAndClose(emitter, "Here are a few frequently asked questions:", faqQuestions);
                return emitter;
            }

            if (userMessage.trim().startsWith("/action module")) {
                String requestedScreen = userMessage.replace("/action module", "").trim();
                List<String> moduleQuestions = questionRepository.findByScreenNameAndIsActive(requestedScreen, "Y")
                        .stream().map(HelpQuestionEntity::getQuestionText).collect(Collectors.toList());

                if (moduleQuestions.isEmpty()) {
                    emitTextAndClose(emitter, "I don't have predefined questions for " + requestedScreen + " right now, but feel free to ask me anything about it!");
                } else {
                    emitSuggestionAndClose(emitter, "Here are a few common questions for the " + requestedScreen + " screen:", moduleQuestions);
                }
                return emitter;
            }

            // ========================================================================
            // 2. ESCALATION CHECK
            // ========================================================================
            if (sessionService.isEscalationRequired(userId)) {
                sessionService.resetStrikes(userId);
                emitEvent(emitter, "escalation", Map.of(
                        "botReply", "I seem to be having trouble helping you today. Would you like me to raise an IT Support Ticket with your chat history attached?"
                ));
                emitter.complete();
                return emitter;
            }

            // ========================================================================
            // 3. VECTOR DB FETCH & RBAC
            // ========================================================================
            List<String> allowedPerms = permissionService.getAllAllowedPermissionIdsForRole(roleId)
                    .stream().map(String::valueOf).collect(Collectors.toList());
            allowedPerms.add("GLOBAL");

            Embedding queryEmbedding = embeddingModel.embed(userMessage).content();
            EmbeddingSearchRequest searchRequest = EmbeddingSearchRequest.builder()
                    .queryEmbedding(queryEmbedding).maxResults(20).minScore(0.65).build();

            EmbeddingSearchResult<TextSegment> searchResult = vectorStore.search(searchRequest);

            List<EmbeddingMatch<TextSegment>> matches = searchResult.matches().stream()
                    .filter(match -> {
                        String docPerm = match.embedded().metadata().getString("permissionId");
                        return docPerm != null && allowedPerms.contains(docPerm);
                    })
                    .limit(2)
                    .toList();

            double highestScore = matches.isEmpty() ? 0.0 : matches.getFirst().score();

            // ========================================================================
            // 4. CONFIDENCE-BASED LINK ROUTING (Threshold: 0.80)
            // ========================================================================
            StringBuilder contextBuilder = new StringBuilder();
            String finalActionLink = null;
            String finalActionLabel = null;

            if (!matches.isEmpty()) {
                for (EmbeddingMatch<TextSegment> match : matches) {
                    contextBuilder.append("- ").append(match.embedded().text()).append("\n\n");
                    if (finalActionLink == null && highestScore >= 0.80) {
                        String link = match.embedded().metadata().getString("actionLink");
                        if (link != null && !"NONE".equals(link)) {
                            finalActionLink = link;
                            finalActionLabel = match.embedded().metadata().getString("actionLabel");
                        }
                    }
                }
            } else {
                contextBuilder.append("NO BANKING CONTEXT FOUND. Either the user lacks permission, or the knowledge does not exist.");
            }

            // Let the UI know we are about to start typing (Shows the "..." animation)
            emitEvent(emitter, "start", Map.of("status", "typing"));

            // ========================================================================
            // 5. PREPARE THE PROMPT & MEMORY
            // ========================================================================
            String liveEtlDate = permissionService.getLiveEtlDate();
            String currentTime = LocalDateTime.now().format(DateTimeFormatter.ofPattern("EEEE, MMMM dd, yyyy - hh:mm a"));
            String currentScreenContext = (currentScreen != null && !currentScreen.isEmpty()) ? currentScreen : "Unknown";

            String dynamicPrompt = """
                    You are the FinCore Smart Assistant, an advanced, highly capable AI banking bot built by Shubhankar, A Software Developer From Fincore Development Team.
                    Current Time: %s
                    System ETL Date: %s
                    User's Current Screen: %s
                    
                    <INSTRUCTIONS>
                    1. CASUAL CONVERSATION: If the user message is a greeting, gratitude, or small talk, respond warmly and dynamically. Make the user feel good. Do NOT mention banking context.
                    2. BANKING QUERIES: For FinCore questions, you MUST rely EXCLUSIVELY on the <AUTHORIZED_CONTEXT> below.
                    3. FORMATTING: Use standard Markdown formatting (**bold**, bullet points) for readability.
                    4. UNAUTHORIZED / NO MATCH: If the <AUTHORIZED_CONTEXT> does not clearly answer the question, or says "NO BANKING CONTEXT FOUND", you MUST output the exact phrase below and NOTHING else (No explanations):
                       %s
                    5. NO HALLUCINATION: Never invent rules or guess. Strictly follow this rule..
                    </INSTRUCTIONS>
                    
                    <AUTHORIZED_CONTEXT>
                    %s
                    </AUTHORIZED_CONTEXT>
                    """.formatted(currentTime, liveEtlDate, currentScreenContext, FAILURE_MSG, contextBuilder.toString());

            ChatMemory memory = userMemories.get(userId, k -> MessageWindowChatMemory.withMaxMessages(3));
            memory.add(UserMessage.from(userMessage));

            List<ChatMessage> fullConversation = new ArrayList<>();
            fullConversation.add(SystemMessage.from(dynamicPrompt));
            fullConversation.addAll(memory.messages());

            // Needed for the async callbacks
            final String threadActionLink = finalActionLink;
            final String threadActionLabel = finalActionLabel;

            // ========================================================================
            // 6. ASYNC STREAMING ENGINE
            // ========================================================================
            streamingChatClient.generate(fullConversation, new StreamingResponseHandler<AiMessage>() {

                @Override
                public void onNext(String token) {
                    // Send each word to the UI the millisecond it is generated!
                    try {
                        emitEvent(emitter, "token", Map.of("token", token));
                    } catch (Exception e) {
                        log.warn("Client disconnected during streaming");
                        emitter.completeWithError(e);
                    }
                }

                @Override
                public void onComplete(Response<AiMessage> response) {
                    try {
                        String aiResponse = response.content().text().trim();
                        log.info("[AI-STREAM-COMPLETE] Successfully generated streaming response.");

                        // Background Cleanup & DB Logging
                        String intentLog = (highestScore < 0.80) ? "SMALL_TALK" : "ANSWERED";
                        Long successLogId = null;

                        if (aiResponse.contains("I cannot find this information") || aiResponse.contains(FAILURE_MSG)) {
                            sessionService.addStrikes(userId, 1);
                            successLogId = analyticsService.logChatInteraction(userId, "AI_RAG", userMessage, "NO_MATCH", (int) (highestScore * 100));
                            memory.add(AiMessage.from(FAILURE_MSG));

                            // Send END event WITHOUT links because it failed
                            emitEvent(emitter, "end", Map.of("logId", successLogId, "status", "complete"));
                        } else {
                            sessionService.resetStrikes(userId);
                            successLogId = analyticsService.logChatInteraction(userId, "AI_RAG", userMessage, intentLog, (int) (highestScore * 100));
                            memory.add(response.content());

                            // Send END event WITH Links to fade-in the buttons
                            Map<String, Object> endPayload = new java.util.HashMap<>(Map.of("logId", successLogId, "status", "complete"));
                            if (threadActionLink != null) {
                                endPayload.put("navigationLink", threadActionLink);
                                endPayload.put("navigationLabel", threadActionLabel);
                            }
                            emitEvent(emitter, "end", endPayload);
                        }

                        emitter.complete();
                    } catch (Exception e) {
                        emitter.completeWithError(e);
                    }
                }

                @Override
                public void onError(Throwable error) {
                    log.error("[AI-STREAM-ERROR] LLM Streaming Failed", error);
                    try {
                        emitEvent(emitter, "error", Map.of("botReply", "I am currently experiencing a cognitive delay. Please try again."));
                        emitter.completeWithError(error);
                    } catch (Exception ignored) {
                    }
                }
            });

        } catch (Exception e) {
            log.error("[AI-STREAM-ERROR] Critical Failure in Stream Setup", e);
            try {
                emitEvent(emitter, "error", Map.of("botReply", "An unexpected system error occurred."));
                emitter.completeWithError(e);
            } catch (Exception ignored) {
            }
        }

        return emitter;
    }

    // --- Helper Methods to easily send Server-Sent Events ---

    private void emitEvent(SseEmitter emitter, String eventName, Map<String, Object> data) throws Exception {
        emitter.send(SseEmitter.event().name(eventName).data(data));
    }

    private void emitSuggestionAndClose(SseEmitter emitter, String botReply, List<String> items) throws Exception {
        emitEvent(emitter, "suggestion", Map.of("botReply", botReply, "items", items));
        emitter.complete();
    }

    private void emitTextAndClose(SseEmitter emitter, String botReply) throws Exception {
        emitEvent(emitter, "text_reply", Map.of("botReply", botReply));
        emitter.complete();
    }

    public void incrementFaqPopularity(String questionText) {
        faqRepository.findByQuestionTextAndIsActive(questionText, "Y").ifPresent(faq -> {
            faq.setViewCount(faq.getViewCount() + 1);
            faqRepository.save(faq);
        });
    }


    // ========================= unused old function ==============================

    public HelpResponseDTO handleChat(String userId, String roleId, String userMessage, String currentScreen) {
        log.info("==================================================================");
        log.info("[AI-STEP-1: INIT] Processing query. User: {} | Role: {} | Msg: '{}'", userId, roleId, userMessage);

        try {
            // ========================================================================
            // GUIDED MENUS (Fast DB Fetch)
            // ========================================================================
            if ("/action faq".equalsIgnoreCase(userMessage.trim())) {
                log.info("[AI-STEP-2: COMMAND] Executing FAQ Quick Action.");
                List<String> faqQuestions = faqRepository.findTop10ByIsActiveOrderByViewCountDesc("Y")
                        .stream().map(HelpFaqEntity::getQuestionText).collect(Collectors.toList());
                return HelpResponseDTO.builder().responseType("SUGGESTION").botReply("Here are a few frequently asked questions:").items(faqQuestions).build();
            }

            if (userMessage.trim().startsWith("/action module")) {
                String requestedScreen = userMessage.replace("/action module", "").trim();
                log.info("[AI-STEP-2: COMMAND] Executing Module Quick Action for: {}", requestedScreen);
                List<String> moduleQuestions = questionRepository.findByScreenNameAndIsActive(requestedScreen, "Y")
                        .stream().map(HelpQuestionEntity::getQuestionText).collect(Collectors.toList());

                if (moduleQuestions.isEmpty()) {
                    return HelpResponseDTO.builder().responseType("TEXT_REPLY").botReply("I don't have predefined questions for " + requestedScreen + ", but feel free to ask me anything about it!").build();
                }
                return HelpResponseDTO.builder().responseType("SUGGESTION").botReply("Here are a few common questions for " + requestedScreen + ":").items(moduleQuestions).build();
            }

            // ========================================================================
            // ESCALATION CHECK
            // ========================================================================
            if (sessionService.isEscalationRequired(userId)) {
                log.warn("[AI-STEP-3: ESCALATION] User hit max failures. Offering IT Support.");
                sessionService.resetStrikes(userId);
                return HelpResponseDTO.builder()
                        .responseType("ESCALATION_OFFER")
                        .botReply("I seem to be having trouble helping you today. Would you like me to raise an IT Support Ticket with your chat history attached?")
                        .build();
            }

            // ========================================================================
            // VECTOR DB FETCH & RBAC FILTERING
            // ========================================================================
            List<String> allowedPerms = permissionService.getAllAllowedPermissionIdsForRole(roleId)
                    .stream().map(String::valueOf).collect(Collectors.toList());
            allowedPerms.add("GLOBAL");
            log.info("[AI-STEP-4: RBAC] User allowed permissions: {}", allowedPerms);

            Embedding queryEmbedding = embeddingModel.embed(userMessage).content();

            // We use a low 0.50 threshold to ensure short queries (like "what is cgl?") are not accidentally dropped.
            EmbeddingSearchRequest searchRequest = EmbeddingSearchRequest.builder()
                    .queryEmbedding(queryEmbedding)
                    .maxResults(20)
                    .minScore(0.65)
                    .build();

            EmbeddingSearchResult<TextSegment> searchResult = vectorStore.search(searchRequest);
            log.info("[AI-STEP-5: REDIS] Found {} raw matches before RBAC filtering.", searchResult.matches().size());

            // Filter ONLY what the user is allowed to see
            List<EmbeddingMatch<TextSegment>> matches = searchResult.matches().stream()
                    .filter(match -> {
                        String docPerm = match.embedded().metadata().getString("permissionId");
                        return docPerm != null && allowedPerms.contains(docPerm);
                    })
                    .limit(2)
                    .toList();

            double highestScore = matches.isEmpty() ? 0.0 : matches.getFirst().score();
            log.info("[AI-STEP-6: FILTER] Safe contexts after RBAC: {}. Highest Score: {}", matches.size(), highestScore);

            // ========================================================================
            // CONFIDENCE-BASED LINK ROUTING
            // ========================================================================
            StringBuilder contextBuilder = new StringBuilder();
            String primaryActionLink = null;
            String primaryActionLabel = null;

            if (!matches.isEmpty()) {
                for (EmbeddingMatch<TextSegment> match : matches) {
                    contextBuilder.append("- ").append(match.embedded().text()).append("\n\n");

                    // Only attach navigation links if the mathematical match is strong (> 0.65)
                    // If it's a weak match (like "How are you?"), the UI gets no buttons.
                    if (primaryActionLink == null && highestScore >= 0.80) {
                        String link = match.embedded().metadata().getString("actionLink");
                        if (link != null && !"NONE".equals(link)) {
                            primaryActionLink = link;
                            primaryActionLabel = match.embedded().metadata().getString("actionLabel");
                        }
                    }
                }
            } else {
                contextBuilder.append("NO BANKING CONTEXT FOUND. Either the user lacks permission, or the knowledge does not exist in the database.");
            }

            // ========================================================================
            // THE LLaMA 3 MASTER AI PROMPT
            // ========================================================================
            String liveEtlDate = permissionService.getLiveEtlDate();
            String currentTime = LocalDateTime.now().format(DateTimeFormatter.ofPattern("EEEE, MMMM dd, yyyy - hh:mm a"));
            String currentScreenContext = (currentScreen != null && !currentScreen.isEmpty()) ? currentScreen : "Unknown";

            String dynamicPrompt = """
                    You are the FinCore Smart Assistant, an advanced, highly capable AI banking bot built by Shubhankar, A Software Developer From Fincore Development Team.
                    Current Time: %s
                    System ETL Date: %s
                    User's Current Screen: %s
                    
                    <INSTRUCTIONS>
                    1. CASUAL CONVERSATION: If the user message is a greeting, gratitude, or small talk, respond warmly and dynamically. Do NOT mention banking context.
                    2. BANKING QUERIES: For FinCore questions, you MUST rely EXCLUSIVELY on the <AUTHORIZED_CONTEXT> below.
                    3. FORMATTING: Use standard Markdown formatting (**bold**, bullet points) for readability.
                    4. DIRECT ANSWERS: Answer immediately. Do NOT use conversational preambles like "Here is the information" or "Sure, I can help".
                    5. UNAUTHORIZED / NO MATCH: If the <AUTHORIZED_CONTEXT> does not clearly answer the question, or says "NO BANKING CONTEXT FOUND", you MUST output the exact phrase below and NOTHING else (No explanations):
                       %s
                    6. NO HALLUCINATION: Never invent rules or guess.
                    7. BE CONCISE: Keep your answers as short and direct as possible. Use brief bullet points instead of long paragraphs.
                    </INSTRUCTIONS>
                    
                    <AUTHORIZED_CONTEXT>
                    %s
                    </AUTHORIZED_CONTEXT>
                    """.formatted(currentTime, liveEtlDate, currentScreenContext, FAILURE_MSG, contextBuilder.toString());

            // ========================================================================
            // CALL LLAMA-3 WITH FULL MEMORY
            // ========================================================================
            ChatMemory memory = userMemories.get(userId, k -> MessageWindowChatMemory.withMaxMessages(3));
            memory.add(UserMessage.from(userMessage));

            List<ChatMessage> fullConversation = new ArrayList<>();
            fullConversation.add(SystemMessage.from(dynamicPrompt));
            fullConversation.addAll(memory.messages());

            log.info("[AI-STEP-7: LLM] Sending instructions, {} history messages, and context to LLaMA-3...", memory.messages().size());
            AiMessage responseMessage = chatClient.generate(fullConversation).content();

            String aiResponse = responseMessage.text();
            log.info("[AI-STEP-8: RESPONSE] Raw LLM Reply: '{}'", aiResponse.replace("\n", " "));

            // ========================================================================
            // OUTPUT SANITIZATION & LOGGING
            // ========================================================================
            if (aiResponse.contains("I cannot find this information") || aiResponse.contains(FAILURE_MSG)) {
                log.warn("[AI-STEP-9: SANITIZE] LLM decided context was insufficient. Applying Failure Message.");
                sessionService.addStrikes(userId, 1);

                Long failLogId = analyticsService.logChatInteraction(userId, "AI_RAG", userMessage, "NO_MATCH", (int) (highestScore * 100));
                memory.add(AiMessage.from(FAILURE_MSG));

                return HelpResponseDTO.builder().responseType("NO_MATCH").botReply(FAILURE_MSG).logId(failLogId).build();
            }

            log.info("[AI-STEP-9: SUCCESS] Valid answer generated!");
            sessionService.resetStrikes(userId);
            memory.add(responseMessage);

            // If score was low, we classify it as Small Talk in analytics
            String intentLog = (highestScore < 0.80) ? "SMALL_TALK" : "ANSWERED";
            Long successLogId = analyticsService.logChatInteraction(userId, "AI_RAG", userMessage, intentLog, (int) (highestScore * 100));

            return HelpResponseDTO.builder()
                    .responseType("TEXT_REPLY")
                    .botReply(aiResponse.trim())
                    .navigationLink(primaryActionLink)
                    .navigationLabel(primaryActionLabel)
                    .logId(successLogId)
                    .build();

        } catch (Exception e) {
            log.error("[AI-STEP-ERROR] Critical AI Generation Failure", e);
            return HelpResponseDTO.builder()
                    .responseType("TEXT_REPLY")
                    .botReply("I am currently experiencing a cognitive delay. Please try again in a moment.")
                    .build();
        }
    }

}




















