import { fetchEventSource } from "@microsoft/fetch-event-source";
import api from "../config/axiosConfig";
import { resolveConfig } from "../config/EnvironmentConfig";

// Use the resolved config if available, otherwise fallback to the relative path
const getApiBase = () => {
  try {
    return resolveConfig("/HS") || "/HS";
  } catch {
    return "/HS";
  }
};

/**
 * Sends a message via SSE and calls handlers for each event type.
 */
export async function sendMessageSSE(
  { userMessage, currentScreen, token },
  handlers,
  abortController,
) {
  const API_URL = `${getApiBase()}/api/help/chat`;

  await fetchEventSource(API_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({ userMessage, currentScreen }),
    signal: abortController?.signal,
    openWhenHidden: true, // CRITICAL FIX: Keeps stream alive when tab is backgrounded

    onopen(response) {
      if (!response.ok) {
        throw new Error(`Server error: ${response.status}`);
      }
    },

    onmessage(event) {
      switch (event.event) {
        case "start":
          handlers.onStart?.();
          break;

        case "token": {
          const data = JSON.parse(event.data);
          handlers.onToken?.(data.token);
          break;
        }

        case "end": {
          const data = JSON.parse(event.data);
          handlers.onEnd?.(data);
          break;
        }

        case "suggestion": {
          const data = JSON.parse(event.data);
          handlers.onSuggestion?.(data);
          break;
        }

        case "escalation": {
          const data = JSON.parse(event.data);
          handlers.onEscalation?.(data);
          break;
        }

        case "error": {
          const data = JSON.parse(event.data);
          handlers.onError?.(data.botReply || "An error occurred");
          break;
        }

        case "text_reply": {
          const data = JSON.parse(event.data);
          handlers.onTextReply?.(data);
          break;
        }

        default:
          break;
      }
    },

    onerror(err) {
      handlers.onError?.(err.message || "Connection lost");
      throw err; // Throwing stops it from endlessly retrying if the server dies
    },
  });
}

/**
 * Submits user feedback (Thumbs up/down) to the analytics endpoint.
 */
export async function submitFeedback(logId, type) {
  if (!logId) return;
  try {
    const isHelpful = type === "up";
    await api.post(`${getApiBase()}/api/help/feedback`, {
      logId: logId,
      isHelpful: isHelpful,
    });
    console.log(`[Feedback] Successfully submitted feedback for Log ID: ${logId}`);
  } catch (err) {
    console.error("[Feedback] Failed to submit feedback:", err);
  }
}

/**
 * Tracks when a user clicks a Global FAQ suggestion.
 */
export async function trackFaqClick(questionText) {
  if (!questionText) return;
  try {
    await api.post(`${getApiBase()}/api/help/faqs/track`, {
      questionText: questionText,
    });
  } catch (err) {
    console.error("[FAQ Track] Failed to track FAQ:", err);
  }
}

let messageCounter = 0;
export function generateId() {
  return `msg-${Date.now()}-${++messageCounter}`;
}

export function getCurrentScreen() {
  return window.location.pathname;
}

























import { useState, useRef, useEffect, useCallback } from "react";
import Box from "@mui/material/Box";
import Fab from "@mui/material/Fab";
import { useSelector } from "react-redux";

import ChatHeader from "./ChatHeader";
import WelcomeScreen from "./WelcomeScreen";
import ChatBubble from "./ChatBubble";
import TypingIndicator from "./TypingIndicator";
import ChatInput from "./ChatInput";
import FinCoreIcon from "./FinCoreIcon";

import {
  sendMessageSSE,
  generateId,
  getCurrentScreen,
  trackFaqClick,
} from "../lib/chatSSEServices";

const ChatWidget = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isClosing, setIsClosing] = useState(false);
  const [hasLaunched, setHasLaunched] = useState(false);
  const [streamingMessageId, setStreamingMessageId] = useState(null);
  
  const scrollRef = useRef(null);
  const abortRef = useRef(null);
  const token = useSelector((state) => state.auth.token);

  const scrollToBottom = useCallback(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTo({
        top: scrollRef.current.scrollHeight,
        behavior: "smooth",
      });
    }
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [messages, isLoading, streamingMessageId, scrollToBottom]);

  const handleStreamMessage = useCallback(
    async (apiMessage, displayMessage) => {
      const userMsg = {
        id: generateId(),
        role: "user",
        content: displayMessage || apiMessage,
        timestamp: new Date(),
        feedback: null,
      };
      setMessages((prev) => [...prev, userMsg]);
      setIsLoading(true); // Show rich TypingIndicator immediately

      // Abort any existing stream
      if (abortRef.current) abortRef.current.abort();
      abortRef.current = new AbortController();

      const botId = generateId();

      const handlers = {
        onStart: () => {
          // Do nothing here. Keep the <TypingIndicator /> spinning until the first token arrives.
        },

        onToken: (token) => {
          // IDEMPOTENCY: Check if bubble already exists to avoid duplicates on tab switch
          setMessages((prev) => {
            const exists = prev.some((msg) => msg.id === botId);
            
            if (exists) {
              return prev.map((msg) =>
                msg.id === botId ? { ...msg, content: msg.content + token } : msg
              );
            }
            
            // First token arrived! Hide TypingIndicator and create the streaming bubble.
            setIsLoading(false);
            setStreamingMessageId(botId);
            return [
              ...prev,
              {
                id: botId,
                role: "bot",
                content: token,
                timestamp: new Date(),
                feedback: null,
                isStreaming: true,
                response: null,
              },
            ];
          });
        },

        onEnd: (data) => {
          setStreamingMessageId(null);
          setIsLoading(false); // Ensure indicator is off
          
          setMessages((prev) => {
            const exists = prev.some((msg) => msg.id === botId);
            const finalResponse = {
              responseType: "TEXT_REPLY",
              logId: data.logId,
              navigationLink: data.navigationLink,
              navigationLabel: data.navigationLabel,
            };

            // Failsafe: If the LLM sent an empty response (no tokens), create the bubble now
            if (!exists) {
              return [
                ...prev,
                {
                  id: botId, role: "bot", content: "I have processed your request.", 
                  timestamp: new Date(), feedback: null, isStreaming: false, response: finalResponse
                }
              ];
            }

            return prev.map((msg) =>
              msg.id === botId
                ? { ...msg, isStreaming: false, response: finalResponse }
                : msg
            );
          });
        },

        onSuggestion: (data) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
             // Idempotent push
             if (prev.some(m => m.id === botId)) return prev;
             return [...prev, {
                id: botId, role: "bot", content: data.botReply, timestamp: new Date(),
                feedback: null, isStreaming: false, 
                response: { responseType: "SUGGESTION", items: data.items, logId: data.logId }
             }];
          });
        },

        onTextReply: (data) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
             if (prev.some(m => m.id === botId)) return prev;
             return [...prev, {
                id: botId, role: "bot", content: data.botReply, timestamp: new Date(),
                feedback: null, isStreaming: false, 
                response: { responseType: "TEXT_REPLY", logId: data.logId }
             }];
          });
        },

        onEscalation: (data) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
             if (prev.some(m => m.id === botId)) return prev;
             return [...prev, {
                id: botId, role: "bot", content: data.botReply, timestamp: new Date(),
                feedback: null, isStreaming: false,
                response: { responseType: "ESCALATION_OFFER", logId: data.logId }
             }];
          });
        },

        onError: (errorMsg) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
            const existing = prev.some((m) => m.id === botId);
            if (existing) {
              return prev.map((msg) =>
                msg.id === botId
                  ? { ...msg, content: errorMsg || "Sorry, something went wrong.", isStreaming: false }
                  : msg
              );
            }
            return [
              ...prev,
              {
                id: botId, role: "bot", content: errorMsg || "Sorry, something went wrong.",
                timestamp: new Date(), feedback: null, isStreaming: false
              },
            ];
          });
        },
      };

      try {
        await sendMessageSSE(
          { userMessage: apiMessage, currentScreen: getCurrentScreen(), token: token },
          handlers,
          abortRef.current
        );
      } catch {
        // Handled by onError natively
      }
    },
    [token]
  );

  const handleSend = (text) => handleStreamMessage(text);

  const handleQuickAction = (label, slashCommand) => {
    const currentScreen = getCurrentScreen();
    const apiMessage = slashCommand
      ? `${slashCommand} ${currentScreen}`.trim()
      : label;
      
    // If it's a direct FAQ click (no slash command), track it in backend
    if (!slashCommand || slashCommand === "/action faq") {
       trackFaqClick(label);
    }
    
    handleStreamMessage(apiMessage, label);
  };

  const handleFeedback = (messageId, feedback) => {
    setMessages((prev) =>
      prev.map((msg) =>
        msg.id === messageId
          ? { ...msg, feedback: msg.feedback === feedback ? null : feedback }
          : msg
      )
    );
  };

  const handleClearChat = () => {
    if (abortRef.current) abortRef.current.abort();
    setMessages([]);
    setStreamingMessageId(null);
    setIsLoading(false);
  };

  const handleOpen = () => {
    setIsOpen(true);
    if (!hasLaunched) setHasLaunched(true);
  };

  const handleClose = () => {
    setIsClosing(true);
    setTimeout(() => {
      setIsOpen(false);
      setIsClosing(false);
    }, 250);
  };

  if (!isOpen) {
    return (
      <Fab
        onClick={handleOpen}
        className="fab-pulse"
        aria-label="Open FinCore AI Assistant"
        sx={{
          position: "fixed",
          bottom: 24,
          right: 24,
          zIndex: 50,
          width: 60,
          height: 60,
          background: "linear-gradient(135deg, hsla(217, 71%, 45%, 0.78), hsl(217,71%,35%))",
          "&:hover": {
            transform: "scale(1.1)",
            background: "linear-gradient(135deg, hsl(217,71%,50%), hsl(217,71%,40%))",
          },
          transition: "all 0.3s",
          boxShadow: "0 8px 32px hsla(217,71%,35%,0.4)",
        }}
      >
        <FinCoreIcon size={58} glow animated />
      </Fab>
    );
  }

  const showWelcome = messages.length === 0;
  const isFirstLaunch = showWelcome && hasLaunched;

  return (
    <Box
      className={isClosing ? "animate-chat-close" : "animate-chat-open"}
      sx={{
        position: "fixed",
        bottom: 24,
        right: 24,
        zIndex: 50,
        width: 390,
        height: 650,
        display: "flex",
        flexDirection: "column",
        borderRadius: 2,
        overflow: "hidden",
        boxShadow: "0 24px 48px rgba(0,0,0,0.3)",
        border: "1px solid hsla(220, 18%, 22%, 0.2)",
        backgroundColor: "background.paper", // Uses theme background
        backdropFilter: "blur(20px)",
      }}
    >
      <ChatHeader onMinimize={handleClose} onClearChat={handleClearChat} />

      <Box
        ref={scrollRef}
        className="chat-scrollbar"
        sx={{ flex: 1, overflowY: "auto", display: "flex", flexDirection: "column" }}
      >
        {showWelcome ? (
          <WelcomeScreen
            onQuickAction={handleQuickAction}
            showTypewriter={isFirstLaunch}
          />
        ) : (
          <Box sx={{ px: 2, py: 2, flex: 1 }}>
            {messages.map((msg) => (
              <ChatBubble
                key={msg.id}
                message={msg}
                onSuggestionClick={handleSend}
                onFeedback={handleFeedback}
              />
            ))}
            {/* Rich Typing Indicator only shows BEFORE the first token arrives */}
            {isLoading && <TypingIndicator />}
          </Box>
        )}
      </Box>

      <ChatInput
        onSend={handleSend}
        isLoading={isLoading || !!streamingMessageId}
      />
    </Box>
  );
};

export default ChatWidget;




























import { useState } from "react";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import IconButton from "@mui/material/IconButton";
import Button from "@mui/material/Button";
import Fade from "@mui/material/Fade";
import ThumbUpOutlinedIcon from "@mui/icons-material/ThumbUpOutlined";
import ThumbUpIcon from "@mui/icons-material/ThumbUp";
import ThumbDownOutlinedIcon from "@mui/icons-material/ThumbDownOutlined";
import ThumbDownIcon from "@mui/icons-material/ThumbDown";
import OpenInNewIcon from "@mui/icons-material/OpenInNew";
import SearchIcon from "@mui/icons-material/Search";
import WarningAmberIcon from "@mui/icons-material/WarningAmber";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import CheckIcon from "@mui/icons-material/Check";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import FinCoreIcon from "./FinCoreIcon";
import { submitFeedback } from "../lib/chatSSEServices"; // Real API

const formatTime = (date) =>
  date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });

const markdownComponents = {
  p: ({ children }) => (
    <Typography component="p" sx={{ fontSize: "14px", lineHeight: 1.6, mb: 0.5, "&:last-child": { mb: 0 } }}>
      {children}
    </Typography>
  ),
  strong: ({ children }) => (
    <Box component="strong" sx={{ fontWeight: 600, color: "inherit" }}>{children}</Box>
  ),
  ul: ({ children }) => (
    <Box component="ul" sx={{ pl: 2, mb: 0.5, "& li": { fontSize: "14px", lineHeight: 1.6, mb: 0.25 } }}>{children}</Box>
  ),
  ol: ({ children }) => (
    <Box component="ol" sx={{ pl: 2, mb: 0.5, "& li": { fontSize: "14px", lineHeight: 1.6, mb: 0.25 } }}>{children}</Box>
  ),
  li: ({ children }) => <li>{children}</li>,
  a: ({ href, children }) => (
    <Box component="a" href={href} target="_blank" rel="noopener noreferrer" sx={{ color: "primary.main", textDecoration: "underline", "&:hover": { opacity: 0.8 } }}>
      {children}
    </Box>
  ),
  code: ({ children }) => (
    <Box component="code" sx={{ fontSize: "12px", px: 0.5, py: 0.25, borderRadius: 1, bgcolor: "hsla(220,18%,50%,0.15)", fontFamily: "monospace" }}>
      {children}
    </Box>
  ),
};

const ChatBubble = ({ message, onSuggestionClick, onFeedback }) => {
  const isUser = message.role === "user";
  const response = message.response;
  const isStreaming = message.isStreaming;
  const [copied, setCopied] = useState(false);

  const handleFeedback = (type) => {
    if (response?.logId) submitFeedback(response.logId, type); // Call Real API
    onFeedback(message.id, type);
  };

  const handleCopy = () => {
    const text = message.content.replace(/[*#_~`]/g, "");
    navigator.clipboard.writeText(text);
    setCopied(true);
    setTimeout(() => setCopied(false), 1500);
  };

  // ─── User Bubble ────────────────────────────────────────────────────────────
  if (isUser) {
    return (
      <Box className="animate-slide-in-right" sx={{ display: "flex", justifyContent: "flex-end", mb: 2 }}>
        <Box sx={{ maxWidth: "80%" }}>
          <Box
            sx={{
              px: 2,
              py: 1.25,
              borderRadius: "16px 16px 4px 16px",
              background: "linear-gradient(135deg, hsl(217,71%,45%), hsla(217,71%,45%,0.85))",
              color: "#fff",
              fontSize: "14px",
              lineHeight: 1.6,
              boxShadow: "0 2px 8px hsla(217,71%,45%,0.2)",
            }}
          >
            {message.content}
          </Box>
          <Typography sx={{ fontSize: "10px", color: "text.disabled", textAlign: "right", mt: 0.5, mr: 0.5 }}>
            {formatTime(message.timestamp)}
          </Typography>
        </Box>
      </Box>
    );
  }

  // ─── Bot Bubble ─────────────────────────────────────────────────────────────
  const isEscalation = response?.responseType === "ESCALATION_OFFER";
  const showActions = !isStreaming;

  return (
    <Box className="animate-slide-in-left" sx={{ display: "flex", justifyContent: "flex-start", mb: 2, gap: 1.25 }}>
      <Box sx={{ flexShrink: 0, mt: 0.5 }}>
        <FinCoreIcon size={26} variant="mini" animated={isStreaming} />
      </Box>
      <Box sx={{ maxWidth: "82%" }}>
        <Box
          sx={{
            px: 2,
            py: 1.5,
            borderRadius: "16px 16px 16px 4px",
            fontSize: "14px",
            lineHeight: 1.6,
            boxShadow: "0 1px 3px rgba(0,0,0,0.08)",
            ...(isEscalation
              ? { bgcolor: "#fffbeb", color: "#78350f", border: "1px solid hsla(45,93%,47%,0.3)" }
              : { bgcolor: "background.glass", color: "text.primary", border: "1px solid hsla(214,20%,50%,0.2)" }),
          }}
        >
          {/* Content rendering */}
          <ReactMarkdown remarkPlugins={[remarkGfm]} components={markdownComponents}>
            {message.content}
          </ReactMarkdown>

          {/* Streaming cursor (Only when actively receiving tokens) */}
          {isStreaming && (
            <Box
              component="span"
              sx={{
                display: "inline-block",
                width: 3,
                height: 14,
                bgcolor: "primary.main",
                ml: "2px",
                verticalAlign: "text-bottom",
                animation: "icon-glow-pulse 0.8s ease-in-out infinite",
              }}
            />
          )}

          {/* Navigation Button */}
          <Fade in={showActions && !!response?.navigationLink} timeout={400}>
            <Box>
              {showActions && response?.navigationLink && (
                <Button
                  onClick={() => window.open(response.navigationLink, "_blank")}
                  variant="contained"
                  size="small"
                  startIcon={<OpenInNewIcon sx={{ fontSize: 14 }} />}
                  fullWidth
                  sx={{
                    mt: 1.5,
                    borderRadius: 3,
                    textTransform: "none",
                    fontWeight: 500,
                    background: "linear-gradient(135deg, hsl(217,71%,45%), hsla(217,71%,45%,0.85))",
                    boxShadow: "0 2px 8px hsla(217,71%,45%,0.2)",
                    "&:hover": { boxShadow: "0 4px 12px hsla(217,71%,45%,0.3)" },
                  }}
                >
                  {response.navigationLabel}
                </Button>
              )}
            </Box>
          </Fade>

          {/* Suggestion Pills */}
          {showActions && response?.responseType === "SUGGESTION" && response.items && (
            <Box sx={{ mt: 1.5, display: "flex", flexDirection: "column", gap: 0.75 }}>
              {response.items.map((item, idx) => (
                <Button
                  key={idx}
                  onClick={(e) => {
                    e.stopPropagation();
                    onSuggestionClick(item);
                  }}
                  variant="outlined"
                  size="small"
                  fullWidth
                  sx={{
                    justifyContent: "flex-start",
                    borderRadius: 3,
                    textTransform: "none",
                    fontSize: "13px",
                    color: "text.primary",
                    borderColor: "divider",
                    textAlign: "left",
                    "&:hover": { borderColor: "primary.main", bgcolor: "background.default" },
                  }}
                >
                  {item}
                </Button>
              ))}
            </Box>
          )}

          {/* Escalation Handling */}
          {showActions && isEscalation && (
            <Box sx={{ mt: 1.5, display: "flex", gap: 1 }}>
              <Button
                onClick={() => onSuggestionClick("Yes, please create a ticket")}
                variant="contained" size="small"
                startIcon={<WarningAmberIcon sx={{ fontSize: 14 }} />}
                sx={{ borderRadius: 3, textTransform: "none", fontWeight: 500, bgcolor: "error.main", "&:hover": { bgcolor: "error.dark" } }}
              >
                Raise IT Ticket
              </Button>
              <Button
                onClick={() => onSuggestionClick("No, I'll figure it out")}
                variant="outlined" size="small"
                sx={{ borderRadius: 3, textTransform: "none", borderColor: "hsla(45,93%,47%,0.4)", color: "#92400e", "&:hover": { bgcolor: "hsla(45,93%,47%,0.1)" } }}
              >
                No thanks
              </Button>
            </Box>
          )}

          {/* No match manual search */}
          {showActions && response?.responseType === "NO_MATCH" && !response?.navigationLink && (
            <Button
              onClick={() => onSuggestionClick("Search the manual", "/action faq")}
              size="small"
              startIcon={<SearchIcon sx={{ fontSize: 12 }} />}
              sx={{ mt: 1, textTransform: "none", fontSize: "11px", color: "text.secondary", "&:hover": { color: "primary.main" } }}
            >
              Search the manual
            </Button>
          )}
        </Box>

        {/* Action Bar */}
        <Fade in={showActions} timeout={400}>
          <Box sx={{ display: "flex", alignItems: "center", gap: 0.25, mt: 0.75, ml: 1 }}>
            <IconButton
              onClick={() => handleFeedback("up")} size="small"
              sx={{ p: 0.5, color: message.feedback === "up" ? "primary.main" : "text.secondary", bgcolor: message.feedback === "up" ? "hsla(217,71%,45%,0.1)" : "transparent" }}
            >
              {message.feedback === "up" ? <ThumbUpIcon sx={{ fontSize: 14 }} /> : <ThumbUpOutlinedIcon sx={{ fontSize: 14 }} />}
            </IconButton>
            <IconButton
              onClick={() => handleFeedback("down")} size="small"
              sx={{ p: 0.5, color: message.feedback === "down" ? "error.main" : "text.secondary", bgcolor: message.feedback === "down" ? "hsla(0,72%,51%,0.1)" : "transparent" }}
            >
              {message.feedback === "down" ? <ThumbDownIcon sx={{ fontSize: 14 }} /> : <ThumbDownOutlinedIcon sx={{ fontSize: 14 }} />}
            </IconButton>
            <IconButton onClick={handleCopy} size="small" sx={{ p: 0.5, color: "text.secondary" }}>
              {copied ? <CheckIcon sx={{ fontSize: 14, color: "success.main" }} /> : <ContentCopyIcon sx={{ fontSize: 14 }} />}
            </IconButton>
            <Typography sx={{ fontSize: "9px", color: "text.disabled", ml: 0.5 }}>
              {formatTime(message.timestamp)}
            </Typography>
          </Box>
        </Fade>
      </Box>
    </Box>
  );
};

export default ChatBubble;



























import { useState, useEffect } from "react";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import Chip from "@mui/material/Chip";
import ButtonBase from "@mui/material/ButtonBase";
import GridViewIcon from "@mui/icons-material/GridView";
import PeopleOutlineIcon from "@mui/icons-material/PeopleOutline";
import MenuBookIcon from "@mui/icons-material/MenuBook";
import HelpOutlineIcon from "@mui/icons-material/HelpOutline";
import DescriptionOutlinedIcon from "@mui/icons-material/DescriptionOutlined";
import AutoAwesomeIcon from "@mui/icons-material/AutoAwesome";
import BoltIcon from "@mui/icons-material/Bolt";
import PsychologyIcon from "@mui/icons-material/Psychology";
import FinCoreIcon from "./FinCoreIcon";

const quickActions = [
  { label: "CGL Management", icon: GridViewIcon, command: "/action module" },
  { label: "User Management", icon: PeopleOutlineIcon, command: "/action module" },
  { label: "Journal Posting", icon: MenuBookIcon, command: "/action module" },
  { label: "Global FAQs", icon: HelpOutlineIcon, command: "/action faq" },
  { label: "Reports & Analytics", icon: DescriptionOutlinedIcon, command: "/action module" },
];

const capabilities = [
  { icon: PsychologyIcon, label: "RAG-Powered" },
  { icon: BoltIcon, label: "Instant Answers" },
  { icon: AutoAwesomeIcon, label: "Context-Aware" },
];

const GREETING = "Hi there, I am the FinCore Smart Assistant. How can I help you today?";

const WelcomeScreen = ({ onQuickAction, showTypewriter = true }) => {
  const [displayedText, setDisplayedText] = useState(showTypewriter ? "" : GREETING);
  const [isTypingDone, setIsTypingDone] = useState(!showTypewriter);
  const [showActions, setShowActions] = useState(!showTypewriter);

  useEffect(() => {
    if (!showTypewriter) return;
    let i = 0;
    const interval = setInterval(() => {
      i++;
      setDisplayedText(GREETING.slice(0, i));
      if (i >= GREETING.length) {
        clearInterval(interval);
        setIsTypingDone(true);
        setTimeout(() => setShowActions(true), 200);
      }
    }, 28);
    return () => clearInterval(interval);
  }, [showTypewriter]);

  return (
    <Box sx={{ display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", height: "100%", px: 3, py: 4 }}>
      {/* Hero icon */}
      <Box sx={{ position: "relative", mb: 3 }}>
        <Box
          sx={{
            position: "absolute", inset: 0, borderRadius: "50%",
            bgcolor: "hsla(217,71%,45%,0.15)", filter: "blur(24px)",
            transform: "scale(2)", animation: "icon-glow-pulse 3s ease-in-out infinite",
          }}
        />
        <Box sx={{ position: "relative", zIndex: 1 }}>
          <FinCoreIcon size={60} glow animated />
        </Box>
      </Box>

      {/* Greeting */}
      <Box sx={{ minHeight: 72, display: "flex", alignItems: "center", justifyContent: "center", mb: 1.5, maxWidth: 310, position: "relative" }}>
        <Typography
          sx={{
            fontSize: "14px", color: "text.primary", textAlign: "center", lineHeight: 1.7,
            fontWeight: 500, fontFamily: '"Share Tech Mono", monospace', letterSpacing: "0.03em",
          }}
        >
          {displayedText}
          {showTypewriter && !isTypingDone && (
            <Box
              component="span"
              sx={{
                display: "inline-block", width: 8, height: 18, bgcolor: "primary.main", ml: "4px",
                verticalAlign: "middle", animation: "cursor-blink 1s step-end infinite",
                "@keyframes cursor-blink": { "0%, 100%": { opacity: 1 }, "50%": { opacity: 0 } },
              }}
            />
          )}
        </Typography>
      </Box>

      {/* Capability badges */}
      <Box sx={{ display: "flex", gap: 1, mb: 3, transition: "all 0.5s", opacity: isTypingDone ? 1 : 0, transform: isTypingDone ? "translateY(0)" : "translateY(8px)" }}>
        {capabilities.map(({ icon: Icon, label }) => (
          <Chip
            key={label}
            icon={<Icon sx={{ fontSize: 12, color: "primary.main" }} />}
            label={label} size="small"
            sx={{
              height: 22, fontSize: "10px", border: "1px solid", borderColor: "divider",
              color: "text.secondary", backdropFilter: "blur(8px)", "& .MuiChip-icon": { ml: 0.5 },
            }}
          />
        ))}
      </Box>

      {/* Quick actions */}
      <Box sx={{ width: "100%", transition: "all 0.5s", opacity: showActions ? 1 : 0, transform: showActions ? "translateY(0)" : "translateY(16px)", pointerEvents: showActions ? "auto" : "none" }}>
        <Typography sx={{ fontSize: "10px", textTransform: "uppercase", letterSpacing: "0.2em", color: "text.secondary", fontWeight: 600, px: 0.5, mb: 1.25 }}>
          Quick Access
        </Typography>
        <Box sx={{ display: "flex", flexWrap: "wrap", gap: 1 }}>
          {quickActions.map(({ label, icon: Icon, command }) => (
            <ButtonBase
              key={label}
              onClick={() => onQuickAction(label, command)}
              sx={{
                display: "flex", alignItems: "center", gap: 1, px: 1.5, py: 1, borderRadius: 3,
                color: "text.primary", fontSize: "13px", fontWeight: 500,
                border: "1px solid", borderColor: "divider", backdropFilter: "blur(8px)", transition: "all 0.2s",
                "&:hover": {
                  bgcolor: "background.glass", borderColor: "primary.main",
                  boxShadow: "0 4px 12px hsla(217, 71%, 45%, 0.1)", transform: "scale(1.02)",
                },
                "&:active": { transform: "scale(0.98)" },
              }}
            >
              <Icon sx={{ fontSize: 16, opacity: 0.6 }} />
              {label}
            </ButtonBase>
          ))}
        </Box>
      </Box>
    </Box>
  );
};

export default WelcomeScreen;




































