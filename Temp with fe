import { fetchEventSource } from "@microsoft/fetch-event-source";
import api from "../config/axiosConfig";
import { resolveConfig } from "../config/EnvironmentConfig";

// Use the resolved config if available, otherwise fallback to the relative path
const getApiBase = () => {
  try {
    return resolveConfig("/HS") || "/HS";
  } catch {
    return "/HS";
  }
};

/**
 * Sends a message via SSE and calls handlers for each event type.
 */
export async function sendMessageSSE(
  { userMessage, currentScreen, token },
  handlers,
  abortController,
) {
  const API_URL = `${getApiBase()}/api/help/chat`;

  await fetchEventSource(API_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({ userMessage, currentScreen }),
    signal: abortController?.signal,
    openWhenHidden: true, // CRITICAL FIX: Keeps stream alive when tab is backgrounded

    onopen(response) {
      if (!response.ok) {
        throw new Error(`Server error: ${response.status}`);
      }
    },

    onmessage(event) {
      switch (event.event) {
        case "start":
          handlers.onStart?.();
          break;

        case "token": {
          const data = JSON.parse(event.data);
          handlers.onToken?.(data.token);
          break;
        }

        case "end": {
          const data = JSON.parse(event.data);
          handlers.onEnd?.(data);
          break;
        }

        case "suggestion": {
          const data = JSON.parse(event.data);
          handlers.onSuggestion?.(data);
          break;
        }

        case "escalation": {
          const data = JSON.parse(event.data);
          handlers.onEscalation?.(data);
          break;
        }

        case "error": {
          const data = JSON.parse(event.data);
          handlers.onError?.(data.botReply || "An error occurred");
          break;
        }

        case "text_reply": {
          const data = JSON.parse(event.data);
          handlers.onTextReply?.(data);
          break;
        }

        default:
          break;
      }
    },

    onerror(err) {
      handlers.onError?.(err.message || "Connection lost");
      throw err; // Throwing stops it from endlessly retrying if the server dies
    },
  });
}

/**
 * Submits user feedback (Thumbs up/down) to the analytics endpoint.
 */
export async function submitFeedback(logId, type) {
  if (!logId) return;
  try {
    const isHelpful = type === "up";
    await api.post(`${getApiBase()}/api/help/feedback`, {
      logId: logId,
      isHelpful: isHelpful,
    });
    console.log(`[Feedback] Successfully submitted feedback for Log ID: ${logId}`);
  } catch (err) {
    console.error("[Feedback] Failed to submit feedback:", err);
  }
}

/**
 * Tracks when a user clicks a Global FAQ suggestion.
 */
export async function trackFaqClick(questionText) {
  if (!questionText) return;
  try {
    await api.post(`${getApiBase()}/api/help/faqs/track`, {
      questionText: questionText,
    });
  } catch (err) {
    console.error("[FAQ Track] Failed to track FAQ:", err);
  }
}

let messageCounter = 0;
export function generateId() {
  return `msg-${Date.now()}-${++messageCounter}`;
}

export function getCurrentScreen() {
  return window.location.pathname;
}

























import { useState, useRef, useEffect, useCallback } from "react";
import Box from "@mui/material/Box";
import Fab from "@mui/material/Fab";
import { useSelector } from "react-redux";

import ChatHeader from "./ChatHeader";
import WelcomeScreen from "./WelcomeScreen";
import ChatBubble from "./ChatBubble";
import TypingIndicator from "./TypingIndicator";
import ChatInput from "./ChatInput";
import FinCoreIcon from "./FinCoreIcon";

import {
  sendMessageSSE,
  generateId,
  getCurrentScreen,
  trackFaqClick,
} from "../lib/chatSSEServices";

const ChatWidget = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isClosing, setIsClosing] = useState(false);
  const [hasLaunched, setHasLaunched] = useState(false);
  const [streamingMessageId, setStreamingMessageId] = useState(null);
  
  const scrollRef = useRef(null);
  const abortRef = useRef(null);
  const token = useSelector((state) => state.auth.token);

  const scrollToBottom = useCallback(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTo({
        top: scrollRef.current.scrollHeight,
        behavior: "smooth",
      });
    }
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [messages, isLoading, streamingMessageId, scrollToBottom]);

  const handleStreamMessage = useCallback(
    async (apiMessage, displayMessage) => {
      const userMsg = {
        id: generateId(),
        role: "user",
        content: displayMessage || apiMessage,
        timestamp: new Date(),
        feedback: null,
      };
      setMessages((prev) => [...prev, userMsg]);
      setIsLoading(true); // Show rich TypingIndicator immediately

      // Abort any existing stream
      if (abortRef.current) abortRef.current.abort();
      abortRef.current = new AbortController();

      const botId = generateId();

      const handlers = {
        onStart: () => {
          // Do nothing here. Keep the <TypingIndicator /> spinning until the first token arrives.
        },

        onToken: (token) => {
          // IDEMPOTENCY: Check if bubble already exists to avoid duplicates on tab switch
          setMessages((prev) => {
            const exists = prev.some((msg) => msg.id === botId);
            
            if (exists) {
              return prev.map((msg) =>
                msg.id === botId ? { ...msg, content: msg.content + token } : msg
              );
            }
            
            // First token arrived! Hide TypingIndicator and create the streaming bubble.
            setIsLoading(false);
            setStreamingMessageId(botId);
            return [
              ...prev,
              {
                id: botId,
                role: "bot",
                content: token,
                timestamp: new Date(),
                feedback: null,
                isStreaming: true,
                response: null,
              },
            ];
          });
        },

        onEnd: (data) => {
          setStreamingMessageId(null);
          setIsLoading(false); // Ensure indicator is off
          
          setMessages((prev) => {
            const exists = prev.some((msg) => msg.id === botId);
            const finalResponse = {
              responseType: "TEXT_REPLY",
              logId: data.logId,
              navigationLink: data.navigationLink,
              navigationLabel: data.navigationLabel,
            };

            // Failsafe: If the LLM sent an empty response (no tokens), create the bubble now
            if (!exists) {
              return [
                ...prev,
                {
                  id: botId, role: "bot", content: "I have processed your request.", 
                  timestamp: new Date(), feedback: null, isStreaming: false, response: finalResponse
                }
              ];
            }

            return prev.map((msg) =>
              msg.id === botId
                ? { ...msg, isStreaming: false, response: finalResponse }
                : msg
            );
          });
        },

        onSuggestion: (data) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
             // Idempotent push
             if (prev.some(m => m.id === botId)) return prev;
             return [...prev, {
                id: botId, role: "bot", content: data.botReply, timestamp: new Date(),
                feedback: null, isStreaming: false, 
                response: { responseType: "SUGGESTION", items: data.items, logId: data.logId }
             }];
          });
        },

        onTextReply: (data) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
             if (prev.some(m => m.id === botId)) return prev;
             return [...prev, {
                id: botId, role: "bot", content: data.botReply, timestamp: new Date(),
                feedback: null, isStreaming: false, 
                response: { responseType: "TEXT_REPLY", logId: data.logId }
             }];
          });
        },

        onEscalation: (data) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
             if (prev.some(m => m.id === botId)) return prev;
             return [...prev, {
                id: botId, role: "bot", content: data.botReply, timestamp: new Date(),
                feedback: null, isStreaming: false,
                response: { responseType: "ESCALATION_OFFER", logId: data.logId }
             }];
          });
        },

        onError: (errorMsg) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
            const existing = prev.some((m) => m.id === botId);
            if (existing) {
              return prev.map((msg) =>
                msg.id === botId
                  ? { ...msg, content: errorMsg || "Sorry, something went wrong.", isStreaming: false }
                  : msg
              );
            }
            return [
              ...prev,
              {
                id: botId, role: "bot", content: errorMsg || "Sorry, something went wrong.",
                timestamp: new Date(), feedback: null, isStreaming: false
              },
            ];
          });
        },
      };

      try {
        await sendMessageSSE(
          { userMessage: apiMessage, currentScreen: getCurrentScreen(), token: token },
          handlers,
          abortRef.current
        );
      } catch {
        // Handled by onError natively
      }
    },
    [token]
  );

  const handleSend = (text) => handleStreamMessage(text);

  const handleQuickAction = (label, slashCommand) => {
    const currentScreen = getCurrentScreen();
    const apiMessage = slashCommand
      ? `${slashCommand} ${currentScreen}`.trim()
      : label;
      
    // If it's a direct FAQ click (no slash command), track it in backend
    if (!slashCommand || slashCommand === "/action faq") {
       trackFaqClick(label);
    }
    
    handleStreamMessage(apiMessage, label);
  };

  const handleFeedback = (messageId, feedback) => {
    setMessages((prev) =>
      prev.map((msg) =>
        msg.id === messageId
          ? { ...msg, feedback: msg.feedback === feedback ? null : feedback }
          : msg
      )
    );
  };

  const handleClearChat = () => {
    if (abortRef.current) abortRef.current.abort();
    setMessages([]);
    setStreamingMessageId(null);
    setIsLoading(false);
  };

  const handleOpen = () => {
    setIsOpen(true);
    if (!hasLaunched) setHasLaunched(true);
  };

  const handleClose = () => {
    setIsClosing(true);
    setTimeout(() => {
      setIsOpen(false);
      setIsClosing(false);
    }, 250);
  };

  if (!isOpen) {
    return (
      <Fab
        onClick={handleOpen}
        className="fab-pulse"
        aria-label="Open FinCore AI Assistant"
        sx={{
          position: "fixed",
          bottom: 24,
          right: 24,
          zIndex: 50,
          width: 60,
          height: 60,
          background: "linear-gradient(135deg, hsla(217, 71%, 45%, 0.78), hsl(217,71%,35%))",
          "&:hover": {
            transform: "scale(1.1)",
            background: "linear-gradient(135deg, hsl(217,71%,50%), hsl(217,71%,40%))",
          },
          transition: "all 0.3s",
          boxShadow: "0 8px 32px hsla(217,71%,35%,0.4)",
        }}
      >
        <FinCoreIcon size={58} glow animated />
      </Fab>
    );
  }

  const showWelcome = messages.length === 0;
  const isFirstLaunch = showWelcome && hasLaunched;

  return (
    <Box
      className={isClosing ? "animate-chat-close" : "animate-chat-open"}
      sx={{
        position: "fixed",
        bottom: 24,
        right: 24,
        zIndex: 50,
        width: 390,
        height: 650,
        display: "flex",
        flexDirection: "column",
        borderRadius: 2,
        overflow: "hidden",
        boxShadow: "0 24px 48px rgba(0,0,0,0.3)",
        border: "1px solid hsla(220, 18%, 22%, 0.2)",
        backgroundColor: "background.paper", // Uses theme background
        backdropFilter: "blur(20px)",
      }}
    >
      <ChatHeader onMinimize={handleClose} onClearChat={handleClearChat} />

      <Box
        ref={scrollRef}
        className="chat-scrollbar"
        sx={{ flex: 1, overflowY: "auto", display: "flex", flexDirection: "column" }}
      >
        {showWelcome ? (
          <WelcomeScreen
            onQuickAction={handleQuickAction}
            showTypewriter={isFirstLaunch}
          />
        ) : (
          <Box sx={{ px: 2, py: 2, flex: 1 }}>
            {messages.map((msg) => (
              <ChatBubble
                key={msg.id}
                message={msg}
                onSuggestionClick={handleSend}
                onFeedback={handleFeedback}
              />
            ))}
            {/* Rich Typing Indicator only shows BEFORE the first token arrives */}
            {isLoading && <TypingIndicator />}
          </Box>
        )}
      </Box>

      <ChatInput
        onSend={handleSend}
        isLoading={isLoading || !!streamingMessageId}
      />
    </Box>
  );
};

export default ChatWidget;




























import { useState } from "react";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import IconButton from "@mui/material/IconButton";
import Button from "@mui/material/Button";
import Fade from "@mui/material/Fade";
import ThumbUpOutlinedIcon from "@mui/icons-material/ThumbUpOutlined";
import ThumbUpIcon from "@mui/icons-material/ThumbUp";
import ThumbDownOutlinedIcon from "@mui/icons-material/ThumbDownOutlined";
import ThumbDownIcon from "@mui/icons-material/ThumbDown";
import OpenInNewIcon from "@mui/icons-material/OpenInNew";
import SearchIcon from "@mui/icons-material/Search";
import WarningAmberIcon from "@mui/icons-material/WarningAmber";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import CheckIcon from "@mui/icons-material/Check";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import FinCoreIcon from "./FinCoreIcon";
import { submitFeedback } from "../lib/chatSSEServices"; // Real API

const formatTime = (date) =>
  date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });

const markdownComponents = {
  p: ({ children }) => (
    <Typography component="p" sx={{ fontSize: "14px", lineHeight: 1.6, mb: 0.5, "&:last-child": { mb: 0 } }}>
      {children}
    </Typography>
  ),
  strong: ({ children }) => (
    <Box component="strong" sx={{ fontWeight: 600, color: "inherit" }}>{children}</Box>
  ),
  ul: ({ children }) => (
    <Box component="ul" sx={{ pl: 2, mb: 0.5, "& li": { fontSize: "14px", lineHeight: 1.6, mb: 0.25 } }}>{children}</Box>
  ),
  ol: ({ children }) => (
    <Box component="ol" sx={{ pl: 2, mb: 0.5, "& li": { fontSize: "14px", lineHeight: 1.6, mb: 0.25 } }}>{children}</Box>
  ),
  li: ({ children }) => <li>{children}</li>,
  a: ({ href, children }) => (
    <Box component="a" href={href} target="_blank" rel="noopener noreferrer" sx={{ color: "primary.main", textDecoration: "underline", "&:hover": { opacity: 0.8 } }}>
      {children}
    </Box>
  ),
  code: ({ children }) => (
    <Box component="code" sx={{ fontSize: "12px", px: 0.5, py: 0.25, borderRadius: 1, bgcolor: "hsla(220,18%,50%,0.15)", fontFamily: "monospace" }}>
      {children}
    </Box>
  ),
};

const ChatBubble = ({ message, onSuggestionClick, onFeedback }) => {
  const isUser = message.role === "user";
  const response = message.response;
  const isStreaming = message.isStreaming;
  const [copied, setCopied] = useState(false);

  const handleFeedback = (type) => {
    if (response?.logId) submitFeedback(response.logId, type); // Call Real API
    onFeedback(message.id, type);
  };

  const handleCopy = () => {
    const text = message.content.replace(/[*#_~`]/g, "");
    navigator.clipboard.writeText(text);
    setCopied(true);
    setTimeout(() => setCopied(false), 1500);
  };

  // â”€â”€â”€ User Bubble â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (isUser) {
    return (
      <Box className="animate-slide-in-right" sx={{ display: "flex", justifyContent: "flex-end", mb: 2 }}>
        <Box sx={{ maxWidth: "80%" }}>
          <Box
            sx={{
              px: 2,
              py: 1.25,
              borderRadius: "16px 16px 4px 16px",
              background: "linear-gradient(135deg, hsl(217,71%,45%), hsla(217,71%,45%,0.85))",
              color: "#fff",
              fontSize: "14px",
              lineHeight: 1.6,
              boxShadow: "0 2px 8px hsla(217,71%,45%,0.2)",
            }}
          >
            {message.content}
          </Box>
          <Typography sx={{ fontSize: "10px", color: "text.disabled", textAlign: "right", mt: 0.5, mr: 0.5 }}>
            {formatTime(message.timestamp)}
          </Typography>
        </Box>
      </Box>
    );
  }

  // â”€â”€â”€ Bot Bubble â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const isEscalation = response?.responseType === "ESCALATION_OFFER";
  const showActions = !isStreaming;

  return (
    <Box className="animate-slide-in-left" sx={{ display: "flex", justifyContent: "flex-start", mb: 2, gap: 1.25 }}>
      <Box sx={{ flexShrink: 0, mt: 0.5 }}>
        <FinCoreIcon size={26} variant="mini" animated={isStreaming} />
      </Box>
      <Box sx={{ maxWidth: "82%" }}>
        <Box
          sx={{
            px: 2,
            py: 1.5,
            borderRadius: "16px 16px 16px 4px",
            fontSize: "14px",
            lineHeight: 1.6,
            boxShadow: "0 1px 3px rgba(0,0,0,0.08)",
            ...(isEscalation
              ? { bgcolor: "#fffbeb", color: "#78350f", border: "1px solid hsla(45,93%,47%,0.3)" }
              : { bgcolor: "background.glass", color: "text.primary", border: "1px solid hsla(214,20%,50%,0.2)" }),
          }}
        >
          {/* Content rendering */}
          <ReactMarkdown remarkPlugins={[remarkGfm]} components={markdownComponents}>
            {message.content}
          </ReactMarkdown>

          {/* Streaming cursor (Only when actively receiving tokens) */}
          {isStreaming && (
            <Box
              component="span"
              sx={{
                display: "inline-block",
                width: 3,
                height: 14,
                bgcolor: "primary.main",
                ml: "2px",
                verticalAlign: "text-bottom",
                animation: "icon-glow-pulse 0.8s ease-in-out infinite",
              }}
            />
          )}

          {/* Navigation Button */}
          <Fade in={showActions && !!response?.navigationLink} timeout={400}>
            <Box>
              {showActions && response?.navigationLink && (
                <Button
                  onClick={() => window.open(response.navigationLink, "_blank")}
                  variant="contained"
                  size="small"
                  startIcon={<OpenInNewIcon sx={{ fontSize: 14 }} />}
                  fullWidth
                  sx={{
                    mt: 1.5,
                    borderRadius: 3,
                    textTransform: "none",
                    fontWeight: 500,
                    background: "linear-gradient(135deg, hsl(217,71%,45%), hsla(217,71%,45%,0.85))",
                    boxShadow: "0 2px 8px hsla(217,71%,45%,0.2)",
                    "&:hover": { boxShadow: "0 4px 12px hsla(217,71%,45%,0.3)" },
                  }}
                >
                  {response.navigationLabel}
                </Button>
              )}
            </Box>
          </Fade>

          {/* Suggestion Pills */}
          {showActions && response?.responseType === "SUGGESTION" && response.items && (
            <Box sx={{ mt: 1.5, display: "flex", flexDirection: "column", gap: 0.75 }}>
              {response.items.map((item, idx) => (
                <Button
                  key={idx}
                  onClick={(e) => {
                    e.stopPropagation();
                    onSuggestionClick(item);
                  }}
                  variant="outlined"
                  size="small"
                  fullWidth
                  sx={{
                    justifyContent: "flex-start",
                    borderRadius: 3,
                    textTransform: "none",
                    fontSize: "13px",
                    color: "text.primary",
                    borderColor: "divider",
                    textAlign: "left",
                    "&:hover": { borderColor: "primary.main", bgcolor: "background.default" },
                  }}
                >
                  {item}
                </Button>
              ))}
            </Box>
          )}

          {/* Escalation Handling */}
          {showActions && isEscalation && (
            <Box sx={{ mt: 1.5, display: "flex", gap: 1 }}>
              <Button
                onClick={() => onSuggestionClick("Yes, please create a ticket")}
                variant="contained" size="small"
                startIcon={<WarningAmberIcon sx={{ fontSize: 14 }} />}
                sx={{ borderRadius: 3, textTransform: "none", fontWeight: 500, bgcolor: "error.main", "&:hover": { bgcolor: "error.dark" } }}
              >
                Raise IT Ticket
              </Button>
              <Button
                onClick={() => onSuggestionClick("No, I'll figure it out")}
                variant="outlined" size="small"
                sx={{ borderRadius: 3, textTransform: "none", borderColor: "hsla(45,93%,47%,0.4)", color: "#92400e", "&:hover": { bgcolor: "hsla(45,93%,47%,0.1)" } }}
              >
                No thanks
              </Button>
            </Box>
          )}

          {/* No match manual search */}
          {showActions && response?.responseType === "NO_MATCH" && !response?.navigationLink && (
            <Button
              onClick={() => onSuggestionClick("Search the manual", "/action faq")}
              size="small"
              startIcon={<SearchIcon sx={{ fontSize: 12 }} />}
              sx={{ mt: 1, textTransform: "none", fontSize: "11px", color: "text.secondary", "&:hover": { color: "primary.main" } }}
            >
              Search the manual
            </Button>
          )}
        </Box>

        {/* Action Bar */}
        <Fade in={showActions} timeout={400}>
          <Box sx={{ display: "flex", alignItems: "center", gap: 0.25, mt: 0.75, ml: 1 }}>
            <IconButton
              onClick={() => handleFeedback("up")} size="small"
              sx={{ p: 0.5, color: message.feedback === "up" ? "primary.main" : "text.secondary", bgcolor: message.feedback === "up" ? "hsla(217,71%,45%,0.1)" : "transparent" }}
            >
              {message.feedback === "up" ? <ThumbUpIcon sx={{ fontSize: 14 }} /> : <ThumbUpOutlinedIcon sx={{ fontSize: 14 }} />}
            </IconButton>
            <IconButton
              onClick={() => handleFeedback("down")} size="small"
              sx={{ p: 0.5, color: message.feedback === "down" ? "error.main" : "text.secondary", bgcolor: message.feedback === "down" ? "hsla(0,72%,51%,0.1)" : "transparent" }}
            >
              {message.feedback === "down" ? <ThumbDownIcon sx={{ fontSize: 14 }} /> : <ThumbDownOutlinedIcon sx={{ fontSize: 14 }} />}
            </IconButton>
            <IconButton onClick={handleCopy} size="small" sx={{ p: 0.5, color: "text.secondary" }}>
              {copied ? <CheckIcon sx={{ fontSize: 14, color: "success.main" }} /> : <ContentCopyIcon sx={{ fontSize: 14 }} />}
            </IconButton>
            <Typography sx={{ fontSize: "9px", color: "text.disabled", ml: 0.5 }}>
              {formatTime(message.timestamp)}
            </Typography>
          </Box>
        </Fade>
      </Box>
    </Box>
  );
};

export default ChatBubble;



























import { useState, useEffect } from "react";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import Chip from "@mui/material/Chip";
import ButtonBase from "@mui/material/ButtonBase";
import GridViewIcon from "@mui/icons-material/GridView";
import PeopleOutlineIcon from "@mui/icons-material/PeopleOutline";
import MenuBookIcon from "@mui/icons-material/MenuBook";
import HelpOutlineIcon from "@mui/icons-material/HelpOutline";
import DescriptionOutlinedIcon from "@mui/icons-material/DescriptionOutlined";
import AutoAwesomeIcon from "@mui/icons-material/AutoAwesome";
import BoltIcon from "@mui/icons-material/Bolt";
import PsychologyIcon from "@mui/icons-material/Psychology";
import FinCoreIcon from "./FinCoreIcon";

const quickActions = [
  { label: "CGL Management", icon: GridViewIcon, command: "/action module" },
  { label: "User Management", icon: PeopleOutlineIcon, command: "/action module" },
  { label: "Journal Posting", icon: MenuBookIcon, command: "/action module" },
  { label: "Global FAQs", icon: HelpOutlineIcon, command: "/action faq" },
  { label: "Reports & Analytics", icon: DescriptionOutlinedIcon, command: "/action module" },
];

const capabilities = [
  { icon: PsychologyIcon, label: "RAG-Powered" },
  { icon: BoltIcon, label: "Instant Answers" },
  { icon: AutoAwesomeIcon, label: "Context-Aware" },
];

const GREETING = "Hi there, I am the FinCore Smart Assistant. How can I help you today?";

const WelcomeScreen = ({ onQuickAction, showTypewriter = true }) => {
  const [displayedText, setDisplayedText] = useState(showTypewriter ? "" : GREETING);
  const [isTypingDone, setIsTypingDone] = useState(!showTypewriter);
  const [showActions, setShowActions] = useState(!showTypewriter);

  useEffect(() => {
    if (!showTypewriter) return;
    let i = 0;
    const interval = setInterval(() => {
      i++;
      setDisplayedText(GREETING.slice(0, i));
      if (i >= GREETING.length) {
        clearInterval(interval);
        setIsTypingDone(true);
        setTimeout(() => setShowActions(true), 200);
      }
    }, 28);
    return () => clearInterval(interval);
  }, [showTypewriter]);

  return (
    <Box sx={{ display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", height: "100%", px: 3, py: 4 }}>
      {/* Hero icon */}
      <Box sx={{ position: "relative", mb: 3 }}>
        <Box
          sx={{
            position: "absolute", inset: 0, borderRadius: "50%",
            bgcolor: "hsla(217,71%,45%,0.15)", filter: "blur(24px)",
            transform: "scale(2)", animation: "icon-glow-pulse 3s ease-in-out infinite",
          }}
        />
        <Box sx={{ position: "relative", zIndex: 1 }}>
          <FinCoreIcon size={60} glow animated />
        </Box>
      </Box>

      {/* Greeting */}
      <Box sx={{ minHeight: 72, display: "flex", alignItems: "center", justifyContent: "center", mb: 1.5, maxWidth: 310, position: "relative" }}>
        <Typography
          sx={{
            fontSize: "14px", color: "text.primary", textAlign: "center", lineHeight: 1.7,
            fontWeight: 500, fontFamily: '"Share Tech Mono", monospace', letterSpacing: "0.03em",
          }}
        >
          {displayedText}
          {showTypewriter && !isTypingDone && (
            <Box
              component="span"
              sx={{
                display: "inline-block", width: 8, height: 18, bgcolor: "primary.main", ml: "4px",
                verticalAlign: "middle", animation: "cursor-blink 1s step-end infinite",
                "@keyframes cursor-blink": { "0%, 100%": { opacity: 1 }, "50%": { opacity: 0 } },
              }}
            />
          )}
        </Typography>
      </Box>

      {/* Capability badges */}
      <Box sx={{ display: "flex", gap: 1, mb: 3, transition: "all 0.5s", opacity: isTypingDone ? 1 : 0, transform: isTypingDone ? "translateY(0)" : "translateY(8px)" }}>
        {capabilities.map(({ icon: Icon, label }) => (
          <Chip
            key={label}
            icon={<Icon sx={{ fontSize: 12, color: "primary.main" }} />}
            label={label} size="small"
            sx={{
              height: 22, fontSize: "10px", border: "1px solid", borderColor: "divider",
              color: "text.secondary", backdropFilter: "blur(8px)", "& .MuiChip-icon": { ml: 0.5 },
            }}
          />
        ))}
      </Box>

      {/* Quick actions */}
      <Box sx={{ width: "100%", transition: "all 0.5s", opacity: showActions ? 1 : 0, transform: showActions ? "translateY(0)" : "translateY(16px)", pointerEvents: showActions ? "auto" : "none" }}>
        <Typography sx={{ fontSize: "10px", textTransform: "uppercase", letterSpacing: "0.2em", color: "text.secondary", fontWeight: 600, px: 0.5, mb: 1.25 }}>
          Quick Access
        </Typography>
        <Box sx={{ display: "flex", flexWrap: "wrap", gap: 1 }}>
          {quickActions.map(({ label, icon: Icon, command }) => (
            <ButtonBase
              key={label}
              onClick={() => onQuickAction(label, command)}
              sx={{
                display: "flex", alignItems: "center", gap: 1, px: 1.5, py: 1, borderRadius: 3,
                color: "text.primary", fontSize: "13px", fontWeight: 500,
                border: "1px solid", borderColor: "divider", backdropFilter: "blur(8px)", transition: "all 0.2s",
                "&:hover": {
                  bgcolor: "background.glass", borderColor: "primary.main",
                  boxShadow: "0 4px 12px hsla(217, 71%, 45%, 0.1)", transform: "scale(1.02)",
                },
                "&:active": { transform: "scale(0.98)" },
              }}
            >
              <Icon sx={{ fontSize: 16, opacity: 0.6 }} />
              {label}
            </ButtonBase>
          ))}
        </Box>
      </Box>
    </Box>
  );
};

export default WelcomeScreen;










































-----------------------------------------------------------------

import { GlobalStyles, useTheme } from "@mui/material";
import { alpha } from "@mui/material/styles";

/**
 * Injects the required CSS animations locally for the Chatbot.
 * This ensures animations work perfectly without touching your global AppTheme.
 */
const ChatAnimations = () => {
  const theme = useTheme();
  
  // Safely grab the primary color to use in our CSS animations
  const primaryColor = theme.palette.primary.main;
  const pulseShadow = alpha(primaryColor, 0.4);

  return (
    <GlobalStyles
      styles={`
        /* Chat Widget Entrance/Exit */
        @keyframes chat-slide-up {
          from { opacity: 0; transform: translateY(20px) scale(0.95); }
          to { opacity: 1; transform: translateY(0) scale(1); }
        }
        @keyframes chat-slide-down {
          from { opacity: 1; transform: translateY(0) scale(1); }
          to { opacity: 0; transform: translateY(16px) scale(0.96); }
        }
        .animate-chat-open { animation: chat-slide-up 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
        .animate-chat-close { animation: chat-slide-down 0.25s cubic-bezier(0.4, 0, 1, 1) forwards; }

        /* Bubble Slide-ins */
        @keyframes slide-in-left {
          from { opacity: 0; transform: translateX(-12px); }
          to { opacity: 1; transform: translateX(0); }
        }
        @keyframes slide-in-right {
          from { opacity: 0; transform: translateX(12px); }
          to { opacity: 1; transform: translateX(0); }
        }
        .animate-slide-in-left { animation: slide-in-left 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
        .animate-slide-in-right { animation: slide-in-right 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards; }

        /* FAB Pulse Effect */
        @keyframes fab-pulse {
          0%, 100% { box-shadow: 0 0 0 0 ${pulseShadow}; }
          50% { box-shadow: 0 0 0 14px rgba(0,0,0,0); }
        }
        .fab-pulse { animation: fab-pulse 2.5s ease-in-out infinite; }

        /* Icon Glow & Cursor */
        @keyframes icon-glow-pulse {
          0%, 100% { filter: drop-shadow(0 0 4px ${primaryColor}); }
          50% { filter: drop-shadow(0 0 12px ${primaryColor}); }
        }
        @keyframes cursor-blink {
          0%, 100% { opacity: 1; }
          50% { opacity: 0; }
        }

        /* Typing Dots Bounce */
        @keyframes typing-bounce {
          0%, 44%, 100% { transform: translateY(0); opacity: 0.4; }
          22% { transform: translateY(-6px); opacity: 1; }
        }

        /* Custom Scrollbar for Chat */
        .chat-scrollbar::-webkit-scrollbar { width: 6px; }
        .chat-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .chat-scrollbar::-webkit-scrollbar-thumb { 
          background: ${alpha(theme.palette.text.primary, 0.2)}; 
          border-radius: 3px; 
        }
        .chat-scrollbar::-webkit-scrollbar-thumb:hover { 
          background: ${alpha(theme.palette.text.primary, 0.4)}; 
        }
      `}
    />
  );
};

export default ChatAnimations;


















import { useState, useRef, useEffect, useCallback } from "react";
import { Box, Fab, IconButton, Tooltip, Button, Fade } from "@mui/material";
import KeyboardArrowDownIcon from "@mui/icons-material/KeyboardArrowDown";
import StopCircleIcon from "@mui/icons-material/StopCircle";
import { useSelector } from "react-redux";

import ChatHeader from "./ChatHeader";
import WelcomeScreen from "./WelcomeScreen";
import ChatBubble from "./ChatBubble";
import TypingIndicator from "./TypingIndicator";
import ChatInput from "./ChatInput";
import FinCoreIcon from "./FinCoreIcon";
import ChatAnimations from "./ChatAnimations"; // <-- Injects animations

import {
  sendMessageSSE,
  generateId,
  getCurrentScreen,
  trackFaqClick,
} from "../lib/chatSSEServices";

const ChatWidget = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isClosing, setIsClosing] = useState(false);
  const [hasLaunched, setHasLaunched] = useState(false);
  const [streamingMessageId, setStreamingMessageId] = useState(null);
  const [isScrolledUp, setIsScrolledUp] = useState(false);
  
  const scrollRef = useRef(null);
  const abortRef = useRef(null);
  const token = useSelector((state) => state.auth.token);

  // â”€â”€â”€ Smart Auto-Scroll Logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const handleScroll = () => {
    if (!scrollRef.current) return;
    const { scrollTop, scrollHeight, clientHeight } = scrollRef.current;
    // If we are more than 60px from the bottom, user is scrolling up to read history
    const isUp = scrollHeight - scrollTop - clientHeight > 60;
    setIsScrolledUp(isUp);
  };

  const scrollToBottom = useCallback((force = false) => {
    if (scrollRef.current) {
      // Only auto-scroll if we are already at the bottom, OR if forced (e.g. user sends a message)
      if (force || !isScrolledUp) {
        scrollRef.current.scrollTo({
          top: scrollRef.current.scrollHeight,
          behavior: "smooth",
        });
      }
    }
  }, [isScrolledUp]);

  useEffect(() => {
    scrollToBottom(false);
  }, [messages, isLoading, streamingMessageId, scrollToBottom]);

  // â”€â”€â”€ Stream Handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const handleStreamMessage = useCallback(
    async (apiMessage, displayMessage) => {
      const userMsg = {
        id: generateId(),
        role: "user",
        content: displayMessage || apiMessage,
        timestamp: new Date(),
        feedback: null,
      };
      
      setMessages((prev) => [...prev, userMsg]);
      setIsLoading(true);
      scrollToBottom(true); // Force scroll down on new user message

      if (abortRef.current) abortRef.current.abort();
      abortRef.current = new AbortController();

      const botId = generateId();

      const handlers = {
        onStart: () => {}, // Keep UI showing Thinking Indicator
        
        onToken: (token) => {
          setMessages((prev) => {
            const exists = prev.some((msg) => msg.id === botId);
            if (exists) {
              return prev.map((msg) =>
                msg.id === botId ? { ...msg, content: msg.content + token } : msg
              );
            }
            setIsLoading(false);
            setStreamingMessageId(botId);
            return [
              ...prev,
              {
                id: botId, role: "bot", content: token, timestamp: new Date(),
                feedback: null, isStreaming: true, response: null,
              },
            ];
          });
        },

        onEnd: (data) => {
          setStreamingMessageId(null);
          setIsLoading(false);
          setMessages((prev) => {
            const exists = prev.some((msg) => msg.id === botId);
            const finalResponse = {
              responseType: "TEXT_REPLY", logId: data.logId,
              navigationLink: data.navigationLink, navigationLabel: data.navigationLabel,
            };
            if (!exists) {
              return [...prev, { id: botId, role: "bot", content: "I have processed your request.", timestamp: new Date(), feedback: null, isStreaming: false, response: finalResponse }];
            }
            return prev.map((msg) => msg.id === botId ? { ...msg, isStreaming: false, response: finalResponse } : msg);
          });
        },

        onSuggestion: (data) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
             if (prev.some(m => m.id === botId)) return prev;
             return [...prev, { id: botId, role: "bot", content: data.botReply, timestamp: new Date(), feedback: null, isStreaming: false, response: { responseType: "SUGGESTION", items: data.items, logId: data.logId } }];
          });
        },

        onTextReply: (data) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
             if (prev.some(m => m.id === botId)) return prev;
             return [...prev, { id: botId, role: "bot", content: data.botReply, timestamp: new Date(), feedback: null, isStreaming: false, response: { responseType: "TEXT_REPLY", logId: data.logId } }];
          });
        },

        onEscalation: (data) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
             if (prev.some(m => m.id === botId)) return prev;
             return [...prev, { id: botId, role: "bot", content: data.botReply, timestamp: new Date(), feedback: null, isStreaming: false, response: { responseType: "ESCALATION_OFFER", logId: data.logId } }];
          });
        },

        onError: (errorMsg) => {
          setIsLoading(false);
          setStreamingMessageId(null);
          setMessages((prev) => {
            const existing = prev.some((m) => m.id === botId);
            if (existing) {
              return prev.map((msg) => msg.id === botId ? { ...msg, content: errorMsg || "Stream interrupted.", isStreaming: false } : msg);
            }
            return [...prev, { id: botId, role: "bot", content: errorMsg || "Sorry, something went wrong.", timestamp: new Date(), feedback: null, isStreaming: false }];
          });
        },
      };

      try {
        await sendMessageSSE(
          { userMessage: apiMessage, currentScreen: getCurrentScreen(), token: token },
          handlers,
          abortRef.current
        );
      } catch {}
    },
    [token, scrollToBottom]
  );

  const handleSend = (text) => handleStreamMessage(text);

  const handleQuickAction = (label, slashCommand) => {
    const currentScreen = getCurrentScreen();
    const apiMessage = slashCommand ? `${slashCommand} ${currentScreen}`.trim() : label;
    if (!slashCommand || slashCommand === "/action faq") trackFaqClick(label);
    handleStreamMessage(apiMessage, label);
  };

  const handleFeedback = (messageId, feedback) => {
    setMessages((prev) =>
      prev.map((msg) => msg.id === messageId ? { ...msg, feedback: msg.feedback === feedback ? null : feedback } : msg)
    );
  };

  const handleStopGeneration = () => {
    if (abortRef.current) abortRef.current.abort();
    setStreamingMessageId(null);
    setIsLoading(false);
  };

  const handleClearChat = () => {
    handleStopGeneration();
    setMessages([]);
  };

  const handleOpen = () => {
    setIsOpen(true);
    if (!hasLaunched) setHasLaunched(true);
  };

  const handleClose = () => {
    setIsClosing(true);
    setTimeout(() => {
      setIsOpen(false);
      setIsClosing(false);
    }, 250);
  };

  if (!isOpen) {
    return (
      <>
        <ChatAnimations />
        <Fab
          onClick={handleOpen}
          className="fab-pulse"
          aria-label="Open FinCore AI Assistant"
          color="primary"
          sx={{
            position: "fixed", bottom: 24, right: 24, zIndex: 50,
            width: 60, height: 60, transition: "all 0.3s",
            "&:hover": { transform: "scale(1.1)" },
          }}
        >
          <FinCoreIcon size={58} glow animated />
        </Fab>
      </>
    );
  }

  const showWelcome = messages.length === 0;

  return (
    <>
      <ChatAnimations />
      <Box
        className={isClosing ? "animate-chat-close" : "animate-chat-open"}
        sx={{
          position: "fixed", bottom: 24, right: 24, zIndex: 50,
          width: 390, height: 650, display: "flex", flexDirection: "column",
          borderRadius: 3, overflow: "hidden",
          boxShadow: (theme) => theme.palette.baseShadow || "0 24px 48px rgba(0,0,0,0.3)",
          border: "1px solid", borderColor: "divider",
          backgroundColor: "background.paper", // Follows your theme
          backdropFilter: "blur(20px)",
        }}
      >
        <ChatHeader onMinimize={handleClose} onClearChat={handleClearChat} />

        <Box
          ref={scrollRef}
          onScroll={handleScroll}
          className="chat-scrollbar"
          sx={{ flex: 1, overflowY: "auto", display: "flex", flexDirection: "column", position: "relative" }}
        >
          {showWelcome ? (
            <WelcomeScreen
              onQuickAction={handleQuickAction}
              showTypewriter={hasLaunched}
            />
          ) : (
            <Box sx={{ px: 2, py: 2, flex: 1, pb: 8 }}>
              {messages.map((msg) => (
                <ChatBubble
                  key={msg.id} message={msg}
                  onSuggestionClick={handleSend} onFeedback={handleFeedback}
                />
              ))}
              {isLoading && <TypingIndicator />}
            </Box>
          )}

          {/* Floating Actions inside Scroll Area */}
          <Box sx={{ position: "sticky", bottom: 10, left: 0, right: 0, display: "flex", justifyContent: "center", gap: 1, pointerEvents: "none" }}>
            {/* Stop Generation Button */}
            <Fade in={!!streamingMessageId || isLoading}>
              <Button
                variant="contained" size="small" color="error"
                startIcon={<StopCircleIcon />}
                onClick={handleStopGeneration}
                sx={{ pointerEvents: "auto", borderRadius: 5, textTransform: "none", boxShadow: 3 }}
              >
                Stop generating
              </Button>
            </Fade>

            {/* Scroll to Bottom Button */}
            <Fade in={isScrolledUp}>
              <Tooltip title="Scroll to bottom" placement="top">
                <Fab
                  size="small" color="primary"
                  onClick={() => scrollToBottom(true)}
                  sx={{ pointerEvents: "auto", width: 36, height: 36, minHeight: 36, opacity: 0.9 }}
                >
                  <KeyboardArrowDownIcon />
                </Fab>
              </Tooltip>
            </Fade>
          </Box>
        </Box>

        <ChatInput
          onSend={handleSend}
          isLoading={isLoading || !!streamingMessageId}
        />
      </Box>
    </>
  );
};

export default ChatWidget;

























import { useState, useEffect } from "react";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import FinCoreIcon from "./FinCoreIcon";

const thinkingStages = [
  { text: "Thinking", icon: "ðŸ§ " },
  { text: "Searching knowledge base", icon: "ðŸ”" },
  { text: "Analyzing results", icon: "âš¡" },
  { text: "Generating response", icon: "âœ¨" },
];

const TypingIndicator = () => {
  const [stageIdx, setStageIdx] = useState(0);
  const [displayedText, setDisplayedText] = useState("");
  const [isTyping, setIsTyping] = useState(true);

  // Cycle through stages
  useEffect(() => {
    const interval = setInterval(() => {
      setStageIdx((prev) => (prev + 1) % thinkingStages.length);
      setDisplayedText("");
      setIsTyping(true);
    }, 2000);
    return () => clearInterval(interval);
  }, []);

  // Typewriter effect for each stage text
  useEffect(() => {
    const text = thinkingStages[stageIdx].text;
    if (!isTyping) return;
    let i = 0;
    const interval = setInterval(() => {
      i++;
      setDisplayedText(text.slice(0, i));
      if (i >= text.length) {
        clearInterval(interval);
        setIsTyping(false);
      }
    }, 40);
    return () => clearInterval(interval);
  }, [stageIdx, isTyping]);

  const stage = thinkingStages[stageIdx];

  return (
    <Box
      className="animate-slide-in-left"
      sx={{ display: "flex", justifyContent: "flex-start", mb: 1.5, gap: 1.25 }}
    >
      <Box sx={{ flexShrink: 0, mt: 0.5 }}>
        <div className="thinking-icon-wrapper">
          <FinCoreIcon size={28} variant="mini" animated active />
        </div>
      </Box>

      <Box
        sx={{
          px: 2,
          py: 1.5,
          borderRadius: "16px 16px 16px 4px",
          bgcolor: "background.glass", // Adapts to theme
          boxShadow: 1,
          border: "1px solid",
          borderColor: "divider",
          backdropFilter: "blur(8px)",
          minWidth: 180,
        }}
      >
        {/* Stage text with typewriter */}
        <Box sx={{ display: "flex", alignItems: "center", gap: 1, mb: 0.75 }}>
          <span style={{ fontSize: 14 }}>{stage.icon}</span>
          <Typography
            sx={{
              fontSize: "12px",
              color: "text.secondary",
              fontWeight: 600,
              fontFamily: "monospace",
            }}
          >
            {displayedText}
            {isTyping && (
              <Box
                component="span"
                sx={{
                  display: "inline-block",
                  width: 2,
                  height: 12,
                  bgcolor: "primary.main",
                  ml: "2px",
                  verticalAlign: "middle",
                  animation: "cursor-blink 0.8s step-end infinite",
                }}
              />
            )}
          </Typography>
        </Box>

        {/* Bouncing dots - utilizing injected global keyframes */}
        <Box sx={{ display: "flex", alignItems: "center", gap: 0.75 }}>
          {[0, 200, 400].map((delay, i) => (
            <Box
              key={i}
              sx={{
                width: 6,
                height: 6,
                borderRadius: "50%",
                bgcolor: "primary.main",
                animation: `typing-bounce 1.4s ease-in-out infinite`,
                animationDelay: `${delay}ms`,
              }}
            />
          ))}
        </Box>
      </Box>
    </Box>
  );
};

export default TypingIndicator;





























import { useState, useRef, useEffect } from "react";
import { Box, IconButton, CircularProgress, Typography, useTheme, alpha } from "@mui/material";
import SendIcon from "@mui/icons-material/Send";

const MAX_CHARS = 500;

const ChatInput = ({ onSend, isLoading }) => {
  const [value, setValue] = useState("");
  const textareaRef = useRef(null);
  const theme = useTheme();

  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = "auto";
      textareaRef.current.style.height =
        Math.min(textareaRef.current.scrollHeight, 120) + "px";
    }
  }, [value]);

  const handleSend = () => {
    const trimmed = value.trim();
    if (!trimmed || isLoading || trimmed.length > MAX_CHARS) return;
    onSend(trimmed);
    setValue("");
    if (textareaRef.current) textareaRef.current.style.height = "auto";
  };

  const handleKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const charCount = value.length;
  const isNearLimit = charCount > MAX_CHARS * 0.85;
  const isOverLimit = charCount > MAX_CHARS;

  return (
    <Box
      sx={{
        borderTop: "1px solid",
        borderColor: "divider",
        backgroundColor: "background.paper",
        px: 1.5,
        py: 1.5,
      }}
    >
      <Box
        sx={{
          display: "flex",
          alignItems: "flex-end",
          gap: 1,
          bgcolor: theme.palette.mode === 'dark' ? alpha(theme.palette.background.default, 0.5) : alpha(theme.palette.primary.light, 0.1),
          borderRadius: 2,
          px: 2,
          py: 1.25,
          border: "1px solid",
          borderColor: "divider",
          transition: "all 0.3s",
          "&:focus-within": { borderColor: "primary.main" },
        }}
      >
        <textarea
          ref={textareaRef}
          value={value}
          onChange={(e) => setValue(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="Ask me anything..."
          rows={1}
          style={{
            flex: 1,
            background: "transparent",
            color: theme.palette.text.primary,
            fontSize: "14px",
            resize: "none",
            outline: "none",
            border: "none",
            maxHeight: 100,
            lineHeight: 1.6,
            fontFamily: "inherit",
          }}
        />
        <IconButton
          onClick={handleSend}
          disabled={!value.trim() || isLoading || isOverLimit}
          size="small"
          color="primary"
          sx={{
            width: 32,
            height: 32,
            borderRadius: 2,
            bgcolor: "primary.main",
            color: "primary.contrastText",
            "&:disabled": { opacity: 0.5, bgcolor: "divider" },
            "&:hover": {
              bgcolor: "primary.dark",
              boxShadow: `0 4px 12px ${alpha(theme.palette.primary.main, 0.4)}`,
            },
            transition: "all 0.2s",
          }}
        >
          {isLoading ? (
            <CircularProgress size={16} color="inherit" />
          ) : (
            <SendIcon sx={{ fontSize: 16 }} />
          )}
        </IconButton>
      </Box>

      <Box sx={{ display: "flex", alignItems: "center", justifyContent: "space-between", mt: 1, px: 0.5 }}>
        <Typography variant="caption" sx={{ fontSize: "10.5px", color: "text.secondary", letterSpacing: "0.02em" }}>
          Warning: AI can make mistakes. Verify important info.
        </Typography>
        {isNearLimit && (
          <Typography variant="caption" sx={{ fontSize: "10px", fontWeight: 500, color: isOverLimit ? "error.main" : "text.secondary" }}>
            {charCount}/{MAX_CHARS}
          </Typography>
        )}
      </Box>
    </Box>
  );
};

export default ChatInput;



























import Box from "@mui/material/Box";
import IconButton from "@mui/material/IconButton";
import Typography from "@mui/material/Typography";
import Stack from "@mui/material/Stack";
import Chip from "@mui/material/Chip";
import RemoveIcon from "@mui/icons-material/Remove";
import AddCommentOutlinedIcon from "@mui/icons-material/AddCommentOutlined";
import AutoAwesomeIcon from "@mui/icons-material/AutoAwesome";
import FinCoreIcon from "./FinCoreIcon";

const ChatHeader = ({ onMinimize, onClearChat }) => {
  return (
    <Stack
      direction="row"
      alignItems="center"
      justifyContent="space-between"
      sx={{
        px: 2,
        py: 1.5,
        borderBottom: "1px solid",
        borderColor: "divider",
        bgcolor: "background.paper", // Inherit Theme
      }}
    >
      <Stack direction="row" alignItems="center" spacing={1.5}>
        <FinCoreIcon size={34} glow animated />
        <Box>
          <Stack direction="row" alignItems="center" spacing={1}>
            <Typography
              variant="subtitle2"
              sx={{ color: "text.primary", fontWeight: 600, letterSpacing: "-0.01em" }}
            >
              FinCore AI
            </Typography>
            <Chip
              icon={<AutoAwesomeIcon sx={{ fontSize: 10 }} />}
              label="Beta" size="small"
              sx={{
                height: 18, fontSize: "9px", fontWeight: 700, letterSpacing: "0.05em",
                textTransform: "uppercase", bgcolor: "primary.main", color: "primary.contrastText",
                "& .MuiChip-icon": { fontSize: 10, color: "inherit" },
              }}
            />
          </Stack>
          <Typography variant="caption" sx={{ color: "text.secondary", fontSize: "11px" }}>
            Powered by RAG
          </Typography>
        </Box>
      </Stack>

      <Stack direction="row" spacing={0.25}>
        <IconButton onClick={onClearChat} size="small" title="New chat" sx={{ color: "text.secondary" }}>
          <AddCommentOutlinedIcon sx={{ fontSize: 18 }} />
        </IconButton>
        <IconButton onClick={onMinimize} size="small" title="Minimize" sx={{ color: "text.secondary" }}>
          <RemoveIcon sx={{ fontSize: 18 }} />
        </IconButton>
      </Stack>
    </Stack>
  );
};

export default ChatHeader;


