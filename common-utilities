package com.fincore.commonutilities.config;


import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.StringRedisTemplate;

@Configuration
public class RedisConfig {

    /**
     * Provides a StringRedisTemplate if the main application hasn't defined one.
     * This is crucial for the RbacFilter to work out-of-the-box.
     */
    @Bean
    @ConditionalOnMissingBean
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {
        return new StringRedisTemplate(connectionFactory);
    }
}








package com.fincore.commonutilities.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
@Slf4j
public class JwtUtil {

    // Reads 'jwt.secret' from the HOST application (CRS, ReportService, etc.)
    // Default value provided just in case, but we MUST OVERRIDE THIS in application.properties
    @Value("${jwt.secret:bWV0aGlvbnlsdGhyZW9ueWx0aHJlb255bGdsdXRhbWlueWxhbGFueWw=}")
    private String secretKey;

    @Value("${jwt.access-token-validity:900000}") // 15 minutes
    private long accessTokenValidity;

    @Value("${jwt.refresh-token-validity:86400000}") // 24 hours
    private long refreshTokenValidity;

    /**
     * Extracts User ID from "Bearer <token>"
     */
    public String getUserIdFromToken(String token) {
        String cleanToken = removeBearerPrefix(token);
        return extractClaim(cleanToken, Claims::getSubject);
    }

    /**
     * Extracts Role ID as integer from "Bearer <token>"
     */
    public int getUserRoleFromToken(String token) {
        String cleanToken = removeBearerPrefix(token);
        // Extracts "role" claim and converts to Integer
        return extractClaim(cleanToken, claims -> {
            Object role = claims.get("role");
            if (role instanceof Number) {
                return ((Number) role).intValue();
            }
            throw new IllegalArgumentException("Token role claim is not a number");
        });
    }

    /**
     * Validates the token signature and expiration.
     */
    /**
     * Validates signature and expiration.
     * Throws specific exceptions for handling in Filter.
     */
    public boolean isTokenValid(String token) {
        String cleanToken = removeBearerPrefix(token);
        // This will throw ExpiredJwtException if expired
        return !isTokenExpired(cleanToken);
    }

    // --- Generation Methods (For Auth Service) ---

    public String generateAccessToken(String userId, int roleId) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("role", roleId);
        return buildToken(claims, userId, accessTokenValidity);
    }

    public String generateRefreshToken(String userId) {
        // Refresh tokens typically just identify the user
        return buildToken(new HashMap<>(), userId, refreshTokenValidity);
    }

    private String buildToken(Map<String, Object> claims, String subject, long validity) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + validity))
                .signWith(getSigningKey())
                .compact();
    }


    // --- Internal Helpers ---

    private String removeBearerPrefix(String token) {
        if (token != null && token.startsWith("Bearer ")) {
            return token.substring(7);
        }
        return token;
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    private <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    private SecretKey getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }

}










package com.fincore.commonutilities.security;

import com.fincore.commonutilities.jwt.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.JwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;
import java.util.Set;

@Slf4j
@RequiredArgsConstructor
public class ContextRbacFilter extends OncePerRequestFilter {

    private final StringRedisTemplate redisTemplate;
    private final JwtUtil jwtUtil;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    // Whitelist
    private static final Set<String> WHITELIST = Set.of(
            "/auth/**", "/actuator/**", "/error", "/swagger-ui/**", "/v3/api-docs/**", "/login"
    );

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        String uri = request.getRequestURI();
        String method = request.getMethod().toUpperCase();

        // 1. SKIP WHITELIST
        for (String pattern : WHITELIST) {
            if (pathMatcher.match(pattern, uri)) {
                filterChain.doFilter(request, response);
                return;
            }
        }

        // 2. VALIDATE TOKEN & CATCH EXPIRATION
        String token = request.getHeader("Authorization");

        if (token != null) {

            try {
                // 2. VALIDATE TOKEN SIGNATURE & EXPIRY
                String userId = jwtUtil.getUserIdFromToken(token);
                int roleIdInt = jwtUtil.getUserRoleFromToken(token);
                String roleId = String.valueOf(roleIdInt);

//                // =================================================================
//                // 3. SECURITY CHECK: SINGLE SESSION ENFORCEMENT (Redis)
//                // =================================================================
//                String sessionKey = "USER_SESSION::" + userId;
//                String activeToken = redisTemplate.opsForValue().get(sessionKey);
//
//                if (activeToken == null) {
//                    // Scenario: Token valid locally, but session expired/deleted in Redis
//                    throw new JwtException("Session Expired or Terminated");
//                }
//
//                if (!token.equals(activeToken)) {
//                    // Scenario: Token valid locally, but Redis has a DIFFERENT token
//                    // This means user logged in on another device.
//                    log.warn("Concurrent Login Detected for User {}. Terminating old session.", userId);
//                    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
//                    response.setContentType("application/json");
//                    response.getWriter().write("{\"status\": 401, \"error\": \"CONCURRENT_LOGIN\", \"message\": \"You have been logged out because you signed in on another device.\"}");
//                    return; // STOP execution
//                }
                // =================================================================

                // Token is valid, set context
                if (SecurityContextHolder.getContext().getAuthentication() == null) {
                    UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                            userId, null, List.of(new SimpleGrantedAuthority("ROLE_" + roleId))
                    );
                    SecurityContextHolder.getContext().setAuthentication(authToken);
                }

                // 3. RBAC LOGIC (Only runs if token is valid)
                if (!checkRbac(request, response, roleId, userId)) {
                    return; // Response already sent in checkRbac
                }

            } catch (ExpiredJwtException e) {
                // --- CATCH EXPIRED TOKEN HERE ---
                log.warn("JWT Expired for IP: {}", request.getRemoteAddr());
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                response.setContentType("application/json");
                response.getWriter().write("{\"status\": 401, \"error\": \"TOKEN_EXPIRED\", \"message\": \"JWT has expired. Please refresh.\"}");
                return;
            } catch (JwtException | IllegalArgumentException e) {
                log.error("Invalid Token/Session: {}", e.getMessage());
                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Invalid Session");
                return;
            }
        } else {
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Missing Authorization Header");
            return;
        }

        filterChain.doFilter(request, response);
    }


    /**
     * Helper method to keep the main filter clean.
     * Returns true if authorized, false if denied (and response written).
     */
    private boolean checkRbac(HttpServletRequest request, HttpServletResponse response, String roleId, String userId) throws IOException {

        String uri = request.getRequestURI();
        String method = request.getMethod().toUpperCase();

        // DETERMINE CONTEXT (Header)
        String contextHeader = request.getHeader("X-Request-Type");
        // Normalize: If header is missing, treat as "*" (Global Context)
        String requestContext = (contextHeader != null && !contextHeader.trim().isEmpty()) ? contextHeader : "*";

        // REDIS AUTHORIZATION CHECK
        String redisKey = "RBAC::PERMISSIONS::" + roleId;
        Set<String> permissions = redisTemplate.opsForSet().members(redisKey);

        boolean isAuthorized = false;

        if (permissions != null) {
            for (String perm : permissions) {
                // Format: "METHOD:URL_PATTERN|CONTEXT"
                String[] parts = perm.split("\\|");
                if (parts.length < 2) continue;

                String methodAndUrl = parts[0];
                String allowedContext = parts[1];

                // --- A. CONTEXT CHECK ---
                // 1. Exact Match: Header "SEGMENT_CODE" matches Permission "SEGMENT_CODE"
                // 2. Wildcard Match: Permission has "*" (e.g. Reports), allows any header (or no header)
                if (!allowedContext.equals(requestContext) && !allowedContext.equals("*")) {
                    continue;
                }

                // --- B. URL & METHOD CHECK ---
                String[] muParts = methodAndUrl.split(":", 2);
                if (muParts.length < 2) continue;

                String allowedMethod = muParts[0];
                String allowedUrlPattern = muParts[1];

                // Method Match AND URL Pattern Match
                if (allowedMethod.equals(method) && pathMatcher.match(allowedUrlPattern, uri)) {
                    isAuthorized = true;
                    break;
                }

            }
        }


        if (!isAuthorized) {
            log.warn("? RBAC Deny: User {} (Role {}) -> {} {} (Context: {})", userId, roleId, method, uri, requestContext);
            response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied: Insufficient Permissions");
            return false;
        }
        return true;
    }
}












spring.application.name=CommonUtilities











