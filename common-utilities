<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.fincore</groupId>
	<artifactId>common-utilities</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>CommonUtilities</name>
	<description>Common utilities used across the application.</description>

	<properties>
		<java.version>21</java.version> <!-- Updated to LTS, or keep 22 if you prefer -->
        <jjwt.version>0.12.5</jjwt.version>
	</properties>

	<dependencies>
        <!-- CORE SPRING BOOT -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>

        <!-- UTILS -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>

        <!-- JWT SECURITY (JJWT) - Industry Standard -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
	</dependencies>
</project>














package com.fincore.commonutilities.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.security.Key;
import java.util.Date;
import java.util.function.Function;

@Component
@Slf4j
public class JwtUtils {

    // Inject this from the microservice's application.properties
    @Value("${jwt.secret:404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970}") 
    private String secretKey;

    /**
     * Extracts the Username (or UserID based on your logic) from the token.
     */
    public String extractUserId(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    /**
     * Extracts the specific Role Claim.
     * Assumes your Auth Service puts "role" in the payload.
     */
    public String extractRole(String token) {
        return extractClaim(token, claims -> claims.get("role", String.class));
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    /**
     * Validates the token signature and expiration.
     */
    public boolean isTokenValid(String token) {
        try {
            return !isTokenExpired(token);
        } catch (JwtException | IllegalArgumentException e) {
            log.error("Invalid JWT Token: {}", e.getMessage());
            return false;
        }
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    private SecretKey getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}









package com.fincore.commonutilities.security;

import com.fincore.commonutilities.jwt.JwtUtils;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.Set;

@Slf4j
@RequiredArgsConstructor
public class ContextRbacFilter extends OncePerRequestFilter {

    private final StringRedisTemplate redisTemplate;
    private final JwtUtils jwtUtils;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    // Endpoints in CRS that MUST have the X-Request-Type header
    private static final Set<String> GENERIC_ENDPOINTS = Set.of(
            "/create-request",
            "/update-request",
            "/my-requests",
            "/pending-requests"
    );

    // Endpoints that skip RBAC
    private static final Set<String> WHITELIST = Set.of(
            "/auth/**", "/actuator/**", "/error", "/swagger-ui/**", "/v3/api-docs/**"
    );

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        String requestUri = request.getRequestURI();
        String method = request.getMethod().toUpperCase();

        // 1. SKIP WHITELIST
        for (String pattern : WHITELIST) {
            if (pathMatcher.match(pattern, requestUri)) {
                filterChain.doFilter(request, response);
                return;
            }
        }

        // 2. EXTRACT & VALIDATE TOKEN
        String token = extractToken(request);
        if (token == null || !jwtUtils.isTokenValid(token)) {
            // We do not fail here; we let downstream SecurityConfig handle 401.
            // But we STOP processing RBAC.
            filterChain.doFilter(request, response);
            return;
        }

        // 3. SET SECURITY CONTEXT (If not already set by another filter)
        // This ensures downstream controllers can access user info
        String userId = jwtUtils.extractUserId(token);
        String roleId = jwtUtils.extractRole(token); // e.g. "51" or "ROLE_51"
        
        // Normalize Role ID (remove ROLE_ prefix if exists for DB lookup)
        String dbRoleId = roleId.replace("ROLE_", "");

        if (SecurityContextHolder.getContext().getAuthentication() == null) {
            UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                    userId, null, List.of(new SimpleGrantedAuthority("ROLE_" + dbRoleId))
            );
            SecurityContextHolder.getContext().setAuthentication(authToken);
        }

        // 4. DETERMINE CONTEXT (The "Context Aware" Part)
        String context = request.getHeader("X-Request-Type");
        
        // Default context is wildcard
        if (context == null || context.trim().isEmpty()) {
            context = "*";
        }

        // 5. VALIDATE GENERIC ENDPOINTS
        // If hitting CRS generic endpoints, we MUST have a specific context
        boolean isGenericEndpoint = GENERIC_ENDPOINTS.stream().anyMatch(requestUri::endsWith);
        if (isGenericEndpoint && context.equals("*")) {
            log.warn("⚠️ Security Alert: Missing X-Request-Type header for generic endpoint: {}", requestUri);
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing Header: X-Request-Type is required");
            return;
        }

        // 6. REDIS LOOKUP (The "Cached Gateway" Part)
        String redisKey = "RBAC::PERMISSIONS::" + dbRoleId;
        
        // Strategy A: Check Specific Context "POST:/create-request|SEGMENT_CODE"
        String specificPermission = method + ":" + requestUri + "|" + context;
        
        // Strategy B: Check Wildcard Context "POST:/reports/download|*"
        String wildcardPermission = method + ":" + requestUri + "|*";

        // Strategy C: Check Method/URL Match using Redis Sets (Fastest)
        // We fetch the set members? No, fetching members is O(N).
        // isMember is O(1). We check isMember.
        
        boolean isAuthorized = Boolean.TRUE.equals(redisTemplate.opsForSet().isMember(redisKey, specificPermission));

        if (!isAuthorized) {
            // Fallback: Check if user has wildcard access to this URL
            isAuthorized = Boolean.TRUE.equals(redisTemplate.opsForSet().isMember(redisKey, wildcardPermission));
        }

        // 7. ENFORCE DECISION
        if (isAuthorized) {
            filterChain.doFilter(request, response);
        } else {
            log.warn("⛔ RBAC Deny: User {} (Role {}) -> {} {} (Context: {})", userId, dbRoleId, method, requestUri, context);
            response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied: Insufficient Permissions");
        }
    }

    private String extractToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}










package com.fincore.commonutilities.config;

import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.StringRedisTemplate;

@Configuration
public class RedisConfig {

    /**
     * Provides a StringRedisTemplate if the main application hasn't defined one.
     * This is crucial for the RbacFilter to work out-of-the-box.
     */
    @Bean
    @ConditionalOnMissingBean
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {
        return new StringRedisTemplate(connectionFactory);
    }
}






