package com.fincore.commonutilities.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.function.Function;

@Component
@Slf4j
public class JwtUtil {

    // Reads 'jwt.secret' from the HOST application (CRS, ReportService, etc.)
    // Default value provided just in case, but YOU MUST OVERRIDE THIS in application.properties
    @Value("${jwt.secret:404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970}") 
    private String secretKey;

    /**
     * Legacy Method Support: Extracts User ID from "Bearer <token>"
     */
    public String getUserIdFromToken(String token) {
        String cleanToken = removeBearerPrefix(token);
        return extractClaim(cleanToken, Claims::getSubject);
    }

    /**
     * Legacy Method Support: Extracts Role ID as integer from "Bearer <token>"
     */
    public int getUserRoleFromToken(String token) {
        String cleanToken = removeBearerPrefix(token);
        // Extracts "role" claim and converts to Integer
        return extractClaim(cleanToken, claims -> {
            Object role = claims.get("role"); // Ensure your Login Service sends key "role"
            if (role instanceof Number) {
                return ((Number) role).intValue();
            }
            throw new IllegalArgumentException("Token role claim is not a number");
        });
    }

    /**
     * Validates the token signature and expiration.
     */
    public boolean isTokenValid(String token) {
        try {
            String cleanToken = removeBearerPrefix(token);
            return !isTokenExpired(cleanToken);
        } catch (JwtException | IllegalArgumentException e) {
            log.error("Invalid JWT Token: {}", e.getMessage());
            return false;
        }
    }

    // --- Internal Helpers ---

    private String removeBearerPrefix(String token) {
        if (token != null && token.startsWith("Bearer ")) {
            return token.substring(7);
        }
        return token;
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    private <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    private SecretKey getSigningKey() {
        // Decodes your Base64 encoded secret key
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(












package com.fincore.commonutilities.security;

import com.fincore.commonutilities.jwt.JwtUtil;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;
import java.util.Set;

@Slf4j
@RequiredArgsConstructor
public class ContextRbacFilter extends OncePerRequestFilter {

    private final StringRedisTemplate redisTemplate;
    private final JwtUtil jwtUtil;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    private static final Set<String> GENERIC_ENDPOINTS = Set.of(
            "/create-request", "/update-request", "/my-requests", "/pending-requests"
    );

    private static final Set<String> WHITELIST = Set.of(
            "/auth/**", "/actuator/**", "/error", "/swagger-ui/**", "/v3/api-docs/**"
    );

    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response, @NonNull FilterChain filterChain) throws ServletException, IOException {

        String uri = request.getRequestURI();
        
        // 1. Skip Whitelist
        for (String pattern : WHITELIST) {
            if (pathMatcher.match(pattern, uri)) {
                filterChain.doFilter(request, response);
                return;
            }
        }

        String token = request.getHeader("Authorization");

        // 2. Validate Token (Fail open if missing, let SecurityConfig handle 401)
        if (token == null || !jwtUtil.isTokenValid(token)) {
            filterChain.doFilter(request, response);
            return;
        }

        // 3. Set Security Context (So you can use @AuthenticationPrincipal later)
        String userId = jwtUtil.getUserIdFromToken(token);
        int roleIdInt = jwtUtil.getUserRoleFromToken(token);
        String roleId = String.valueOf(roleIdInt);

        if (SecurityContextHolder.getContext().getAuthentication() == null) {
            UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                    userId, null, List.of(new SimpleGrantedAuthority("ROLE_" + roleId))
            );
            SecurityContextHolder.getContext().setAuthentication(authToken);
        }

        // 4. Context Logic
        String context = request.getHeader("X-Request-Type");
        if (context == null || context.trim().isEmpty()) {
            context = "*";
        }

        boolean isGenericEndpoint = GENERIC_ENDPOINTS.stream().anyMatch(uri::endsWith);
        if (isGenericEndpoint && context.equals("*")) {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing Header: X-Request-Type is required");
            return;
        }

        // 5. Redis Check
        String method = request.getMethod().toUpperCase();
        String redisKey = "RBAC::PERMISSIONS::" + roleId;
        String specificKey = method + ":" + uri + "|" + context;
        String wildcardKey = method + ":" + uri + "|*";

        boolean isAuthorized = Boolean.TRUE.equals(redisTemplate.opsForSet().isMember(redisKey, specificKey));
        if (!isAuthorized) {
            isAuthorized = Boolean.TRUE.equals(redisTemplate.opsForSet().isMember(redisKey, wildcardKey));
        }

        if (isAuthorized) {
            filterChain.doFilter(request, response);
        } else {
            log.warn("â›” RBAC Deny: User {} (Role {}) -> {} {} (Context: {})", userId, roleId, method, uri, context);
            response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
        }
    }
}









package com.fincore.commonutilities.config;

import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.StringRedisTemplate;

@Configuration
public class RedisConfig {

    @Bean
    @ConditionalOnMissingBean
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {
        return new StringRedisTemplate(connectionFactory);
    }
}








<dependency>
    <groupId>com.fincore</groupId>
    <artifactId>common-utilities</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
4.  **Configure Properties (CRITICAL):**
Open `application.properties` in **CRS**, **ReportService**, and **NotificationService** and add:
```properties
# MUST MATCH LOGIN SERVICE KEY EXACTLY
jwt.secret=YOUR_ACTUAL_SECRET_KEY_FROM_LOGIN_SERVICE_HERE

# REDIS CONFIG
spring.data.redis.host=localhost
spring.data.redis.port=6379








