package com.fincore.gateway.Controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.gateway.JwtUtil.HmacJwtUtil;
import com.fincore.gateway.Service.LoginService;
import com.fincore.gateway.Service.TokenSessionValidator;
import com.fincore.gateway.dto.LoginResponseDTO;
import com.fincore.gateway.dto.UpdatePasswordDTO;
import com.fincore.gateway.dto.UserDto;
import com.fincore.gateway.dto.VerifyUserDTO;
import com.fincore.gateway.utility.Constants;
import com.fincore.gateway.utility.LoginUtility;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.tomcat.util.bcel.Const;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.ReactiveStringRedisTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.time.Duration;
import java.util.Arrays;
import java.util.Base64;
import java.util.List;
import java.util.Map;

/**
 * Authentication Controller (Reactive).
 * Handles Login, Logout, and Token Refresh using a distributed Redis session model.
 * <p>
 * Security Features:
 * 1. Dual Token System: Short-lived Access Token (JSON) + Long-lived Refresh Token (HttpOnly Cookie).
 * 2. Token Rotation: A new Refresh Token is issued on every use to detect theft.
 * 3. Session Binding: Access Token JTI is bound to Redis `USR:<userId>`.
 * 4. Concurrency Control: "One Session Per User" enforced via Redis JTI checks.
 * 5. Reactive Non-Blocking: Uses WebFlux Mono/Flux patterns with Elastic Scheduler for DB.
 */
@Slf4j
@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {

    private static final String USER_PREFIX = "USR:";
    private final TokenSessionValidator validator;
    private final ReactiveStringRedisTemplate redisTemplate;
    private final LoginService loginService;
    private final ObjectMapper mapper;

    @Value("${security.jwt.hmac-base64-secret:}")
    private String hmacSecret;

    // Access Token: Short Lived (e.g., 15 mins)
    @Value("${security.jwt.ttl-seconds:900}")
    private long accessTokenTtl;

    // Refresh Token: Long Lived (e.g., 24 hours)
    @Value("${security.jwt.refresh-ttl-seconds:43200}")
    private long refreshTokenTtl;


    @Value("${security.login.blocked-ips:}")
    private String blockedIpsConfig;

    /**
     * Helper to clean the IP address string.
     * Converts "/10.0.19.203:52373" -> "10.0.19.203"
     */
    private String sanitizeIp(String rawIp) {
        if (rawIp == null) return "";
        String ip = rawIp;
        if (ip.startsWith("/")) ip = ip.substring(1);
        int colonIndex = ip.indexOf(':');
        if (colonIndex != -1) ip = ip.substring(0, colonIndex);
        return ip;
    }

    private boolean isIpBlocked(String rawClientIp) {
        if (blockedIpsConfig == null || blockedIpsConfig.trim().isEmpty()) return false;
        String cleanIp = sanitizeIp(rawClientIp);
        List<String> blockedIps = Arrays.asList(blockedIpsConfig.split("\\s*,\\s*"));
        boolean blocked = blockedIps.contains(cleanIp);
        if (blocked) log.warn("Blocked IP Match Found: Raw='{}' -> Clean='{}'", rawClientIp, cleanIp);
        return blocked;
    }


    /**
     * Creates a secure HttpOnly cookie for the refresh token.
     * Prevents XSS attacks as JavaScript cannot read this cookie.
     * <p>
     * CONFIG NOTE:
     * - secure(false): Allows HTTP (Localhost). Set to true in PROD with HTTPS.
     * - sameSite("Lax"): Allows cross-origin navigation in Localhost dev.
     * - path("/"): Ensures cookie is sent to all auth endpoints.
     */
    private ResponseCookie createRefreshTokenCookie(String token) {
        return ResponseCookie.from("refresh_token", token)
                .httpOnly(true)
                .secure(true) //  Set to true in Production (requires HTTPS)
                .path("/")     // Root path ensures availability to all auth endpoints
                .maxAge(Duration.ofSeconds(refreshTokenTtl))
                .sameSite("Lax") // 'Lax' is safer for localhost dev than 'Strict'
                .build();
    }

    /**
     * Creates an empty cookie to clear the refresh token on logout.
     */
    private ResponseCookie createEmptyCookie() {
        return ResponseCookie.from("refresh_token", "")
                .httpOnly(true)
                .path("/")
                .maxAge(0)
                .build();
    }

    /**
     * LOGIN ENDPOINT
     * 1. Validates credentials (Blocking DB call on Elastic Scheduler).
     * 2. Generates Access Token & Refresh Token.
     * 3. Stores Access Token JTI in Redis (Session Start).
     * 4. Returns Access Token in Body, Refresh Token in HttpOnly Cookie.
     */
    @PostMapping(value = "/login", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<LoginResponseDTO> login(ServerHttpRequest request, ServerHttpResponse response, @RequestBody @Valid UserDto payload) {
        final String clientIp = LoginUtility.getClientIp(request);
        log.info("Login request for user: {} from IP: {}", payload.getUserId(), clientIp);

        // 1. IP BLOCK CHECK
        if (isIpBlocked(clientIp)) {
            log.warn("Login BLOCKED for user: {} from IP: {}", payload.getUserId(), clientIp);
            return Mono.just(LoginResponseDTO.builder()
                    .userId(payload.getUserId())
                    .validCredentials(false)
                    .userStatus(Constants.RESTRICTED)
                    .error("Access denied: Your IP address is blocked.")
                    .build());

        }

        return Mono.fromCallable(() -> loginService.verifyUserCredentials(payload, clientIp))
                .subscribeOn(Schedulers.boundedElastic()) // Move blocking JDBC call off the event loop
                .flatMap(user -> {
                    if (!user.isValidCredentials()) {
                        log.warn("Invalid credentials for user: {}", payload.getUserId());
                        return Mono.just(LoginResponseDTO.builder()
                                .userId(user.getUserId())
                                .validCredentials(false)
                                .userStatus(user.getUserStatus())
                                .error(user.getMessage() != null ? user.getMessage() : "Invalid credentials")
                                .build());
                    }

                    if (hmacSecret == null || hmacSecret.isBlank()) {
                        log.error("Server Config Error: HMAC secret is missing.");
                        return Mono.error(new IllegalStateException("Missing HMAC secret"));
                    }

                    // 1. Generate Tokens
                    @SuppressWarnings("unchecked")
                    Map<String, Object> claimsMap = mapper.convertValue(user.getUser(), Map.class);
                    // Access Token (Short TTL)
                    String accessToken = HmacJwtUtil.generate(hmacSecret, user.getUserId(), accessTokenTtl, claimsMap);

                    // Refresh Token (Long TTL)
                    Map<String, Object> refreshClaims = Map.of("type", "refresh");
                    String refreshToken = HmacJwtUtil.generate(hmacSecret, user.getUserId(), refreshTokenTtl, refreshClaims);

                    // Extract JTI from Access Token (This is what we track in Redis)
                    String jti = extractClaims(accessToken).getId();

                    // 2. Set Refresh Token in HttpOnly Cookie
                    ResponseCookie cookie = createRefreshTokenCookie(refreshToken);
                    response.addCookie(cookie);
                    log.info("Login Success. Access Token TTL: {}s. Refresh Cookie Set.", accessTokenTtl);

                    // 3. Register Session (JTI) in Redis & Fetch Menus
                    return validator.registerUserSession(user.getUserId(), jti)
                            .then(Mono.defer(() -> Mono.fromCallable(() -> loginService.fetchRoleWiseData(user.getUserId()))
                                    .subscribeOn(Schedulers.boundedElastic())))
                            .map(roleData -> LoginResponseDTO.builder()
                                    .userId(user.getUserId())
                                    .validCredentials(true)
                                    .accessToken(accessToken) // Only Access Token goes to Frontend JS
                                    .tokenType("Bearer")
                                    .expiresIn(accessTokenTtl)
                                    .sub(user.getUserId())
                                    .jti(jti)
                                    .roleData(roleData)
                                    .build());
                })
                .onErrorResume(e -> {
                    log.error("Login System Error for user {}", payload.getUserId(), e);
                    return Mono.just(LoginResponseDTO.builder().error("Login failed: " + e.getMessage()).build());
                });
    }

    /**
     * REFRESH TOKEN ENDPOINT
     * 1. Reads Refresh Token from Cookie.
     * 2. Validates Signature & Expiry.
     * 3. Checks Redis to ensure User Session is still valid/active.
     * 4. Rotates Tokens (New Access Token + New Refresh Cookie).
     */
    @PostMapping(value = "/refresh-token", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<LoginResponseDTO> refreshToken(ServerHttpRequest request, ServerHttpResponse response) {

        org.springframework.http.HttpCookie cookie = request.getCookies().getFirst("refresh_token");
        String refreshToken = (cookie != null) ? cookie.getValue() : null;

        if (refreshToken == null || refreshToken.isBlank()) {
            log.warn("Refresh failed: No refresh token cookie.");
            return Mono.just(LoginResponseDTO.builder().error("Missing refresh token cookie").build());
        }

        return Mono.fromCallable(() -> {
                    try {
                        return extractClaims(refreshToken);
                    } catch (ExpiredJwtException e) {
                        log.warn("Refresh token expired.");
                        throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Refresh token expired");
                    } catch (Exception e) {
                        log.error("Invalid refresh token.", e);
                        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid refresh token");
                    }
                })
                .subscribeOn(Schedulers.boundedElastic())
                .flatMap(claims -> {
                    String userId = claims.getSubject();
                    String userKey = USER_PREFIX + userId;
                    log.info("Refreshing Token for User: {}", userId);
                    // Check Session
                    return redisTemplate.opsForValue().get(userKey)
                            .flatMap(currentJti -> {
                                log.info("Session Active in Redis. Fetching Full Profile.");
                                // 1. Fetch Full User Profile (Blocking)
                                return Mono.fromCallable(() -> loginService.getUserProfile(userId))
                                        .subscribeOn(Schedulers.boundedElastic())
                                        .flatMap(userDto -> {

                                            if (userDto == null)
                                                return Mono.error(new RuntimeException("User not found"));

                                            // 2. Fetch Menu Data (Blocking)
                                            return Mono.fromCallable(() -> loginService.fetchRoleWiseData(userId))
                                                    .subscribeOn(Schedulers.boundedElastic())
                                                    .flatMap(roleData -> {

                                                        // 3. Generate New Tokens with FULL Claims
                                                        @SuppressWarnings("unchecked")
                                                        Map<String, Object> claimsMap = mapper.convertValue(userDto.getUser(), Map.class);
                                                        String newAccessToken = HmacJwtUtil.generate(hmacSecret, userId, accessTokenTtl, claimsMap);

                                                        Map<String, Object> refreshClaims = Map.of("type", "refresh");
                                                        String newRefreshToken = HmacJwtUtil.generate(hmacSecret, userId, refreshTokenTtl, refreshClaims);

                                                        String newJti = extractClaims(newAccessToken).getId();
                                                        response.addCookie(createRefreshTokenCookie(newRefreshToken));

                                                        // 4. Update Redis & Return Full DTO
                                                        return validator.registerUserSession(userId, newJti)
                                                                .thenReturn(LoginResponseDTO.builder()
                                                                        .accessToken(newAccessToken)
                                                                        .userId(userId)
                                                                        .jti(newJti)
                                                                        .expiresIn(accessTokenTtl)
                                                                        .validCredentials(true)
                                                                        .roleData(roleData) // Menus restored!
                                                                        .userStatus(userDto.getUserStatus()) // Status restored!
                                                                        .passwordLoginStatus(userDto.getPasswordLoginStatus())
                                                                        .sub(userId)
                                                                        .build());
                                                    });
                                        });
                            })
                            .switchIfEmpty(Mono.defer(() -> {
                                log.warn("Redis returned EMPTY for key: {}. Session expired.", userKey);
                                return Mono.just(LoginResponseDTO.builder().error("Session expired. Please login again.").build());
                            }));
                })
                .onErrorResume(e -> {
                    if (e instanceof ResponseStatusException) {
                        return Mono.just(LoginResponseDTO.builder().error(e.getMessage()).build());
                    }
                    log.error("Refresh Token Unexpected Error", e);
                    return Mono.just(LoginResponseDTO.builder().error("Invalid refresh token").build());
                });
    }

    /**
     * LOGOUT ENDPOINT (ROBUST & VERIFIED)
     * Handles:
     * 1. Valid Tokens -> Standard Logout
     * 2. Expired Tokens -> Manually extracts claims -> Cleans up Redis if JTI matches
     * 3. Concurrent Logins -> Blacklists current token, but PRESERVES the active session in Redis
     * 4. Missing/Malformed Tokens -> Clears cookies and returns success (Idempotent)
     */
    @PostMapping(value = "/logout", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<LoginResponseDTO>> logout(JwtAuthenticationToken jwtAuth, ServerHttpRequest request, ServerHttpResponse response) {

        // 1. Always clear the Refresh Token Cookie (Idempotent)
        response.addCookie(createEmptyCookie());

        // 2. Resolve Token Strategy
        String tokenString = null;

        // Strategy A: Spring Security Context (Valid Tokens)
        if (jwtAuth != null && jwtAuth.getToken() != null) {
            tokenString = jwtAuth.getToken().getTokenValue();
        }
        // Strategy B: Manual Header Extraction (Expired Tokens)
        else {
            String header = request.getHeaders().getFirst("Authorization");
            if (header != null && header.startsWith("Bearer ")) {
                tokenString = header.substring(7);
            }
        }

        // 3. Fast Exit: If no token found anywhere, just return success so frontend can clear state
        if (tokenString == null || tokenString.isBlank()) {
            log.warn("Logout called without token. Cleaning up cookies only.");
            return Mono.just(ResponseEntity.ok(
                    LoginResponseDTO.builder().userId("anonymous").error("Logged out (No Token)").build()
            ));
        }

        final String finalToken = tokenString;

        // 4. Processing Chain
        return Mono.fromCallable(() -> {
                    try {
                        // Try standard parsing
                        return extractClaims(finalToken);
                    } catch (ExpiredJwtException e) {
                        // CRITICAL FIX: If token is expired, we STILL want the claims to perform cleanup
                        log.info("Logout: Token is expired. Using claims from exception for cleanup.");
                        return e.getClaims();
                    }
                })
                .subscribeOn(Schedulers.boundedElastic())
                .flatMap(claims -> {
                    String userId = claims.getSubject();
                    String incomingJti = claims.getId();

                    if (userId == null || incomingJti == null) {
                        return Mono.just(ResponseEntity.ok(
                                LoginResponseDTO.builder().error("Invalid Token Claims").build()
                        ));
                    }

                    log.info("Logout Processing for User: {} | JTI: {}", userId, incomingJti);

                    // 5. Blacklist the Token (Always blacklist the incoming token)
                    return validator.blacklistToken(incomingJti)
                            .then(redisTemplate.opsForValue().get(USER_PREFIX + userId))
                            .flatMap(activeJti -> {
                                // 6. Conditional Redis Cleanup
                                if (activeJti != null && activeJti.equals(incomingJti)) {
                                    // SCENARIO: Normal Logout. The session in Redis belongs to THIS token.
                                    // Action: Delete it.
                                    log.info("Session MATCH. Deleting active session for user: {}", userId);
                                    return validator.clearUserSession(userId)
                                            .then(Mono.just(ResponseEntity.ok(
                                                    LoginResponseDTO.builder().userId(userId).error("Logged out successfully").build()
                                            )));
                                } else {
                                    // SCENARIO: Concurrent Login.
                                    // The session in Redis belongs to a NEWER token (on another device/tab).
                                    // Action: Do NOT delete it. Just let the blacklist happen.
                                    log.warn("Session MISMATCH or ALREADY GONE. Active JTI: {}. Incoming JTI: {}. Preserving Redis Session.", activeJti, incomingJti);
                                    return Mono.just(ResponseEntity.ok(
                                            LoginResponseDTO.builder().userId(userId).error("Logged out (Concurrent Session Preserved)").build()
                                    ));
                                }
                            })
                            // If key is missing in Redis (Already timed out), return success
                            .switchIfEmpty(Mono.just(ResponseEntity.ok(
                                    LoginResponseDTO.builder().userId(userId).error("Logged out (Session already expired)").build()
                            )));
                })
                .onErrorResume(e -> {
                    // Safety Net: If anything explodes (Redis down, etc), allow frontend to logout
                    log.error("Logout Unexpected Error", e);
                    return Mono.just(ResponseEntity.ok(
                            LoginResponseDTO.builder().error("Logged out (System Error handled)").build()
                    ));
                });
    }


    @PostMapping(value = "/check-user")
    public Mono<VerifyUserDTO> checkUser(ServerHttpRequest request, @RequestBody Map<String, String> body) {
        final String rawClientIp = LoginUtility.getClientIp(request);
        log.info("Client info user id: {} , ip : {}", body.get("userId"), rawClientIp);

        // 1. IP BLOCK CHECK
        if (isIpBlocked(rawClientIp)) {
            log.warn("Login BLOCKED for user: {} from IP: {}", body.get("userId"), rawClientIp);
            return Mono.just(VerifyUserDTO.builder()
                    .userId(body.get("userId"))
                    .message("Access denied: Your IP address is blocked.")
                    .userStatus(Constants.RESTRICTED)
                    .build());

        }


        return Mono.fromCallable(() -> loginService.checkUser(body.get("userId"))).subscribeOn(Schedulers.boundedElastic());
    }

    @PostMapping(value = "/update-password")
    public Mono<UpdatePasswordDTO> updatePassword(@RequestBody @Valid UpdatePasswordDTO dto) {
        return Mono.fromCallable(() -> loginService.updatePassword(dto)).subscribeOn(Schedulers.boundedElastic());
    }

    // Helper to parse token
    private Claims extractClaims(String token) {
        byte[] secretBytes = Base64.getDecoder().decode(hmacSecret);
        return Jwts.parser().verifyWith(Keys.hmacShaKeyFor(secretBytes)).build().parseSignedClaims(token).getPayload();
    }

}

























package com.fincore.gateway.Controller;

import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

import java.util.Map;

/**
 * Protected endpoint to verify auth+redis policies easily.
 */
@RestController
@RequestMapping("/secure")
public class ProtectedEchoController {

    @GetMapping("/hello")
    public Mono<Map<String, Object>> hello(JwtAuthenticationToken auth) {
        return Mono.just(Map.of(
                "message", "Hello " + auth.getName(),
                "sub", auth.getToken().getSubject(),
                "jti", auth.getToken().getId()
        ));
    }
}








package com.fincore.gateway.Service;

import com.fincore.gateway.dto.MenuResponse;
import com.fincore.gateway.dto.UpdatePasswordDTO;
import com.fincore.gateway.dto.UserDto;
import com.fincore.gateway.dto.VerifyUserDTO;
import com.fincore.gateway.model.LoginAttempt;
import com.fincore.gateway.model.LoginParam;
import com.fincore.gateway.model.User;
import com.fincore.gateway.model.UserRoles;

/**
 * Contract for login/authentication workflows, user/session checks, and menu resolution.
 *
 * <p>Implementations should:
 * <ul>
 *   <li>Validate credentials (password-based or SSO-based)</li>
 *   <li>Issue JWTs and compose token-visible user data</li>
 *   <li>Enforce wrong-password attempt limits and track attempts</li>
 *   <li>Transform role permissions to a menu response</li>
 * </ul>
 */
public interface LoginService {

    /**
     * Verifies user credentials and, on success, produces a {@link UserDto} containing
     * validity flags, statuses, and an access token with token-visible user data.
     *
     * @param userCredentials input payload with userId (and password for password mode)
     * @param clientIp        caller's IP address for auditing
     * @return populated {@link UserDto} describing the outcome
     */
    UserDto verifyUserCredentials(UserDto userCredentials, String clientIp);

    /**
     * Fetches role-wise permissions for the user and transforms them into a menu response.
     *
     * @param userId the user identifier
     * @return {@link MenuResponse} built from ordered permissions (possibly empty)
     */
    MenuResponse fetchRoleWiseData(String userId);

    /**
     * Checks a user's status and requirements prior to login.
     *
     * @param userId the user identifier
     * @return {@link VerifyUserDTO} describing status and next steps (e.g., update password)
     */
    VerifyUserDTO checkUser(String userId);

    /**
     * Updates a user's password hash and related metadata.
     *
     * @param userCredentials input DTO containing {@code userId} and new raw {@code password}
     * @return {@link UpdatePasswordDTO} with status and message
     */
    UpdatePasswordDTO updatePassword(UpdatePasswordDTO userCredentials);

    /**
     * Executes password-based authentication logic, enforcing wrong-password limits and
     * updating counters/flags in the provided objects.
     *
     * @param password     raw password from the request
     * @param loginAttempt login attempt entity to update with success/failure
     * @param userInfo     output DTO to set validity flags and attempts left
     * @param user         the user being authenticated
     * @param loginParam   login parameters (e.g., permitted attempts)
     */
    void passwordBasedLogin(String password,
                            LoginAttempt loginAttempt,
                            UserDto userInfo,
                            User user,
                            LoginParam loginParam);

    /**
     * Produces a human-readable message describing a blocked login due to the given status/type.
     *
     * @param status status string (e.g., ACTIVE/INACTIVE/LOCKED)
     * @param type   subject type (e.g., "user", "role")
     * @return formatted message
     */
    String generateStatusMessage(String status, String type);

 

    /**
     * Retrives the user profile information.
     * used during token refresh to ensure user claims are up to date.
     * @param userId
     * @return userRole
     */
    UserDto getUserProfile(String userId);
}












package com.fincore.gateway.Service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.gateway.JwtUtil.HmacJwtUtil;
import com.fincore.gateway.dto.MenuResponse;
import com.fincore.gateway.dto.UpdatePasswordDTO;
import com.fincore.gateway.dto.UserDto;
import com.fincore.gateway.dto.UserTokenDataDto;
import com.fincore.gateway.dto.VerifyUserDTO;
import com.fincore.gateway.model.LoginAttempt;
import com.fincore.gateway.model.LoginParam;
import com.fincore.gateway.dto.PermissionRow;
import com.fincore.gateway.model.User;
import com.fincore.gateway.model.UserRoles;
import com.fincore.gateway.repository.LoginAttemptRepository;
import com.fincore.gateway.repository.LoginParamRepository;
import com.fincore.gateway.repository.RolePermissionsRepository;
import com.fincore.gateway.repository.UserRepository;
import com.fincore.gateway.utility.Constants;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Service implementation handling user login/verification, menu resolution, and password updates.
 *
 * <p><strong>Responsibilities</strong>
 * <ul>
 *   <li>Validate credentials (password-based and SSO-based)</li>
 *   <li>Issue HS256 JWTs and embed limited user/role claims</li>
 *   <li>Transform role permissions into menu responses</li>
 *   <li>Track login attempts and enforce wrong password limits</li>
 * </ul>
 *
 * <p><strong>Notes</strong>
 * <ul>
 *   <li>JWT generation uses an HMAC Base64 secret; ensure it is configured for the environment.</li>
 *   <li>{@code BCryptPasswordEncoder} is created locally for convenience; consider injecting a singleton bean instead.</li>
 *   <li>Write operations are wrapped in {@link Transactional} where appropriate.</li>
 * </ul>
 */
@Slf4j
@Service("LoginService")
@RequiredArgsConstructor
public class LoginServiceImpl implements LoginService {

    /**
     * Prefer injecting a singleton bean; retained local instance for compatibility.
     */
    private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

    // ======= Config =======

    /**
     * Base64-encoded HMAC secret used to sign HS256 JWTs.
     */
    @Value("${security.jwt.hmac-base64-secret:}")
    private String hmacSecret;

    /**
     * Token time-to-live in seconds.
     */
    @Value("${security.jwt.ttl-seconds:900}")
    private long ttlSeconds;

    // ======= Dependencies =======

    private final UserRepository userRepository;
    private final LoginAttemptRepository loginAttemptRepository;
    private final LoginParamRepository loginParamRepository;
    private final RolePermissionsRepository rolePermissionsRepository;
    private final MenuService menuService;
    private final ObjectMapper mapper;

    // ======= Public API =======

    /**
     * Fetches role-wise permissions for the given user and transforms them into a menu response.
     *
     * @param userId ID of the user
     * @return {@link MenuResponse} built from ordered permissions; empty if none or on error
     */
    @Transactional(readOnly = true)
    @Override
    public MenuResponse fetchRoleWiseData(String userId) {
        log.info("Fetching role-wise data for userId: {}", userId);
        try {
            List<PermissionRow> rows = rolePermissionsRepository.findAllPermissionsByUserId(userId);

            if (rows == null || rows.isEmpty()) {
                log.info("No permissions found for userId: {}", userId);
                return new MenuResponse(Collections.emptyList());
            }
            return menuService.transformFromProjection(rows);
        } catch (Exception e) {
            log.error("Error fetching permissions for userId: {}", userId, e);
            return new MenuResponse(Collections.emptyList());
        }
    }

    /**
     * Verifies user credentials and, on success, builds {@link UserDto} populated with an access token and token data.
     * <p>Also records the login attempt and enforces password attempt limits.</p>
     *
     * @param userCredentials payload containing {@code userId} and (for password mode) {@code password}
     * @param clientIp        caller's IP address for audit
     * @return {@link UserDto} with validity flags, statuses, and (if valid) a signed access token
     */
    @Transactional
    @Override
    public UserDto verifyUserCredentials(UserDto userCredentials, String clientIp) {

        final String userId = userCredentials.getUserId();
        final String rawPassword = userCredentials.getPassword();

        UserDto result = new UserDto();
        User user = userRepository.findByUserId(userId);

        if (user == null) {
            result.setValidCredentials(false);
            result.setUserStatus(Constants.INVALID);
            log.info("Login attempt for invalid userId: {}", userId);
            return result;
        }

        LoginParam loginParam = loginParamRepository.getLoginParam();
        LoginAttempt attempt = new LoginAttempt();
        attempt.setLoginMethod(loginParam.getActiveLoginMode() == 'P'
                ? Constants.PASSWORD_BASED_LOGIN
                : Constants.SSO_BASED_LOGIN);
        attempt.setSuccess("N");
        attempt.setIpAddress(clientIp);
        attempt.setUserId(userId);

        result.setLoginMethod(loginParam.getActiveLoginMode());
        result.setUserId(user.getUserId());

        UserRoles userRole = userRepository.getUserRole(userId);

        // Status checks: role & user
        result.setRoleStatus(userRole.getRoleStatus());
        result.setUserStatus(user.getAccountStatus());
        result.setPasswordLoginStatus(user.getPasswordLogin());

        if (!Constants.ACTIVE.equalsIgnoreCase(userRole.getRoleStatus())) {
            attempt.setFailureReason(generateStatusMessage(userRole.getRoleStatus(), "role"));
            loginAttemptRepository.save(attempt);
            result.setValidCredentials(false);
            return result;
        }

        if (!Constants.ACTIVE.equalsIgnoreCase(user.getAccountStatus())) {
            attempt.setFailureReason(generateStatusMessage(user.getAccountStatus(), "user"));
            loginAttemptRepository.save(attempt);
            result.setValidCredentials(false);
            return result;
        }

        // Proceed by login mode
        if (loginParam.getActiveLoginMode() == Constants.PASSWORD) {
            // Password-based login allowed?
            if (Constants.ACTIVE.equalsIgnoreCase(user.getPasswordLogin())) {
                passwordBasedLogin(rawPassword, attempt, result, user, loginParam);
            } else {
                result.setValidCredentials(false);
                attempt.setFailureReason("Password login is disabled for this user.");
            }
        } else {
            // SSO-based login
            attempt.setSuccess("Y");
            attempt.setFailureReason("SUCCESS");
            result.setValidCredentials(true);

            // If password-login was disabled, re-enable it on successful SSO per your original logic
            if (Constants.INACTIVE.equalsIgnoreCase(user.getPasswordLogin())) {
                user.setPasswordLogin(Constants.ACTIVE);
                userRepository.save(user);
            }
        }

        // On success, mint token and populate token data
        if (result.isValidCredentials()) {
            log.info("Credentials validated. Issuing token for userId={}", userId);

            UserDto safeClaims = new UserDto();
            safeClaims.setUserId(user.getUserId());
            safeClaims.setUserrole(userRole.getRole());

            @SuppressWarnings("unchecked")
            String accessToken = HmacJwtUtil.generate(
                    hmacSecret,
                    user.getUserId(),
                    ttlSeconds,
                    mapper.convertValue(safeClaims, Map.class)
            );

            UserTokenDataDto tokenData = initializeTokenData(user, userRole);
            result.setAccessToken(accessToken);
            result.setUser(tokenData);
        }

        loginAttemptRepository.save(attempt);
        log.debug("verifyUserCredentials result={}", result);
        return result;
    }

    /**
     * Password-based authentication flow that enforces wrong password limits and updates counters/flags.
     *
     * @param password     raw password from the request
     * @param loginAttempt login attempt entity to be updated with success/failure
     * @param userInfo     output DTO updated with validity and attempts left
     * @param user         the user entity being authenticated
     * @param loginParam   login parameter configuration (e.g., permitted attempts)
     */
    @Transactional
    @Override
    public void passwordBasedLogin(String password,
                                   LoginAttempt loginAttempt,
                                   UserDto userInfo,
                                   User user,
                                   LoginParam loginParam) {

        log.info("Password-based login for userId={}", user.getUserId());

        int failedCount = user.getUserWrongPasswordCount();
        int permitted = loginParam.getWrongPasswordAttempts();

        if (failedCount >= permitted) {
            loginAttempt.setFailureReason("Exceeded attempt limit");
            userInfo.setMessage("Exceeded attempt limit");
            userInfo.setValidCredentials(false);
            return;
        }

        if (encoder.matches(password, user.getPasswordHash())) {
            // Success
            loginAttempt.setSuccess("Y");
            loginAttempt.setFailureReason("Success");
            userInfo.setValidCredentials(true);
            // Reset wrong password counter on success (optional, add if desired)
            if (failedCount != 0) {
                user.setUserWrongPasswordCount(0);
                userRepository.save(user);
            }
            return;
        }

        // Failure path
        if (failedCount == permitted - 1) {
            // Lock password login on next failure threshold
            user.setPasswordLogin(Constants.INACTIVE);
            user.setUserWrongPasswordCount(0);
        } else {
            user.setUserWrongPasswordCount(failedCount + 1);
        }

        userRepository.save(user);
        loginAttempt.setSuccess("N");
        loginAttempt.setFailureReason("Wrong password");
        userInfo.setValidCredentials(false);
        userInfo.setAttemptsLeft(Math.max(0, permitted - failedCount - 1));
    }

    /**
     * Produces a human-readable message describing a blocked login due to {@code status} of a given {@code type}.
     *
     * @param status status string (e.g., ACTIVE/INACTIVE/LOCKED)
     * @param type   subject type (e.g., "user", "role")
     * @return formatted message
     */
    @Override
    public String generateStatusMessage(String status, String type) {
        return String.format("Trying to login with a %s %s", status, type);
    }


    /**
     * Checks the status and requirements for a user attempting to log in (without performing login).
     *
     * @param userId the user identifier
     * @return {@link VerifyUserDTO} describing status, password update requirements, and messages
     */
    @Transactional(readOnly = true)
    public VerifyUserDTO checkUser(String userId) {
        VerifyUserDTO out = new VerifyUserDTO();
        out.setUserId(userId);

        User user = userRepository.findByUserId(userId);
        LoginParam loginParam = loginParamRepository.getLoginParam();
        out.setLoginMethod(loginParam.getActiveLoginMode());

        if (user == null) {
            // Invalid user
            out.setUserCheck(false);
            out.setUserStatus(Constants.INVALID);
            out.setMessage("Invalid User");
            return out;
        }

        // Existing user
        if (Constants.ACTIVE.equalsIgnoreCase(user.getAccountStatus())) {
            // Password validity window based on tempPasswordSetAt (guard nulls)
            Timestamp setAt = user.getTempPasswordSetAt();
            boolean isPasswordValid = false;
            if (setAt != null) {
                LocalDateTime lastUpdate = setAt.toLocalDateTime();
                isPasswordValid = LocalDateTime.now()
                        .isBefore(lastUpdate.plusHours(loginParam.getPasswordValidity()));
            }

            UserRoles userRole = userRepository.getUserRole(userId);
            out.setRoleStatus(userRole.getRoleStatus());
            out.setUpdatePassword(user.getPasswordHash() == null || !isPasswordValid);
            out.setUserStatus(Constants.ACTIVE);
            out.setMessage(Constants.ACTIVE_USER);
            out.setPasswordLoginStatus(user.getPasswordLogin());
        } else {
            // Inactive, Locked, Pending_Verification
            String accountStatus = user.getAccountStatus();
            out.setUserCheck(true);
            out.setUserStatus(accountStatus);
            out.setMessage(
                    accountStatus.equalsIgnoreCase("locked") ? "Locked User"
                            : accountStatus.equalsIgnoreCase("inactive") ? "Inactive User" : "Verification Pending"
            );
        }

        return out;
    }

    /**
     * Updates the user's password hash and resets the temporary password timestamp.
     * <p><strong>TODO:</strong> Integrate OTP validation before update.</p>
     *
     * @param userCredentials input DTO with {@code userId} and new raw {@code password}
     * @return {@link UpdatePasswordDTO} indicating success and message; sensitive fields are cleared
     */
    @Transactional
    public UpdatePasswordDTO updatePassword(UpdatePasswordDTO userCredentials) {
        String userId = userCredentials.getUserId();
        String password = userCredentials.getPassword();

        // Always sanitize outbound fields
        userCredentials.setUpdateFlag(false);
        userCredentials.setPassword("");
        userCredentials.setOtp("");

        try {
            User user = userRepository.findByUserId(userId);
            if (user == null) {
                userCredentials.setMessage("Invalid user id");
                return userCredentials;
            }

            String passwordHash = encoder.encode(password);
            user.setPasswordHash(passwordHash);
            user.setTempPasswordSetAt(Timestamp.valueOf(LocalDateTime.now()));
            userRepository.save(user);

            userCredentials.setMessage("User password successfully updated");
            userCredentials.setUpdateFlag(true);
        } catch (DataIntegrityViolationException e) {
            log.warn("Data integrity violation while updating password for userId={}", userId, e);
            userCredentials.setMessage("Failed to change password, please try again");
        } catch (Exception e) {
            log.error("Unexpected error while updating password for userId={}", userId, e);
            userCredentials.setMessage("Unexpected error while changing password");
        }

        return userCredentials;
    }

    // ======= Helpers =======

    /**
     * Initializes the token-visible user data embedded/returned alongside the JWT.
     *
     * @param user     the user entity
     * @param userRole the role mapping for the user
     * @return user token DTO with non-sensitive fields
     */
    private UserTokenDataDto initializeTokenData(User user, UserRoles userRole) {
        UserTokenDataDto tokenData = new UserTokenDataDto();
        tokenData.setFirstName(user.getFirstName());
        tokenData.setLastName(user.getLastName());
        tokenData.setPhoneNumber(user.getPhoneNumber());
        tokenData.setUserId(user.getUserId());
        tokenData.setBranch(user.getBranch());
        tokenData.setEmail(user.getEmail());
        tokenData.setRole(userRole.getRole());
        tokenData.setRoleName(userRole.getRoleName());
        return tokenData;
    }



    /**
     * Retrieves the full user profile for Token Refresh.
     * Uses the exact same structure as verifyUserCredentials to ensure token claims are identical.
     */
    @Override
    @Transactional(readOnly = true)
    public UserDto getUserProfile(String userId) {
        User user = userRepository.findByUserId(userId);
        UserRoles userRole = userRepository.getUserRole(userId);

        // Return null if user doesn't exist, caller handles the error
        if (user == null) {
            return null;
        }
        UserDto userDto = new UserDto();
        userDto.setUserId(user.getUserId());
        userDto.setUserStatus(user.getPasswordLogin());
        userDto.setPasswordLoginStatus(user.getPasswordLogin());
        userDto.setUser(initializeTokenData(user, userRole));
        return userDto;
    }
}



















package com.fincore.gateway.Service;

import com.fincore.gateway.dto.ChildMenu;
import com.fincore.gateway.dto.MenuResponse;
import com.fincore.gateway.dto.PermissionRow;
import com.fincore.gateway.dto.RootMenu;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Builds navigational menu structures from permission entities or projections.
 *
 * <p>Responsibilities:</p>
 * <ul>
 *   <li>Group permissions by root menu title</li>
 *   <li>Create root and child menu DTOs</li>
 *   <li>Ensure deterministic ordering (by {@code orderId} / {@code permissionOrder})</li>
 *   <li>Be tolerant to missing/nullable sorting fields</li>
 * </ul>
 *
 * <p><strong>Ordering</strong>: Root menus and child menus are sorted in ascending order using their respective
 * order fields. Null order values are placed last to keep ordering stable.</p>
 *
 * <strong>UPDATED:</strong> Merges 'menuAction' for Root Menus with the same Title.
 */
@Slf4j
@Service
public class MenuService {

    /**
     * Returns a non-null order for {@link PermissionRow} (nulls go to the end).
     */
    private static int safePermissionOrder(PermissionRow r) {
        Integer v = r.getPermissionOrder();
        return v != null ? v : Integer.MAX_VALUE;
    }

    // --------------------------------------------------------------------------------------------
    // Builders
    // --------------------------------------------------------------------------------------------

    /**
     * Comparator key extractor for root menus.
     */
    private static int safeOrderIdRoot(RootMenu r) {
        Integer v = r.getOrderId();
        return v != null ? v : Integer.MAX_VALUE;
    }

    /**
     * Comparator key extractor for child menus.
     */
    private static int safeOrderIdChild(ChildMenu c) {
        Integer v = c.getOrderId();
        return v != null ? v : Integer.MAX_VALUE;
    }

    // --------------------------------------------------------------------------------------------
    // Null-safe order helpers
    // --------------------------------------------------------------------------------------------

    /**
     * Transforms a list of {@link PermissionRow} projections into a {@link MenuResponse}.
     * <p>Groups by {@code menuTitle}, creates root items, and child items from rows having a non-null {@code subMenu}.</p>
     *
     * @param rows permission projection rows (typically from a custom query join)
     * @return menu response with ordered root and child menus
     */
    public MenuResponse transformFromProjection(List<PermissionRow> rows) {
        MenuResponse response = new MenuResponse();

        if (rows == null || rows.isEmpty()) {
            response.setRoot_menus(Collections.emptyList());
            return response;
        }

        // Group by root menu title
        Map<String, List<PermissionRow>> grouped = rows.stream().collect(Collectors.groupingBy(PermissionRow::getMenuTitle));

        List<RootMenu> rootMenus = new ArrayList<>();

        for (Map.Entry<String, List<PermissionRow>> entry : grouped.entrySet()) {
            List<PermissionRow> group = entry.getValue();

            //1. Representative root row: choose the smallest non-null permissionOrder
            PermissionRow root = group.stream().min(Comparator.comparing(MenuService::safePermissionOrder)).orElse(group.get(0));

            RootMenu rootMenu = buildRootFromProjection(root);

            // 2. MERGE ROOT ACTIONS
            String mergedAction = group.stream().map(PermissionRow::getMenuAction)       // Get action from each row
                    .filter(Objects::nonNull)                // Ignore nulls
                    .flatMap(action -> Arrays.stream(action.split("\\|"))) // Split "create|modify"
                    .map(String::trim)                       // Clean spaces
                    .filter(s -> !s.isEmpty())               // Remove empty strings
                    .distinct()                              // Remove duplicates
                    .collect(Collectors.joining("|"));       // Join back to "create|modify|block"
            // Overwrite the single-row action with the merged action
            rootMenu.setMenuAction(mergedAction);

            // 3.  Children (only rows that actually represent a sub-menu), ordered by permissionOrder asc
            List<ChildMenu> children = group.stream().filter(r ->
                    r.getSubMenu() != null)
                    .map(this::buildChildFromProjection)
                    .sorted(Comparator.comparing(MenuService::safeOrderIdChild))
                    .collect(Collectors.toList());

            boolean multiChildren = children.size() > 1;
            rootMenu.setHasChildren(multiChildren);
            if (!multiChildren) {
                // children size is 0 or 1
                if (children.size() == 1) {
                    // promote the only child
                    rootMenu.setTitle(children.get(0).getTitle());
                }
            } else {
                // children > 1 â†’ set children normally
                rootMenu.setChildren(children);
            }
            // add root menu
            rootMenus.add(rootMenu);
        }

        // Order root menus as well
        rootMenus.sort(Comparator.comparing(MenuService::safeOrderIdRoot));

        response.setRoot_menus(rootMenus);
        return response;
    }

    private RootMenu buildRootFromProjection(PermissionRow r) {
        RootMenu root = new RootMenu();
        root.setId(r.getMenuId());
        root.setTitle(r.getMenuTitle());
        root.setIcon(r.getMenuIcon());
        root.setRoute(r.getMenuUrl());
        root.setMenuAction(r.getMenuAction());
        root.setComponentPath(r.getComponentPath());
        root.setScreenDescription(r.getMenuDescription());
        root.setOrderId(safePermissionOrder(r));
        root.setRequestType(r.getRequestType());
        return root;
    }

    private ChildMenu buildChildFromProjection(PermissionRow r) {
        ChildMenu c = new ChildMenu();
        c.setId(r.getMenuId());
        c.setTitle(r.getSubMenu());
        c.setIcon(r.getMenuIcon());
        c.setRoute(r.getMenuUrl());
        c.setComponentPath(r.getComponentPath());
        c.setScreenDescription(r.getMenuDescription());
        c.setMenuAction(r.getMenuAction());
        c.setRequestType(r.getRequestType());
        c.setOrderId(safePermissionOrder(r));
        return c;
    }
}











package com.fincore.gateway.Service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.ReactiveStringRedisTemplate;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.Objects;

/**
 * Validates JWT sessions against Redis using two key families:
 * <ul>
 *   <li><b>USR:&lt;username&gt;</b> â†’ stores the latest active JTI for the user</li>
 *   <li><b>BL:&lt;jti&gt;</b> â†’ blacklisted JTIs (revoked/expired/rotated)</li>
 * </ul>
 *
 * <p><strong>Workflow</strong></p>
 * <ol>
 *   <li><b>registerUserSession</b>: On login, blacklist any previous JTI and store the new one.</li>
 *   <li><b>validateWithRedis</b>: On each request, reject if blacklisted or if JTI != stored latest.</li>
 *   <li><b>clearUserSession</b>: On logout, remove the USR:&lt;user&gt; pointer.</li>
 *   <li><b>blacklistToken</b>: On logout or rotation, add JTI to blacklist.</li>
 * </ol>
 *
 * <p><strong>TTL</strong>: Keys are set to the same TTL as the JWT (configurable via
 * {@code security.jwt.ttl-seconds}).</p>
 */
@Component
public class TokenSessionValidator {

    private static final Logger log = LoggerFactory.getLogger(TokenSessionValidator.class);

    /** Redis key prefixes. */
    private static final String USER_PREFIX = "USR:";
    private static final String BLACKLIST_PREFIX = "BL:";

    private final ReactiveStringRedisTemplate redis;

    /** Token TTL aligned with JWT expiry. */
    private final Duration tokenTtl;

    public TokenSessionValidator(
            ReactiveStringRedisTemplate redis,
            @Value("${security.jwt.refresh-ttl-seconds:86400}") long refreshTtlSeconds // <--- Use Refresh TTL
    ) {
        this.redis = redis;
        this.tokenTtl = Duration.ofSeconds(refreshTtlSeconds); // Set Redis to live for 24h
    }

    // --------------------------------------------------------------------------------------------
    // Session management
    // --------------------------------------------------------------------------------------------

    /**
     * Register a new session for a user.
     * <ol>
     *   <li>If an old JTI exists for the user, blacklist it.</li>
     *   <li>Store the new JTI under {@code USR:<username>} with {@link #tokenTtl}.</li>
     * </ol>
     *
     * @param username the subject/username
     * @param newJti   the new token ID
     * @return completion signal
     */
    public Mono<Void> registerUserSession(String username, String newJti) {
        Objects.requireNonNull(username, "username must not be null");
        Objects.requireNonNull(newJti, "newJti must not be null");

        final String userKey = userKey(username);
        log.info("Registering new session user={} jti={}", username, newJti);

        return redis.opsForValue().get(userKey)
                .flatMap(oldJti -> {
                    if (oldJti != null) {
                        log.info("Found old session for user={} -> blacklisting oldJti={}", username, oldJti);
                        return blacklistToken(oldJti).then();
                    }
                    return Mono.empty();
                })
                .then(
                        redis.opsForValue()
                                .set(userKey, newJti, tokenTtl)
                                .doOnSuccess(v -> log.info("Registered session in Redis user={} jti={}", username, newJti))
                                .then()
                );
    }

    /**
     * Blacklist a JTI (used on logout or token rotation).
     *
     * @param jti token id
     * @return {@code true} if set succeeded
     */
    public Mono<Boolean> blacklistToken(String jti) {
        Objects.requireNonNull(jti, "jti must not be null");
        final String blKey = blacklistKey(jti);
        return redis.opsForValue().set(blKey, "true", tokenTtl)
                .doOnSuccess(v -> log.info("Blacklisted jti={}", jti));
    }

    /**
     * Clear the current session pointer for a user.
     *
     * @param username the subject/username
     * @return {@code true} if a key was deleted
     */
    public Mono<Boolean> clearUserSession(String username) {
        Objects.requireNonNull(username, "username must not be null");
        return redis.delete(userKey(username))
                .map(deleted -> {
                    if (deleted > 0) {
                        log.info("Cleared session for user={}", username);
                        return true;
                    }
                    return false;
                });
    }

    // --------------------------------------------------------------------------------------------
    // Request-time validation
    // --------------------------------------------------------------------------------------------

    /**
     * Validate an incoming {@link Authentication} against Redis:
     * <ul>
     *   <li>Reject if not a {@link JwtAuthenticationToken}</li>
     *   <li>Reject if JTI is blacklisted</li>
     *   <li>Reject if JTI != {@code USR:&lt;username&gt;} stored JTI</li>
     * </ul>
     *
     * @param authentication the Spring Security authentication (expected {@link JwtAuthenticationToken})
     * @return a {@link Mono} with the same {@code authentication} on success, or an error on failure
     */
    public Mono<Authentication> validateWithRedis(Authentication authentication) {
        if (!(authentication instanceof JwtAuthenticationToken jwtAuth)) {
            log.warn("Validation failed: not a JwtAuthenticationToken -> {}", authentication);
            return Mono.error(new BadCredentialsException("Invalid authentication type"));
        }

        Jwt jwt = jwtAuth.getToken();
        String username = jwt.getSubject();
        String jti = jwt.getId();

        if (username == null || username.isBlank()) {
            log.error("Token missing subject -> rejecting");
            return Mono.error(new BadCredentialsException("Missing subject (sub)"));
        }
        if (jti == null || jti.isBlank()) {
            log.error("Token missing JTI claim -> rejecting user={}", username);
            return Mono.error(new BadCredentialsException("Missing token ID (jti)"));
        }

        log.info("Validating token user={} jti={}", username, jti);

        // 1) Check blacklist
        return redis.hasKey(blacklistKey(jti))
                .flatMap(isBlacklisted -> {
                    if (Boolean.TRUE.equals(isBlacklisted)) {
                        log.warn("Token is blacklisted jti={} user={}", jti, username);
                        return Mono.error(new BadCredentialsException("Token revoked"));
                    }

                    // 2) Ensure JTI matches the latest session pointer
                    return redis.opsForValue().get(userKey(username))
                            .flatMap(currentJti -> {
                                log.debug("Redis stored JTI for user={} -> {}", username, currentJti);

                                if (currentJti == null) {
                                    log.warn("No active session in Redis for user={} -> rejecting", username);
                                    return Mono.error(new BadCredentialsException("No active session"));
                                }

                                if (!currentJti.equals(jti)) {
                                    log.warn("Token mismatch user={} expectedJti={} gotJti={}", username, currentJti, jti);
                                    return Mono.error(new BadCredentialsException("Another session is active"));
                                }

                                log.info("Token validation success user={} jti={}", username, jti);
                                return Mono.just(authentication);
                            });
                });
    }

    // --------------------------------------------------------------------------------------------
    // Key helpers
    // --------------------------------------------------------------------------------------------

    private static String userKey(String username) {
        return USER_PREFIX + username;
    }

    private static String blacklistKey(String jti) {
        return BLACKLIST_PREFIX + jti;
    }
}












package com.fincore.gateway.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.fincore.gateway.model.LoginAttempt;

/**
 * Repository interface for managing {@link LoginAttempt} entities.
 * <p>
 * This interface extends {@link JpaRepository} to provide standard CRUD operations
 * and adds a custom native query method to check for existing login attempts for a specific user.
 * </p>
 */
@Repository
public interface LoginAttemptRepository extends JpaRepository<LoginAttempt, Long> {

    /**
     * Checks if a user has any existing login attempts recorded in the database.
     * <p>
     * This method executes a native SQL query to count the number of records
     * in the {@code USER_LOGIN_ATTEMPTS} table for the given user ID.
     * </p>
     *
     * @param userId The unique identifier of the user to check.
     * @return The number of login attempts found for the specified user. A return value greater than 0 indicates the user is present in the attempts table.
     */
    @Query(value = "select count(1) from USER_LOGIN_ATTEMPTS where USER_ID =:userId ", nativeQuery = true)
    int getIfUserPresent(@Param("userId") String userId);

}










package com.fincore.gateway.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import com.fincore.gateway.model.LoginParam;

/**
 * Repository interface for managing {@link LoginParam} entities.
 * <p>
 * This interface extends {@link JpaRepository} to provide standard data access operations
 * and defines a custom native query method to retrieve the single configuration
 * entity that stores global login parameters. The primary key type is {@link Character},
 * suggesting a specific key (e.g., 'A' for Active parameters).
 * </p>
 */
@Repository
public interface LoginParamRepository extends JpaRepository<LoginParam, Character> {

    /**
     * Retrieves the single configuration entity containing system-wide login parameters.
     * <p>
     * This method executes a native SQL query to select all records from the
     * {@code LOGIN_PARAM} table. It is designed to return a single {@link LoginParam}
     * object, assuming the table only contains one such configuration record
     * (or that the application expects only one result).
     * </p>
     *
     * @return The single {@link LoginParam} entity containing the system's login parameters.
     */
    @Query(value = "Select * from LOGIN_PARAM", nativeQuery = true)
    LoginParam getLoginParam();
}














package com.fincore.gateway.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import com.fincore.gateway.model.MenuItems;

import java.util.List;

/**
 * Repository interface for managing {@link MenuItems} entities.
 * <p>
 * This interface extends {@link JpaRepository} to provide standard data access operations
 * for menu items, using {@link Integer} as the type for the entity's primary key.
 * </p>
 */
public interface MenuItemRepository extends JpaRepository<MenuItems, Integer> {

    // The following is an example of a custom method that could be added to this repository.
    // It is commented out in the original request, but included here for documentation purposes.

    /**
     * Retrieves a list of all menu items associated with a specific role ID, ordered by menu item ID.
     * <p>
     * This method uses a JPQL query to join the {@code MenuItems} entity with its associated
     * roles and filters the results based on the provided {@code roleId}.
     * </p>
     *
     * @param roleId The unique identifier of the user role.
     * @return A list of {@link MenuItems} accessible by the specified role.
     */
    // @Query("SELECT m FROM MenuItems m JOIN m.roles r WHERE r.ROLE_ID = :roleId ORDER BY m.id ASC")
    // List<MenuItems> findAllByRoleId(@Param("roleId") Integer roleId);
}











package com.fincore.gateway.repository;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.fincore.gateway.model.RefreshToken;

/**
 * Repository interface for managing {@link RefreshToken} entities (user sessions).
 * <p>
 * This interface extends {@link CrudRepository} to provide standard create, read, update,
 * and delete operations, and includes a custom native query method to retrieve the
 * most recent refresh token (session) for a given user.
 * </p>
 */
@Repository
public interface RefreshTokenRepository extends CrudRepository<RefreshToken, Long> {

    /**
     * Retrieves the latest active refresh token (user session) for a specified user ID.
     * <p>
     * This method executes a native SQL query against the {@code user_session} table.
     * It orders sessions by the start time in descending order and fetches only the
     * first row, effectively retrieving the most recent session.
     * </p>
     *
     * @param userId The unique identifier of the user whose latest session is to be retrieved.
     * @return The most recent {@link RefreshToken} entity for the user, or {@code null} if none is found.
     */
    @Query(value = "select * from user_session where user_id=:userId" +
            " order by session_started_at desc fetch first 1 rows only", nativeQuery = true)
    RefreshToken getLatestRefreshTokensByUserid(@Param("userId") String userId);
}













package com.fincore.gateway.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import com.fincore.gateway.dto.PermissionRow;
import com.fincore.gateway.model.Permissions;
import com.fincore.gateway.model.RolePermissions;

import java.util.List;

/**
 * Repository interface for managing {@link RolePermissions} entities and retrieving
 * related permission data based on user roles.
 * <p>
 * This interface extends {@link JpaRepository} to provide standard data access operations
 * and includes custom native queries to fetch menu items and permissions associated
 * with a specific user ID.
 * </p>
 */
public interface RolePermissionsRepository extends JpaRepository<RolePermissions, Integer> {

    /**
     * Retrieves a list of {@link Permissions} entities (menu items) associated with a specific user ID.
     * <p>
     * This native query joins {@code permissions}, {@code role_permissions}, and {@code user_roles}
     * tables to find all distinct menu items granted to the user through their roles, ordered
     * by the assigned permission order. This query maps results directly to the {@link Permissions} entity.
     * </p>
     *
     * @param userid The unique identifier of the user.
     * @return A list of {@link Permissions} objects representing the user's menu access.
     */
    @Query(nativeQuery = true, value = """
                        SELECT DISTINCT
                p.menu_id,
                p.menu_title,
                p.menu_icon,
                p.menu_submenu,
                p.menu_action,
                p.menu_url,
                p.menu_component_path,
                p.MENU_DESCRIPTION,
                p.menu_dependant,
                rp.permission_order
            FROM
                     permissions p
                JOIN role_permissions rp ON p.menu_id = rp.permission_id
                JOIN user_roles       ur ON ur.role_id = rp.role_id
            WHERE
                ur.user_id = :userid
            ORDER BY
            	rp.permission_order
            """)
    List<Permissions> findAllByUserId(@Param("userid") String userid);

    /**
     * Retrieves a list of permission details mapped to the Data Transfer Object {@link PermissionRow}
     * for a specific user ID.
     * <p>
     * Similar to {@link #findAllByUserId(String)}, this native query fetches all relevant permissions
     * but maps the selected columns to the {@link PermissionRow DTO} interface using SQL aliases
     * (JPA projection). The results are ordered by {@code rp.permission_order}.
     * </p>
     *
     * @param userId The unique identifier of the user.
     * @return A list of {@link PermissionRow} objects containing key details of the user's permissions.
     */
    @Query(value = """
                     SELECT DISTINCT
                         p.menu_id             AS menuid,
                         p.menu_title          AS menutitle,
                         p.menu_icon           AS menuicon,
                         p.menu_submenu        AS submenu,
                         p.menu_action         AS menuaction,
                         p.menu_url            AS menuurl,
                         p.menu_component_path AS componentpath,
                         p.menu_description    AS menudescription,
                         p.menu_dependant      AS dependant,
                         p.MAPPED_REQUEST_TYPE AS requestType,
                         rp.permission_order   AS permissionorder
                     FROM
                              permissions p
                         JOIN role_permissions rp ON p.menu_id = rp.permission_id
                         JOIN user_roles       ur ON ur.role_id = rp.role_id
                     WHERE
                         ur.user_id = :userid
                     ORDER BY
                         rp.permission_order
            """, nativeQuery = true)
    List<PermissionRow> findAllPermissionsByUserId(@Param("userid") String userId);
}
















package com.fincore.gateway.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.fincore.gateway.model.User;
import com.fincore.gateway.model.UserRoles;

/**
 * Repository interface for managing {@link User} entities.
 * <p>
 * This interface extends {@link JpaRepository} to provide standard data access operations
 * and includes custom methods for finding user details, roles, and checking user existence.
 * The primary key type for the User entity is {@link String}.
 * </p>
 */
@Repository
public interface UserRepository extends JpaRepository<User, String> {

    /**
     * Finds a user entity by their unique user ID.
     * <p>
     * Spring Data JPA automatically generates the query for this method based on the method name.
     * </p>
     *
     * @param userId The unique identifier of the user.
     * @return The {@link User} entity associated with the given userId, or {@code null} if not found.
     */
    User findByUserId(String userId);

    /**
     * Retrieves the role information for a specific user ID.
     * <p>
     * This native query joins the {@code user_roles} and {@code roles} tables to fetch
     * the user's role details. It assumes a user has a single primary role and uses
     * {@code fetch first 1 rows only} to ensure a single result is returned, mapped to
     * the {@link UserRoles} DTO/interface projection.
     * </p>
     *
     * @param userId The unique identifier of the user.
     * @return A {@link UserRoles} object containing the user's role ID, name, and status.
     */
    @Query(value = """
            select  u.user_id as USER_ID, u.role_id as ROLE_ID , r.role_name as ROLE_NAME ,r.ROLE_STATUS as ROLE_STATUS
            from  user_roles u join roles r on u.role_id = r.role_id
            where u.user_Id = :userId fetch first 1 rows only
            """, nativeQuery = true)
    UserRoles getUserRole(@Param("userId") String userId);

    /**
     * Checks if a user exists in the {@code USERS} table by counting records matching the user ID.
     *
     * @param userId The unique identifier of the user to check.
     * @return The count of users found. A value of 1 indicates the user exists.
     */
    @Query(value = "Select count(1) from USERS where USER_ID = :userId", nativeQuery = true)
    int checkUserExists(@Param("userId") String userId);

}
























package com.fincore.gateway.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import java.sql.Timestamp;

/**
 * Entity class that stores details of each user login attempt.
 * 
 * Maps to the USER_LOGIN_ATTEMPTS table and keeps track of
 * login activity such as user ID, login method, IP address,
 * timestamp, and whether the attempt was successful or not.
 */
@Entity
@Getter
@Setter
@Table(name = "USER_LOGIN_ATTEMPTS")
public class LoginAttempt {

    /** Primary key for the login attempt record. */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ATTEMPT_ID")
    private Long attemptId;

    /** ID of the user who tried to log in. */
    @Column(name = "USER_ID")
    private String userId;

    /** Type of login method used (e.g. PASSWORD, OTP, BIOMETRIC). */
    @Column(name = "LOGIN_METHOD")
    private String loginMethod;

    /** IP address from which the login attempt was made. */
    @Column(name = "IP_ADDRESS")
    private String ipAddress;

    /**
     * Timestamp when the login attempt occurred.
     * 
     * This is managed at the database level and not manually updated in code.
     */
    @Column(name = "ATTEMPT_TIME", nullable = false, updatable = false, insertable = false)
    private Timestamp attemptTime;

    /** Indicates if the login was successful (Y/N). */
    @Column(name = "SUCCESS")
    private String success;

    /** Reason for failure, if the attempt was not successful. */
    @Column(name = "FAILURE_REASON")
    private String failureReason;
}










package com.fincore.gateway.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

/**
 * Entity representing the system-wide login configuration paramters.
 * 
 * Maps to the LOGIN_PARAM table, which holds information such as
 * the active login mode, OTP validity period, password validity period,
 * allowed wrong attempts, and interval between attempts.
 */
@Entity
@Getter
@Setter
@ToString
@Table(name = "LOGIN_PARAM")
public class LoginParam {

    /** Defines the currently active login mode in the system. */
    @Id
    @Column(name = "ACTIVE_LOGIN_MODE")
    private char activeLoginMode;

    /** OTP validity period in minutes. */
    @Column(name = "OTP_VALIDITY")
    private int otpValidity;

    /** Password validity period in days. */
    @Column(name = "PASSWORD_VALIDITY")
    private int passwordValidity;

    /** Number of consecutive wrong password attemps allowed before blocking. */
    @Column(name = "WRONG_PASSWORD_ATTEMPTS")
    private int wrongPasswordAttempts;

    /** Time interval (in minutes) after which a new login attempt is allowed. */
    @Column(name = "ATTEMPT_INTERVAL")
    private int attemptInterval;
}











package com.fincore.gateway.model;

import jakarta.persistence.*;
import lombok.Data;

import java.util.List;
import java.util.Set;

/**
 * Entity representing a menu item in the application.
 * 
 * Each record in MENU_ITEMS defines a single menu entry â€” which may
 * have a parent (for nested menus), child items, or be directly linked
 * to a screen route. This structure helps build dynamic menu hierarchies
 * based on user roles and permissions.
 */
@Entity
@Table(name = "MENU_ITEMS")
@Data
public class MenuItems {

    /** Unique ID for the menu item. */
    @Id
    @Column(name = "MENU_ID")
    private Integer id;

    /** Display title of the menu item. */
    @Column(name = "MENU_TITLE")
    private String title;

    /** Icon name or path used for the menu item UI. */
    @Column(name = "MENU_ICON")
    private String icon;

    /** Route or navigation path associated with the menu item. */
    @Column(name = "MENU_ROUTE")
    private String route;

    /** Flag to indicate if this menu item contains child items. */
    @Column(name = "MENU_HAS_CHILDREN")
    private boolean hasChildren;

    // Embedded screen level details
    /** Screen ID linked with this menu item (if applicable). */
    @Column(name = "MENU_SCREEN_ID")
    private String screenId;

    /** Title of the screen linked with this menu item. */
    @Column(name = "MENU_SCREEN_TITLE")
    private String screenTitle;

    /** Route of the screen linked with this menu item. */
    @Column(name = "MENU_SCREEN_ROUTE")
    private String screenRoute;

    /**
     * Parent menu item, used for hierarchical navigation.
     * A menu can have zero or one parent.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "MENU_PARENT_ID")
    private MenuItems parent;

    /**
     * List of child menu items linked to this parent.
     * If the menu has no children, this list will be empty.
     */
    @OneToMany(mappedBy = "parent", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    private List<MenuItems> children;

    /**
     * Roles that have access to this menu item.
     * A menu item can be visible to multiple roles.
     */
    @ManyToMany(mappedBy = "accessibleMenuItems")
    private Set<UserRoles> roles;
}











package com.fincore.gateway.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

/**
 * Entity representing permission details for each menu or action in the system.
 * 
 * Maps to the PERMISSIONS table and defines information such as menu title,
 * icon, sub-menu, related action, and route path used within the application.
 */
@Entity
@Data
@Table(name = "PERMISSIONS")
public class Permissions {

    /** Unique ID for the menu or permission entry. */
    @Id
    @Column(name = "MENU_ID")
    private int menuId;

    /** Title displayed for this menu item or feature. */
    @Column(name = "MENU_TITLE")
    private String menuTitle;

    /** Icon associated with the menu item (used in UI). */
    @Column(name = "MENU_ICON")
    private String menuIcon;

    /** Name of the parent or sub menu this item belongs to. */
    @Column(name = "MENU_SUBMENU")
    private String subMenu;

    /** Specific action type or permission (like VIEW, EDIT, DELETE etc). */
    @Column(name = "MENU_ACTION")
    private String menuAction;

    /** URL path or endpoint linked with this menu. */
    @Column(name = "MENU_URL")
    private String menuUrl;

    /** Component path or frontend route used for navigation. */
    @Column(name = "MENU_COMPONENT_PATH")
    private String componentPath;

    /** Short description explaining what this permission or menu does. */
    @Column(name = "MENU_DESCRIPTION")
    private String menuDescription;

    /** Indicates if this menu depends on another one. */
    @Column(name = "MENU_DEPENDANT")
    private String dependent;

    /** Order in which the menu appears in UI. */
    private int orderId;
}










package com.fincore.gateway.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import java.sql.Timestamp;

/**
 * Entity representing user session details along with the refresh token.
 * 
 * Maps to USER_SESSION table and keeps track of when a session was started,
 * ended, and from which device it was initiated.
 */
@Entity
@Getter
@Setter
@Table(name = "USER_SESSION")
public class RefreshToken {

    /** Primary key for the user session. */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "SESSION_ID")
    private Long sessionId;

    /** Unique ID of the user associated with this session. */
    @Column(name = "USER_ID")
    private String userId;

    /** Refresh token assigned to the current session. */
    @Column(name = "REFRESH_TOKEN")
    private String refreshToken;

    /** Timestamp indicating when the session started. */
    @Column(name = "SESSION_STARTED_AT", insertable = false, updatable = false)
    private Timestamp sessionStartedAt;

    /** Timestamp indicating when the session ended. */
    @Column(name = "SESSION_ENDED_AT")
    private Timestamp sessionEndedAt;

    /** Device identifier or token from which session was created. */
    @Column(name = "DEVICE_ID")
    private String deviceId;
}










package com.fincore.gateway.model;

import jakarta.persistence.*;
import lombok.Data;

/**
 * Entity representing the mapping between roles and permissions.
 * 
 * Each entry defines which permission belongs to which role.
 * This acts as a bridge table between USER_ROLES and PERMISSIONS.
 */
@Entity
@Data
@Table(name = "ROLE_PERMISSIONS")
public class RolePermissions {

    /** ID of the role. */
    @Id
    @Column(name = "ROLE_ID")
    private int roleId;

    /** ID of the permission linked to the role. */
    @Column(name = "PERMISSION_ID")
    private int permissionId;
}









package com.fincore.gateway.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

import java.sql.Timestamp;

/**
 * Entity representing a user in the system.
 * 
 * Holds user profile information, credentials, and audit details
 * such as creation date, last login, and deletion timestamp.
 */
@Data
@Entity
@Table(name = "USERS")
public class User {

    /** Unique identifier for the user. */
    @Id
    @Column(name = "USER_ID")
    private String userId;

    /** First name of the user. */
    @Column(name = "FIRST_NAME")
    private String firstName;

    /** Middle name, if provided. */
    @Column(name = "MIDDLE_NAME")
    private String middleName;

    /** Last name of the user. */
    @Column(name = "LAST_NAME")
    private String lastName;

    /** Registered phone number of the user. */
    @Column(name = "PHONE_NUMBER")
    private String phoneNumber;

    /** Email address used for login or notifications. */
    @Column(name = "EMAIL")
    private String email;

    /** Encrypted password hash used for authentication. */
    @Column(name = "PASSWORD_HASH")
    private String passwordHash;

    /** Current status of the account (e.g. ACTIVE, INACTIVE, LOCKED). */
    @Column(name = "ACCOUNT_STATUS")
    private String accountStatus;

    /** Timestamp when the user record was created. */
    @Column(name = "CREATED_AT")
    private Timestamp createdAt;

    /** Timestamp when the record was last updated. */
    @Column(name = "UPDATED_AT")
    private Timestamp updatedAt;

    /** Timestamp of the user's last successful login. */
    @Column(name = "LAST_LOGIN_AT")
    private Timestamp lastLoginAt;

    /** Flag to indicate soft delete status (Y/N). */
    @Column(name = "IS_DELETED")
    private String isDeleted;

    /** Timestamp when the user was marked as deleted. */
    @Column(name = "DELETED_AT")
    private Timestamp deletedAt;

    /** When the temporary password was last set, if applicable. */
    @Column(name = "TEMP_PASSWORD_SET_AT")
    private Timestamp tempPasswordSetAt;

    /** Count of consecutive wrong password attempts. */
    @Column(name = "USER_WRONG_PASSWORD_COUNT")
    private int userWrongPasswordCount;

    /** Branch or location code assigned to the user. */
    @Column(name = "BRANCH")
    private int branch;

    /** Indicates if password login is enabled or not. */
    @Column(name = "PASSWORD_LOGIN")
    private String passwordLogin;
}








package com.fincore.gateway.model;

import jakarta.persistence.*;
import lombok.Data;

import java.util.Set;

/**
 * Entity representing the roles assigned within the system.
 * 
 * Each role defines a set of permissions and accessible menu items.
 * Roles are linked to users and control access levels across the app.
 */
@Data
@Entity
@Table(name = "ROLES")
public class UserRoles {

    /** Unique ID assigned to the role. */
    @Id
    @Column(name = "ROLE_ID")
    private Integer role;

    /** Name of the role (e.g. ADMIN, MANAGER, USER). */
    @Column(name = "ROLE_NAME")
    private String roleName;

    /** ID of the user to whom this role belongs. */
    @Column(name = "USER_ID")
    private String userId;

    /** Status of the role (e.g. ACTIVE, INACTIVE). */
    @Column(name = "ROLE_STATUS")
    private String roleStatus;

    /**
     * Menu items this role has access to.
     * Defines many-to-many mapping between roles and menu items.
     */
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name = "ROLE_MENU_ACCESS",
            joinColumns = @JoinColumn(name = "ROLE_ID"),
            inverseJoinColumns = @JoinColumn(name = "MENU_ITEM_ID")
    )
    private Set<MenuItems> accessibleMenuItems;
}












package com.fincore.gateway.JwtUtil;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;

import javax.crypto.SecretKey;
import java.time.Instant;
import java.util.Base64;
import java.util.Date;
import java.util.Map;
import java.util.UUID;

/**
 * Utility class for generating HMAC-SHA256 (HS256) JSON Web Tokens (JWTs).
 * <p>
 * This class provides a method to create signed JWTs for authentication and authorization purposes.
 * It is marked with {@code @Slf4j} for logging capabilities.
 * </p>
 */
@Slf4j
public final class HmacJwtUtil {

    /**
     * Private constructor to prevent instantiation of this utility class.
     */
    private HmacJwtUtil() {
    }

    /**
     * Generates a signed JSON Web Token (JWT) using the HS256 algorithm.
     * <p>
     * The token includes a subject, unique ID (JTI), issue time, expiration time,
     * and custom user data as claims. The secret key for signing must be provided
     * in Base64 encoded format.
     * </p>
     *
     * @param base64Secret The Base64 encoded secret key used for signing the JWT (HS256).
     * @param subject The principal subject of the token (e.g., a user ID or username).
     * @param ttlSeconds The time-to-live for the token in seconds from the current time.
     * @param UserData A {@link Map} containing custom claims (user data) to be included in the token payload.
     * @return A compact, signed JWT string.
     */
    public static String generate(String base64Secret, String subject, long ttlSeconds, Map<String,Object> UserData) {
        // Decode the Base64 secret to a byte array
        byte[] secret = Base64.getDecoder().decode(base64Secret);
        // Create an HMAC secret key object from the byte array
        SecretKey key = Keys.hmacShaKeyFor(secret);

        Instant now = Instant.now();
        Instant exp = now.plusSeconds(ttlSeconds);
        log.info("Generated exp in Seconds={}", exp);
        String jti = UUID.randomUUID().toString();
        log.info("Jti generated={}", jti);

        // Build the JWT token
        return Jwts.builder()
                .setClaims(UserData)                 // Set custom user data claims
                .setSubject(String.valueOf(subject)) // Set the subject claim
                .id(jti)                             // Set the unique JWT ID (jti)
                .issuedAt(Date.from(now))            // Set the issued at time (iat)
                .expiration(Date.from(exp))          // Set the expiration time (exp)
                .signWith(key)                       // Sign the token using the HS256 key
                .compact();                          // Compact the token into its final string form
    }
}










package com.fincore.gateway.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Getter;

import java.time.Instant;

/**
 * A generic Data Transfer Object (DTO) used for standardizing API responses across the application.
 * It encapsulates the result of an operation, a message, optional data payload, and a timestamp.
 * <p>
 * The {@link JsonInclude} annotation ensures that fields with {@code null} values are
 * omitted when serializing this object to JSON, making the response payload cleaner.
 * </p>
 *
 * @param <T> The type of the data payload contained within the response.
 */
@Getter
@JsonInclude(JsonInclude.Include.NON_NULL) // Don't include null fields in the JSON response
public class ApiResponse<T> {

    /**
     * Indicates whether the API request was successful (true) or failed (false).
     */
    private final boolean success;

    /**
     * A descriptive message related to the outcome of the request.
     */
    private final String message;

    /**
     * The actual data payload returned by the API (e.g., a User object, a list of items).
     * This field is often null for error responses or simple success confirmations.
     */
    private final T data;

    /**
     * The timestamp indicating when the response was generated.
     */
    private final Instant timestamp;

    /**
     * Private constructor used internally by the static factory methods.
     *
     * @param success The success status.
     * @param message The response message.
     * @param data The data payload.
     */
    private ApiResponse(boolean success, String message, T data) {
        this.success = success;
        this.message = message;
        this.data = data;
        this.timestamp = Instant.now();
    }

    /**
     * Factory method to create a successful API response with a custom message and data payload.
     *
     * @param data The data payload to include in the response.
     * @param message A custom success message.
     * @param <T> The type of the data payload.
     * @return A new {@link ApiResponse} instance for a successful operation.
     */
    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, message, data);
    }

    /**
     * Factory method to create a successful API response with data payload and a default success message.
     *
     * @param data The data payload to include in the response.
     * @param <T> The type of the data payload.
     * @return A new {@link ApiResponse} instance for a successful operation.
     */
    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, "Operation completed successfully.", data);
    }

    /**
     * Factory method to create an error API response with a specific error message and a null data payload.
     *
     * @param message The error message describing the failure.
     * @param <T> The expected type of the data payload (which will be null).
     * @return A new {@link ApiResponse} instance for a failed operation.
     */
    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(false, message, null);
    }
}









package com.fincore.gateway.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Data Transfer Object (DTO) representing a child menu item within a hierarchical menu structure.
 * This class is used to structure the menu data returned to the client application.
 *
 * <p>
 * Uses Lombok annotations for boilerplate code reduction:
 * <ul>
 *     <li>{@code @Data} generates getters, setters, equals, hashCode, and toString methods.</li>
 *     <li>{@code @NoArgsConstructor} generates a no-argument constructor.</li>
 *     <li>{@code @AllArgsConstructor} generates a constructor with all fields as arguments.</li>
 * </ul>
 * </p>
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChildMenu {

    /**
     * The unique identifier for the menu item. Corresponds to a permission ID in the database.
     */
    private int id;

    /**
     * The title or display name of the menu item shown in the UI.
     */
    private String title;

    /**
     * The name of the icon to be used for this menu item in the UI.
     */
    private String icon;

    /**
     * The client-side route or URL fragment used for navigation to this menu item's view/screen.
     */
    private String route;

    // A field for ScreenDetails was commented out in the original source.
    // private ScreenDetails screenDetails;

    /**
     * The internal path to the frontend component that corresponds to this menu item.
     */
    private String componentPath;

    /**
     * A brief description of what the screen/menu item does.
     */
    private String screenDescription;

    /**
     * The display order of this child menu item within its parent menu or list.
     */
    private int orderId;

    private String menuAction;

    private String requestType;
}












package com.fincore.gateway.dto;

import lombok.Builder;
import lombok.Data;

/**
 * Data Transfer Object (DTO) used to carry the response data after a successful or failed login attempt.
 * It implements the {@link UserLoginDTO} interface and provides comprehensive details about the
 * authenticated user, generated tokens, and login status.
 *
 * <p>
 * Uses Lombok annotations for boilerplate code reduction:
 * <ul>
 *     <li>{@code @Data} generates getters, setters, equals, hashCode, and toString methods.</li>
 *     <li>{@code @Builder} provides a fluent API for creating instances of this DTO.</li>
 * </ul>
 * </p>
 */
@Data
@Builder
public class LoginResponseDTO implements UserLoginDTO {

    /**
     * The unique identifier of the authenticated user.
     */
    private String userId;

    /**
     * The generated JWT access token used for subsequent authorized requests.
     */
    private String accessToken;

    /**
     * The type of the token, typically "Bearer".
     */
    private String tokenType;

    /**
     * The time until the access token expires, in seconds.
     */
    private long expiresIn;

    /**
     * The subject of the JWT (usually the user ID or username).
     */
    private String sub;

    /**
     * The unique JWT ID (JTI) for session tracking.
     */
    private String jti;

    /**
     * A structured object containing the menu and permissions data associated with the user's role.
     */
    private MenuResponse roleData;

    /**
     * An error message provided in case of a login failure (e.g., bad credentials, locked account).
     */
    private String error;

    /**
     * A flag indicating whether the provided credentials were fundamentally valid.
     */
    private boolean validCredentials;

    /**
     * The current status of the user account (e.g., ACTIVE, INACTIVE, LOCKED).
     */
    private String userStatus;

    /**
     * The status specific to the password validation result (e.g., SUCCESS, EXPIRED, TEMP_PASSWORD).
     */
    private String passwordLoginStatus;
}













package com.fincore.gateway.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Data;

import java.util.List;

/**
 * Data Transfer Object (DTO) representing a single menu item within a hierarchical menu structure.
 * This class is designed to be recursive, allowing for nested menu items (parent menus with children).
 * <p>
 * The {@link JsonInclude} annotation ensures that fields with {@code null} values (e.g., a null list of children for a leaf node)
 * are omitted when serializing this object to JSON.
 * </p>
 * <p>
 * Uses Lombok's {@code @Data} annotation to automatically generate getters, setters,
 * equals, hashCode, and toString methods.
 * </p>
 */
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
public class MenuDto {

    /**
     * The unique identifier for the menu item.
     */
    private Integer id;

    /**
     * The title or display name of the menu item shown in the UI.
     */
    private String title;

    /**
     * The name of the icon to be used for this menu item in the UI.
     */
    private String icon;

    /**
     * The client-side route or URL fragment used for navigation when this item is clicked.
     */
    private String route;

    /**
     * A flag indicating whether this menu item acts as a parent/submenu container.
     */
    private Boolean hasChildren;

    /**
     * Details about the specific screen or component associated with this menu item, if applicable.
     */
    private ScreenDetailsDto screenDetails;

    /**
     * A list of child menu items, forming the nested structure. This field will be null or excluded from JSON
     * if {@code hasChildren} is false.
     */
    private List<MenuDto> children;

    // Lombok handles the boilerplate Constructor, Getters, and Setters...
}











package com.fincore.gateway.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * Data Transfer Object (DTO) used to structure the complete menu configuration returned to the client
 * after a successful login or during application initialization. It acts as a container for
 * a list of top-level (root) menu items.
 *
 * <p>
 * Uses Lombok annotations for boilerplate code reduction:
 * <ul>
 *     <li>{@code @Data} generates getters, setters, equals, hashCode, and toString methods.</li>
 *     <li>{@code @NoArgsConstructor} generates a no-argument constructor.</li>
 *     <li>{@code @AllArgsConstructor} generates a constructor with all fields as arguments.</li>
 * </ul>
 * </p>
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class MenuResponse {

    /**
     * A list of {@link RootMenu} DTOs, representing the top-level navigation structure of the application
     * accessible by the user's role.
     */
    private List<RootMenu> root_menus;
}










package com.fincore.gateway.dto;


/**
 * Projection interface used by Spring Data JPA repositories to retrieve specific,
 * mapped columns from a native database query result.
 * <p>
 * This interface defines the contract for accessing data returned by the
 * {@link com.fincore.gateway.repository.RolePermissionsRepository#findAllPermissionsByUserId(String) RolePermissionsRepository.findAllPermissionsByUserId}
 * method, mapping SQL aliases to Java method names (e.g., SQL column {@code menuId} maps to {@code getMenuId()}).
 * This pattern is often referred to as a "DTO projection" or "interface projection" in Spring Data JPA documentation.
 * </p>
 */
public interface PermissionRow {

    /**
     * Retrieves the menu item's unique identifier.
     * Corresponds to the SQL column aliased as {@code menuId}.
     *
     * @return The menu ID.
     */
    int getMenuId();

    /**
     * Retrieves the display title of the menu item.
     * Corresponds to the SQL column aliased as {@code menuTitle}.
     *
     * @return The menu title.
     */
    String getMenuTitle();

    /**
     * Retrieves the icon identifier for the menu item.
     * Corresponds to the SQL column aliased as {@code menuIcon}.
     *
     * @return The menu icon name/path.
     */
    String getMenuIcon();

    /**
     * Indicates if this item is a submenu/parent item.
     * Corresponds to the SQL column aliased as {@code subMenu}.
     *
     * @return A string indicating submenu status (e.g., "Y" or "N").
     */
    String getSubMenu();

    /**
     * Retrieves the action associated with the menu item (e.g., READ, WRITE).
     * Corresponds to the SQL column aliased as {@code menuAction}.
     *
     * @return The associated action string.
     */
    String getMenuAction();

    /**
     * Retrieves the URL path for client-side routing.
     * Corresponds to the SQL column aliased as {@code menuUrl}.
     *
     * @return The destination URL.
     */
    String getMenuUrl();

    /**
     * Retrieves the internal application component path.
     * Corresponds to the SQL column aliased as {@code componentPath}.
     *
     * @return The path to the UI component.
     */
    String getComponentPath();

    /**
     * Retrieves the description of the menu item/screen.
     * Corresponds to the SQL column aliased as {@code menuDescription}.
     *
     * @return The menu description.
     */
    String getMenuDescription();

    /**
     * Retrieves the ID of a parent or dependent menu item if this item is hierarchical.
     * Corresponds to the SQL column aliased as {@code dependant}.
     *
     * @return The ID of the dependent item, or null/empty if none.
     */
    String getDependant();

    /**
     * Retrieves the x-request type for gateway level validation.
     * Corresponds to the SQL column aliased as {@code requestType}.
     *
     * @return The requestType of item, or null/empty if none.
     */
    String getRequestType();

    /**
     * Retrieves the order in which the menu item should be displayed.
     * Corresponds to the SQL column aliased as {@code permissionOrder}.
     *
     * @return The display order ID.
     */
    int getPermissionOrder();

}









package com.fincore.gateway.dto;

import java.util.List;

import com.fincore.gateway.model.Permissions;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Data Transfer Object (DTO) used to represent detailed role information,
 * including a list of associated permissions. This is typically used when
 * retrieving or managing user roles within the system.
 *
 * <p>
 * Uses Lombok annotations for boilerplate code reduction:
 * <ul>
 *     <li>{@code @Data} generates getters, setters, equals, hashCode, and toString methods.</li>
 *     <li>{@code @NoArgsConstructor} generates a no-argument constructor.</li>
 *     <li>{@code @AllArgsConstructor} generates a constructor with all fields as arguments.</li>
 * </ul>
 * </p>
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RoleDto {

    /**
     * The unique identifier for the role.
     */
    private Integer role;

    /**
     * The descriptive name of the role (e.g., "ADMIN", "USER", "MANAGER").
     */
    private String roleName;

    /**
     * The ID of the user associated with this specific role assignment instance,
     * if the context is user-specific role management.
     */
    private String userId;

    /**
     * The current status of the role (e.g., "ACTIVE", "INACTIVE").
     */
    private String roleStatus;

    /**
     * A list of {@link Permissions} entities granted by this role.
     */
    private List<Permissions> permissions;

}







package com.fincore.gateway.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * Data Transfer Object (DTO) representing a top-level (root) menu item in a hierarchical navigation structure.
 * This class typically holds references to a list of {@link ChildMenu} DTOs.
 *
 * <p>
 * Uses Lombok annotations for boilerplate code reduction:
 * <ul>
 *     <li>{@code @Data} generates getters, setters, equals, hashCode, and toString methods.</li>
 *     <li>{@code @NoArgsConstructor} generates a no-argument constructor.</li>
 *     <li>{@code @AllArgsConstructor} generates a constructor with all fields as arguments.</li>
 * </ul>
 * </p>
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RootMenu {

    /**
     * The unique identifier for the root menu item.
     */
    private int id;

    /**
     * The title or display name of the root menu item shown in the UI.
     */
    private String title;

    /**
     * The name of the icon to be used for this root menu item.
     */
    private String icon;

    /**
     * The client-side route or URL fragment for this menu item.
     */
    private String route;

    /**
     * A flag indicating whether this root menu item contains nested child menus.
     */
    private boolean hasChildren;

    // A field for ScreenDetails was commented out in the original source.
    // private ScreenDetails screenDetails;

    /**
     * The internal path to the frontend component associated with this root menu item.
     */
    private String componentPath;

    /**
     * A brief description of the screen or functionality provided by this menu item.
     */
    private String screenDescription;

    /**
     * The display order ID for positioning this root menu item in the main navigation bar/list.
     */
    private int orderId;

    /**
     * The display menu action for special access in root menu item in the main navigation bar/list.
     */
    private String menuAction;

    /**
     * The display x-requestType for root menu item in the main navigation bar/list.
     */
    private String requestType;

    /**
     * A list of {@link ChildMenu} DTOs representing the sub-items within this root menu.
     */
    private List<ChildMenu> children;
}












package com.fincore.gateway.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Data Transfer Object (DTO) holding detailed metadata about a specific application screen or view.
 * This DTO is typically nested within menu-related DTOs (like {@link MenuDto} or {@link RootMenu})
 * to provide context about where a menu item navigates.
 *
 * <p>
 * Uses Lombok annotations for boilerplate code reduction:
 * <ul>
 *     <li>{@code @Data} generates getters, setters, equals, hashCode, and toString methods.</li>
 *     <li>{@code @NoArgsConstructor} generates a no-argument constructor.</li>
 *     <li>{@code @AllArgsConstructor} generates a constructor with all fields as arguments.</li>
 * </ul>
 * </p>
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ScreenDetails {

    /**
     * A unique identifier for the screen (e.g., a technical ID or database key).
     */
    private String screenId;

    /**
     * The human-readable title of the screen as displayed in the application UI.
     */
    private String screenTitle;

    /**
     * The file path or identifier pointing to the actual frontend component implementation.
     */
    private String componentPath;

    /**
     * A brief description of the screen's purpose or functionality.
     */
    private String description;
}













package com.fincore.gateway.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Data;

/**
 * DTO representing basic details of a screen or component.
 * 
 * Used mainly for transferring limited screen metadata,
 * typically for menu or UI rendering responses.
 */
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ScreenDetailsDto {

    /** Unique identifier of the screen. */
    private String screenId;

    /** Title displayed for the screen in the UI. */
    private String screenTitle;

    /** Path or route of the frontend component. */
    private String componentPath;
}










package com.fincore.gateway.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO used for handling password update requests and responses.
 *
 * Carries basic details like userId, password, OTP, and a flag
 * indicating whether the password was successfully updated or not.
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class UpdatePasswordDTO {

    /** Unique ID of the user performing password update. */
    private String userId;

    /** Message describing update status or additional info. */
    private String message;

    /** The new password to be set for the user. */
    private String password;

    /** Flag that indicates if password update was successful. */
    private boolean updateFlag;

    /** OTP value used for verifying the password change. */
    private String otp;
}












package com.fincore.gateway.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;

/**
 * DTO that represents user details along with login and token info.
 *
 * Used across authentication and profile flows for passing
 * consolidated user information between layers.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserDto implements UserLoginDTO {

    /** Unique identifier for the user. */
    private String userId;

    /** Role ID or level assigned to the user. */
    private int userrole;

    /** First name of the user. */
    private String firstName;

    /** Middle name of the user, if provided. */
    private String middleName;

    /** Last name of the user. */
    private String lastName;

    /** Registered phone number. */
    private String phoneNumber;

    /** User's email address. */
    private String email;

    /** Stored password hash for authentication. */
    private String passwordHash;

    /** Plain password (usually used temporarily during validation). */
    private String password;

    /** Current role status (ACTIVE / INACTIVE). */
    private String roleStatus;

    /** Timestamp when the account was created. */
    private Timestamp createdAt;

    /** Timestamp when the user record was last updated. */
    private Timestamp updatedAt;

    /** Timestamp of the userâ€™s last successful login. */
    private Timestamp lastLoginAt;

    /** Soft delete flag (Y/N). */
    private String isDeleted;

    /** Timestamp when the user was deleted (if applicable). */
    private Timestamp deletedAt;

    /** Time when a temporary password was last set. */
    private Timestamp tempPasswordSetAt;

    /** Number of failed password attempts. */
    private int userWrongPasswordCount;

    /** Branch or location code associated with the user. */
    private int branch;

    /** Optional status message returned from operations. */
    private String message;

    /** Login method used (P - Password, O - OTP, etc.). */
    private char loginMethod;

    /** Current status of the user account. */
    private String userStatus;

    /** Access token issued after login. */
    private String accessToken;

    /** Refresh token for renewing session without re-login. */
    private String refreshToken;

    /** Flag indicating if the password needs to be updated. */
    private boolean updatePassword;

    /** Whether the user exists and is valid in system. */
    private boolean userCheck;

    /** Remaining attempts before account lockout. */
    private int attemptsLeft;

    /** True if credentials are valid during authentication. */
    private boolean validCredentials;

    /** Status of password login attempt. */
    private String passwordLoginStatus;

    /** Token-related data, if available. */
    private UserTokenDataDto user;
}













package com.fincore.gateway.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO that carries minimal user data embedded inside a token.
 *
 * This object is typically serialized within access or refresh tokens
 * to represent the authenticated user's identity and basic profile info.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserTokenDataDto {

    /** Unique identifier of the user. */
    private String userId;

    /** Numeric role ID assigned to the user. */
    private Integer role;

    /** Name of the role (e.g. ADMIN, MANAGER, USER). */
    private String roleName;

    /** First name of the user. */
    private String firstName;

    /** Middle name, if provided. */
    private String middleName;

    /** Last name of the user. */
    private String lastName;

    /** Contact number registered with the user. */
    private String phoneNumber;

    /** Email address associated with the user account. */
    private String email;

    /** Branch or office code where the user is mapped. */
    private int branch;
}








package com.fincore.gateway.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO used during user verification process.
 *
 * Contains essential details about the userâ€™s login state,
 * role validation, and password update requirements.
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class VerifyUserDTO {

    /** Unique ID of the user being verified. */
    private String userId;

    /** Message conveying status or feedback from verification. */
    private String message;

    /** Login method used (P - Password, O - OTP, etc.). */
    private char loginMethod;

    /** Current status of the user account. */
    private String userStatus;

    /** Current status of the user's role (ACTIVE / INACTIVE). */
    private String roleStatus;

    /** Indicates if user needs to update their password. */
    private boolean updatePassword;

    /** Whether the user exists and passes basic checks. */
    private boolean userCheck;

    /** Status of password login attempt. */
    private String passwordLoginStatus;
}















package com.fincore.gateway.Config;

import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.interfaces.RSAPublicKey;
import java.util.Base64;

/**
 * Configuration class responsible for dynamically creating a {@link ReactiveJwtDecoder}
 * based on the configured security mode (HMAC or RSA).
 * <p>
 * This configuration allows switching between HMAC-SHA256 (HS256) and
 * RSA-SHA256 (RS256) token verification mechanisms solely by changing
 * properties in the application configuration file.
 * </p>
 * <p>
 * Supported modes and required properties:
 * <ul>
 *     <li>{@code mode=hmac}: Requires {@code security.jwt.hmac-base64-secret} (Base64 encoded secret bytes >= 256-bit).</li>
 *     <li>{@code mode=rsa}: Requires {@code security.jwt.rsa-public} (PEM formatted public key).</li>
 * </ul>
 * </p>
 */
@Configuration
public class JwtDecoderConfig {

    /**
     * The configured JWT mode (e.g., "hmac" or "rsa"). Defaults to "hmac".
     */
    @Value("${security.jwt.mode:hmac}")
    private String mode;

    /**
     * The Base64 encoded secret used for HMAC verification. Required if mode is "hmac".
     */
    @Value("${security.jwt.hmac-base64-secret:}")
    private String hmacBase64Secret;

    /**
     * The PEM-encoded RSA public key used for RSA verification. Required if mode is "rsa".
     */
    @Value("${security.jwt.rsa-public:}")
    private String rsaPublicPem;

    /**
     * Performs sanity checks on the configuration properties after injection is complete.
     * Ensures that the necessary properties for the selected {@code mode} are present and valid,
     * throwing an {@link IllegalStateException} if configuration is invalid.
     */
    @PostConstruct
    void sanity() {
        if ("hmac".equalsIgnoreCase(mode)) {
            if (hmacBase64Secret == null || hmacBase64Secret.isBlank()) {
                throw new IllegalStateException("HMAC mode selected but security.jwt.hmac-base64-secret is empty");
            }
        } else if ("rsa".equalsIgnoreCase(mode)) {
            if (rsaPublicPem == null || rsaPublicPem.isBlank()) {
                throw new IllegalStateException("RSA mode selected but security.jwt.rsa-public is empty");
            }
        } else {
            // Catches any mode that is neither 'hmac' nor 'rsa'
            throw new IllegalStateException("Unsupported security.jwt.mode: " + mode + " (use 'hmac' or 'rsa')");
        }
    }

    /**
     * Configures and provides a {@link ReactiveJwtDecoder} bean based on the application's
     * configured {@code security.jwt.mode}.
     *
     * @return A {@link NimbusReactiveJwtDecoder} configured with the appropriate verification key (HMAC secret or RSA public key).
     */
    @Bean
    public ReactiveJwtDecoder jwtDecoder() {
        if ("hmac".equalsIgnoreCase(mode)) {
            // Decode base64 secret to raw bytes and create a SecretKey for HS256 verification
            byte[] secretBytes = Base64.getDecoder().decode(hmacBase64Secret);
            SecretKey key = new SecretKeySpec(secretBytes, "HmacSHA256");
            return NimbusReactiveJwtDecoder.withSecretKey(key).build();
        } else {
            // Parse RSA public key from PEM format for RS256 verification
            RSAPublicKey publicKey = KeyUtils.parseRsaPublicKey(rsaPublicPem);
            return NimbusReactiveJwtDecoder.withPublicKey(publicKey).build();
        }
    }
}








package com.fincore.gateway.Config;

import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

/**
 * Utility class for handling cryptographic keys, specifically for parsing
 * PEM-formatted RSA public keys into Java's {@link RSAPublicKey} object format.
 */
public class KeyUtils {

    /**
     * Parses a PEM (Privacy Enhanced Mail) formatted String containing an RSA public key
     * into a standard {@link RSAPublicKey} object.
     * <p>
     * This method handles removing standard PEM headers/footers and whitespace before
     * decoding the Base64 content and generating the key specification.
     * </p>
     *
     * @param pem The PEM formatted public key string (e.g., including "-----BEGIN PUBLIC KEY-----" headers).
     * @return The resulting {@link RSAPublicKey} object.
     * @throws IllegalArgumentException if the provided PEM string is invalid, poorly formatted,
     *                                  or does not represent a valid RSA public key.
     */
    public static RSAPublicKey parseRsaPublicKey(String pem) {
        try {
            // Remove PEM headers, footers, and all whitespace
            String clean = pem
                    .replace("-----BEGIN PUBLIC KEY-----", "")
                    .replace("-----END PUBLIC KEY-----", "")
                    .replaceAll("\\s", "");

            // Decode the Base64 content into raw bytes
            byte[] decoded = Base64.getDecoder().decode(clean);

            // Define the key specification using X509 encoding (standard for public keys)
            X509EncodedKeySpec spec = new X509EncodedKeySpec(decoded);

            // Get an instance of the RSA KeyFactory and generate the public key
            KeyFactory kf = KeyFactory.getInstance("RSA");
            return (RSAPublicKey) kf.generatePublic(spec);

        } catch (NoSuchAlgorithmException e) {
            // RSA algorithm is expected to be present in standard JVMs
            throw new IllegalStateException("RSA algorithm not available in the runtime environment", e);
        } catch (InvalidKeySpecException e) {
            // Thrown if the decoded bytes do not form a valid RSA public key structure
            throw new IllegalArgumentException("Invalid RSA public key specification provided in PEM string", e);
        }
    }
}











package com.fincore.gateway.Config;


import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.StringRedisTemplate;

@Configuration
public class RedisConfig {

    /**
     * Provides a StringRedisTemplate if the main application hasn't defined one.
     * This is crucial for the RbacFilter to work out-of-the-box.
     */
    @Bean
    @ConditionalOnMissingBean
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {
        return new StringRedisTemplate(connectionFactory);
    }
}











package com.fincore.gateway.Config;

import com.fincore.gateway.Service.TokenSessionValidator;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpStatus;
import org.springframework.security.config.Customizer;
// import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity; // Commented out in source
import org.springframework.security.config.web.server.SecurityWebFiltersOrder;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.Set;

/**
 * Security configuration class for the Spring WebFlux application.
 * This class defines the security filter chain, handles authentication logic,
 * and integrates a custom filter for validating tokens against a Redis session store.
 * It uses Project Reactor for reactive programming.
 */
@Slf4j
@Configuration
// @EnableWebFluxSecurity // Annotation is commented out in the original file, so omitted here as well.
public class SecurityConfig {

    private final TokenSessionValidator tokenSessionValidator;

    /**
     * Set of endpoints that are explicitly excluded from full security checks (permit all access).
     */
    private static final Set<String> WHITELIST = Set.of(
            "/auth/check-user",
            "/auth/login1",
            "/auth/logout",
            "/actuator/info",
            "/actuator/health",
            "/auth/update-password");

    /**
     * Constructor for dependency injection of the {@link TokenSessionValidator}.
     *
     * @param tokenSessionValidator The service responsible for validating session tokens via Redis.
     */
    public SecurityConfig(TokenSessionValidator tokenSessionValidator) {
        this.tokenSessionValidator = tokenSessionValidator;
    }

    /**
     * Configures the main security web filter chain for the gateway application.
     * Disables CSRF protection, configures authorization rules, enables OAuth2 resource server support
     * with JWT decoding, and injects a custom Redis validation filter before standard authorization checks.
     *
     * @param http The ServerHttpSecurity instance to configure.
     * @return The built {@link SecurityWebFilterChain}.
     */
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        log.info("Loading SecurityWebFilterChain");
        return http.csrf(ServerHttpSecurity.CsrfSpec::disable)
                .authorizeExchange(exchanges -> exchanges
                        .pathMatchers("/auth/**", "/actuator/**").permitAll() // Allow public access to auth and actuator endpoints
                        .anyExchange().authenticated() // Require authentication for all other requests
                )
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults())) // Configure OAuth2 JWT resource server
                // Run the custom Redis filter before standard Spring Security authorization
                .addFilterBefore(redisValidationFilter(), SecurityWebFiltersOrder.AUTHORIZATION).build();
    }

    /**
     * Creates a custom {@link WebFilter} to validate the current user's session against Redis.
     * This filter runs *after* the JWT has been decoded and the {@link Authentication} principal
     * has been established by the standard Spring Security flow, but *before* method/resource
     * authorization decisions are made.
     *
     * @return A {@link WebFilter} implementation for Redis session validation.
     */
    private WebFilter redisValidationFilter() {
        return (ServerWebExchange exchange, WebFilterChain chain) -> {
            String path = exchange.getRequest().getPath().value();
            log.info("RedisValidationFilter invoked for path={}", path);

            // Skip validation for paths that do not require an active session check
            if (isWhitelisted(path)) {
                return chain.filter(exchange);
            }

            // Retrieve the authenticated principal (if present) as an Authentication object
            return exchange.getPrincipal().cast(Authentication.class)
                    .flatMap(auth -> tokenSessionValidator.validateWithRedis(auth) // Validate the token/session in Redis
                            .flatMap(validAuth -> {
                                if (validAuth == null) {
                                    log.warn("Redis validation failed for principal={}", auth.getName());
                                    exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                                    return exchange.getResponse().setComplete(); // Stop processing if validation fails
                                }
                                log.info("Redis validated for {}", validAuth.getName());
                                return chain.filter(exchange); // Continue the filter chain
                            })
                    )
                    .switchIfEmpty(chain.filter(exchange)) // If there is no principal found, simply continue the chain (e.g. anonymous access might be handled later, though usually blocked by .anyExchange().authenticated())
                    .onErrorResume(e -> {
                        // Catch any exceptions during validation and return 401 Unauthorized
                        log.error("RedisValidationFilter error: {}", e.getMessage(), e);
                        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                        return exchange.getResponse().setComplete();
                    });
        };
    }

    /**
     * Helper method to check if a given request path is in the exclusion list.
     *
     * @param path The request URI path.
     * @return true if the path is whitelisted, false otherwise.
     */
    private boolean isWhitelisted(String path) {
        // Checks explicit matches and path prefixes
        return WHITELIST.contains(path) || path.startsWith("/auth/") || path.startsWith("/actuator/");
    }
}









package com.fincore.gateway.advice;

import org.springframework.core.MethodParameter;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

import com.fincore.gateway.dto.ApiResponse;

/**
 * This ControllerAdvice intercepts successful responses from
 * any @RestController
 * and wraps them in a standard ApiResponse format.
 */
@ControllerAdvice
public class ApiResponseWrapper implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        // This advice applies to any method in a class annotated with @RestController
        // that is not already returning a ResponseEntity (which gives manual control).
        return AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), RestController.class) &&
                !returnType.getParameterType().equals(ResponseEntity.class);
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
            Class<? extends HttpMessageConverter<?>> selectedConverterType,
            ServerHttpRequest request, ServerHttpResponse response) {

        // If the controller has already manually wrapped the response, do nothing.
        if (body instanceof ApiResponse<?>) {
            return body;
        }

        // Wrap the successful response body in the standard ApiResponse structure.
        return ApiResponse.success(body);
    }
}










package com.fincore.gateway.utility;

public class Constants {

    public static final String STATUS = "status";
    public static final String MESSAGE = "message";
    public static final String ACCEPTED = "ACCEPTED";
    public static final String REJECTED = "REJECTED";
    public static final String SUCCESS = "SUCCESS";
    public static final String ERROR = "ERROR";
    public static final String LOCK = "LOCK";
    public static final String UNLOCK = "UNLOCK";
    public static final String ACTIVE = "ACTIVE";
    public static final String INACTIVE = "INACTIVE";
    public static final String CREATE = "CREATE";
    public static final String MODIFY = "MODIFY";
    public static final String DELETE = "DELETE";
    public static final String BLOCK = "BLOCK";
    public static final String UNBLOCK = "UNBLOCK";
    public static final String ACCEPT = "ACCEPT";
    public static final String REJECT = "REJECT";
    public static final String PENDING = "PENDING";
    public static final String LOCKED = "LOCKED";
    public static final String PASSWORD_BASED_LOGIN = "PASS";
    public static final String SSO_BASED_LOGIN = "SSO";
    public static final String INVALID = "INVALID";
    public static final char PASSWORD = 'P';
    public static final char SSO = 'S';
    public static final String ACTIVE_USER = "Active User";
    public static final String HMAC = "hmac";

}






package com.fincore.gateway.utility;

import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.server.reactive.ServerHttpRequest;
@Slf4j
public class LoginUtility {

    public static String getClientIp(ServerHttpRequest request)
    {
        String ip = request.getHeaders().getFirst("X-Forwarded-For");

        if(ip ==null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip))
        {
            ip = String.valueOf(request.getRemoteAddress());

        }
        if(ip!=null){
            if(ip.contains(",")){
                ip = ip.split(",")[0].trim();
            } else if (ip.startsWith("::ffff:")) {
                ip = ip.substring(7);

            }
            else if (ip.startsWith("::1"))
            {
                ip = ip.substring(3);
            }

        }

        return ip;
    }


}










package com.fincore.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Api Gateway Application (Spring Cloud Gateway - WebFlux).
 */
@SpringBootApplication
public class LoginService {
    public static void main(String[] args) {
        SpringApplication.run(LoginService.class, args);
    }
}







spring:
  application:
    name: LoginService



  profiles:
    active: dev
  main:
    web-application-type: reactive

#  cloud:
  gateway:
    routes:
      - id: product-service
        uri: http://product-service:8081
        predicates:
          - Path=/Product/**
      - id: fincore-service
        uri: http://fincore-service:8089
        predicates:
          - Path=/Fincore/**
  kubernetes:
    discovery:
      enabled: false

# ========== DB Details ==========
  datasource:
    url: jdbc:oracle:thin:@10.177.103.192:1523/fincorepdb1
    username: fincore
    password: Password#1234
    driver-class-name: oracle.jdbc.OracleDriver

server:
  port: 8085

# ========== JWT MODE ==========
security:
  jwt:
    mode: hmac
    hmac-base64-secret: UG5ldW1vbm91bHRyYW1pY3Jvc2NvcGljc2lsaWNvdm9sY2Fub2Nvbmlvc2lz
    # for prod, if using RSA
    rsa-public: ""
#    Timeout in 15 Min (900 Sec)
#    todo
    ttl-seconds: 1800
    #    ByPassing Spring-Security URL/ Allowed Without JWT Security
    bypass-paths: /auth/login,/auth/logout,/auth/check-user


# ========== Redis ==========
redis:
  enabled: true
  data:
    redis:
      host: localhost
      port: 6379
      database: 0
      # password: ""  # if needed

# ========== Actuator ==========
management:
  endpoints:
    web:
      exposure:
        include: health,info
  endpoint:
    health:
      show-details: always

# ========== Logging ==========
logging:
  pattern:
    console: "%d{yyyy-MM-dd :: HH:mm:ss.SSS ||} %highlight(%-5level:: %file: | %line |){ERROR=bold red, WARN=yellow, INFO=white, DEBUG=green, TRACE=green} :: %msg%n"











security:
  jwt:
    mode: hmac
    # example 32-byte (256-bit) base64-encoded secret
    hmac-base64-secret: bWV0aGlvbnlsdGhyZW9ueWx0aHJlb255bGdsdXRhbWlueWxhbGFueWw=
    # bypass-paths: /auth/login,/actuator/**

spring:
  data:
    redis:
#      host: redis
#      use "localhost" when run locally
      host: localhost
      port: 6379
      database: 0

redis:
  enabled: true











db details :

LOGIN_PARAM :

ACTIVE_LOGIN_MODE	CHAR(1 BYTE)	No		1	 The active login mode S for SSO, P for Password, A for Auto switch to password if sso not working
OTP_VALIDITY	VARCHAR2(5 BYTE)	No		2	 Store the time for validity for OTP, in minutes
PASSWORD_VALIDITY	VARCHAR2(5 BYTE)	No		3	 Store the time for validity for Password, in hrs
WRONG_PASSWORD_ATTEMPTS	NUMBER(2,0)	No		4	 Store the number of times wrong passwords are allowed after which account to be locked.
ATTEMPT_INTERVAL	NUMBER(5,0)	No		5	Store the interval time for checking wrong login attempts of a user

data :
P	5	720	5	24




USER_LOGIN_ATTEMPTS :
ATTEMPT_ID	NUMBER(19,0)	No	"FINCORE"."USER_LOGIN_ATTEMPTS_ATTEMPT_ID_SEQ"."NEXTVAL"	1	 Unique identifier for the login attempt.
USER_ID	VARCHAR2(12 BYTE)	Yes		2	 Foreign key to the USERS table (can be null for non-existent users).
LOGIN_METHOD	VARCHAR2(5 BYTE)	No		3	 Login method used SSO or Password
IP_ADDRESS	VARCHAR2(45 BYTE)	Yes		4	 IP address from which the attempt was made.
ATTEMPT_TIME	TIMESTAMP(6)	No	SYSTIMESTAMP	5	 Timestamp of the login attempt.
SUCCESS	CHAR(1 BYTE)	No		6	'Y' for successful, 'N' for failed.
FAILURE_REASON	VARCHAR2(100 BYTE)	Yes		7	 Reason for failure (e.g., 'INVALID_PASSWORD', 'ACCOUNT_LOCKED').

DATA :
2833	7378051	PASS	/10.0.26.124:22118	25-11-25 11:16:46.634907000 AM	Y	Success
2834	1015698	PASS	/10.0.19.238:33879	25-11-25 11:38:52.951522000 AM	Y	Success
2835	v7378051	PASS	/10.0.19.238:53180	25-11-25 11:40:08.027266000 AM	Y	Success
2836	7378051	PASS	/10.0.19.238:33880	25-11-25 11:41:23.001908000 AM	Y	Success
2839	7378051	PASS	/10.0.26.124:36226	25-11-25 11:52:14.697772000 AM	Y	Success
2841	8888888	PASS	/10.0.19.35:56796	27-11-25 02:16:24.594155000 PM	Y	Success
2842	8888888	PASS	/10.0.19.35:58051	27-11-25 02:17:15.470653000 PM	Y	Success
2843	8888888	PASS	/10.0.19.35:65244	27-11-25 02:17:34.211019000 PM	Y	Success
2844	8888888	PASS	/10.0.19.35:51237	27-11-25 02:28:42.062701000 PM	Y	Success
2856	1015698	PASS	/10.0.19.35:59633	27-11-25 06:26:36.042552000 PM	Y	Success
2857	8888888	PASS	/10.0.19.35:64176	27-11-25 06:26:46.750694000 PM	Y	Success
2861	7378051	PASS	/10.0.19.238:58533	27-11-25 06:52:30.392372000 PM	Y	Success
2862	8888888	PASS	/10.0.19.35:65015	27-11-25 06:53:26.913309000 PM	Y	Success
2867	1015698	PASS	/10.0.19.203:50171	28-11-25 11:21:09.322376000 AM	Y	Success
2877	7378051	PASS	/10.0.19.101:50003	28-11-25 12:39:31.531299000 PM	Y	Success
2905	8888888	PASS	/10.0.19.35:52557	28-11-25 06:13:55.944396000 PM	Y	Success
2914	1015698	PASS	/10.0.19.203:61865	28-11-25 07:04:52.609141000 PM	Y	Success
2938	1234567	PASS	/10.0.19.35:52650	01-12-25 01:15:02.280407000 PM	Y	Success
2970	7378051	PASS	/10.0.26.124:53182	01-12-25 04:50:21.876451000 PM	Y	Success
3001	1015698	PASS	/10.0.19.203:57622	02-12-25 10:55:18.344746000 AM	Y	Success
3002	1015699	PASS	/10.0.19.203:63773	02-12-25 10:58:11.904471000 AM	Y	Success
3003	7378051	PASS	/10.0.19.101:63485	02-12-25 11:06:35.688673000 AM	N	Wrong password
3004	7378051	PASS	/10.0.19.101:63038	02-12-25 11:06:45.893707000 AM	N	Wrong password
3012	1015698	PASS	/10.0.19.203:49862	02-12-25 11:24:03.094527000 AM	Y	Success











USERS :
USER_ID	VARCHAR2(255 CHAR)	No		1	 Unique identifier for the user
FIRST_NAME	VARCHAR2(255 CHAR)	Yes		2	 User's first name
LAST_NAME	VARCHAR2(255 CHAR)	Yes		3	 User's last name
PHONE_NUMBER	VARCHAR2(255 CHAR)	Yes		4	 User's phone number
EMAIL	VARCHAR2(255 CHAR)	No		5	 User's primary email address
PASSWORD_HASH	VARCHAR2(255 BYTE)	Yes		6	 Hashed and salted password
ACCOUNT_STATUS	VARCHAR2(255 CHAR)	No		7	 Status of the user's account
CREATED_AT	TIMESTAMP(6)	No	SYSTIMESTAMP	8	 Timestamp when the user account was created
UPDATED_AT	TIMESTAMP(6)	No	SYSTIMESTAMP	9	 Timestamp when the user account was last updated
LAST_LOGIN_AT	TIMESTAMP(6)	Yes		10	 Timestamp of the user's last successful login
IS_DELETED	CHAR(1 BYTE)	No	'N'	11	 Flag for soft deletion: Y if deleted, N otherwise
DELETED_AT	TIMESTAMP(6)	Yes		12	 Timestamp when the user was soft-deleted
TEMP_PASSWORD_SET_AT	TIMESTAMP(6)	Yes	SYSTIMESTAMP	13	 Timestamp when the current temporary password was set via OTP
MIDDLE_NAME	VARCHAR2(255 CHAR)	Yes		14	 User's middle name
USER_WRONG_PASSWORD_COUNT	NUMBER(5,0)	No	0	15	Number of wrong login attempts 
BRANCH	NUMBER(5,0)	No		16	Branch Number
PASSWORD_LOGIN	VARCHAR2(20 BYTE)	No	"'ACTIVE'
   "	17	Status of users ability to login through password ( ACTIVE OR INACTIVE)


DATA:
1122334	Pratik	Test2	34234234	vv	$2a$10$hB9v4508x01MxP8IrUvIvujUVCOX3mcVZnxFBX3XSyjXHlusHOLx2	ACTIVE	11-08-25 11:59:42.622654000 AM	11-08-25 11:59:42.622654000 AM		N		04-11-25 06:47:59.354452000 PM	Testing	0	12345	INACTIVE
1015698	Rehaman	Shaik	0000000000	ttr@sbi.co.in	$2a$10$.DfcL84kc/D7bj1aRNXYturF45DlV0Vd36FWfI.pSW0pWpl2eOBeu	ACTIVE	11-08-25 11:59:42.622654000 AM	11-08-25 11:59:42.622654000 AM		N		08-12-25 10:42:10.341996000 AM	Tr	0	12345	ACTIVE








7378051	Pratik	Test	34234235	b	$2a$10$C3eIb7P3wsX5Bh4NPRlDcuRaVBuut2ukEHzXdCgobKefLjLFszuoO	ACTIVE	11-08-25 11:59:42.622654000 AM	11-08-25 11:59:42.622654000 AM		N		01-12-25 05:55:35.103109000 AM		0	12345	ACTIVE

