
package com.tcs.userservice.advice;

import com.tcs.userservice.dto.ApiResponse;
import org.springframework.core.MethodParameter;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

/**
 * This ControllerAdvice intercepts successful responses from
 * any @RestController
 * and wraps them in a standard ApiResponse format.
 */
@ControllerAdvice
public class ApiResponseWrapper implements ResponseBodyAdvice<Object> {
	
	static {
		System.setProperty("spring.classformat.ignore", "true");
	}

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        // This advice applies to any method in a class annotated with @RestController
        // that is not already returning a ResponseEntity (which gives manual control).
        return AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), RestController.class) &&
                !returnType.getParameterType().equals(ResponseEntity.class);
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
            Class<? extends HttpMessageConverter<?>> selectedConverterType,
            ServerHttpRequest request, ServerHttpResponse response) {

        // If the controller has already manually wrapped the response, do nothing.
        if (body instanceof ApiResponse<?>) {
            return body;
        }

        // Wrap the successful response body in the standard ApiResponse structure.
        return ApiResponse.success(body);
    }
}









package com.tcs.userservice.config;

import com.tcs.userservice.service.PermissionCacheService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class CacheWarmer {

    private final PermissionCacheService permissionCacheService;
    private final JdbcTemplate jdbcTemplate;

    /**
     * Runs once when the application starts.
     * Iterates over ALL Role IDs and refreshes their permissions in Redis.
     */
    @EventListener(ApplicationReadyEvent.class)
    public void onStartup() {
        log.info("Startup: Warming Permission Cache...");

        // Fetch all Role IDs (using JDBC for speed/simplicity)
        List<Long> roleIds = jdbcTemplate.queryForList("SELECT ROLE_ID FROM ROLES", Long.class);

        for (Long roleId : roleIds) {
            try {
                permissionCacheService.refreshRolePermissions(roleId);
            } catch (Exception e) {
                log.error("Failed to refresh permissions for Role {}", roleId, e);
            }
        }
        log.info("üèÅ Cache Warming Complete. Processed {} roles.", roleIds.size());
    }
}












package com.tcs.userservice.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.jsontype.BasicPolymorphicTypeValidator;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        // 1. Create a specialized ObjectMapper for Redis
        ObjectMapper redisObjectMapper = new ObjectMapper();
        redisObjectMapper.registerModule(new JavaTimeModule());
        // --- THIS IS THE FIX ---
        // We explicitly verify and enable "Type Info" so Redis saves the class name.
        redisObjectMapper.activateDefaultTyping(
                BasicPolymorphicTypeValidator.builder()
                        .allowIfBaseType(Object.class)
                        .build(),
                ObjectMapper.DefaultTyping.NON_FINAL
        );
        // -----------------------
        GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(redisObjectMapper);
        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(24))
                .disableCachingNullValues()
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(serializer));
        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(cacheConfig)
                .build();
    }

    // Ensure ObjectMapper handles Java 8 Dates (LocalDate, Instant) correctly in Redis
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        return mapper;
    }

    // This bean configures our RedisTemplate to use the fixed ObjectMapper
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory, ObjectMapper objectMapper) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        Jackson2JsonRedisSerializer<Object> serializer =
                new Jackson2JsonRedisSerializer<>(objectMapper, Object.class);

        template.setValueSerializer(serializer);
        template.setKeySerializer(new StringRedisSerializer());

        return template;
    }

}














package com.tcs.userservice.config;

import com.fincore.commonutilities.config.RedisConfig; // Ensures Redis Template is loaded
import com.fincore.commonutilities.jwt.JwtUtil;
import com.fincore.commonutilities.security.ContextRbacFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/**
 * Global security configuration for the application.
 * This class uses Spring Security's Java configuration to define security rules,
 * such as disabling CSRF, making the session stateless, and defining authorization policies.
 *
 * The `@Configuration` annotation marks this class as a source of bean definitions.
 * The `@EnableWebSecurity` annotation enables Spring Security's web security support and provides
 * the integration with the Spring MVC.
 */
@Configuration
@EnableWebSecurity
@Import({RedisConfig.class, JwtUtil.class}) // Import Redis Config from Library
public class SecurityConfig {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private JwtUtil jwtUtil;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .cors(cors -> {}) // Enable CORS (uses your existing WebConfig)
                .sessionManagement(s -> s.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                // LOCK DOWN ENDPOINTS
                .authorizeHttpRequests(authz -> authz
                        .requestMatchers("/**").permitAll() // Allows access to all your API endpoints
                        .requestMatchers("/actuator/**", "/auth/**", "/error").permitAll()
                        // All other requests MUST pass the ContextRbacFilter
                        .anyRequest().authenticated()
                )

                // ======== INSERTING THE GUARD HERE =======
                // This filter does two things:
                // 1. Validates JWT & Sets User Context
                // 2. Checks Redis for Permissions (e.g. "POST:/create-request|SEGMENT_CODE")
                .addFilterBefore(new ContextRbacFilter(redisTemplate, jwtUtil), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}













package com.tcs.userservice.controller;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.userservice.dto.PermissionOrderDto;
import com.tcs.userservice.dto.RoleRequestCreateDto;
import com.tcs.userservice.service.RoleRequestService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/role")
@RequiredArgsConstructor
public class RoleRequestController {

    private final RoleRequestService roleRequestService;
    private final JwtUtil jwtUtil;

    @GetMapping("/get-roles")
    public ResponseEntity getAllRoles(@RequestParam Map<String, Object> requestParams) {
        return roleRequestService.getAllRoles(requestParams);
    }

    // UPDATED: Now accepts DTO for type safety
    @PostMapping("/create-role-request")
    public ResponseEntity createNewRequest(@RequestBody RoleRequestCreateDto request,
                                           @RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return roleRequestService.createNewRoleRequest(request, userId);
    }

    @GetMapping("/pending-role-requests")
    public ResponseEntity getPendingRequests(@RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return roleRequestService.getPendingRoleRequests(userId);
    }

    @PostMapping("/role-request-action")
    public ResponseEntity acceptRequest(@RequestBody Map<String, Object> request,
                                        @RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return roleRequestService.acceptOrRejectRoleRequest(request, userId);
    }

    @GetMapping("/my-role-requests")
    public ResponseEntity getMyRequests(@RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return roleRequestService.getMyRoleRequests(userId);
    }

    @PostMapping("/cancel-role-request")
    public ResponseEntity cancelRoleRequest(@RequestBody Map<String, Object> request,
                                            @RequestHeader("Authorization") String token) {
        return roleRequestService.cancelRoleRequest(request, jwtUtil.getUserIdFromToken(token));
    }

    @GetMapping("/get-all-permissions")
    public ResponseEntity getRoleWisePermissions() {
        return roleRequestService.getAllPermissions();
    }

    @PatchMapping("/save-permission-order")
    public ResponseEntity savePermissionOrder(@RequestBody PermissionOrderDto payload) {
        return roleRequestService.savePermissionOrder(payload);
    }
}









package com.tcs.userservice.controller;

import com.fincore.commonutilities.jwt.JwtUtil;
import com.tcs.userservice.dto.UserLogsDto;
import com.tcs.userservice.dto.UserRequestCreateDto;
import com.tcs.userservice.dto.UserRequestDto;
import com.tcs.userservice.service.UserLogsService;
import com.tcs.userservice.service.UserRequestService;
import com.tcs.userservice.utility.RequestUtility;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping("/user")
@RequiredArgsConstructor
public class UserRequestController {

    private final UserRequestService userRequestService;
    private final UserLogsService userLogsService;
    private final JwtUtil jwtUtil;

    // UPDATED: Now accepts DTO
    @PostMapping("/create-request")
    public ResponseEntity createNewRequest(@RequestBody UserRequestCreateDto request,
                                           @RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return userRequestService.createNewRequest(request, userId);
    }

    @GetMapping("/pending-user-requests")
    public ResponseEntity getPendingRequests(@RequestParam Map<String, Object> params,
                                             @RequestHeader("Authorization") String token) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return userRequestService.getPendingRequests(params, userId);
    }

    @PostMapping("/accept-request")
    public ResponseEntity acceptRequest(HttpServletRequest request,
                                        @RequestBody UserRequestDto userRequest,
                                        @RequestHeader("Authorization") String token) {
        String clientIp = RequestUtility.getClientIp(request);
        String userId = jwtUtil.getUserIdFromToken(token);
        userRequest.setApproverUserId(userId);
        return userRequestService.acceptOrRejectUserRequest(userRequest, clientIp, userId);
    }

    @GetMapping("/user-details")
    public ResponseEntity getUserDetails(@RequestParam Map<String, String> request) {
        return userRequestService.getUserDetails(request);
    }

    @GetMapping("/my-requests")
    public ResponseEntity getMyRequests(@RequestHeader("Authorization") String token, @RequestParam Map<String, String> params) {
        String userId = jwtUtil.getUserIdFromToken(token);
        return userRequestService.getMyRequests(params, userId);
    }

    @PostMapping("/cancel-request")
    public ResponseEntity cancelRequest(@RequestBody Map<String, Object> request) {
        return userRequestService.cancelRequest(request);
    }

    @PostMapping("/logs-batch")
    public ResponseEntity<List<UserLogsDto>> createLogsBatch(@RequestBody List<UserLogsDto> payload) {
        List<UserLogsDto> savedLogs = (List<UserLogsDto>) userLogsService.saveLogs(payload);
        return new ResponseEntity<>(savedLogs, HttpStatus.CREATED);
    }

    @GetMapping("/all-logs")
    public ResponseEntity<List<UserLogsDto>> findAllLogs() {
        return ResponseEntity.ok(userLogsService.findAllLogs());
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserLogsDto> findLogById(@PathVariable Integer id) {
        return ResponseEntity.ok(userLogsService.findLogById(id));
    }
}









package com.tcs.userservice.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Getter;

import java.time.Instant;

@Getter
@JsonInclude(JsonInclude.Include.NON_NULL) // Don't include null fields in the JSON response
public class ApiResponse<T> {

    private final boolean success;
    private final String message;
    private final T data;
    private final Instant timestamp;

    private ApiResponse(boolean success, String message, T data) {
        this.success = success;
        this.message = message;
        this.data = data;
        this.timestamp = Instant.now();
    }

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, message, data);
    }

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, "Operation completed successfully.", data);
    }

    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(false, message, null);
    }
}









package com.tcs.userservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChildMenu {
    
	private int id;
    
	private String title;
    
	private String route;
    
	private ScreenDetails screenDetails;
	
}






package com.tcs.userservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MenuResponse {
    private List<RootMenu> root_menus;
}





package com.tcs.userservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class NotificationConfigDto {

    private String targetUrl;

    private String targetRoles; // Comma separated string: "51,52,55"

}







package com.tcs.userservice.dto;
import lombok.AllArgsConstructor; 
import lombok.Builder; 
import lombok.Data; 
import lombok.NoArgsConstructor;

@Data 
@NoArgsConstructor 
@AllArgsConstructor
@Builder 
public class PermissionDto { 
	private Integer id; // MENU_ID 
	private String title; // MENU_TITLE
	private String icon; // MENU_ICON
	private String description; // MENU_ORDER 
	private int order;
    private String menuSubmenu; // new addition - v1018405

}





package com.tcs.userservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class PermissionEventDto {
    @JsonProperty("payload")
    private Payload payload;

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Payload {
        private DataBlock after;
        private DataBlock before;
        private String op;
    }

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class DataBlock {
        @JsonProperty("MENU_ID")
        private Long menuId;

    }
}








package com.tcs.userservice.dto;

import lombok.Data;

@Data
public class PermissionList {

	public int id;

	public String title;

	public String icon;

	public int order;
}








package com.tcs.userservice.dto;

import java.util.List;

import lombok.Data;

@Data
public class PermissionOrderDto {
	
	private int selectedRole;
	
	private List<PermissionOrderListDto> permissions;

}




package com.tcs.userservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;


@Data
@NoArgsConstructor
@AllArgsConstructor
public class PermissionOrderListDto {

	private int id;

	private String title;

	private String icon;

	private String description;

	private int order;

}









package com.tcs.userservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PermissionsDto {

    private int menuId;

    private String menuTitle;

    private String menuIcon;

    private String menuSubmenu;

    private String menuAction;

    private String menuUrl;

    private String menuComponentPath;

    private String menuOrder;

    private int menuDependant;
}










package com.tcs.userservice.dto;


import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.ArrayList;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleDto {
	private Integer roleId;
	
	private String roleName;
	
	private String description;
	
	private String roleStatus;
	
	@Builder.Default
	private List permissions = new ArrayList<>();
}











package com.tcs.userservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class RolePermissionEventDto {

    @JsonProperty("payload")
    private Payload payload;

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Payload {
        private DataBlock after;  // State after change
        private DataBlock before; // State before change (for deletes)
        private String op;        // 'c', 'u', 'd'
    }

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class DataBlock {
        @JsonProperty("ROLE_ID")
        private Long roleId;

        @JsonProperty("PERMISSION_ID")
        private Long permissionId;
    }
}







package com.tcs.userservice.dto;

import java.util.List;

import lombok.Data;

@Data
public class RoleRequestPayload {


    public String roleId;

	public String roleName;

	public String description;

    public String roleStatus;

	public List<PermissionList> permissions;

}








package com.tcs.userservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;


@Data
@NoArgsConstructor
@AllArgsConstructor
public class RootMenu {


        private int id;
        private String title;
        private String icon;
        private String route;
        private boolean hasChildren;
        private ScreenDetails screenDetails;
        private String menuDescription;
        private List<ChildMenu> children;

}









package com.tcs.userservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ScreenDetails {
    private String screenId;
    private String screenTitle;
    private String componentPath;
}








package com.tcs.userservice.dto;

import lombok.Data;

@Data
public class UserCrudRequestDto {

    private Integer targetUserId;

    private String requestType;

    private UserDetailsDto requestPayload;
}









package com.tcs.userservice.dto;

import jakarta.persistence.Column;
import lombok.Data;

@Data
public class UserDetailsDto {

    private String userId;

    private String firstName;

    private String middleName;

    private String lastName;

    private String email;

    private String phoneNumber;

    private String roleName;

}




package com.tcs.userservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserDto {

    private int userId;

    private int userRole;


}








package com.tcs.userservice.dto;

import java.sql.Timestamp;

import lombok.Data;
@Data
public class UserLogsDto {
	
	private Integer logId;

	private String actionType;

	private String changeType;

	private Timestamp actionTime;

	private Integer userId;

	private String oldValue;

	private String newValue;
}









package com.tcs.userservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserRequestDto {

    private long requestId;

    private String approverUserId;

    private String oldValue;

    private String remarks;

    private String actionFlag;

    private String requestType;

    private String requesterUserId;
}



package com.tcs.userservice.dto;

import java.sql.Timestamp;

public interface UserRequestProjection {
	
	String getRequestorUserId();

	String getRequestStatus();
	
	String getRequestId();
	
	String getRequestType();
	
	Timestamp getRequestDate();

	String getRequestPayload();

}




package com.tcs.userservice.mapper;

import com.tcs.userservice.dto.UserLogsDto;
import com.tcs.userservice.model.UserLogs;

public class UserLogsMapper {

    /**
     * This function is for mapping database to network layer
     *
     * @param: UserLogs : Entity
     * @Author: Deepshikha Biswas
     */
    public static UserLogsDto toDto(UserLogs userLogs) {

        UserLogsDto userLogsDto = new UserLogsDto();
        userLogsDto.setLogId(userLogs.getLogId());
        userLogsDto.setActionType(userLogs.getActionType());
        userLogsDto.setChangeType(userLogs.getChangeType());
        userLogsDto.setActionTime(userLogs.getActionTime());
        userLogsDto.setUserId(userLogs.getUserId());
        userLogsDto.setOldValue(userLogs.getOldValue());
        userLogsDto.setNewValue(userLogs.getNewValue());

        return userLogsDto;
    }

    public static UserLogs toEntity(UserLogsDto userLogsDto) {
        UserLogs userLogs = new UserLogs();
        userLogs.setLogId(userLogsDto.getLogId());
        userLogs.setActionType(userLogsDto.getActionType());
        userLogs.setChangeType(userLogsDto.getChangeType());
        userLogs.setActionTime(userLogsDto.getActionTime());
        userLogs.setUserId(userLogsDto.getUserId());
        userLogs.setOldValue(userLogsDto.getOldValue());
        userLogs.setNewValue(userLogsDto.getNewValue());

        return userLogs;
    }
}







// model

package com.tcs.userservice.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

import java.sql.Timestamp;

@Entity
@Table(name = "AUDIT_LOG")
@Data
public class AuditLog {

    @Id
    @Column(name="LOG_ID")
    private long logId;
    @Column(name="REQUEST_ID")
    private long requestId;
    @Column(name="USER_ID")
    private String userId;
    @Column(name="ACTION_TYPE")
    private String actionType;
    @Column(name="CHANGE_TYPE")
    private String changeType;
    @Column(name="OLD_VALUE")
    private String oldValue;
    @Column(name="NEW_VALUE")
    private String newValue;
    @Column(name="IP_ADDRESS")
    private String ipAddress;
    @Column(name="ACTION_TIME")
    private Timestamp actionTime;



}



package com.tcs.userservice.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp; // Import this
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.io.Serializable;
import java.time.Instant; // This is the correct type
import java.util.Objects;
import java.util.UUID;

/**
 * Represents an event in the outbox system, intended for notification purposes.
 * UPDATED: Added @CreationTimestamp for automatic timestamping.
 */
@Entity
@Table(name = "NOTIFICATIONS")
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class NotificationTable implements Serializable {

    // Unique primary key for the outbox event.
    // Using UUID strategy is correct for Oracle's SYS_GUID() or RAW(16
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "EVENT_ID", updatable = false, nullable = false)
    private UUID eventId;

    // The ID of the user who should receive this notification (for 1-to-1).
    @Column(name = "USER_ID", length = 255)
    private String userId;

    // The human-readable message to be displayed.
    @Column(name = "MESSAGE", length = 1024, nullable = false)
    private String message;

    // The relative URL the user should be taken to when clicking the notification.
    @Column(name = "LINK_URL", length = 1024)
    private String linkUrl;

    // The microservice that generated this event.
    @Column(name = "EVENT_SOURCE", length = 100)
    private String eventSource;

    // The primary key of the business object (e.g., the CommonReq ID).
    @Column(name = "AGGREGATE_ID", length = 255)
    private String aggregateId;

    // The timestamp when the event was created.
    @CreationTimestamp
    @Column(name = "EVENT_TIMESTAMP", nullable = false, updatable = false)
    private Instant eventTimestamp;

    // For 1-to-Many notifications. If USER_ID is null, this role is used.
    @Column(name = "TARGET_ROLE", length = 100)
    private String targetRole;


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        NotificationTable that = (NotificationTable) o;
        return Objects.equals(eventId, that.eventId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(eventId);
    }


    @Override
    public String toString() {
        return "NotificationTable{" +
                "eventId='" + eventId + '\'' +
                ", userId='" + userId + '\'' +
                ", targetRole='" + targetRole + '\'' +
                ", eventSource='" + eventSource + '\'' +
                ", aggregateId='" + aggregateId + '\'' +
                ", eventTimestamp=" + eventTimestamp +
                '}';
    }
}









package com.tcs.userservice.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Entity
@Table(name = "PERMISSIONS")
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PermissionForRole {

	@Id
	@Column(name = "MENU_ID")
	private Integer menuId;

	@Column(name = "MENU_TITLE")
	private String menuTitle;

	@Column(name = "MENU_ORDER")
	private String menuOrder;
}







package com.tcs.userservice.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Entity
@Table(name = "PERMISSIONS")
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Permissions {

    @Id
    @Column(name = "MENU_ID")
    private int menuId;

    @Column(name = "MENU_TITLE")
    private String menuTitle;

    @Column(name = "MENU_ICON")
    private String menuIcon;

    @Column(name = "MENU_SUBMENU")
    private String menuSubmenu;

    @Column(name = "MENU_ACTION")
    private String menuAction;

    @Column(name = "MENU_URL")
    private String menuUrl; // Frontend route (e.g: //glif-reports/**)
    @Column(name = "MENU_COMPONENT_PATH")
    private String menuComponentPath;

    @Column(name = "MENU_DESCRIPTION")
    private String menuDescription;

    @Column(name = "MENU_DEPENDANT")
    private Integer menuDependant;

    @Column(name = "MAPPED_REQUEST_TYPE")
    private String mappedRequestType;

    @Column(name = "API_RESOURCE_PATTERN")
    private String apiResourcePattern; // Backend route (e.g: //reports/**)
}







package com.tcs.userservice.model;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;

@Entity
@Table(name = "MENU_ITEMS") // Assuming the table name is MENU_ITEMS
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class PermissionsForNotification {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "menu_item_seq_gen")
    @SequenceGenerator(name = "menu_item_seq_gen", sequenceName = "MENU_ITEMS_SEQ", allocationSize = 1)
    @Column(name = "MENU_ID", nullable = false)
    private int menuId;

    @Column(name = "MENU_TITLE", nullable = false, length = 100)
    private String menuTitle;

    @Column(name = "MENU_ICON", length = 100)
    private String menuIcon;

    @Column(name = "MENU_SUBMENU", length = 100)
    private String menuSubmenu;

    @Column(name = "MENU_ACTION", nullable = false, length = 200)
    private String menuAction;

    @Column(name = "MENU_URL", nullable = false, length = 200)
    private String menuUrl;

    @Column(name = "MENU_COMPONENT_PATH", nullable = false, length = 200)
    private String menuComponentPath;

    @Column(name = "MENU_DESCRIPTION", nullable = false, length = 255)
    private String menuDescription;

    @Column(name = "MENU_DEPENDANT")
    private int menuDependant;

    @Column(name = "MAPPED_REQUEST_TYPE", length = 50)
    private String mappedRequestType;
}









package com.tcs.userservice.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "ROLES")
public class Role {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "ROLE_ID")
	private int roleId;

	@Column(name = "ROLE_NAME")
	private String roleName;

	@Column(name = "DESCRIPTION")
	private String description;

	@Column(name = "ROLE_STATUS")
	private String status;
}







package com.tcs.userservice.model;

import java.io.Serializable;
import java.util.Objects;

import jakarta.persistence.Embeddable;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;


@Embeddable
@NoArgsConstructor
@AllArgsConstructor
@Data
public class RolePermissionId implements Serializable {
	
	
	private int roleId;
	
    private int permissionId;

}









package com.tcs.userservice.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Value;

@Entity
@Data
@Table(name = "ROLE_PERMISSIONS")
public class RolePermissions {

	@EmbeddedId
	private RolePermissionId id;

	@Column(name = "PERMISSION_ORDER")
	int permissionOrder;

}








package com.tcs.userservice.model;

import jakarta.persistence.*;
import lombok.Data;

import java.sql.Timestamp;

@Entity
@Data
@Table(name = "ROLE_REQUESTS")
public class RoleRequest {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "REQUEST_ID")
	private int requestId;

	@Column(name = "REQUEST_TYPE")
	private String requestType;

	@Column(name = "REQUESTOR_USER_ID")
	private String requestorUserId;

	@Column(name = "TARGET_ROLE_ID")
	private int targetRoleId;

	@Column(name = "REQUEST_PAYLOAD")
	private String requestPayload;

	@Column(name = "REQUEST_STATUS")
	private String requestStatus;

	@Column(name = "REQUEST_DATE", nullable = false, insertable = false, updatable = false)
	private Timestamp requestDate;

	@Column(name = "APPROVAL_DATE")
	private Timestamp approvalDate;

	@Column(name = "APPROVER_USER_ID")
	private String approverUserId;

	@Column(name = "REASON_FOR_REJECTION")
	private String reasonForRejection;

	@Column(name = "EXECUTION_DATE")
	private Timestamp executionDate;

	@Column(name = "EXECUTION_DETAILS")
	private String executionDetails;

}





package com.tcs.userservice.model;

import java.util.List;

import org.springframework.beans.factory.annotation.Qualifier;

import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import jakarta.persistence.Transient;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
@Table(name="ROLES")
public class RoleWithPermissions {
    @Id
    @Column(name="ROLE_ID")
    private int roleId;

    @Column(name="ROLE_NAME")
    private String roleName;

    @Column(name="DESCRIPTION")
    private String description;

    @Column(name="ROLE_STATUS")
    private String status;

    @Column(name="PERMISSIONS")
    @Transient
    private List<PermissionForRole> permissions;
}









package com.tcs.userservice.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

import java.sql.Timestamp;

@Entity
@Getter
@Setter
@Table(name="users")
public class User {

    @Id
    @Column(name="USER_ID")
    private String userId;

    @Column(name="FIRST_NAME")
    private String firstName;
    @Column(name="MIDDLE_NAME")
    private String middleName;
    @Column(name="LAST_NAME")
    private String lastName;
    @Column(name="PHONE_NUMBER")
    private String phoneNumber;
    @Column(name="EMAIL")
    private String email;
    @Column(name="PASSWORD_HASH")
    private String passwordHash;
    @Column(name="ACCOUNT_STATUS")
    private String accountStatus;
    @Column(name="CREATED_AT")
    private Timestamp createdAt;
    @Column(name="UPDATED_AT")
    private Timestamp updatedAt;
    @Column(name="LAST_LOGIN_AT")
    private Timestamp lastLoginAt;

    @Column(name="IS_DELETED")
    private char isDeleted;
    @Column(name="DELETED_AT")
    private Timestamp deletedAt;

    @Column(name="TEMP_PASSWORD_SET_AT")
    private Timestamp tempPasswordSetAt;

    @Column(name="USER_WRONG_PASSWORD_COUNT")
    private int userWrongPasswordCount;

    @Column(name="BRANCH")
    private int branch;
}





package com.tcs.userservice.model;

import java.sql.Timestamp;

import jakarta.persistence.*;
import lombok.Data;

@Entity
@Data
@Table(name="User_logs")

// Main model for the entire log entry
public class UserLogs {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name="LOG_ID")
	private Integer logId;
	
	@Column(name="ACTION_TYPE")
	private String actionType;
	
	@Column(name="CHANGE_TYPE")
	private String changeType;
	
	@Column(name="ACTION_TIME")
	private Timestamp actionTime;
	
	@Column(name="USER_ID")
	private Integer userId;

    @Lob
	@Column(name="OLD_VALUE")
	private String oldValue;

    @Lob
	@Column(name="NEW_VALUE")
	private String newValue;


}











package com.tcs.userservice.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.sql.Timestamp;

@Entity
@Getter
@Setter
@ToString
/*
 * @Table(name="USER_CHANGES_REQUEST_TRACK") public class UserRequest {
 * 
 * @Id
 * 
 * @GeneratedValue(strategy = GenerationType.IDENTITY)
 * 
 * @Column(name="REQUEST_ID") private int requestId;
 * 
 * @Column(name="REQUEST_STATUS") private String requestStatus;
 * 
 * @Column(name="REQUEST_RAISED_BY") private String requestRaisedBy;
 * 
 * @Column(name="REQUEST_RAISED_AT",nullable=false,updatable=false,insertable=
 * false) private Timestamp requestRaisedAt;
 * 
 * @Column(name="REQUEST_REVIEWED_BY") private String requestReviewedBy;
 * 
 * @Column(name="REQUEST_REVIEWED_AT") private Timestamp requestReviewedAt;
 * 
 * @Column(name="REQUEST_FLAG") private String requestFlag;
 * 
 * @Column(name="REQUEST_CATEGORIES") private String requestCategories;
 * 
 * @Column(name="USER_ID") private String userId;
 * 
 * @Column(name="UPDATED_FIRST_NAME") private String updatedFirstName;
 * 
 * @Column(name="UPDATED_MIDDLE_NAME") private String updatedMiddleName;
 * 
 * @Column(name="UPDATED_LAST_NAME") private String updatedLastName;
 * 
 * @Column(name="UPDATED_PHONE_NUMBER") private String updatedPhoneNumber;
 * 
 * @Column(name="UPDATED_EMAIL") private String updatedEmail;
 * 
 * @Column(name="UPDATED_ROLE") private int updatedRole;
 * 
 * @Column(name="REQUEST_REMARKS") private String requestRemarks; }
 */
@Table(name = "USER_REQUESTS")
public class UserRequest {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "REQUEST_ID")
	private int requestId;
	
	@Column(name = "REQUEST_TYPE")
	private String requestType;
	
	@Column(name = "REQUESTOR_USER_ID")
	private String requestorUserId;
	
	@Column(name = "TARGET_USER_ID")
	private String targetUserId;
	
	@Column(name = "REQUEST_PAYLOAD")
	private String requestPayload;
	
	@Column(name = "REQUEST_STATUS")
	private String requestStatus;
	
	@Column(name = "REQUEST_DATE", nullable = false, insertable = false, updatable = false)
	private Timestamp requestDate;
	
	@Column(name = "APPROVAL_DATE")
	private Timestamp approvalDate;
	
	@Column(name = "APPROVER_USER_ID")
	private String approverUserId;
	
	@Column(name = "REASON_FOR_REJECTION")
	private String reasonForRejection;
	
	@Column(name = "EXECUTION_DATE")
	private Timestamp executionDate;
	
	@Column(name = "EXECUTION_DETAILS")
	private String executionDetails;
}








package com.tcs.userservice.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

@Entity
@Data
@Table(name = "USER_ROLES")
public class UserRole {
    
    @Id
    @Column(name = "USER_ID")
    private String userId;

    @Column(name = "ROLE_ID")
    private int roleId;

}








package com.tcs.userservice.repository;

import com.tcs.userservice.model.NotificationTable;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.UUID;

public interface NotificationRepository extends JpaRepository<NotificationTable, UUID> {
}
package com.tcs.userservice.repository;

import com.tcs.userservice.model.NotificationTable;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.UUID;

public interface NotificationRepository extends JpaRepository<NotificationTable, UUID> {
}






package com.tcs.userservice.repository;

import com.tcs.userservice.model.Permissions;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;
import java.util.Set;

public interface PermissionsRepository extends JpaRepository<Permissions, Integer> {

    List<Permissions> findAll();

    /**
     * Retrieves a list of mapped request type keys for a given set of menu IDs.
     */
    @Query("SELECT p.mappedRequestType FROM Permissions p WHERE p.menuId IN :incomingIds")
    List<String> findMappedRequestTypeByMenuId(@Param("incomingIds") Set<Integer> incomingIds);

    /**
     * Fetches both the Target URL and the authorized Role IDs in a single database call.
     *
     * @param requestType The mapped request type string (e.g., 'SEGMENT_CODE')
     * @return A list of arrays where index [0] is MENU_URL (String) and index [1] is ROLE_ID (Number)
     */
    @Query(value = """
            SELECT p.MENU_URL, rp.ROLE_ID
            FROM PERMISSIONS p
            JOIN ROLE_PERMISSIONS rp ON p.MENU_ID = rp.PERMISSION_ID
            JOIN ROLES r ON rp.ROLE_ID = r.ROLE_ID
            WHERE p.MAPPED_REQUEST_TYPE = :requestType
            AND (p.MENU_ACTION LIKE '%approve%' OR p.MENU_ACTION LIKE '%reject%')
            AND r.ROLE_STATUS = 'ACTIVE'
            """, nativeQuery = true)
    List<Object[]> findUrlAndRolesByRequestType(@Param("requestType") String requestType);


    /**
     * Joins ROLES -> ROLE_PERMISSIONS -> PERMISSIONS
     *
     * @return all permissions assigned specific to role id
     */
    @Query(value = """
                SELECT p.* FROM PERMISSIONS p
                JOIN ROLE_PERMISSIONS rp ON p.MENU_ID = rp.PERMISSION_ID
                WHERE rp.ROLE_ID = :roleId
            """, nativeQuery = true)
    List<Permissions> findAllByRoleId(@Param("roleId") Long roleId);
}








package com.tcs.userservice.repository;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import com.tcs.userservice.model.Role;

import java.util.List;

@Repository
public interface RolePermissionRepository extends CrudRepository<Role, Integer> {
	// Native query that returns role columns +
	// permission columns. Aliases and column order
	// must match mapping below.
	@Query(value = """
            SELECT
                r.role_id,
                r.role_name,
                r.description,
                r.role_status,
                p.menu_id,
                p.menu_title,
                p.menu_icon,
                p.MENU_DESCRIPTION,
                rp.PERMISSION_ORDER,
                p.MENU_SUBMENU
            FROM
                roles r
                LEFT JOIN role_permissions rp ON r.role_id = rp.role_id
                LEFT JOIN permissions     p ON rp.permission_id = p.menu_id
            ORDER BY
                r.role_id,
            	rp.PERMISSION_ORDER
            """, nativeQuery = true)
	List<Object[]> findAllRolesWithPermissionsRaw();
}








package com.tcs.userservice.repository;

import java.util.List;

import com.tcs.userservice.model.Permissions;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import com.tcs.userservice.model.RolePermissionId;
import com.tcs.userservice.model.RolePermissions;

public interface RolePermissionsRepository extends JpaRepository<RolePermissions, RolePermissionId> {

	/**
	 * Function for getting permission based on role id used for modification of
	 * permissions
	 * 
	 * @param : roleId : must be a valid role id
	 */
	@Query(nativeQuery = true, value = """
			SELECT
			    p.MENU_ID,
			    p.MENU_TITLE,
			    p.MENU_ICON,
			    p.MENU_SUBMENU,
			    p.MENU_ACTION,
			    p.MENU_URL,
			    p.MENU_COMPONENT_PATH,
			    p.MENU_ORDER,
			    p.MENU_DEPENDANT
			FROM
			    PERMISSIONS p
			INNER JOIN
			    ROLE_PERMISSIONS rp
			ON
			    p.MENU_ID = rp.PERMISSION_ID
			WHERE
			    rp.ROLE_ID = :roleId

						""")
	List<Permissions> findAllByRole(@Param("roleId") String roleId);

	List<RolePermissions> findByIdRoleIdAndIdPermissionIdIn(int roleId, List<Integer> permissionIds);

	List<RolePermissions> findByIdRoleId(int roleId);

    @Query(value = "SELECT ROLE_ID FROM ROLE_PERMISSIONS WHERE permission_id = :permissionId", nativeQuery = true)
    List<Long> findRoleIdsByPermissionId(Long permissionId);
}









package com.tcs.userservice.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.tcs.userservice.model.Role;

public interface RoleRepository extends JpaRepository<Role, Integer> {

	Role findRoleByRoleId(int roleId);

	Role findRoleByRoleName(String roleName);
}






package com.tcs.userservice.repository;

import com.tcs.userservice.dto.UserRequestProjection;
import com.tcs.userservice.model.RoleRequest;
import com.tcs.userservice.model.UserRequest;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.List;
import java.util.Map;

@Repository
public interface RoleRequestRepository extends JpaRepository<RoleRequest, Integer> {

	@Query(value = "select count(*) from role_requests where TARGET_ROLE_ID=:roleId and request_status='PENDING'", nativeQuery = true)
	int countPendingRoleRequests(@RequestParam("roleId") int roleId);

	@Query(value = """
			SELECT
			    COUNT(*)
			FROM
			    role_requests
			WHERE
				lower(JSON_VALUE(request_payload, '$.roleName')) =:roleName
			    AND request_status = 'PENDING'
					""", nativeQuery = true)
	int countPendingRoleRequestsByRoleName(@RequestParam("roleName") String roleName);

	@Query(value = """
						SELECT
			    request_id,
			    request_type,
			    requestor_user_id,
			    target_role_id,
			    dbms_lob.substr(REQUEST_PAYLOAD) AS requestPayload,
			    request_status,
			    request_date,
			    approval_date,
			    approver_user_id,
			    reason_for_rejection,
			    execution_date,
			    execution_details
			FROM
			    role_requests
			WHERE
			        requestor_user_id !=:requestedByUserId
			    AND request_status = 'PENDING'
						""", nativeQuery = true)
	List<UserRequestProjection> findPendingRoleRequests(@Param("requestedByUserId") String requestedByUserId);

	@Query(value = """
									SELECT
			    request_id,
			    request_type,
			    requestor_user_id,
			    target_role_id,
			    dbms_lob.substr(request_payload) AS requestpayload,
			    request_status,
			    request_date,
			    approval_date,
			    approver_user_id,
			    reason_for_rejection,
			    execution_date,
			    execution_details
			FROM
			    role_requests
			WHERE
			    requestor_user_id = :requestedByUserId
			ORDER BY
				request_id DESC
															""", nativeQuery = true)
	List<UserRequestProjection> findMyPendingRoleRequests(@Param("requestedByUserId") String requestedByUserId);

	RoleRequest findRoleRequestByRequestId(int requestId);

	RoleRequest getRoleRequestByRequestId(long requestId);

	@Query(nativeQuery = true, value = "SELECT ROLE_ID_SEQUENCE.NEXTVAL FROM DUAL")
	int getNewRoleIdOnCreation();
}










package com.tcs.userservice.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.tcs.userservice.model.UserLogs;
@Repository
public interface UserLogsRepository extends JpaRepository<UserLogs, Integer>{

}






package com.tcs.userservice.repository;

import com.tcs.userservice.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Map;

@Repository
public interface UserRepository extends JpaRepository<User, String> {

        User findUserByUserId(String userId);

        @Query(value = "select u.user_Id   , u.first_name as firstName,u.last_name,u.email,u.phone_number,u.branch, u.ACCOUNT_STATUS,r.role_id"
                        +
                        ",r.role_name " +
                        "from users  u  join user_roles ur on u.user_id= ur.user_id " +
                        "join roles r on ur.role_id  = r.role_id where u.user_id = :userId", nativeQuery = true)
        Map<String, Object> getUserByUserId(@Param("userId") String userId);

        @Query(value = "select u.user_Id as userid , u.first_name,u.last_name,u.email,u.phone_number,u.branch,r.role_id "
                        +
                        ",r.role_name " +
                        "from users  u  join user_roles ur on u.user_id= ur.user_id " +
                        "join roles r on ur.role_id = r.role_id where u.branch = :branch", nativeQuery = true)
        List<Map<String, Object>> getUsersByBranch(@Param("branch") int branch);

        @Query(value = "select u.user_Id as userid , u.first_name,u.last_name,u.email,u.phone_number,u.branch,r.role_id "
                        +
                        ",r.role_name " +
                        "from users  u  join user_roles ur on u.user_id= ur.user_id " +
                        "join roles r on ur.role_id = r.role_id where r.role_name = :role", nativeQuery = true)
        List<Map<String, Object>> getUsersByRole(@Param("role") String role);

        @Query(value = "select u.user_Id as userid , u.first_name,u.last_name,u.email,u.phone_number,u.ACCOUNT_STATUS,u.branch,r.role_id ,r.role_name\n" +
                "from users  u  join user_roles ur on u.user_id= ur.user_id join roles r on ur.role_id = r.role_id where  (:userId is NULL or u.user_id=:userId ) and (:role is NULL or  r.role_id = :role)", nativeQuery = true)
        List<Map<String, Object>> getUsers(@Param("userId") String userId, @Param("role") Integer role);
}










package com.tcs.userservice.repository;

import com.tcs.userservice.dto.UserRequestDto;
import com.tcs.userservice.model.UserRequest;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.List;

@Repository
public interface UserRequestRepository extends JpaRepository<UserRequest, Integer> {

    @Query(value="select count(*) from user_requests where target_user_id=:targetUserId and request_status='PENDING'", nativeQuery=true)
    int countUserPendingRequests(@RequestParam("targetUserId") String targetUserId);

    @Query(value="select * from user_requests where REQUESTOR_USER_ID!=:requestedByUserId and request_status='PENDING'",nativeQuery = true)
    List<UserRequest> findUserPendingRequests(@RequestParam("requestedByUserId") String requestedByUserId);

    UserRequest findUserRequestsByRequestId(long requestId);

    List<UserRequest> findUserRequestsByRequestorUserId(String userId);

    @Query(nativeQuery = true,
            value = """
                    SELECT
                        request_id,
                        request_type AS action_flag,
                        requestor_user_id,
                        request_payload,
                        request_type,
                        approver_user_id
                    FROM
                        user_requests
                    WHERE
                        request_id = :requestId
                    """
    )
    UserRequestDto getUserRequestDto(@Param("requestId") String requestId);



}














package com.tcs.userservice.repository;

import com.tcs.userservice.model.UserRole;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRoleRepository extends JpaRepository<UserRole, String> {
    UserRole getUserRolesByUserId(String targetUserId);
}







// service


package com.tcs.userservice.service;

import com.tcs.userservice.dto.*;
import com.tcs.userservice.model.Permissions;
import lombok.extern.slf4j.Slf4j;

import org.springframework.stereotype.Service;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
public class MenuService {

	public MenuResponse transform(List<Permissions> permissionsList) {
		MenuResponse response = new MenuResponse();

		// Group by root menuTitle
		Map<String, List<Permissions>> grouped = permissionsList.stream()
				.collect(Collectors.groupingBy(Permissions::getMenuTitle));

		List<RootMenu> rootMenus = new ArrayList<>();

		for (Map.Entry<String, List<Permissions>> entry : grouped.entrySet()) {
			List<Permissions> group = entry.getValue();
            Permissions rootPerm = group.get(0);

			RootMenu rootMenu = new RootMenu();
			rootMenu.setId(rootPerm.getMenuId());
			rootMenu.setTitle(rootPerm.getMenuTitle());
			rootMenu.setIcon(rootPerm.getMenuIcon());
			rootMenu.setRoute(rootPerm.getMenuUrl());
			rootMenu.setMenuDescription(rootPerm.getMenuDescription());

			log.info("Root permission url:{}", rootPerm.getMenuComponentPath());
			rootMenu.setScreenDetails(
					new ScreenDetails(rootPerm.getMenuTitle().toUpperCase().replace(" ", "_") + "_SCREEN",
							rootPerm.getMenuTitle(), rootPerm.getMenuComponentPath()));

			if (group.size() > 1) {
				rootMenu.setHasChildren(true);

				List<ChildMenu> children = new ArrayList<>();
				for (Permissions p : group) {
					if (p.getMenuSubmenu() != null) {
						ChildMenu child = getChildMenu(p);
						children.add(child);
					}
				}
				rootMenu.setChildren(children);
			} else {
				rootMenu.setHasChildren(false);
			}

			rootMenus.add(rootMenu);
		}

		response.setRoot_menus(rootMenus);
		return response;
	}

	private static ChildMenu getChildMenu(Permissions p) {
		ChildMenu child = new ChildMenu();
		child.setId(p.getMenuId());
		child.setTitle(p.getMenuSubmenu());
		child.setRoute(p.getMenuUrl() + "/" + p.getMenuSubmenu().toLowerCase().replace(" ", ""));
		
		log.info("Root permission url:{}", p.getMenuUrl());
		child.setScreenDetails(new ScreenDetails(p.getMenuSubmenu().toUpperCase().replace(" ", "_") + "_SCREEN",
				p.getMenuSubmenu(), p.getMenuComponentPath()));
		return child;
	}
}









package com.tcs.userservice.service;

import com.tcs.userservice.model.NotificationTable;
import com.tcs.userservice.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * A service to create and save Notification events to the outbox table.
 * This is designed to be called from within a parent @Transactional method
 * in RequestServiceImpl to ensure atomic operations.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationWriterService {

    private final NotificationRepository notificationRepository;

    /**
     * Creates and saves a notification outbox event.
     * This method joins the existing transaction from the calling service.
     *
     * @param userId      The specific user to notify (for 1-to-1). Null if using targetRole.
     * @param targetRole  The role to notify (for 1-to-many). Null if using userId.
     * @param message     The human-readable message.
     * @param linkUrl     The frontend link for the notification.
     * @param aggregateId The ID of the business object (e.g., the CommonReq ID).
     * @param eventSource The name of this service.
     */
    @Transactional(propagation = Propagation.MANDATORY)
    // Ensures this is only called from within an existing transaction
    public void createNotification(String userId, String targetRole, String message, String linkUrl, String aggregateId, String eventSource) {

        if (userId == null && targetRole == null) {
            log.warn("Skipping notification creation: Both userId and targetRole are null. AggregateID: {}", aggregateId);
            // In a real scenario, you might want to throw an exception here
            // if one of them is strictly required, to roll back the parent transaction.
            return;
        }

        if (message == null || message.isBlank()) {
            log.warn("Skipping notification creation: Message is null or blank. AggregateID: {}", aggregateId);
            // Throwing an exception ensures the parent transaction rolls back.
            throw new IllegalArgumentException("Notification message cannot be null or blank.");
        }

        NotificationTable notification = NotificationTable.builder()
                .userId(userId)  // user id of the receiver
                .targetRole(targetRole) // role id of the receiver
                .message(message) // what notification we need to send
                .linkUrl(linkUrl)
                .aggregateId(aggregateId)
                .eventSource(eventSource)
                .build();

        // The EVENT_ID (UUID) and EVENT_TIMESTAMP (CreationTimestamp)
        // will be set automatically by the NotificationTable entity.

        notificationRepository.save(notification);

        if (userId != null) {
            log.info("Saved 1-to-1 notification event for user: {} (AggregateID: {})", userId, aggregateId);
        } else {
            log.info("Saved 1-to-many notification event for role: {} (AggregateID: {})", targetRole, aggregateId);
        }
    }


    /*@SneakyThrows
    public void createRequestApprovedNotification(CommonReq request, String approverId) {
        // 2. Prepare the success notification message
        String notificationMessage = "Your " + request.getReqType().name().toLowerCase() + " " + request.getChangeType().name()
                + " request for '" + request.getTargetId() + "' has been approved by " + approverId;

        createNotification(
                request.getCreatorId(),
                null,
                notificationMessage,
                "/my-requests", // Or specific link
                request.getId().toString(),
                "CommonRequestService"
        );
    }

    @SneakyThrows
    public void createRequestRejectedNotification(CommonReq request, String rejectorId, String reason) {
        // 2. Prepare the rejection notification message
        String notificationMessage = "Your " + request.getReqType().name().toLowerCase() + " " + request.getChangeType().name()
                + " request for '" + request.getTargetId() + "' was rejected by " + rejectorId;
        if (reason != null && reason.isBlank()) {
            notificationMessage += " Reason: " + reason;
        }

        createNotification(
                request.getCreatorId(),
                null,
                notificationMessage,
                "/my-requests",
                request.getId().toString(),
                "CommonRequestService"
        );
    }*/
}












package com.tcs.userservice.service;

import com.tcs.userservice.model.Permissions;
import com.tcs.userservice.repository.PermissionsRepository;
import com.tcs.userservice.repository.RolePermissionsRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor
@Slf4j
public class PermissionCacheService {

    private final PermissionsRepository permissionRepository;
    private final StringRedisTemplate redisTemplate;
    private final RolePermissionsRepository rolePermissionsRepository;

    /**
     * Refreshes the Redis cache for a specific Role ID.
     * Call this on Startup and whenever a Role is updated.
     */
    @Transactional(readOnly = true)
    public void refreshRolePermissions(Long roleId) {
        List<Permissions> perms = permissionRepository.findAllByRoleId(roleId);
        String redisKey = "RBAC::PERMISSIONS::" + roleId;

        redisTemplate.delete(redisKey);
        Set<String> redisValues = new HashSet<>();

        for (Permissions p : perms) {
            String apiPattern = p.getApiResourcePattern(); // e.g. "/user/**" or "/cgl*"
            String actionRaw = p.getMenuAction();
            String action = (actionRaw != null) ? actionRaw.toLowerCase() : "";
            String context = p.getMappedRequestType(); // e.g. "CGL_CODE" or "USER_MANAGEMENT"

            String contextSuffix = (context == null || context.trim().isEmpty()) ? "*" : context;

            // ==========================================================================================
            // LOGIC BLOCK A: MAKER-CHECKER & GENERIC REQUESTS (CommonRequestService)
            // ==========================================================================================
            if (!contextSuffix.equals("*")) {

                // DRY RUN: Role 51 (CGL Maker). Action="create|modify". Context="CGL_CODE".
                // Controller: RequestController. Endpoint: POST /create-request, POST /update-request.
                // VERDICT: GRANTED.
                if (containsAny(action, "create", "modify", "delete", "cancel")) {
                    redisValues.add("POST:/create-request|" + contextSuffix);
                    redisValues.add("POST:/update-request|" + contextSuffix);
                    redisValues.add("POST:/cancel-request|" + contextSuffix);
                    // Endpoint: /my-requests (MyRequestFilterDto)
                    redisValues.add("POST:/my-requests|" + contextSuffix);
                }

                // DRY RUN: Role 52 (CGL Blocker). Action="block". Context="CGL_CODE".
                // Controller: RequestController. Endpoint: POST /create-request (Blocking is a request).
                // VERDICT: GRANTED.
                if (containsAny(action, "block", "unblock")) {
                    redisValues.add("POST:/create-request|" + contextSuffix);
                    redisValues.add("POST:/update-request|" + contextSuffix);
                    redisValues.add("POST:/my-requests|" + contextSuffix);
                }

                // DRY RUN: Role 55 (CGL Checker). Action="approve". Context="CGL_CODE".
                // Controller: RequestController. Endpoint: PATCH /update-request (ProcessRequestDto).
                // VERDICT: GRANTED.
                if (containsAny(action, "approve", "reject")) {
                    redisValues.add("PATCH:/update-request|" + contextSuffix);
                    redisValues.add("POST:/pending-requests|" + contextSuffix);
                }

                // store different actions for specific context to differentiate
                String opsKey = "RBAC::OPS::" + roleId + "::" + contextSuffix;
                Set<String> allowedOps = new HashSet<>();

                // Map DB Action Strings -> Enum ChangeTypes
                if (action.contains("create")) allowedOps.add("ADD");
                if (action.contains("modify")) allowedOps.add("UPDATE");
                if (action.contains("delete")) allowedOps.add("DELETE");

                // GRANULAR PERMISSIONS
                if (action.contains("block")) allowedOps.add("BLOCK");
                if (action.contains("unblock")) allowedOps.add("UNBLOCK");

                if (!allowedOps.isEmpty()) {
                    // Store allowed operations in Redis
                    // Example Key: RBAC::OPS::52::CGL_CODE -> ["BLOCK", "UNBLOCK"]
                    redisTemplate.opsForSet().add(opsKey, allowedOps.toArray(new String[0]));
                    log.info("üîí Cached OPS for Role {} Context {}: {}", roleId, contextSuffix, allowedOps);
                }
            }

            // ==========================================================================================
            // LOGIC BLOCK B: RESOURCE ENDPOINTS (User, Role, Reports, Masters, Notifications)
            // ==========================================================================================
            if (apiPattern != null && !apiPattern.isEmpty()) {

                // Handle comma-separated patterns (e.g., Circle needs /circle-codes AND /zone-codes)
                String[] patterns = apiPattern.split(",");

                for (String effectiveUrl : patterns) {
                    effectiveUrl = effectiveUrl.trim();

                    // --- READ ACCESS ---
                    // DRY RUN: Role 51 (Maker). Needs to see CGL list to edit.
                    // Controller: CommonMasterController. Endpoint: GET /cgls.
                    // VERDICT: GRANTED (Implicitly via 'create'/'modify' check).
                    //
                    // DRY RUN: Dashboard (All Users). Action="view". Pattern="/notifications/**".
                    // Controller: NotificationController. Endpoint: GET /notifications.
                    // VERDICT: GRANTED.
                    if (containsAny(action, "view", "read", "create", "modify", "block", "unblock")) {
                        // Grant access with Specific Context (if header sent)
                        redisValues.add("GET:" + effectiveUrl + "|" + contextSuffix);
                        // DRY RUN: Transactions/Balance. These use POST to search/view.
                        redisValues.add("POST:" + effectiveUrl + "|" + contextSuffix);

                        // Grant access with Wildcard Context (if header NOT sent - Standard behavior)
                        redisValues.add("GET:" + effectiveUrl + "|*");
                        redisValues.add("POST:" + effectiveUrl + "|*");
                    }

                    // --- WRITE ACCESS (Create) ---
                    // DRY RUN: User Mgmt (ID 12). Action="create". Pattern="/user/**|USER-MANAGEMENT OR /user/**|* work both cases".
                    // Controller: UserRequestController. Endpoint: POST /user/create-request.
                    // VERDICT: GRANTED.
                    String writeContext = "*"; // Standard APIs rarely send context headers

                    if (action.contains("create")) {
                        redisValues.add("POST:" + effectiveUrl + "|" + contextSuffix);
                        redisValues.add("POST:" + effectiveUrl + "|" + writeContext);
                    }

                    // --- WRITE ACCESS (Modify/Approve) ---
                    // DRY RUN: Role Mgmt (ID 22). Action="modify". Pattern="/role/**".
                    // Controller: RoleRequestController. Endpoint: PATCH /save-permission-order.
                    // VERDICT: GRANTED.
                    if (action.contains("modify") || action.contains("approve")) {
                        redisValues.add("PUT:" + effectiveUrl + "|" + contextSuffix);
                        redisValues.add("PUT:" + effectiveUrl + "|" + writeContext);

                        redisValues.add("PATCH:" + effectiveUrl + "|" + contextSuffix);
                        redisValues.add("PATCH:" + effectiveUrl + "|" + writeContext);

                        // Some update APIs use POST (e.g. /user/accept-request)
                        redisValues.add("POST:" + effectiveUrl + "|" + contextSuffix);
                        redisValues.add("POST:" + effectiveUrl + "|" + writeContext);
                    }

                    // --- WRITE ACCESS (Delete/Cancel) ---
                    // DRY RUN: User Mgmt. Action="cancel". Pattern="/user/**".
                    // Controller: UserRequestController. Endpoint: POST /user/cancel-request.
                    // VERDICT: GRANTED.
                    if (action.contains("delete") || action.contains("cancel")) {
                        redisValues.add("DELETE:" + effectiveUrl + "|" + contextSuffix);
                        redisValues.add("DELETE:" + effectiveUrl + "|" + writeContext);
                        redisValues.add("POST:" + effectiveUrl + "|" + contextSuffix);
                        redisValues.add("POST:" + effectiveUrl + "|" + writeContext);
                    }

                    // --- WRITE ACCESS (Download/Upload) ---
                    // DRY RUN: Reports (ID 26). Action="download". Pattern="/reports/**".
                    // Controller: ReportController. Endpoint: POST /reports/download.
                    // VERDICT: GRANTED.
                    // DRY RUN: Journal Upload (ID 36). Action="Bulk Upload". Pattern="/journal-bulk-upload/**".
                    // VERDICT: GRANTED.
                    if (action.contains("download") || action.contains("upload")) {
                        redisValues.add("GET:" + effectiveUrl + "|" + contextSuffix);
                        redisValues.add("POST:" + effectiveUrl + "|" + contextSuffix);
                        redisValues.add("POST:" + effectiveUrl + "|" + writeContext);

                        redisValues.add("GET:" + effectiveUrl + "|" + writeContext);
                        redisValues.add("POST:" + effectiveUrl + "|" + writeContext);
                        redisValues.add("POST:" + effectiveUrl + "|" + writeContext);
                    }
                }
            }
        }

        if (!redisValues.isEmpty()) {
            redisTemplate.opsForSet().add(redisKey, redisValues.toArray(new String[0]));
        }
        log.info("‚úÖ Cached {} permissions for Role {}", redisValues.size(), roleId);
    }

    /**
     * Called when a PERMISSION definition changes (e.g. URL update).
     * Finds all roles using this permission and refreshes them.
     */
    @Transactional(readOnly = true)
    public void refreshRolesByPermissionId(Long permissionId) {
        // Query DB: Find all Role IDs associated with this Permission ID
        // You'll need to add this query to your Repository
        List<Long> affectedRoleIds = rolePermissionsRepository.findRoleIdsByPermissionId(permissionId);

        log.info("Permission {} changed. Refreshing {} affected roles.", permissionId, affectedRoleIds.size());

        for (Long roleId : affectedRoleIds) {
            refreshRolePermissions(roleId);
        }
    }

    private boolean containsAny(String input, String... keywords) {
        if (input == null) return false;
        for (String keyword : keywords) {
            if (input.contains(keyword)) return true;
        }
        return false;
    }
}







package com.tcs.userservice.service;

import com.tcs.userservice.dto.NotificationConfigDto;
import com.tcs.userservice.repository.PermissionsRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class PermissionConfigService {

    private final PermissionsRepository permissionRepository;

    /**
     * This method is Cached.
     * - First call: Hits DB (approx 10ms).
     * - Subsequent calls: Hits Memory
     * - Key: The RequestType string (e.g., "SEGMENT_CODE").
     */
    @Cacheable(value = "user_configs", key = "#requestType")
    public NotificationConfigDto getConfig(String requestType) {

        log.info("Cache Miss: Fetching DB permissions for type: {}", requestType);

        // 1. Single DB Call
        List<Object[]> results = permissionRepository.findUrlAndRolesByRequestType(requestType);

        if (results.isEmpty()) {
            // Return default fallback logic if no config found
            log.info("No URL and roles found for request type {}. Using defaults.", requestType);
            return new NotificationConfigDto("/dashboard", "ALL_USERS");
        }

        log.info("Fetched Url and roles from db for the request type {} : {}", requestType, results.getFirst()[0]);

        // 2. Process logic in Java
        // The URL is the same for all rows (index 0)
        String url = (String) results.get(0)[0];

        if (url == null) url = "/dashboard";
        // Collect all Role IDs (index 1) into a comma-separated string

        String roles = results.stream()
                .map(row -> String.valueOf(row[1])) // Role ID
                .distinct()
                .collect(Collectors.joining(","));

        if (roles.isEmpty()) roles = "55";

        return new NotificationConfigDto(url, roles);
    }
}










package com.tcs.userservice.service;

public interface PermissionsService {
    String getPermissions();
}







package com.tcs.userservice.service;

import org.springframework.stereotype.Service;

@Service("PermissionsService")
public class PermissionsServiceImpl implements PermissionsService {

  
    @Override
    public String getPermissions() {
        return "Hello this is a string";
    }
}










package com.tcs.userservice.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.userservice.dto.PermissionEventDto;
import com.tcs.userservice.dto.RolePermissionEventDto;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;
import org.springframework.messaging.handler.annotation.Payload;

@Service
@Slf4j
@RequiredArgsConstructor
public class RbacEventListener {

    private final PermissionCacheService cacheService;
    private final ObjectMapper objectMapper; // Spring's default mapper

    /**
     * Scenario 1: A Role is assigned/unassigned a Permission.
     * Table: ROLE_PERMISSIONS
     */
    @KafkaListener(topics = "fincore.FINCORE.ROLE_PERMISSIONS", groupId = "rbac-cache-group")
    public void handleRolePermissionChange(@Payload(required = false) String message) {
        // 1. Handle Tombstone Record (Cleanup message from Debezium)
        if (message == null) {
            log.debug("üëª Ignored Tombstone record for ROLE_PERMISSIONS");
            return;
        }

        try {
            // Manual Deserialization
            RolePermissionEventDto event = objectMapper.readValue(message, RolePermissionEventDto.class);

            if (event == null || event.getPayload() == null) return;
            String op = event.getPayload().getOp();

            Long roleId = null;

            if ("c".equals(op) || "u".equals(op)) {
                roleId = event.getPayload().getAfter().getRoleId();
            } else if ("d".equals(op)) {
                roleId = event.getPayload().getBefore().getRoleId();
            }
            if (roleId != null) {
                log.info("‚ö° Real-time RBAC Update: Role {} permissions changed.", roleId);
                cacheService.refreshRolePermissions(roleId);
            }
        } catch (Exception e) {
            log.error("Failed to process Role Permission event: {}", e.getMessage());
        }
    }

    /**
     * Scenario 2: A Permission definition itself changes (e.g. URL update).
     * Table: PERMISSIONS
     */
    @KafkaListener(topics = "fincore.FINCORE.PERMISSIONS", groupId = "rbac-cache-group")
    public void handlePermissionDefinitionChange(@Payload(required = false) String message) {
        // 1. Handle Tombstone Record
        if (message == null) {
            log.debug("üëª Ignored Tombstone record for PERMISSIONS");
            return;
        }

        try {
            // Manual Deserialization
            PermissionEventDto event = objectMapper.readValue(message, PermissionEventDto.class);
            if (event == null || event.getPayload() == null) return;
            String op = event.getPayload().getOp();
            Long menuId = null;
            if ("c".equals(op) || "u".equals(op)) {
                menuId = event.getPayload().getAfter().getMenuId();
            } else if ("d".equals(op)) {
                menuId = event.getPayload().getBefore().getMenuId();
            }
            if (menuId != null) {
                log.info("‚ö° Real-time RBAC Update: Permission Definition {} changed.", menuId);
                cacheService.refreshRolesByPermissionId(menuId);
            }
        } catch (Exception e) {
            log.error("Failed to process Permission event: {}", e.getMessage());
        }
    }
}








package com.tcs.userservice.service;

import org.springframework.http.ResponseEntity;

import com.tcs.userservice.dto.PermissionOrderDto;

import java.util.Map;

public interface RoleRequestService {
	ResponseEntity createNewRoleRequest(Map<String, Object> request, String userId);

	ResponseEntity getPendingRoleRequests(String userId);

	ResponseEntity acceptOrRejectRoleRequest(Map<String, Object> request, String userId);

	ResponseEntity getAllRoles(Map<String, Object> request);

	ResponseEntity cancelRoleRequest(Map<String, Object> request, String userId);

	ResponseEntity getMyRoleRequests(String userId);

	ResponseEntity getAllPermissions();

	ResponseEntity savePermissionOrder(PermissionOrderDto payload);
}








package com.tcs.userservice.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.userservice.ResponseVO;
import com.tcs.userservice.dto.*;
import com.tcs.userservice.model.*;
import com.tcs.userservice.repository.PermissionsRepository;
import com.tcs.userservice.repository.RolePermissionsRepository;
import com.tcs.userservice.repository.RoleRepository;
import com.tcs.userservice.repository.RoleRequestRepository;
import com.tcs.userservice.utility.Constant;
import com.tcs.userservice.utility.RequestUtility;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

@Slf4j
@Service
public class RoleRequestServiceImpl implements RoleRequestService {

    private static final String EVENT_SOURCE = "USER_SERVICE";
    private static final String REQUEST_TYPE_KEY = "ROLE_MANAGEMENT";

    private final String STATUS = Constant.STATUS;
    private final String MESSAGE = Constant.MESSAGE;
    @Autowired
    private RoleRequestRepository roleRequestRepository;
    @Autowired
    private RoleRepository roleRepository;
    @Autowired
    private ObjectMapper objectMapper;
    @Autowired
    private RoleService roleService;
    @Autowired
    private PermissionsRepository permissionsRepository;
    @Autowired
    private RolePermissionsRepository rolePermissionsRepository;
    @Autowired
    private CacheManager cacheManager;
    @Autowired
    private PermissionConfigService permissionConfigService;
    @Autowired
    private NotificationWriterService notificationWriterService;

    private static String getStatusText(String actionFlag, boolean success) {
        String statusText;
        if ("PENDING".equalsIgnoreCase(actionFlag)) {
            statusText = success ? "PENDING" : "FAILED";
        } else if (Constant.ACCEPT.equalsIgnoreCase(actionFlag)) {
            statusText = success ? "APPROVED" : "FAILED";
        } else if (Constant.REJECT.equalsIgnoreCase(actionFlag)) {
            statusText = "REJECTED";
        } else if (Constant.CANCEL.equalsIgnoreCase(actionFlag)) {
            statusText = "CANCELLED";
        } else {
            statusText = "UNKNOWN";
        }
        return statusText;
    }

    /**
     * Creates a new role request (CREATE / MODIFY / LOCK / UNLOCK / DELETE).
     * <p>
     * - Validates mandatory fields.
     * <p>
     * - Applies business rules (no duplicate pending requests, etc.).
     * <p>
     * - Persists a RoleRequest with PENDING status.
     * <p>
     * - Triggers a "PENDING" notification on success.
     */
    @SuppressWarnings("unchecked")
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<?>> createNewRoleRequest(final Map<String, Object> request, String userId) {
        final ResponseVO<Object> responseVo = new ResponseVO<>();
        final Map<String, Object> result = new HashMap<>();

        // 1) Basic request validation (return early on invalid)
        final String[] required = {"requestType", "requestPayload", "targetRoleId", "requestorUserId"};
        if (RequestUtility.verifyRequest(request, required)) { // 'true' means invalid
            result.put(STATUS, false);
            result.put(MESSAGE, "Invalid request.");
            responseVo.setResult(result);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
            responseVo.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(responseVo);
        }

        // 2) Map incoming request -> RoleRequest safely
        final RoleRequest roleRequest;
        try {
            roleRequest = objectMapper.convertValue(request, RoleRequest.class);
        } catch (IllegalArgumentException ex) {
            log.error("Malformed role request payload", ex);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
            responseVo.setMessage("Malformed request payload.");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(responseVo);
        }

        // 3) Canonicalize inputs for RoleRequest
        roleRequest.setRequestStatus(Constant.PENDING);
        roleRequest.setRequestDate(new Timestamp(System.currentTimeMillis()));
        roleRequest.setRequestorUserId(userId);

        final String requestFlag = String.valueOf(request.get("requestType"));
        final boolean isCreate = Constant.CREATE.equalsIgnoreCase(requestFlag);
        final int targetRoleId = roleRequest.getTargetRoleId();

        // 4) Parse JSON requestPayload to extract roleName
        final JsonNode payloadNode;
        try {
            payloadNode = objectMapper.readTree(String.valueOf(request.get("requestPayload")));
        } catch (JsonProcessingException e) {
            log.error("Error parsing requestPayload JSON", e);
            result.put(STATUS, false);
            result.put(MESSAGE, "Invalid requestPayload JSON");
            responseVo.setResult(result);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
            responseVo.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(responseVo);
        }

        // Extract simple fields from payload
        String roleName = payloadNode.get("roleName").asText();
        log.info("Role request roleName: {}", roleName);

        log.info("Role request: flag={}, targetRoleId={}, roleName={}, requestorUserId={}",
                requestFlag, targetRoleId, roleName, userId);

        // 5) Pre-fetch dependent data (avoid duplicate queries)
        final Role existingRole = roleRepository.findRoleByRoleId(targetRoleId);
        final long pendingById = isCreate ? 0L : roleRequestRepository.countPendingRoleRequests(targetRoleId);
        final long pendingByName = isCreate && roleName != null
                ? roleRequestRepository.countPendingRoleRequestsByRoleName(roleName.toLowerCase())
                : 0L;

        // 6) Business rules (early exit on conflicts)
        if (isCreate && existingRole != null) {
            log.info("Create denied: role with id {} already exists", targetRoleId);
            result.put(STATUS, false);
            result.put(MESSAGE, "A role with this ID already exists.");
            responseVo.setResult(result);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.CONFLICT.value()));
            responseVo.setMessage(HttpStatus.CONFLICT.getReasonPhrase());
            return ResponseEntity.status(HttpStatus.CONFLICT).body(responseVo);
        }

        if (!isCreate && pendingById > 0) {
            result.put(STATUS, false);
            result.put(MESSAGE, "There is already a pending request for this role.");
            responseVo.setResult(result);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.CONFLICT.value()));
            responseVo.setMessage(HttpStatus.CONFLICT.getReasonPhrase());
            return ResponseEntity.status(HttpStatus.CONFLICT).body(responseVo);
        }

        if (isCreate && pendingByName > 0) {
            result.put(STATUS, false);
            result.put(MESSAGE, "There is already a role creation request pending for this role.");
            responseVo.setResult(result);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.CONFLICT.value()));
            responseVo.setMessage(HttpStatus.CONFLICT.getReasonPhrase());
            return ResponseEntity.status(HttpStatus.CONFLICT).body(responseVo);
        }

        // 7) Finalize and persist RoleRequest
        if (isCreate) {
            roleRequest.setTargetRoleId(roleRequestRepository.getNewRoleIdOnCreation());
        }

        roleRequestRepository.save(roleRequest);

        result.put("roleRequest", roleRequest);
        result.put(STATUS, true);
        result.put(MESSAGE, "New request created.");
        responseVo.setResult(result);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.CREATED.value()));
        responseVo.setMessage(HttpStatus.CREATED.getReasonPhrase());

        String cancelMessage = "New role : "+ roleRequest.getTargetRoleId() + " creation request is pending for approval";
        // 8) Notification: new ROLE request is now PENDING (atomic with DB)
        createRoleRequestNotification(
                roleRequest,
                "PENDING",                      // workflow stage
                true,                           // success path
                cancelMessage  // info message
        );

        return ResponseEntity.status(HttpStatus.CREATED).body(responseVo);
    }

    /**
     * Returns all pending role requests assigned to the given userId (approver).
     * <p>
     * - No notifications here
     * <p>
     * - This is a pure read operation.
     */
    public ResponseEntity<ResponseVO<Map<String, Object>>> getPendingRoleRequests(String userId) {
        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();

        try {
            List<UserRequestProjection> pendingRequests = roleRequestRepository.findPendingRoleRequests(userId);

            if (pendingRequests.isEmpty()) {
                result.put(MESSAGE, "No pending requests");
            } else {
                result.put(MESSAGE, String.format("%d pending requests found ", pendingRequests.size()));
                result.put("pendingRequests", pendingRequests);
                result.put("pendingRequestsCount", pendingRequests.size());
            }

            result.put(STATUS, true);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
            responseVo.setMessage(HttpStatus.OK.getReasonPhrase());

        } catch (Exception e) {
            log.error("Error fetching pending role requests for userId={}", userId, e);
            result.put(STATUS, false);
            result.put(MESSAGE, "Invalid User Id and parameters: " + e.getMessage());
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
            responseVo.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
        }
        responseVo.setResult(result);
        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
    }

    /**
     * Approves or rejects a role request.
     *
     * <p>- Delegates core business logic to {@link #performUpdateOperation}.</p>
     * <p>- Sets approver info and timestamps.</p>
     * <p>- Triggers notification for APPROVE/REJECT outcomes.</p>
     *
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> acceptOrRejectRoleRequest(Map<String, Object> request,
                                                                                     String userId) {
        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();

        String actionFlag = (String) request.get("actionFlag");
        int requestId = Integer.parseInt((String) request.get("requestId"));
        RoleRequest roleRequest = roleRequestRepository.findRoleRequestByRequestId(requestId);

        roleRequest.setApproverUserId(userId);
        roleRequest.setApprovalDate(new Timestamp(System.currentTimeMillis()));
        String requestFlag = roleRequest.getRequestType();

        // Perform DB operations based on actionFlag + requestFlag
        responseVo.setResult(performUpdateOperation(result, actionFlag, roleRequest, requestFlag));
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
        responseVo.setMessage(HttpStatus.OK.getReasonPhrase());

        // Notification (ACCEPT / REJECT) ‚Äì based on result
        boolean success = Boolean.TRUE.equals(result.get(STATUS));
        String actionText = actionFlag.equalsIgnoreCase("ACCEPT") ? "approved." : "rejected.";
        String infoMessage = "Your role creation/modification request has been "+ actionText ;

        createRoleRequestNotification(
                roleRequest,
                actionFlag,   // ACCEPT / REJECT
                success,
                infoMessage
        );

        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
    }

    /**
     * Core business handler for ACCEPT / REJECT on RoleRequest.
     * <p>
     * - For ACCEPT: dispatches based on requestType (CREATE/MODIFY/LOCK/UNLOCK/DELETE).
     * <p>
     * - For REJECT: only marks the request as REJECTED.
     * <p>
     * - Populates the result map used for API response + notification.
     */
    private Map<String, Object> performUpdateOperation(Map<String, Object> result,
                                                       String actionFlag,
                                                       RoleRequest roleRequest,
                                                       String requestFlag) {

        if (actionFlag.equalsIgnoreCase(Constant.ACCEPT)) {
            Role role = roleRepository.findRoleByRoleId(roleRequest.getTargetRoleId());
            roleRequest.setRequestStatus(Constant.ACCEPTED);

            // Flags for type of operation
            boolean isCreate = requestFlag.equalsIgnoreCase(Constant.CREATE);
            boolean isModify = requestFlag.equalsIgnoreCase(Constant.MODIFY);
            boolean isLock = requestFlag.equalsIgnoreCase(Constant.LOCK);
            boolean isUnlock = requestFlag.equalsIgnoreCase(Constant.UNLOCK);
            boolean isDelete = requestFlag.equalsIgnoreCase(Constant.DELETE);

            // Basic presence checks
            if (role == null && !isCreate) {
                result.put(STATUS, false);
                result.put(MESSAGE, "Role not found");
                return result;
            }
            if (role != null && isCreate) {
                result.put(STATUS, false);
                result.put(MESSAGE, "This Role already present");
                return result;
            }

            // CREATE / MODIFY: upsert Role + permissions
            if (isCreate || isModify) {
                if (isCreate) {
                    role = new Role();
                }
                try {
                    Map<String, Object> roleMap = objectMapper.readValue(roleRequest.getRequestPayload(),
                            new TypeReference<Map<String, Object>>() {
                            });
                    log.info("Role payload map: {}", roleMap);

                    role.setRoleName(String.valueOf(roleMap.get("roleName")));
                    role.setDescription(String.valueOf(roleMap.get("description")));
                    role.setStatus(Constant.ACTIVE);
                    Role newRole = roleRepository.save(role);
                    log.info("Saved Role: {} with id={}", newRole, newRole.getRoleId());

                    RoleRequestPayload roleRequestPayload = objectMapper.readValue(
                            roleRequest.getRequestPayload(),
                            RoleRequestPayload.class
                    );

                    if (savePermissions(roleRequestPayload, newRole.getRoleId())) {
                        // Evict notification configs cache entries for affected menus
                        List<PermissionList> selectedPermissions = roleRequestPayload.getPermissions();
                        Set<Integer> incomingIds = selectedPermissions.stream()
                                .map(PermissionList::getId)
                                .collect(Collectors.toCollection(LinkedHashSet::new));

                        List<String> requestTypeKey = permissionsRepository.findMappedRequestTypeByMenuId(incomingIds);

                        Cache cache = cacheManager.getCache("notification_configs");
                        if (cache != null) {
                            for (String key : requestTypeKey) {
                                cache.evict(key);
                                log.info("Cache evicted: cleared configuration for key {}", key);
                            }
                        }

                        result.put(STATUS, true);
                        result.put(MESSAGE, isCreate ? "New Role Created" : "Existing role Updated");
                    } else {
                        result.put(STATUS, false);
                        result.put(MESSAGE, "Error while saving permissions for " + role.getRoleId() + ".");
                    }
                    roleRequestRepository.save(roleRequest);
                } catch (JsonProcessingException e) {
                    log.error("Error parsing roleRequest payload for create/modify", e);
                    throw new RuntimeException(e);
                }
                return result;
            }

            // LOCK / UNLOCK: toggle Role status
            if (isLock || isUnlock) {
                role.setStatus(isUnlock ? Constant.ACTIVE : Constant.LOCKED);
                roleRepository.save(role);

                result.put(STATUS, true);
                result.put(MESSAGE, isUnlock ? "USER UNLOCKED" : "USER LOCKED");
                roleRequestRepository.save(roleRequest);
                return result;
            }

            // DELETE: remove role
            if (isDelete) {
                try {
                    roleRepository.delete(role);
                    result.put(STATUS, true);
                    result.put(MESSAGE, "User Deleted");
                    roleRequestRepository.save(roleRequest);
                } catch (Exception e) {
                    log.error("Error deleting role", e);
                    result.put(STATUS, false);
                    result.put(MESSAGE, e.getMessage());
                }
                return result;
            }

            // Unknown requestFlag
            result.put(STATUS, false);
            result.put(MESSAGE, "Invalid Action Flag");
            return result;

        } else {
            // REJECT flow: only update RoleRequest status
            roleRequest.setRequestStatus(Constant.REJECTED);
            roleRequestRepository.save(roleRequest);
            result.put(STATUS, true);
            result.put(MESSAGE, "User request rejected");
            return result;
        }
    }

    /**
     * Saves permissions for a specific role, handling:
     * <p>
     * - inserts, updates and deletes in one pass
     * <p>
     * - prevents duplicates via composite key (roleId, permissionId)
     */
    private boolean savePermissions(RoleRequestPayload payload, int roleId) {
        try {
            List<PermissionList> selectedPermissions = payload.getPermissions() == null
                    ? Collections.emptyList()
                    : payload.getPermissions();

            // Build set of incoming permissionIds (unique, ordered)
            Set<Integer> incomingIds = selectedPermissions.stream()
                    .map(PermissionList::getId)
                    .collect(Collectors.toCollection(LinkedHashSet::new));

            // Fetch existing role-permission links
            List<RolePermissions> existingList = rolePermissionsRepository.findByIdRoleId(roleId);

            // Map existing by permissionId for quick lookup
            Map<Integer, RolePermissions> existingMap = existingList.stream()
                    .collect(Collectors.toMap(rp -> rp.getId().getPermissionId(), Function.identity()));

            List<RolePermissions> toInsert = new ArrayList<>();
            List<RolePermissions> toUpdate = new ArrayList<>();

            // Process incoming payload (insert or update)
            for (PermissionList p : selectedPermissions) {
                int pid = p.getId();
                RolePermissions existing = existingMap.get(pid);

                if (existing == null) {
                    // New mapping
                    RolePermissionId newId = new RolePermissionId(roleId, pid);
                    RolePermissions rp = new RolePermissions();
                    rp.setId(newId);
                    rp.setPermissionOrder(p.getOrder());
                    toInsert.add(rp);
                } else {
                    // Update order if changed
                    Integer existingOrder = existing.getPermissionOrder();
                    Integer incomingOrder = p.getOrder();
                    if (!Objects.equals(existingOrder, incomingOrder)) {
                        existing.setPermissionOrder(incomingOrder);
                        toUpdate.add(existing);
                    }
                    // Mark as processed
                    existingMap.remove(pid);
                }
            }

            // Persist inserts and updates
            if (!toInsert.isEmpty()) {
                rolePermissionsRepository.saveAll(toInsert);
            }
            if (!toUpdate.isEmpty()) {
                rolePermissionsRepository.saveAll(toUpdate);
            }

            // Delete mappings that are no longer present in incoming payload
            if (!existingMap.isEmpty()) {
                List<RolePermissions> toDelete = new ArrayList<>(existingMap.values());
                rolePermissionsRepository.deleteAll(toDelete);
            }

            rolePermissionsRepository.flush();

            log.info("Inserted {}, updated {}, deleted {} for roleId {}",
                    toInsert.size(), toUpdate.size(), existingMap.size(), roleId);

            return true;
        } catch (Exception e) {
            log.error("Exception while saving permissions for roleId {}: {}", roleId, e.getMessage(), e);
            return false;
        }
    }

    /**
     * Returns all roles (optionally with permissions) based on request flag.
     * <p>
     * This is a read-only method, no notifications involved.
     */
    @Override
    public ResponseEntity<ResponseVO<Map<String, Object>>> getAllRoles(Map<String, Object> request) {

        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();

        boolean includePermissions = Boolean.parseBoolean((String) request.get("permissions"));
        List<RoleDto> roles = roleService.getAllRolesWithPermissions(includePermissions);

        if (roles.isEmpty()) {
            result.put(STATUS, false);
            result.put(MESSAGE, "No roles found.");
        } else {
            result.put(STATUS, true);
            result.put(MESSAGE, String.format("%d pending roles found ", roles.size()));
            result.put("roles", roles);
        }

        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
        responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
        responseVo.setResult(result);
        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
    }

    /**
     * Cancels a pending role request raised by the same user (requestor).
     * <p>
     * - Validates that the caller is the owner of the request.
     * <p>
     * - Sets status to CANCEL.
     * <p>
     * - Triggers a "CANCELLED" notification on success.
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> cancelRoleRequest(Map<String, Object> request, String userId) {
        ResponseVO<Map<String, Object>> responseVO = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();

        try {
            int requestId = Integer.parseInt(request.get("requestId").toString());
            RoleRequest roleRequest = roleRequestRepository.getRoleRequestByRequestId(requestId);

            log.info("Requester ID {}", roleRequest.getRequestorUserId());
            log.info("User ID : {}", userId);

            if (userId == null || userId.isEmpty() || !userId.equals(roleRequest.getRequestorUserId())) {
                result.put(STATUS, false);
                result.put(MESSAGE, "You are unauthorized to cancel this request");
                responseVO.setStatusCode(HttpStatusCode.valueOf(HttpStatus.UNAUTHORIZED.value()));
                responseVO.setMessage(HttpStatus.UNAUTHORIZED.getReasonPhrase());
            } else {
                roleRequest.setRequestStatus(Constant.CANCEL);
                roleRequestRepository.save(roleRequest);

                result.put(STATUS, true);
                result.put(MESSAGE, "Request cancelled");
                responseVO.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
                responseVO.setMessage(HttpStatus.OK.getReasonPhrase());

                String cancelMessage = "Your role : "+ roleRequest.getTargetRoleId() +"creation/modification request has been cancelled.";

                // Notification only on successful cancel (atomic with DB)
                createRoleRequestNotification(
                        roleRequest,
                        Constant.CANCEL,          // workflow action
                        true,
                        cancelMessage
                );
            }

        } catch (Exception e) {
            log.error("Error while cancelling role request", e);
            result.put(STATUS, false);
            result.put(MESSAGE, e.getMessage());
            responseVO.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
            responseVO.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
        }
        responseVO.setResult(result);
        return new ResponseEntity<>(responseVO, responseVO.getStatusCode());
    }

    /**
     * Returns pending role requests raised by the given userId (requestor).
     * <p>
     * No notifications, pure query.
     */
    @Override
    public ResponseEntity<ResponseVO<Map<String, Object>>> getMyRoleRequests(String userId) {
        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();

        if (userId != null && !userId.isEmpty()) {
            try {
                List<UserRequestProjection> myRequests = roleRequestRepository.findMyPendingRoleRequests(userId);

                if (myRequests.isEmpty()) {
                    result.put(STATUS, false);
                    result.put(MESSAGE, "You have raised 0 requests");
                } else {
                    result.put(STATUS, true);
                    result.put(MESSAGE, String.format("You have raised %d  requests.", myRequests.size()));
                    result.put("myRequests", myRequests);
                    result.put("requestCount", myRequests.size());
                }
                responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
                responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
                responseVo.setResult(result);
            } catch (IllegalArgumentException e) {
                log.error("Error fetching my role requests for userId={}", userId, e);
                responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
                responseVo.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
            }
        } else {
            result.put(STATUS, false);
            result.put(MESSAGE, "Invalid user id");
            responseVo.setResult(result);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
            responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
        }

        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
    }

    /**
     * Returns master list of permissions (menus) as DTOs.
     * <p>
     * Pure read-only operation, no notifications.
     */
    @Override
    public ResponseEntity<ResponseVO<List<PermissionDto>>> getAllPermissions() {
        ResponseVO<List<PermissionDto>> responseVo = new ResponseVO<>();

        List<Permissions> permissions = permissionsRepository.findAll();

        if (permissions.isEmpty()) {
            responseVo.setMessage(HttpStatus.NOT_FOUND.getReasonPhrase());
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.NOT_FOUND.value()));
        } else {
            List<PermissionDto> permissionDto = permissions.stream()
                    .map(p -> PermissionDto.builder()
                            .id(p.getMenuId())
                            .title(p.getMenuTitle())
                            .icon(p.getMenuIcon())
                            .description(p.getMenuDescription())
                            .menuSubmenu(p.getMenuSubmenu())
                            .build())
                    .toList();
            responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
            responseVo.setResult(permissionDto);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
        }

        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
    }

    /**
     * Saves the display order of permissions for a given role.
     * <p>
     * Note: this is a direct write, no notifications triggered from here.
     */
    @Override
    public ResponseEntity<?> savePermissionOrder(PermissionOrderDto payload) {

        try {
            List<RolePermissions> newPermissions = payload.getPermissions().stream()
                    .map(p -> {
                        RolePermissions rp = new RolePermissions();
                        RolePermissionId newId = new RolePermissionId(payload.getSelectedRole(), p.getId());
                        rp.setId(newId);
                        rp.setPermissionOrder(p.getOrder());
                        return rp;
                    })
                    .collect(Collectors.toList());

            if (newPermissions.isEmpty()) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(Map.of("message", "No permissions provided"));
            }

            rolePermissionsRepository.saveAll(newPermissions);

            return ResponseEntity.ok(
                    Map.of("message", "Permissions saved successfully", "savedCount", newPermissions.size())
            );

        } catch (Exception e) {
            log.error("Error saving permissions for roleId {}: {}", payload.getSelectedRole(), e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("message", "Failed to save permissions", "error", e.getMessage()));
        }

    }

    /**
     * Creates a notification event for a role request lifecycle change.
     * <p>
     * - Uses PermissionConfigService to resolve target roles + URL by request type key.
     * <p>
     * - Throws RuntimeException on failure to force transaction rollback in caller.
     */
    private void createRoleRequestNotification(RoleRequest roleRequest,
                                               String actionFlag,   // PENDING / ACCEPT / REJECT / CANCEL
                                               boolean success,
                                               String infoMessage) {
        try {
            // Build requestTypeKey for notification configuration (e.g. ROLE_CREATE)
            NotificationConfigDto config = permissionConfigService.getConfig(REQUEST_TYPE_KEY);

            // Derive status label to show in message
//            String statusText = getStatusText(actionFlag, success);

            String referenceId = String.valueOf(roleRequest.getRequestId());


            String userId = Objects.equals(roleRequest.getRequestType(), Constant.ACCEPT)
                    || Objects.equals(roleRequest.getRequestType(), Constant.REJECT)
                    || Objects.equals(actionFlag, Constant.CANCEL)
                    ? roleRequest.getRequestorUserId()
                    : roleRequest.getApproverUserId();

            String targetRoles = Objects.equals(actionFlag, Constant.CANCEL) ? null : config.getTargetRoles();
            notificationWriterService.createNotification(
                    userId,                          // userId == null => group notification
                    targetRoles,       // e.g. "51,55"
                    infoMessage,
                    config.getTargetUrl(),         // e.g. "/role-requests"
                    referenceId,
                    EVENT_SOURCE
            );

        } catch (Exception e) {
            log.error("CRITICAL: Failed to create notification for role request {}. Rolling back transaction.",
                    roleRequest.getRequestId(), e);
            throw new RuntimeException("Failed to create role request notification, rolling back.", e);
        }
    }

    /**
     * Maps a RoleRequest into a notification config key.
     * <p>
     * For example, a requestType "CREATE" becomes "ROLE_CREATE".
     */
    private String buildRoleRequestTypeKey(RoleRequest roleRequest) {
        return "ROLE_" + roleRequest.getRequestType().toUpperCase();
    }

}













package com.tcs.userservice.service;

import com.tcs.userservice.dto.PermissionDto;
import com.tcs.userservice.dto.RoleDto;
import com.tcs.userservice.model.Role;
import com.tcs.userservice.repository.RolePermissionRepository;
import com.tcs.userservice.repository.RoleRepository;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.*;

@Slf4j
@Service
public class RoleService {

	private final RolePermissionRepository rolePermissionRepository;
	private final RoleRepository roleRepository;

	public RoleService(RolePermissionRepository rolePermissionRepository, RoleRepository roleRepository) {
		this.rolePermissionRepository = rolePermissionRepository;
		this.roleRepository = roleRepository;
	}

	public List<RoleDto> getAllRolesWithPermissions(boolean permissions) {

		// Case 1: If permissions flag is false, just return basic role details
		if (!permissions) {
			return roleRepository.findAll().stream()
					.map(role -> RoleDto.builder()
							.roleId(role.getRoleId())
							.roleName(role.getRoleName())
							.roleStatus(role.getStatus())
							.description(role.getDescription()).build())
					.toList();
		}

		// Case 2: If permissions flag is true, return roles with permission details
		List<Object[]> rows = rolePermissionRepository.findAllRolesWithPermissionsRaw();
		Map<Integer, RoleDto> roleMap = new LinkedHashMap<>();

		for (Object[] row : rows) {
			Integer roleId = safeNumberToInteger(row[0]);
			String roleName = safeToString(row[1]);
			String description = safeToString(row[2]);
			String roleStatus = safeToString(row[3]);

			RoleDto role = roleMap.computeIfAbsent(
					roleId, id -> RoleDto.builder()
					.roleId(id)
					.roleName(roleName)
					.description(description)
					.roleStatus(roleStatus)
					.permissions(new ArrayList<>()).build());

			// Add permission only if present
			if (row[4] != null) {
				Integer menuId = safeNumberToInteger(row[4]);
				String menuTitle = safeToString(row[5]);
				String menuIcon = safeToString(row[6]);
				String menuDescription = safeToString(row[7]);
				int order = safeNumberToInteger(row[8]);
                String menuSubmenu = safeToString(row[9]);

                PermissionDto permission = PermissionDto.builder()
						.id(menuId)
						.title(menuTitle)
						.icon(menuIcon)
						.description(menuDescription)
                        .order(order)
                        .menuSubmenu(menuSubmenu)
						.build();

				role.getPermissions().add(permission);
			}
		}

		return new ArrayList<>(roleMap.values());
	}

// helpers
	private static Integer safeNumberToInteger(Object o) {
		if (o == null)
			return null;
		if (o instanceof Number)
			return ((Number) o).intValue();
		try {
			return Integer.parseInt(o.toString());
		} catch (NumberFormatException e) {
			return null;
		}
	}

	private static String safeToString(Object o) {
		return o == null ? null : o.toString();
	}
}








package com.tcs.userservice.service;

import com.tcs.userservice.dto.UserLogsDto;
import org.springframework.http.ResponseEntity;

import java.util.List;

public interface UserLogsService {

    ResponseEntity saveLogs(List<UserLogsDto> payload);

    List<UserLogsDto> findAllLogs();

    UserLogsDto findLogById(Integer id);


}









package com.tcs.userservice.service;

import com.tcs.userservice.dto.UserLogsDto;
import com.tcs.userservice.mapper.UserLogsMapper;
import com.tcs.userservice.model.UserLogs;
import com.tcs.userservice.repository.UserLogsRepository;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class UserLogsServiceImpl implements UserLogsService {


    @Autowired
    private UserLogsRepository userLogsRepository;

    @Override
    @Transactional
    public ResponseEntity saveLogs(List<UserLogsDto> payload) {

        List<UserLogs> userLogsEntities = payload.stream()
                .map(UserLogsMapper::toEntity)
                .collect(Collectors.toList());

        // Saving the entities to the database
        List<UserLogs> savedEntities = userLogsRepository.saveAll(userLogsEntities);

        // Mapping the saved entities (which now have their generated IDs) back to DTOs
        List<UserLogsDto> userLogsDto = savedEntities.stream()
                .map(UserLogsMapper::toDto)
                .collect(Collectors.toList());

        return (ResponseEntity) userLogsDto;
    }

    @Override
    public List<UserLogsDto> findAllLogs() {
        List<UserLogs> entities = userLogsRepository.findAll();
        return entities.stream()
                .map(UserLogsMapper::toDto)
                .collect(Collectors.toList());
    }

    @Override
    public UserLogsDto findLogById(Integer id) {
        UserLogs entity = userLogsRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Log not found with ID: " + id));
        return UserLogsMapper.toDto(entity);
    }

}








package com.tcs.userservice.service;

import com.tcs.userservice.dto.UserRequestDto;
import org.springframework.http.ResponseEntity;

import java.util.Map;

public interface
UserRequestService {

        ResponseEntity createNewRequest(Map<String, Object> request, String userId);

        ResponseEntity  getPendingRequests(Map<String,Object> request);

        ResponseEntity acceptOrRejectUserRequest(UserRequestDto userRequestDto,String ipAddress);

        ResponseEntity getUserDetails(Map<String,String> params);

        ResponseEntity getMyRequests(Map<String,String> params);

        ResponseEntity cancelRequest(Map<String, Object> request);


}







package com.tcs.userservice.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tcs.userservice.ResponseVO;
import com.tcs.userservice.dto.NotificationConfigDto;
import com.tcs.userservice.dto.UserRequestDto;
import com.tcs.userservice.model.AuditLog;
import com.tcs.userservice.model.User;
import com.tcs.userservice.model.UserRequest;
import com.tcs.userservice.model.UserRole;
import com.tcs.userservice.repository.UserRepository;
import com.tcs.userservice.repository.UserRequestRepository;
import com.tcs.userservice.repository.UserRoleRepository;
import com.tcs.userservice.utility.Constant;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.*;

@Slf4j
@Service
public class UserRequestServiceImpl implements UserRequestService {
    private static final String EVENT_SOURCE = "USER_SERVICE";
    private static final String REQUEST_TYPE_KEY = "USER_MANAGEMENT";
    private final String STATUS = Constant.STATUS;
    private final String MESSAGE = Constant.MESSAGE;
    @Autowired
    NotificationWriterService notificationWriterService;

    @Autowired
    PermissionConfigService permissionConfigService;
    @Autowired
    private UserRequestRepository userRequestRepository;
    @Autowired
    private ObjectMapper objectMapper;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private UserRoleRepository userRoleRepository;

    private static String getStatusText(boolean success, String actionFlag) {
        String statusText;
        if (Constant.PENDING.equalsIgnoreCase(actionFlag)) {
            statusText = success ? Constant.PENDING : Constant.FAILED;
        } else if (actionFlag.equalsIgnoreCase(Constant.ACCEPT)) {
            statusText = success ? Constant.APPROVED : Constant.FAILED;
        } else if (actionFlag.equalsIgnoreCase(Constant.REJECT)) {
            statusText = Constant.REJECTED;
        } else {
            statusText = Constant.UNKNOWN;
        }
        return statusText;
    }

    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> createNewRequest(Map<String, Object> request, String userId) {
        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();

        UserRequest savedRequest = null;
        UserRequestDto dto = null;
        String targetUserId;

        try {

            targetUserId = request.get("targetUserId").toString();
            String requestType = request.get("requestType").toString();

            UserRequest userRequest = objectMapper.convertValue(request, UserRequest.class);
            userRequest.setRequestDate(new Timestamp(System.currentTimeMillis()));

            // 2. Fetch current user state
            User user = userRepository.findUserByUserId(targetUserId);

            // 3. Business validation
            if (userRequestRepository.countUserPendingRequests(targetUserId) > 0) {
                // Already pending request
                setConflictResult(result, "There is already a pending request for this user", responseVo);
            } else if (requestType.equalsIgnoreCase(Constant.CREATE) && user != null) {
                // Trying to create existing user
                setConflictResult(result, "User already exists", responseVo);
            } else if (!requestType.equalsIgnoreCase(Constant.CREATE) && user == null) {
                // Trying to modify non-existing user
                setConflictResult(result, "User does not exist", responseVo);
            } else {
                // 4. Happy path ‚Äì save userRequest
                userRequest.setRequestorUserId(userId);
                userRequest.setRequestStatus(Constant.PENDING);
                log.info("User Request: {}", userRequest);

                savedRequest = userRequestRepository.save(userRequest);

                result.put("userRequest", savedRequest);
                result.put(STATUS, true);
                result.put(MESSAGE, "New request created");

                responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.CREATED.value()));
                responseVo.setMessage(HttpStatus.CREATED.getReasonPhrase());
            }

            // 5. Notification (for both success + business failure)
            boolean success = Boolean.TRUE.equals(result.get(STATUS));
            String message = (String) result.getOrDefault(MESSAGE, "No message");

            // notification services integration for user creation/ modification requests
            assert savedRequest != null;
            createRequestNotification(userRequestRepository.getUserRequestDto(String.valueOf(savedRequest.getRequestId())), targetUserId, savedRequest, success, message, Constant.PENDING);

            responseVo.setResult(result);

        } catch (IllegalArgumentException e) {
            log.error("Invalid request payload", e);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
            responseVo.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
            responseVo.setResult(Collections.emptyMap());
        }

        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
    }

    /**
     * Helper to avoid repeating conflict response setup.
     */
    private void setConflictResult(Map<String, Object> result, String message, ResponseVO<Map<String, Object>> responseVo) {
        result.put(STATUS, false);
        result.put(MESSAGE, message);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.CONFLICT.value()));
        responseVo.setMessage(HttpStatus.CONFLICT.getReasonPhrase());
    }

    public ResponseEntity<ResponseVO<Map<String, Object>>> getPendingRequests(Map<String, Object> params) {
        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();
        String userId = (String) params.get("userId");
        log.info("userId : {}", userId);
        if (userId != null && !userId.isEmpty()) {
            try {
                List<UserRequest> pendingRequests = userRequestRepository.findUserPendingRequests(userId);

                if (pendingRequests.isEmpty()) {

                    result.put(STATUS, false);
                    result.put(MESSAGE, "No pending requests");
                } else {
                    result.put(STATUS, true);
                    result.put(MESSAGE, String.format("%d pending requests found for user", pendingRequests.size()));
                    result.put("pendingRequests", pendingRequests);
                }
                responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
                responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
                responseVo.setResult(result);
            } catch (IllegalArgumentException e) {
                responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
                responseVo.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
            }
        } else {
            result.put(STATUS, false);
            result.put(MESSAGE, "Invalid user id");
            responseVo.setResult(result);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
            responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
        }

        return new ResponseEntity(responseVo, responseVo.getStatusCode());
    }

    /**
     * Super method for handling all requests in SRP-style
     *
     */
    @Transactional(rollbackFor = Exception.class)
    public ResponseEntity<ResponseVO<Map<String, Object>>> acceptOrRejectUserRequest(UserRequestDto userRequestDto, String ipAddress) {
        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();

        String actionFlag = userRequestDto.getActionFlag();
        String approverUserId = userRequestDto.getApproverUserId();

        long requestId = userRequestDto.getRequestId();
        UserRequest userRequest = userRequestRepository.findUserRequestsByRequestId(requestId);

        userRequest.setApproverUserId(approverUserId);
        userRequest.setApprovalDate(new Timestamp(System.currentTimeMillis()));

        String requestFlag = userRequest.getRequestType();

        if (actionFlag.equalsIgnoreCase(Constant.ACCEPT)) {
            handleAcceptFlow(userRequestDto, ipAddress, userRequest, requestFlag, result);
        } else if (actionFlag.equalsIgnoreCase(Constant.REJECT)) {
            handleRejectFlow(userRequestDto, userRequest, result);
        } else {
            result.put("status", false);
            result.put("message", "Invalid action flag");
        }

        // Final request status only when ACCEPT and business success
        if (actionFlag.equalsIgnoreCase(Constant.ACCEPT) && Boolean.TRUE.equals(result.get("status"))) {
            userRequest.setRequestStatus(Constant.ACCEPTED);
            userRequestRepository.save(userRequest);
        }

        // ---------- Notification ----------
        boolean success = Boolean.TRUE.equals(result.get("status"));
        String infoMessage = (String) result.getOrDefault("message", "No message");

        String message = "[" + getStatusText(success, userRequestDto.getActionFlag()) + "] "
                + userRequestDto.getRequestType() + " request for " + userRequest.getTargetUserId()
                + " - " + infoMessage;

        notificationWriterService.createNotification(
                userRequestDto.getRequesterUserId(), // id to be excluded
                null,    // e.g. "51,55"
                message, "/dashboard",      // e.g. "/user-requests"
                String.valueOf(userRequest.getRequestId()),
                EVENT_SOURCE);

        // ------------ notification ends -------------

        responseVo.setResult(result);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
        responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
    }

    /**
     * Handles the ACCEPT path: create/modify/lock/unlock/delete.
     */
    private void handleAcceptFlow(UserRequestDto userRequestDto, String ipAddress, UserRequest userRequest, String requestFlag, Map<String, Object> result) {

        String approverUserId = userRequestDto.getApproverUserId();
        long requestId = userRequestDto.getRequestId();

        // Init audit log (only meaningful when change actually happens)
        AuditLog newLog = new AuditLog();
        newLog.setRequestId(requestId);
        newLog.setUserId(approverUserId);
        newLog.setOldValue(userRequestDto.getOldValue());
        newLog.setChangeType(Constant.USER);
        newLog.setActionType(Constant.USER + requestFlag + "ED");
        newLog.setNewValue(userRequest.getRequestPayload());
        newLog.setIpAddress(ipAddress);

        User user = userRepository.findUserByUserId(userRequest.getTargetUserId());

        if (user == null && !(requestFlag.equalsIgnoreCase(Constant.CREATE))) {
            result.put("status", false);
            result.put("message", "User not found");
            return;
        }

        if (user != null && (requestFlag.equalsIgnoreCase(Constant.CREATE))) {
            result.put("status", false);
            result.put("message", "User already present");
            return;
        }

        if (requestFlag.equalsIgnoreCase(Constant.MODIFY) || requestFlag.equals(Constant.CREATE)) {
            handleCreateOrModifyUser(userRequest, requestFlag, user, result);
        } else if (requestFlag.equalsIgnoreCase(Constant.LOCK) || requestFlag.equalsIgnoreCase(Constant.UNLOCK)) {
            handleLockUnlockUser(requestFlag, user, result);
        } else if (requestFlag.equalsIgnoreCase("D")) {
            handleDeleteUser(user, result);
        } else {
            result.put("status", false);
            result.put("message", "Invalid request flag");
        }
    }

    /**
     *
     *
     */
    private void handleRejectFlow(UserRequestDto userRequestDto, UserRequest userRequest, Map<String, Object> result) {
        userRequest.setRequestStatus(Constant.REJECTED);
        userRequest.setReasonForRejection(userRequestDto.getRemarks());
        userRequestRepository.save(userRequest);

        result.put("status", true);
        result.put("message", "User request rejected");
    }

    /**
     * CREATE / MODIFY logic for User + UserRole.
     */
    private void handleCreateOrModifyUser(UserRequest userRequest, String requestFlag, User user, Map<String, Object> result) {
        if (requestFlag.equals(Constant.CREATE)) {
            user = new User();
            user.setAccountStatus(Constant.ACTIVE);
            user.setCreatedAt(new Timestamp(System.currentTimeMillis()));
            user.setIsDeleted('N');
            user.setUserWrongPasswordCount(0);
        }

        try {
            Map<String, Object> userMap = objectMapper.readValue(userRequest.getRequestPayload(), new TypeReference<Map<String, Object>>() {
            });

            applyUserPayloadToEntity(user, userRequest, userMap);
            userRepository.save(user);

            UserRole userRole = userRoleRepository.getUserRolesByUserId(userRequest.getTargetUserId());
            if (userRole == null) {
                userRole = new UserRole();
            }
            userRole.setUserId(userMap.get("userId").toString());
            userRole.setRoleId(Integer.parseInt(userMap.get("roleId").toString()));
            userRoleRepository.save(userRole);

            result.put("status", true);
            result.put("message", requestFlag.equalsIgnoreCase(Constant.CREATE) ? "USER CREATED" : "USER UPDATED");

        } catch (JsonProcessingException e) {
            result.put("status", false);
            result.put("message", e.getMessage());
        }
    }

    /**
     * LOCK / UNLOCK logic.
     */
    private void handleLockUnlockUser(String requestFlag, User user, Map<String, Object> result) {
        user.setAccountStatus(requestFlag.equalsIgnoreCase(Constant.UNLOCK) ? Constant.ACTIVE : Constant.LOCKED);

        userRepository.save(user);
        result.put("status", true);
        result.put("message", requestFlag.equalsIgnoreCase(Constant.UNLOCK) ? "USER UNLOCKED" : "USER LOCKED");
    }

    /**
     * DELETE logic.
     */
    private void handleDeleteUser(User user, Map<String, Object> result) {
        try {
            userRepository.delete(user);
            result.put("status", true);
            result.put("message", "User deleted successfully");
        } catch (Exception e) {
            result.put("status", false);
            result.put("message", "Failed to delete user");
        }
    }

    /**
     * Maps JSON payload -> User entity fields.
     */
    private void applyUserPayloadToEntity(User user, UserRequest userRequest, Map<String, Object> userMap) {
        user.setUserId(userRequest.getTargetUserId());
        user.setFirstName(Objects.toString(userMap.get("firstName"), null));
        user.setMiddleName(Objects.toString(userMap.get("middleName"), null));
        user.setLastName(Objects.toString(userMap.get("lastName"), null));
        user.setEmail(userMap.get("email").toString());
        user.setPhoneNumber(userMap.get("phoneNumber").toString());
        user.setBranch(Integer.parseInt(userMap.get("branch").toString()));
        user.setUpdatedAt(new Timestamp(System.currentTimeMillis()));
    }

    public ResponseEntity<ResponseVO<Map<String, Object>>> getUserDetailsById(String userId) {
        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();

        Map<String, Object> user = userRepository.getUserByUserId(userId);
        if (user == null) {
            result.put("status", false);
            result.put("message", String.format("User not found with ID %s", userId));
        } else {
            result.put("status", true);
            result.put("message", "User found");
            result.put("user", user);
        }
        responseVo.setResult(result);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
        responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
    }

    public ResponseEntity<ResponseVO<Map<String, Object>>> getUserDetailsByBranch(int branch) {
        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();

        List<Map<String, Object>> users = userRepository.getUsersByBranch(branch);
        if (users.isEmpty()) {
            result.put("status", false);
            result.put("message", "Users not found");
        } else {
            result.put("status", true);
            result.put("message", String.format("%d users found for %d", users.size(), branch));
            result.put("users", users);
        }
        responseVo.setResult(result);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
        responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
    }

    public ResponseEntity<ResponseVO<Map<String, Object>>> getUserDetailsByRole(String role) {
        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();

        List<Map<String, Object>> users = userRepository.getUsersByRole(role);
        if (users.isEmpty()) {
            result.put("status", false);
            result.put("message", "Users not found");
        } else {
            result.put("status", true);
            result.put("message", String.format("%d users found  ", users.size()));
            result.put("users", users);
        }
        responseVo.setResult(result);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
        responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
    }

    public ResponseEntity<ResponseVO<Map<String, Object>>> getUserDetails(Map<String, String> params) {
        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();

        String userId = params.get("id");
        Integer role = params.get("roleId") != null ? Integer.parseInt(params.get("roleId")) : null;

        //Integer branch = params.get("branch")!=null?Integer.parseInt(params.get("branch")):null;
        Map<String, Object> result = new HashMap<>();
        log.info("userID:{}", userId);
        log.info("Role :{}", role);


        List<Map<String, Object>> users = userRepository.getUsers(userId, role);
        if (users.isEmpty()) {
            result.put("status", false);
            result.put("message", "Users not found");
        } else {
            result.put("status", true);
            result.put("message", String.format("%d users found ", users.size()));
            result.put("users", users);
        }
        responseVo.setResult(result);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
        responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());


    }

    public ResponseEntity<ResponseVO<Map<String, Object>>> getMyRequests(Map<String, String> params) {
        ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
        Map<String, Object> result = new HashMap<>();
        String userId = params.get("userId");
        if (userId != null && !userId.isEmpty()) {
            try {
                List<UserRequest> myRequests = userRequestRepository.findUserRequestsByRequestorUserId(userId);

                if (myRequests.isEmpty()) {

                    result.put(STATUS, false);
                    result.put(MESSAGE, "You have raised 0 requests");
                } else {
                    result.put(STATUS, true);
                    result.put(MESSAGE, String.format("You have raised %d  requests.", myRequests.size()));
                    result.put("myRequests", myRequests);
                    result.put("requestCount", myRequests.size());
                }
                responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
                responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
                responseVo.setResult(result);
            } catch (IllegalArgumentException e) {
                responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
                responseVo.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
            }
        } else {
            result.put(STATUS, false);
            result.put(MESSAGE, "Invalid user id");
            responseVo.setResult(result);
            responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
            responseVo.setMessage(HttpStatus.OK.getReasonPhrase());
        }

        return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
    }

    @Override
    public ResponseEntity cancelRequest(Map<String, Object> request) {
        ResponseVO responseVO = new ResponseVO();
        Map<String, Object> result = new HashMap<>();
        try {
            long requestId = Long.parseLong(request.get("requestId").toString());
            String userId = (String) request.get("userId");
            UserRequest userRequest = userRequestRepository.findUserRequestsByRequestId(requestId);

            if (userRequest == null) {
                result.put(STATUS, false);
                result.put(MESSAGE, "Request not found");
                responseVO.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
                responseVO.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
                responseVO.setResult(result);
            } else if (userId == null || userId.isEmpty() || !userId.equals(userRequest.getRequestorUserId())) {
                result.put(STATUS, false);
                result.put(MESSAGE, "You are unauthorized to cancel this request");
                responseVO.setStatusCode(HttpStatusCode.valueOf(HttpStatus.UNAUTHORIZED.value()));
                responseVO.setMessage(HttpStatus.UNAUTHORIZED.getReasonPhrase());

            } else {
                userRequestRepository.delete(userRequest);
                result.put(STATUS, true);
                result.put(MESSAGE, "Request cancelled");
                responseVO.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
                responseVO.setMessage(HttpStatus.OK.getReasonPhrase());
            }

        } catch (NullPointerException | NumberFormatException e) {

            result.put(STATUS, false);
            result.put(MESSAGE, e.getMessage());
            responseVO.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
            responseVO.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
        }
        responseVO.setResult(result);
        return new ResponseEntity(responseVO, responseVO.getStatusCode());
    }

    /**
     *
     * Helper method ‚Äì called from createNewRequest(), acceptOrRejectUserRequest()
     * If this throws, the @Transactional on createNewRequest and acceptOrRejectUserRequest
     * will roll back everything.
     */
    private void createRequestNotification(UserRequestDto dto, String targetId, UserRequest savedRequest, boolean success, String infoMessage, String actionFlag) {
        try {
            // 1. Fetch Config from CACHE/DB
            NotificationConfigDto config = permissionConfigService.getConfig(REQUEST_TYPE_KEY);

            String statusText = getStatusText(success, actionFlag);

            String message = "[" + statusText + "] " + dto.getRequestType() + " request for " + targetId + " - " + infoMessage;

            String referenceId = String.valueOf(savedRequest.getRequestId());

            notificationWriterService.createNotification(dto.getRequesterUserId(), // id to be excluded
                    config.getTargetRoles(),    // e.g. "51,55"
                    message, config.getTargetUrl(),      // e.g. "/user-requests"
                    referenceId, EVENT_SOURCE);

        } catch (Exception e) {
            log.error("CRITICAL: Failed to create notification for request: {}. Rolling back transaction.", dto.getRequestId(), e);
            throw new RuntimeException("Failed to create notification event, rolling back.", e);
        }
    }


}





package com.tcs.userservice.utility;

public class Constant {
    public static final String UNKNOWN = "UNKNOWN";
    public static final String STATUS = "status";
    public static final String MESSAGE = "message";
    public static final String ACCEPTED = "ACCEPTED";
    public static final String REJECTED = "REJECTED";
    public static final String LOCKED = "LOCKED";
    public static final String SUCCESS = "SUCCESS";
    public static final String ERROR = "ERROR";
    public static final String LOCK = "LOCK";
    public static final String UNLOCK = "UNLOCK";
    public static final String ACTIVE = "ACTIVE";
    public static final String INACTIVE = "INACTIVE";
    public static final String CREATE = "CREATE";
    public static final String MODIFY = "MODIFY";
    public static final String DELETE = "DELETE";
    public static final String BLOCK = "BLOCK";
    public static final String UNBLOCK = "UNBLOCK";
    public static final String ACCEPT = "ACCEPT";
    public static final String REJECT = "REJECT";
    public static final String PENDING = "PENDING";
    public static final String ROLE = "ROLE";
    public static final String USER = "USER";
    public static final String CANCEL= "CANCELED";
    public static final String FAILED= "FAILED";
    public static final String APPROVED= "APPROVED";


}







package com.tcs.userservice.utility;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;

import java.util.Map;


public class RequestUtility {
    public static String verifyPayload(String payload,String[] keys){
        ObjectMapper mapper = new ObjectMapper();
        Map map = mapper.convertValue(payload, Map.class);
        for(String key:keys){
            if(map.get(key)==null) return key;
        }
        return "";
    }
    public static boolean verifyRequest(Map<String,Object>request,String[] keys){
        for(String key:keys){
            if(request.get(key)==null) return false;
        }
        return request==null;
    }

    public static String getClientIp(ServerHttpRequest request)
    {
        String ip = request.getHeaders().getFirst("X-Forwarded-For");

        if(ip ==null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip))
        {
            ip = String.valueOf(request.getRemoteAddress());

        }
        if(ip!=null){
            if(ip.contains(",")){
                ip = ip.split(",")[0].trim();
            } else if (ip.startsWith("::ffff:")) {
                ip = ip.substring(7);

            }
            else if (ip.startsWith("::1"))
            {
                ip = ip.substring(3);
            }

        }

        return ip;
    }
}










package com.tcs.userservice;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;

import java.sql.Timestamp;

@Getter
@Setter
public class ResponseVO<T>{
    private HttpStatusCode statusCode;
    private String message;
    private T result;
    private Timestamp timestamp;





}











package com.tcs.userservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;

@SpringBootApplication
@EnableCaching
public class UserServiceApplication {

    public static void main(String[] args) {
        System.setProperty("spring.classformat.ignore", "true");
        SpringApplication.run(UserServiceApplication.class, args);
    }

}






spring.application.name=userService
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.profiles.active=dev

# --- Redis Configuration ---
spring.cache.type=redis

# --- Kafka Configuration ---
# --- Jackson (JSON) ---
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=UTC
spring.jackson.serialization.write-dates-as-timestamps=false

## --- Debezium JSON Deserialization ---
## This tells Spring Kafka to parse the incoming JSON into our Java objects (DTOs)
# Force String Deserialization for both Key and Value
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer
# Disable JSON type mapping features to prevent auto-conversion attempts
spring.kafka.consumer.properties.spring.json.trusted.packages=*
spring.kafka.consumer.properties.spring.json.use.type.headers=false

# --- JPA Common ---
spring.jpa.open-in-view=false

# --- Actuator Base Config ---
# Enable the endpoints, but control exposure in specific profile files
management.endpoints.web.base-path=/actuator
management.endpoint.health.probes.enabled=true

# LOGIN SERVICE KEY USED BY common-entities
jwt.secret=bWV0aGlvbnlsdGhyZW9ueWx0aHJlb255bGdsdXRhbWlueWxhbGFueWw=











server.port=8087

# --- Database ---
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.datasource.url=jdbc:oracle:thin:@10.177.103.192:1523/fincorepdb1
spring.datasource.username=fincore
spring.datasource.password=Password#1234

# LOGIN SERVICE KEY USED BY common-entities
jwt.secret=bWV0aGlvbnlsdGhyZW9ueWx0aHJlb255bGdsdXRhbWlueWxhbGFueWw=

# In Dev only auto-update schema
#spring.jpa.hibernate.ddl-auto=update
#spring.jpa.show-sql=true

# --- Redis (Docker Localhost) ---
spring.data.redis.host=localhost
spring.data.redis.port=6379

# --- Kafka (Localhost) ---
spring.kafka.consumer.bootstrap-servers=localhost:9092
spring.kafka.producer.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=rbac-cache-group
spring.kafka.consumer.auto-offset-reset=earliest

# ======================== Actuator (for Dev) =============================
# Expose EVERYTHING for easy debugging
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always
management.info.env.enabled=true

# Add some custom info to the /info endpoint
info.app.name=UserService - DEV env
info.app.description=Service for managing all user and role related operations
info.app.version=1.0.0

# ========================= 2. LOG ROLLING POLICIES =========================
# Keep logs for 7 days (Old logs auto-deleted)
logging.logback.rollingpolicy.max-history=30

# Log file rotation based on size (Each file max 10MB)
logging.logback.rollingpolicy.max-file-size=10MB

# Roll logs daily (Time-based rolling)
logging.logback.rollingpolicy.file-name-pattern=${logging.file.path}/Archived/${spring.application.name}-%d{yyyy-MM-dd}.%i.log.zip

# ========================= 3. LOG FORMATTING =========================
# Console log pattern (Color-coded output)
logging.pattern.console=%d{yyyy-MM-dd :: HH:mm:ss.SSS ||} %highlight(%-5level:: %file: | %line |){ERROR=bold red, WARN=yellow, INFO=white, DEBUG=green, TRACE=green} ::  %msg%n

# File log pattern
logging.pattern.file=%d{yyyy-MM-dd :: HH:mm:ss.SSS ||}  %-5level:: %file: | %line | :: %msg %n


















