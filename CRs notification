package com.fincore.NotificationService.service;

import com.fincore.NotificationService.model.UserRole;
import com.fincore.NotificationService.repository.UserRoleRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class UserService {
    private static final Logger log = LoggerFactory.getLogger(UserService.class);

    private final UserRoleRepository userRoleRepository;

    public UserService(UserRoleRepository userRoleRepository) {
        this.userRoleRepository = userRoleRepository;
    }

    /**
     * Determines target users based on a generic target string.
     * Supports:
     * 1. Single Role: "55"
     * 2. Multiple Roles: "55,52,53"
     * 3. All Users: "ALL_USERS"
     */
    public List<String> resolveTargetUsers(String targetRoleString) {
        if (targetRoleString == null || targetRoleString.isEmpty()) {
            return Collections.emptyList();
        }

        // SCENARIO: ALL USERS
        if ("ALL_USERS".equalsIgnoreCase(targetRoleString)) {
            log.info("Target is ALL_USERS. Fetching all users from DB...");
            return userRoleRepository.findAllUserIds();
        }

        // SCENARIO: MULTIPLE ROLES (Comma Separated)
        if (targetRoleString.contains(",")) {
            List<String> roleIds = Arrays.stream(targetRoleString.split(","))
                    .map(String::trim)
                    .collect(Collectors.toList());
            
            log.info("Target contains multiple roles: {}", roleIds);
            // We don't cache this complex query easily, hitting DB is safer here
            return userRoleRepository.findByRoleIdIn(roleIds)
                    .stream()
                    .map(UserRole::getUserId)
                    .distinct() // Remove duplicates if a user has multiple roles
                    .collect(Collectors.toList());
        }

        // SCENARIO: SINGLE ROLE (Cached)
        return findUserIdsByRole(targetRoleString);
    }

    @Cacheable(value = "roles", key = "#roleId")
    public List<String> findUserIdsByRole(String roleId) {
        log.info("Cache miss for role: {}. Querying local Postgres DB...", roleId);
        return userRoleRepository.findByRoleId(roleId)
                .stream()
                .map(UserRole::getUserId)
                .collect(Collectors.toList());
    }
}








package com.fincore.NotificationService.service;

import com.fincore.NotificationService.model.UserRole;
import com.fincore.NotificationService.repository.UserRoleRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class UserService {
    private static final Logger log = LoggerFactory.getLogger(UserService.class);

    private final UserRoleRepository userRoleRepository;

    public UserService(UserRoleRepository userRoleRepository) {
        this.userRoleRepository = userRoleRepository;
    }

    /**
     * Determines target users based on a generic target string.
     * Supports:
     * 1. Single Role: "55"
     * 2. Multiple Roles: "55,52,53"
     * 3. All Users: "ALL_USERS"
     */
    public List<String> resolveTargetUsers(String targetRoleString) {
        if (targetRoleString == null || targetRoleString.isEmpty()) {
            return Collections.emptyList();
        }

        // SCENARIO: ALL USERS
        if ("ALL_USERS".equalsIgnoreCase(targetRoleString)) {
            log.info("Target is ALL_USERS. Fetching all users from DB...");
            return userRoleRepository.findAllUserIds();
        }

        // SCENARIO: MULTIPLE ROLES (Comma Separated)
        if (targetRoleString.contains(",")) {
            List<String> roleIds = Arrays.stream(targetRoleString.split(","))
                    .map(String::trim)
                    .collect(Collectors.toList());
            
            log.info("Target contains multiple roles: {}", roleIds);
            // We don't cache this complex query easily, hitting DB is safer here
            return userRoleRepository.findByRoleIdIn(roleIds)
                    .stream()
                    .map(UserRole::getUserId)
                    .distinct() // Remove duplicates if a user has multiple roles
                    .collect(Collectors.toList());
        }

        // SCENARIO: SINGLE ROLE (Cached)
        return findUserIdsByRole(targetRoleString);
    }

    @Cacheable(value = "roles", key = "#roleId")
    public List<String> findUserIdsByRole(String roleId) {
        log.info("Cache miss for role: {}. Querying local Postgres DB...", roleId);
        return userRoleRepository.findByRoleId(roleId)
                .stream()
                .map(UserRole::getUserId)
                .collect(Collectors.toList());
    }
}







package com.fincore.NotificationService.service;

import com.fincore.NotificationService.dto.DispatchEvent;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
@Slf4j
public class InternalNotificationListener {

    @Autowired
    private EventProcessorService eventProcessorService;

    /**
     * WORKER CONSUMER
     * Listens to 'notification.dispatch'.
     * Can be scaled by running multiple instances of this service.
     */
    @KafkaListener(
            topics = "notification.dispatch", 
            groupId = "notification-dispatch-workers",
            containerFactory = "kafkaListenerContainerFactory" // reusing the generic factory
    )
    public void consumeDispatchEvent(ConsumerRecord<String, DispatchEvent> record) {
        try {
            DispatchEvent event = record.value();
            eventProcessorService.processDispatchEvent(event);
        } catch (Exception e) {
            log.error("Error processing dispatch event: {}", e.getMessage(), e);
            // Ideally, throw exception here to trigger retry/DLQ
        }
    }
}










    // ... inside existing class ...

    // --- LISTENER 1: For Notifications ---
    @KafkaListener(topics = "fincore.FTWOAHM.NOTIFICATION_TABLE", containerFactory = "kafkaListenerContainerFactory")
    public void listen(DebeziumEvent event) {
        try {
            log.info("ðŸŽ‰ KAFKA OUTBOX EVENT RECEIVED!");
            // CHANGED: Call processDebeziumEvent (The Splitter)
            eventProcessorService.processDebeziumEvent(event); 

        } catch (Exception e) {
            log.error("Error processing notification event: {}", e.getMessage(), e);
            throw new RuntimeException("Error processing notification event", e);
        }
    }
    
    // ... rest of the class ...






