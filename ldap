package com.fincore.gateway.Config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.ldap.core.LdapTemplate;
import org.springframework.ldap.core.support.LdapContextSource;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Configuration
public class LdapConfig {

    @Value("${spring.ldap.urls:ldaps://10.189.42.83:636}")
    private String ldapUrl;

    @Value("${spring.ldap.base:DC=UATAD,DC=SBI}")
    private String ldapBaseDn;

    // We will inject the ResourceLoader to find the file
    private final ResourceLoader resourceLoader;

    public LdapConfig(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }

    @Bean
    public LdapContextSource contextSource() {
        log.info("Configuring LDAP Context Source. URL: {}", ldapUrl);

        // =========================================================================
        // DYNAMIC TRUSTSTORE LOADING
        // This allows us to keep the cert in the application resources
        // =========================================================================
        try {
            Resource trustStore = resourceLoader.getResource("classpath:ad-truststore.jks");
            if (trustStore.exists()) {
                String trustStorePath = trustStore.getFile().getAbsolutePath();
                log.info("Setting custom truststore from: {}", trustStorePath);

                System.setProperty("javax.net.ssl.trustStore", trustStorePath);
                System.setProperty("javax.net.ssl.trustStorePassword", "changeit");
            } else {
                log.warn("ad-truststore.jks NOT FOUND in classpath. Falling back to system truststore.");
            }
        } catch (IOException e) {
            log.error("Could not load custom truststore", e);
        }

        LdapContextSource contextSource = new LdapContextSource();
        contextSource.setUrl(ldapUrl);
        contextSource.setBase(ldapBaseDn);

        // Timeout Configuration
        Map<String, Object> baseEnv = new HashMap<>();
        baseEnv.put("java.naming.security.protocol", "ssl");
        baseEnv.put("com.sun.jndi.ldap.connect.timeout", "5000");
        baseEnv.put("com.sun.jndi.ldap.read.timeout", "5000");

        contextSource.setBaseEnvironmentProperties(baseEnv);
        return contextSource;
    }

    @Bean
    public LdapTemplate ldapTemplate() {
        return new LdapTemplate(contextSource());
    }
}
















package com.fincore.gateway.Service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.ldap.CommunicationException;
import org.springframework.ldap.core.LdapTemplate;
import org.springframework.stereotype.Service;

/**
 * Service responsible for interacting with Active Directory.
 * Handles the "Bind" operation to verify credentials.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class AdAuthenticationService {

    private final LdapTemplate ldapTemplate;

    @Value("${spring.ldap.domain:UATAD.SBI}")
    private String adDomain;

    /**
     * Authenticate against Active Directory by attempting a Bind.
     * * @param username The sAMAccountName (e.g., "7378051")
     *
     * @param password The raw password
     * @return true if credentials are valid, false otherwise.
     */
    public boolean authenticate(String username, String password) {
        if (username == null || username.isBlank() || password == null || password.isBlank()) {
            log.warn("LDAP Auth failed: Empty username or password");
            return false;
        }

        try {
            // AD usually requires "user@domain.com" or "DOMAIN/user" for binding.
            // Using the UPN (User Principal Name) format is standard.
            // Logic: username + "@" + "UATAD.SBI"
            String principalName = username + "@" + adDomain;

            log.info("Attempting LDAP Bind for principal: {}", principalName);

            // The authenticate method handles the opening of connection and binding.
            // Filter: (sAMAccountName=username) checks if the user exists.
            // Password: The credential to verify.
            boolean authenticated = ldapTemplate.authenticate(
                    "",                                  // Base DN is already set in config
                    "(sAMAccountName=" + username + ")", // Filter to locate the user
                    password                             // Password to verify
            );

            if (authenticated) {
                log.info("LDAP Authentication SUCCESS for user: {}", username);
                return true;
            } else {
                log.warn("LDAP Authentication FAILED for user: {} (Invalid Credentials)", username);
                return false;
            }

        } catch (CommunicationException e) {
            // Server is down or SSL failed.
            log.error("LDAP CONNECTION ERROR: {}", e.getMessage());
            // Throwing exception allows LoginService to know it wasn't a wrong password
            throw new RuntimeException("LDAP Server Down");
        } catch (Exception e) {
            // CRITICAL: Handle Server Down or Network issues
            log.error("LDAP Generic Error during auth for user: {}. Error: {}", username, e.getMessage());
            // In a production app, you might want to throw a specific custom exception
            // if you want to differentiate between "Wrong Password" and "Server Down".
            return false;
        }
    }
}


















package com.fincore.gateway.Service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.gateway.JwtUtil.HmacJwtUtil;
import com.fincore.gateway.dto.*;
import com.fincore.gateway.model.LoginAttempt;
import com.fincore.gateway.model.LoginParam;
import com.fincore.gateway.model.User;
import com.fincore.gateway.model.UserRoles;
import com.fincore.gateway.repository.LoginAttemptRepository;
import com.fincore.gateway.repository.LoginParamRepository;
import com.fincore.gateway.repository.RolePermissionsRepository;
import com.fincore.gateway.repository.UserRepository;
import com.fincore.gateway.utility.Constants;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 * Service implementation handling user login/verification, menu resolution, and password updates.
 *
 * <p><strong>Responsibilities</strong>
 * <ul>
 *   <li>Validate credentials (password-based and SSO-based)</li>
 *   <li>Issue HS256 JWTs and embed limited user/role claims</li>
 *   <li>Transform role permissions into menu responses</li>
 *   <li>Track login attempts and enforce wrong password limits</li>
 * </ul>
 *
 * <p><strong>Notes</strong>
 * <ul>
 *   <li>JWT generation uses an HMAC Base64 secret; ensure it is configured for the environment.</li>
 *   <li>{@code BCryptPasswordEncoder} is created locally for convenience; consider injecting a singleton bean instead.</li>
 *   <li>Write operations are wrapped in {@link Transactional} where appropriate.</li>
 * </ul>
 */
@Slf4j
@Service("LoginService")
@RequiredArgsConstructor
public class LoginServiceImpl implements LoginService {

    /**
     * Prefer injecting a singleton bean; retained local instance for compatibility.
     */
    private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

    // ======= Config =======
    private final UserRepository userRepository;
    private final LoginAttemptRepository loginAttemptRepository;

    // ======= Dependencies =======
    private final LoginParamRepository loginParamRepository;
    private final RolePermissionsRepository rolePermissionsRepository;
    private final MenuService menuService;
    private final ObjectMapper mapper;

    // LDAP Service
    private final AdAuthenticationService adAuthenticationService;

    /**
     * Base64-encoded HMAC secret used to sign HS256 JWTs.
     */
    @Value("${security.jwt.hmac-base64-secret:}")
    private String hmacSecret;
    /**
     * Token time-to-live in seconds.
     */
    @Value("${security.jwt.ttl-seconds:900}")
    private long ttlSeconds;

    // ======= Public API =======

    /**
     * Fetches role-wise permissions for the given user and transforms them into a menu response.
     *
     * @param userId ID of the user
     * @return {@link MenuResponse} built from ordered permissions; empty if none or on error
     */
    @Transactional(readOnly = true)
    @Override
    public MenuResponse fetchRoleWiseData(String userId) {
        log.info("Fetching role-wise data for userId: {}", userId);
        try {
            List<PermissionRow> rows = rolePermissionsRepository.findAllPermissionsByUserId(userId);

            if (rows == null || rows.isEmpty()) {
                log.info("No permissions found for userId: {}", userId);
                return new MenuResponse(Collections.emptyList());
            }
            return menuService.transformFromProjection(rows);
        } catch (Exception e) {
            log.error("Error fetching permissions for userId: {}", userId, e);
            return new MenuResponse(Collections.emptyList());
        }
    }

    /**
     * Verifies user credentials and, on success, builds {@link UserDto} populated with an access token and token data.
     * <p>Also records the login attempt and enforces password attempt limits.</p>
     *
     * @param userCredentials payload containing {@code userId} and (for password mode) {@code password}
     * @param clientIp        caller's IP address for audit
     * @return {@link UserDto} with validity flags, statuses, and (if valid) a signed access token
     */
    @Transactional
    @Override
    public UserDto verifyUserCredentials(UserDto userCredentials, String clientIp) {

        final String userId = userCredentials.getUserId();
        final String rawPassword = userCredentials.getPassword();

        UserDto result = new UserDto();

        // 1. AUTHORIZATION CHECK (Must exist in Local DB)
        User user = userRepository.findByUserId(userId);
        if (user == null) {
            result.setValidCredentials(false);
            result.setUserStatus(Constants.INVALID);
            log.warn("Login blocked: User {} not found in local DB.", userId);
            return result;
        }

        LoginParam loginParam = loginParamRepository.getLoginParam();
        char activeMode = loginParam.getActiveLoginMode();

        // Prepare Audit Log
        LoginAttempt attempt = new LoginAttempt();
        attempt.setLoginMethod(determineMethodString(activeMode));
        attempt.setSuccess("N");
        attempt.setIpAddress(clientIp);
        attempt.setUserId(userId);

        result.setLoginMethod(activeMode);
        result.setUserId(user.getUserId());

        UserRoles userRole = userRepository.getUserRole(userId);

        // 2. STATUS CHECKS
        result.setRoleStatus(userRole.getRoleStatus());
        result.setUserStatus(user.getAccountStatus());
        result.setPasswordLoginStatus(user.getPasswordLogin());

        if (!Constants.ACTIVE.equalsIgnoreCase(userRole.getRoleStatus())) {
            attempt.setFailureReason(generateStatusMessage(userRole.getRoleStatus(), "role"));
            loginAttemptRepository.save(attempt);
            result.setValidCredentials(false);
            return result;
        }

        if (!Constants.ACTIVE.equalsIgnoreCase(user.getAccountStatus())) {
            attempt.setFailureReason(generateStatusMessage(user.getAccountStatus(), "user"));
            loginAttemptRepository.save(attempt);
            result.setValidCredentials(false);
            return result;
        }

        // 3. AUTHENTICATION LOGIC BASED ON MODE
        if (activeMode == Constants.LDAP) {
            // --- MODE: LDAP ---
            log.info("Processing LDAP Login for user: {}", userId);
            boolean ldapSuccess = adAuthenticationService.authenticate(userId, rawPassword);

            if (ldapSuccess) {
                // LDAP Success -> Treat as valid login
                handleSuccess(attempt, result, user, userRole);
            } else {
                // LDAP Failure -> Handle as wrong credentials
                // Note: We intentionally map LDAP failure to "Password Based Login" failure logic
                // to reuse the lockout mechanism/audit logs if desired.
                handleFailure(attempt, result, user, loginParam, "LDAP Authentication Failed");
            }

        } else if (activeMode == Constants.PASSWORD) {
            // --- MODE: LOCAL PASSWORD ---
            // Check if Password Login is explicitly disabled for this specific user
            if (Constants.ACTIVE.equalsIgnoreCase(user.getPasswordLogin())) {
                passwordBasedLogin(rawPassword, attempt, result, user, loginParam);
            } else {
                // Account is Locked or Disabled
                handleAccountLocked(attempt, result, user);
            }

        } else {
            // --- MODE: SSO (Existing Logic) ---
            attempt.setSuccess("Y");
            attempt.setFailureReason("SUCCESS");
            result.setValidCredentials(true);

            // Re-enable password login if it was locked, upon successful SSO
            if (Constants.INACTIVE.equalsIgnoreCase(user.getPasswordLogin())) {
                user.setPasswordLogin(Constants.ACTIVE);
                userRepository.save(user);
            }
            handleSuccess(attempt, result, user, userRole);
        }

        loginAttemptRepository.save(attempt);
        log.debug("verifyUserCredentials result={}", result);
        return result;
    }

    // --- Helper Methods to keep code clean ---

    private String determineMethodString(char mode) {
        if (mode == Constants.LDAP) return "LDAP";
        if (mode == Constants.PASSWORD) return Constants.PASSWORD_BASED_LOGIN;
        return Constants.SSO_BASED_LOGIN;
    }

    private void handleAccountLocked(LoginAttempt attempt, UserDto result, User user) {
        result.setValidCredentials(false);
        result.setPasswordLoginStatus(user.getPasswordLogin());
        result.setMessage("Your account is locked due to multiple failed attempts.");

        if (Constants.INACTIVE.equalsIgnoreCase(user.getPasswordLogin())) {
            result.setAttemptsLeft(0);
            attempt.setFailureReason("Account Locked (Pre-check)");
        } else {
            result.setMessage("Password login is disabled.");
            attempt.setFailureReason("Password login disabled");
        }
    }

    private void handleSuccess(LoginAttempt attempt, UserDto result, User user, UserRoles userRole) {
        attempt.setSuccess("Y");
        attempt.setFailureReason("Success");
        result.setValidCredentials(true);
        result.setMessage("Login Successful");

        // Reset wrong password count on successful login
        if (user.getUserWrongPasswordCount() > 0) {
            user.setUserWrongPasswordCount(0);
            userRepository.save(user);
        }

        // Generate Token
        log.info("Credentials validated. Issuing token for userId={}", user.getUserId());
        UserDto safeClaims = new UserDto();
        safeClaims.setUserId(user.getUserId());
        safeClaims.setUserrole(userRole.getRole());

        @SuppressWarnings("unchecked")
        String accessToken = HmacJwtUtil.generate(
                hmacSecret,
                user.getUserId(),
                ttlSeconds,
                mapper.convertValue(safeClaims, Map.class)
        );

        UserTokenDataDto tokenData = initializeTokenData(user, userRole);
        result.setAccessToken(accessToken);
        result.setUser(tokenData);
    }

    private void handleFailure(LoginAttempt attempt, UserDto userInfo, User user, LoginParam loginParam, String reason) {
        log.warn("Login failed for user {}: {}", user.getUserId(), reason);
        attempt.setSuccess("N");

        int currentFailedCount = user.getUserWrongPasswordCount();
        int maxAllowed = loginParam.getWrongPasswordAttempts();
        int newFailedCount = currentFailedCount + 1;

        user.setUserWrongPasswordCount(newFailedCount);
        userInfo.setValidCredentials(false);

        if (newFailedCount >= maxAllowed) {
            user.setPasswordLogin(Constants.INACTIVE);
            // user.setAccountStatus(Constants.LOCKED); // Optional: Depending on business rule
            attempt.setFailureReason(reason + " -> Account Locked");
            userInfo.setMessage("Your account has been locked due to multiple unsuccessful login attempts.");
            userInfo.setPasswordLoginStatus(Constants.INACTIVE);
            userInfo.setAttemptsLeft(0);
        } else {
            int remaining = maxAllowed - newFailedCount;
            attempt.setFailureReason(reason);
            if (remaining > 1) {
                userInfo.setMessage("Incorrect credentials. Please check and try again.");
            } else {
                userInfo.setMessage("Incorrect credentials. ⚠️ Final attempt before lock.");
            }
            userInfo.setAttemptsLeft(remaining);
        }
        userRepository.save(user);
    }


    /**
     * Password-based authentication flow that enforces wrong password limits and updates counters/flags.
     * 1. Increments count on failure.
     * 2. Calculates remaining attempts.
     * 3. Locks account immediately if limit reached.
     *
     * @param password     raw password from the request
     * @param loginAttempt login attempt entity to be updated with success/failure
     * @param userInfo     output DTO updated with validity and attempts left
     * @param user         the user entity being authenticated
     * @param loginParam   login parameter configuration (e.g., permitted attempts)
     */
    @Transactional
    @Override
    public void passwordBasedLogin(String password, LoginAttempt loginAttempt, UserDto userInfo, User user, LoginParam loginParam) {
        log.info("Password-based login for userId={}", user.getUserId());

        if (Constants.INACTIVE.equalsIgnoreCase(user.getPasswordLogin())) {
            handleAccountLocked(loginAttempt, userInfo, user);
            return;
        }

        if (encoder.matches(password, user.getPasswordHash())) {
            UserRoles userRole = userRepository.getUserRole(user.getUserId());
            handleSuccess(loginAttempt, userInfo, user, userRole);
        } else {
            handleFailure(loginAttempt, userInfo, user, loginParam, "Wrong Password");
        }
    }


    /**
     * Produces a human-readable message describing a blocked login due to {@code status} of a given {@code type}.
     *
     * @param status status string (e.g., ACTIVE/INACTIVE/LOCKED)
     * @param type   subject type (e.g., "user", "role")
     * @return formatted message
     */
    @Override
    public String generateStatusMessage(String status, String type) {
        return String.format("Trying to login with a %s %s", status, type);
    }


    /**
     * Checks the status and requirements for a user attempting to log in (without performing login).
     *
     * @param userId the user identifier
     * @return {@link VerifyUserDTO} describing status, password update requirements, and messages
     */
    @Transactional(readOnly = true)
    public VerifyUserDTO checkUser(String userId) {
        VerifyUserDTO out = new VerifyUserDTO();
        out.setUserId(userId);

        User user = userRepository.findByUserId(userId);
        LoginParam loginParam = loginParamRepository.getLoginParam();
        out.setLoginMethod(loginParam.getActiveLoginMode());

        if (user == null) {
            out.setUserCheck(false);
            out.setUserStatus(Constants.INVALID);
            out.setMessage("Invalid User");
            return out;
        }

        if (Constants.ACTIVE.equalsIgnoreCase(user.getAccountStatus())) {
            Timestamp setAt = user.getTempPasswordSetAt();
            boolean isPasswordValid = false;

            // Validate password expiration only for Password Mode
            if (loginParam.getActiveLoginMode() == Constants.PASSWORD && setAt != null) {
                LocalDateTime lastUpdate = setAt.toLocalDateTime();
                isPasswordValid = LocalDateTime.now()
                        .isBefore(lastUpdate.plusHours(loginParam.getPasswordValidity()));
            } else {
                // For LDAP/SSO, we rely on their policies, so treat local validity as true
                isPasswordValid = true;
            }

            UserRoles userRole = userRepository.getUserRole(userId);
            out.setRoleStatus(userRole.getRoleStatus());

            // Logic: Update Password only needed if Mode is Password AND (Password is null OR Expired)
            boolean updateNeeded = (loginParam.getActiveLoginMode() == Constants.PASSWORD)
                    && (user.getPasswordHash() == null || !isPasswordValid);

            out.setUpdatePassword(updateNeeded);
            out.setUserStatus(Constants.ACTIVE);
            out.setMessage(Constants.ACTIVE_USER);
            out.setPasswordLoginStatus(user.getPasswordLogin());
        } else {
            String accountStatus = user.getAccountStatus();
            out.setUserCheck(true);
            out.setUserStatus(accountStatus);
            out.setMessage(
                    accountStatus.equalsIgnoreCase("locked") ? "Your account is locked. Please contact support."
                            : accountStatus.equalsIgnoreCase("inactive") ? "Inactive User" : "Verification Pending"
            );
        }

        return out;
    }

    /**
     * Updates the user's password hash and resets the temporary password timestamp.
     * <p><strong>TODO:</strong> Integrate OTP validation before update.</p>
     *
     * @param userCredentials input DTO with {@code userId} and new raw {@code password}
     * @return {@link UpdatePasswordDTO} indicating success and message; sensitive fields are cleared
     */
    @Transactional
    public UpdatePasswordDTO updatePassword(UpdatePasswordDTO userCredentials) {
        String userId = userCredentials.getUserId();
        String password = userCredentials.getPassword();

        // Always sanitize outbound fields
        userCredentials.setUpdateFlag(false);
        userCredentials.setPassword("");
        userCredentials.setOtp("");

        try {
            User user = userRepository.findByUserId(userId);
            if (user == null) {
                userCredentials.setMessage("Invalid user id");
                return userCredentials;
            }

            String passwordHash = encoder.encode(password);
            user.setPasswordHash(passwordHash);
            user.setTempPasswordSetAt(Timestamp.valueOf(LocalDateTime.now()));
            userRepository.save(user);

            userCredentials.setMessage("User password successfully updated");
            userCredentials.setUpdateFlag(true);
        } catch (DataIntegrityViolationException e) {
            log.warn("Data integrity violation while updating password for userId={}", userId, e);
            userCredentials.setMessage("Failed to change password, please try again");
        } catch (Exception e) {
            log.error("Unexpected error while updating password for userId={}", userId, e);
            userCredentials.setMessage("Unexpected error while changing password");
        }

        return userCredentials;
    }

    // ======= Helpers =======

    /**
     * Initializes the token-visible user data embedded/returned alongside the JWT.
     *
     * @param user     the user entity
     * @param userRole the role mapping for the user
     * @return user token DTO with non-sensitive fields
     */
    private UserTokenDataDto initializeTokenData(User user, UserRoles userRole) {
        UserTokenDataDto tokenData = new UserTokenDataDto();
        tokenData.setFirstName(user.getFirstName());
        tokenData.setLastName(user.getLastName());
        tokenData.setPhoneNumber(user.getPhoneNumber());
        tokenData.setUserId(user.getUserId());
        tokenData.setBranch(user.getBranch());
        tokenData.setEmail(user.getEmail());
        tokenData.setRole(userRole.getRole());
        tokenData.setRoleName(userRole.getRoleName());
        return tokenData;
    }


    /**
     * Retrieves the full user profile for Token Refresh.
     * Uses the exact same structure as verifyUserCredentials to ensure token claims are identical.
     */
    @Override
    @Transactional(readOnly = true)
    public UserDto getUserProfile(String userId) {
        User user = userRepository.findByUserId(userId);
        UserRoles userRole = userRepository.getUserRole(userId);

        // Return null if user doesn't exist, caller handles the error
        if (user == null) {
            return null;
        }
        UserDto userDto = new UserDto();
        userDto.setUserId(user.getUserId());
        userDto.setUserStatus(user.getPasswordLogin());
        userDto.setPasswordLoginStatus(user.getPasswordLogin());
        userDto.setUser(initializeTokenData(user, userRole));
        return userDto;
    }
}

