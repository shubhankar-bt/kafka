package com.fincore.gateway.Config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.ldap.core.LdapTemplate;
import org.springframework.ldap.core.support.LdapContextSource;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Configuration
public class LdapConfig {

    @Value("${spring.ldap.urls:ldaps://10.189.42.83:636}")
    private String ldapUrl;

    @Value("${spring.ldap.base:DC=UATAD,DC=SBI}")
    private String ldapBaseDn;

    // We will inject the ResourceLoader to find the file
    private final ResourceLoader resourceLoader;

    public LdapConfig(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }

    @Bean
    public LdapContextSource contextSource() {
        log.info("Configuring LDAP Context Source. URL: {}", ldapUrl);

        // =========================================================================
        // DYNAMIC TRUSTSTORE LOADING
        // This allows us to keep the cert in the application resources
        // =========================================================================
        try {
            Resource trustStore = resourceLoader.getResource("classpath:ad-truststore.jks");
            if (trustStore.exists()) {
                String trustStorePath = trustStore.getFile().getAbsolutePath();
                log.info("Setting custom truststore from: {}", trustStorePath);
                
                System.setProperty("javax.net.ssl.trustStore", trustStorePath);
                System.setProperty("javax.net.ssl.trustStorePassword", "changeit");
            } else {
                log.warn("ad-truststore.jks NOT FOUND in classpath. Falling back to system truststore.");
            }
        } catch (IOException e) {
            log.error("Could not load custom truststore", e);
        }

        LdapContextSource contextSource = new LdapContextSource();
        contextSource.setUrl(ldapUrl);
        contextSource.setBase(ldapBaseDn);
        
        // Timeout Configuration
        Map<String, Object> baseEnv = new HashMap<>();
        baseEnv.put("java.naming.security.protocol", "ssl");
        baseEnv.put("com.sun.jndi.ldap.connect.timeout", "5000"); 
        baseEnv.put("com.sun.jndi.ldap.read.timeout", "5000");    
        
        contextSource.setBaseEnvironmentProperties(baseEnv);
        return contextSource;
    }

    @Bean
    public LdapTemplate ldapTemplate() {
        return new LdapTemplate(contextSource());
    }
}


















package com.fincore.gateway.Service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.ldap.CommunicationException;
import org.springframework.ldap.core.LdapTemplate;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor
public class AdAuthenticationService {

    private final LdapTemplate ldapTemplate;

    @Value("${spring.ldap.domain:UATAD.SBI}")
    private String adDomain;

    /**
     * @return true if success, false if invalid credentials.
     * @throws RuntimeException if the server is unreachable (so we don't lock the user account).
     */
    public boolean authenticate(String username, String password) {
        if (username == null || username.isBlank() || password == null || password.isBlank()) {
            return false;
        }

        try {
            String principalName = username + "@" + adDomain;
            log.info("Attempting LDAP Bind for principal: {}", principalName);

            boolean authenticated = ldapTemplate.authenticate(
                "", 
                "(sAMAccountName=" + username + ")", 
                password
            );

            if (authenticated) {
                log.info("LDAP Success: {}", username);
                return true;
            } else {
                log.warn("LDAP Invalid Credentials: {}", username);
                return false;
            }

        } catch (CommunicationException e) {
            // Server is down or SSL failed.
            log.error("LDAP CONNECTION ERROR: {}", e.getMessage());
            // Throwing exception allows LoginService to know it wasn't a wrong password
            throw new RuntimeException("LDAP Server Down"); 
        } catch (Exception e) {
            log.error("LDAP Generic Error", e);
            return false;
        }
    }
}



















// Inside LoginServiceImpl.java -> verifyUserCredentials

if (activeMode == Constants.LDAP) {
    try {
        boolean ldapSuccess = adAuthenticationService.authenticate(userId, rawPassword);
        if (ldapSuccess) {
            handleSuccess(attempt, result, user, userRole);
        } else {
            handleFailure(attempt, result, user, loginParam, "LDAP Invalid Credentials");
        }
    } catch (RuntimeException e) {
        // Server Down - Do NOT increment wrong password count
        log.error("Skipping Login Failure logic due to LDAP System Error");
        result.setValidCredentials(false);
        result.setMessage("System Error: Unable to verify credentials. Please contact support.");
        // We do NOT save a failed attempt here
        return result;
    }
}

**Summary of what to do now:**
1.  **Generate `ad-truststore.jks`** using the command in Step 2.
2.  **Replace `LdapConfig.java`** with the one provided above.
3.  **Run the app.** The SSL error will vanish, and you will either get "Login Successful" or "Invalid Credentials" (depending on if your password is actually correct).

