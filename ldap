package com.fincore.gateway.Config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.ldap.core.LdapTemplate;
import org.springframework.ldap.core.support.LdapContextSource;

import java.util.HashMap;
import java.util.Map;

@Slf4j
@Configuration
public class LdapConfig {

    // Default to the UAT IP provided in your requirement
    @Value("${spring.ldap.urls:ldaps://10.189.42.83:636}")
    private String ldapUrl;

    // The base path in the directory (DC=UATAD,DC=SBI)
    @Value("${spring.ldap.base:DC=UATAD,DC=SBI}")
    private String ldapBaseDn;

    // Domain name to append to username (e.g., user@UATAD.SBI)
    @Value("${spring.ldap.domain:UATAD.SBI}")
    private String ldapDomain;

    @Bean
    public LdapContextSource contextSource() {
        log.info("Configuring Secure LDAP Context Source. URL: {} | Base: {}", ldapUrl, ldapBaseDn);
        LdapContextSource contextSource = new LdapContextSource();
        contextSource.setUrl(ldapUrl);
        contextSource.setBase(ldapBaseDn);
        
        // We use "Simple Authentication" which passes the username/password directly
        // We do NOT set a userDn/password here because we are dynamically binding as the USER logging in.
        
        Map<String, Object> baseEnv = new HashMap<>();
        // SSL Protocol is mandatory for port 636
        baseEnv.put("java.naming.security.protocol", "ssl");
        
        // Timeouts are CRITICAL. If AD is down, we don't want the app to hang forever.
        baseEnv.put("com.sun.jndi.ldap.connect.timeout", "5000"); // 5 Seconds max to connect
        baseEnv.put("com.sun.jndi.ldap.read.timeout", "5000");    // 5 Seconds max to read

        // SECURITY NOTE: 
        // Ensure your JVM trusts the AD certificate.
        // Run: keytool -import -alias ad_uat -keystore $JAVA_HOME/lib/security/cacerts -file <your_cert>.cer
        
        contextSource.setBaseEnvironmentProperties(baseEnv);
        return contextSource;
    }

    @Bean
    public LdapTemplate ldapTemplate() {
        return new LdapTemplate(contextSource());
    }
}





















package com.fincore.gateway.Service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.ldap.core.LdapTemplate;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor
public class AdAuthenticationService {

    private final LdapTemplate ldapTemplate;

    @Value("${spring.ldap.domain:UATAD.SBI}")
    private String adDomain;

    /**
     * Authenticate against Active Directory by attempting a Bind.
     * * @param username The sAMAccountName (e.g., "7378051")
     * @param password The raw password
     * @return true if credentials are valid, false otherwise.
     */
    public boolean authenticate(String username, String password) {
        if (username == null || username.isBlank() || password == null || password.isBlank()) {
            log.warn("LDAP Auth failed: Empty username or password");
            return false;
        }

        try {
            // AD usually requires "user@domain.com" or "DOMAIN\user" for binding.
            // Using the UPN (User Principal Name) format is standard.
            // Logic: username + "@" + "UATAD.SBI"
            String principalName = username + "@" + adDomain;
            
            log.info("Attempting LDAP Bind for principal: {}", principalName);

            // The authenticate method handles the opening of connection and binding.
            // Filter: (sAMAccountName=username) checks if the user exists.
            // Password: The credential to verify.
            boolean authenticated = ldapTemplate.authenticate(
                "",                                  // Base DN is already set in config
                "(sAMAccountName=" + username + ")", // Filter to locate the user
                password                             // Password to verify
            );

            if (authenticated) {
                log.info("LDAP Authentication SUCCESS for user: {}", username);
                return true;
            } else {
                log.warn("LDAP Authentication FAILED for user: {} (Invalid Credentials)", username);
                return false;
            }

        } catch (Exception e) {
            // CRITICAL: Handle Server Down or Network issues
            log.error("LDAP System Error during auth for user: {}. Error: {}", username, e.getMessage());
            // In a production app, you might want to throw a specific custom exception 
            // if you want to differentiate between "Wrong Password" and "Server Down".
            return false;
        }
    }
}

















package com.fincore.gateway.Service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.ldap.core.LdapTemplate;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor
public class AdAuthenticationService {

    private final LdapTemplate ldapTemplate;

    @Value("${spring.ldap.domain:UATAD.SBI}")
    private String adDomain;

    /**
     * Authenticate against Active Directory by attempting a Bind.
     * * @param username The sAMAccountName (e.g., "7378051")
     * @param password The raw password
     * @return true if credentials are valid, false otherwise.
     */
    public boolean authenticate(String username, String password) {
        if (username == null || username.isBlank() || password == null || password.isBlank()) {
            log.warn("LDAP Auth failed: Empty username or password");
            return false;
        }

        try {
            // AD usually requires "user@domain.com" or "DOMAIN\user" for binding.
            // Using the UPN (User Principal Name) format is standard.
            // Logic: username + "@" + "UATAD.SBI"
            String principalName = username + "@" + adDomain;
            
            log.info("Attempting LDAP Bind for principal: {}", principalName);

            // The authenticate method handles the opening of connection and binding.
            // Filter: (sAMAccountName=username) checks if the user exists.
            // Password: The credential to verify.
            boolean authenticated = ldapTemplate.authenticate(
                "",                                  // Base DN is already set in config
                "(sAMAccountName=" + username + ")", // Filter to locate the user
                password                             // Password to verify
            );

            if (authenticated) {
                log.info("LDAP Authentication SUCCESS for user: {}", username);
                return true;
            } else {
                log.warn("LDAP Authentication FAILED for user: {} (Invalid Credentials)", username);
                return false;
            }

        } catch (Exception e) {
            // CRITICAL: Handle Server Down or Network issues
            log.error("LDAP System Error during auth for user: {}. Error: {}", username, e.getMessage());
            // In a production app, you might want to throw a specific custom exception 
            // if you want to differentiate between "Wrong Password" and "Server Down".
            return false;
        }
    }
}


















package com.fincore.gateway.Service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fincore.gateway.JwtUtil.HmacJwtUtil;
import com.fincore.gateway.dto.*;
import com.fincore.gateway.model.LoginAttempt;
import com.fincore.gateway.model.LoginParam;
import com.fincore.gateway.model.User;
import com.fincore.gateway.model.UserRoles;
import com.fincore.gateway.repository.LoginAttemptRepository;
import com.fincore.gateway.repository.LoginParamRepository;
import com.fincore.gateway.repository.RolePermissionsRepository;
import com.fincore.gateway.repository.UserRepository;
import com.fincore.gateway.utility.Constants;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 * Service implementation handling user login/verification, menu resolution, and password updates.
 *
 * <p><strong>Updated for LDAP Integration</strong>
 * <ul>
 * <li>Supports 'L' mode for Active Directory Authentication.</li>
 * <li>Maintains local Authorization (User/Role check) regardless of Auth mode.</li>
 * </ul>
 */
@Slf4j
@Service("LoginService")
@RequiredArgsConstructor
public class LoginServiceImpl implements LoginService {

    private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

    // ======= Config =======
    private final UserRepository userRepository;
    private final LoginAttemptRepository loginAttemptRepository;

    // ======= Dependencies =======
    private final LoginParamRepository loginParamRepository;
    private final RolePermissionsRepository rolePermissionsRepository;
    private final MenuService menuService;
    private final ObjectMapper mapper;
    
    // NEW: LDAP Service
    private final AdAuthenticationService adAuthenticationService;

    @Value("${security.jwt.hmac-base64-secret:}")
    private String hmacSecret;
    
    @Value("${security.jwt.ttl-seconds:900}")
    private long ttlSeconds;

    // ======= Public API =======

    @Transactional(readOnly = true)
    @Override
    public MenuResponse fetchRoleWiseData(String userId) {
        log.info("Fetching role-wise data for userId: {}", userId);
        try {
            List<PermissionRow> rows = rolePermissionsRepository.findAllPermissionsByUserId(userId);
            if (rows == null || rows.isEmpty()) {
                return new MenuResponse(Collections.emptyList());
            }
            return menuService.transformFromProjection(rows);
        } catch (Exception e) {
            log.error("Error fetching permissions for userId: {}", userId, e);
            return new MenuResponse(Collections.emptyList());
        }
    }

    @Transactional
    @Override
    public UserDto verifyUserCredentials(UserDto userCredentials, String clientIp) {

        final String userId = userCredentials.getUserId();
        final String rawPassword = userCredentials.getPassword();

        UserDto result = new UserDto();
        
        // 1. AUTHORIZATION CHECK (Must exist in Local DB)
        User user = userRepository.findByUserId(userId);
        if (user == null) {
            result.setValidCredentials(false);
            result.setUserStatus(Constants.INVALID);
            log.warn("Login blocked: User {} not found in local DB.", userId);
            return result;
        }

        LoginParam loginParam = loginParamRepository.getLoginParam();
        char activeMode = loginParam.getActiveLoginMode();
        
        // Prepare Audit Log
        LoginAttempt attempt = new LoginAttempt();
        attempt.setLoginMethod(determineMethodString(activeMode));
        attempt.setSuccess("N");
        attempt.setIpAddress(clientIp);
        attempt.setUserId(userId);

        result.setLoginMethod(activeMode);
        result.setUserId(user.getUserId());

        UserRoles userRole = userRepository.getUserRole(userId);

        // 2. STATUS CHECKS
        result.setRoleStatus(userRole.getRoleStatus());
        result.setUserStatus(user.getAccountStatus());
        result.setPasswordLoginStatus(user.getPasswordLogin());

        if (!Constants.ACTIVE.equalsIgnoreCase(userRole.getRoleStatus())) {
            attempt.setFailureReason(generateStatusMessage(userRole.getRoleStatus(), "role"));
            loginAttemptRepository.save(attempt);
            result.setValidCredentials(false);
            return result;
        }

        if (!Constants.ACTIVE.equalsIgnoreCase(user.getAccountStatus())) {
            attempt.setFailureReason(generateStatusMessage(user.getAccountStatus(), "user"));
            loginAttemptRepository.save(attempt);
            result.setValidCredentials(false);
            return result;
        }

        // 3. AUTHENTICATION LOGIC BASED ON MODE
        if (activeMode == Constants.LDAP) {
            // --- MODE: LDAP ---
            log.info("Processing LDAP Login for user: {}", userId);
            boolean ldapSuccess = adAuthenticationService.authenticate(userId, rawPassword);
            
            if (ldapSuccess) {
                // LDAP Success -> Treat as valid login
                handleSuccess(attempt, result, user, userRole);
            } else {
                // LDAP Failure -> Handle as wrong credentials
                // Note: We intentionally map LDAP failure to "Password Based Login" failure logic 
                // to reuse the lockout mechanism/audit logs if desired.
                handleFailure(attempt, result, user, loginParam, "LDAP Authentication Failed");
            }

        } else if (activeMode == Constants.PASSWORD) {
            // --- MODE: LOCAL PASSWORD ---
            // Check if Password Login is explicitly disabled for this specific user
            if (Constants.ACTIVE.equalsIgnoreCase(user.getPasswordLogin())) {
                passwordBasedLogin(rawPassword, attempt, result, user, loginParam);
            } else {
                // Account is Locked or Disabled
                handleAccountLocked(attempt, result, user);
            }

        } else {
            // --- MODE: SSO (Existing Logic) ---
            attempt.setSuccess("Y");
            attempt.setFailureReason("SUCCESS");
            result.setValidCredentials(true);
            
            // Re-enable password login if it was locked, upon successful SSO
            if (Constants.INACTIVE.equalsIgnoreCase(user.getPasswordLogin())) {
                user.setPasswordLogin(Constants.ACTIVE);
                userRepository.save(user);
            }
            handleSuccess(attempt, result, user, userRole);
        }

        loginAttemptRepository.save(attempt);
        log.debug("verifyUserCredentials result={}", result);
        return result;
    }
    
    // --- Helper Methods to keep code clean ---

    private String determineMethodString(char mode) {
        if (mode == Constants.LDAP) return "LDAP";
        if (mode == Constants.PASSWORD) return Constants.PASSWORD_BASED_LOGIN;
        return Constants.SSO_BASED_LOGIN;
    }

    private void handleAccountLocked(LoginAttempt attempt, UserDto result, User user) {
        result.setValidCredentials(false);
        result.setPasswordLoginStatus(user.getPasswordLogin()); 
        result.setMessage("Your account is locked due to multiple failed attempts.");
        
        if (Constants.INACTIVE.equalsIgnoreCase(user.getPasswordLogin())) {
            result.setAttemptsLeft(0);
            attempt.setFailureReason("Account Locked (Pre-check)");
        } else {
            result.setMessage("Password login is disabled.");
            attempt.setFailureReason("Password login disabled");
        }
    }

    private void handleSuccess(LoginAttempt attempt, UserDto result, User user, UserRoles userRole) {
        attempt.setSuccess("Y");
        attempt.setFailureReason("Success");
        result.setValidCredentials(true);
        result.setMessage("Login Successful");

        // Reset wrong password count on successful login
        if (user.getUserWrongPasswordCount() > 0) {
            user.setUserWrongPasswordCount(0);
            userRepository.save(user);
        }

        // Generate Token
        log.info("Credentials validated. Issuing token for userId={}", user.getUserId());
        UserDto safeClaims = new UserDto();
        safeClaims.setUserId(user.getUserId());
        safeClaims.setUserrole(userRole.getRole());

        @SuppressWarnings("unchecked")
        String accessToken = HmacJwtUtil.generate(
                hmacSecret,
                user.getUserId(),
                ttlSeconds,
                mapper.convertValue(safeClaims, Map.class)
        );

        UserTokenDataDto tokenData = initializeTokenData(user, userRole);
        result.setAccessToken(accessToken);
        result.setUser(tokenData);
    }
    
    private void handleFailure(LoginAttempt attempt, UserDto userInfo, User user, LoginParam loginParam, String reason) {
        log.warn("Login failed for user {}: {}", user.getUserId(), reason);
        attempt.setSuccess("N");
        
        int currentFailedCount = user.getUserWrongPasswordCount();
        int maxAllowed = loginParam.getWrongPasswordAttempts();
        int newFailedCount = currentFailedCount + 1;
        
        user.setUserWrongPasswordCount(newFailedCount);
        userInfo.setValidCredentials(false);

        if (newFailedCount >= maxAllowed) {
            user.setPasswordLogin(Constants.INACTIVE);
            // user.setAccountStatus(Constants.LOCKED); // Optional: Depending on business rule
            attempt.setFailureReason(reason + " -> Account Locked");
            userInfo.setMessage("Your account has been locked due to multiple unsuccessful login attempts.");
            userInfo.setPasswordLoginStatus(Constants.INACTIVE);
            userInfo.setAttemptsLeft(0);
        } else {
            int remaining = maxAllowed - newFailedCount;
            attempt.setFailureReason(reason);
            if (remaining > 1) {
                userInfo.setMessage("Incorrect credentials. Please check and try again.");
            } else {
                userInfo.setMessage("Incorrect credentials. ⚠️ Final attempt before lock.");
            }
            userInfo.setAttemptsLeft(remaining);
        }
        userRepository.save(user);
    }

    /**
     * Password-based authentication logic
     */
    @Transactional
    @Override
    public void passwordBasedLogin(String password, LoginAttempt loginAttempt, UserDto userInfo, User user, LoginParam loginParam) {
        log.info("Password-based login for userId={}", user.getUserId());

        if (Constants.INACTIVE.equalsIgnoreCase(user.getPasswordLogin())) {
            handleAccountLocked(loginAttempt, userInfo, user);
            return;
        }

        if (encoder.matches(password, user.getPasswordHash())) {
            UserRoles userRole = userRepository.getUserRole(user.getUserId());
            handleSuccess(loginAttempt, userInfo, user, userRole);
        } else {
            handleFailure(loginAttempt, userInfo, user, loginParam, "Wrong Password");
        }
    }

    @Override
    public String generateStatusMessage(String status, String type) {
        return String.format("Trying to login with a %s %s", status, type);
    }

    @Transactional(readOnly = true)
    public VerifyUserDTO checkUser(String userId) {
        VerifyUserDTO out = new VerifyUserDTO();
        out.setUserId(userId);

        User user = userRepository.findByUserId(userId);
        LoginParam loginParam = loginParamRepository.getLoginParam();
        out.setLoginMethod(loginParam.getActiveLoginMode());

        if (user == null) {
            out.setUserCheck(false);
            out.setUserStatus(Constants.INVALID);
            out.setMessage("Invalid User");
            return out;
        }

        if (Constants.ACTIVE.equalsIgnoreCase(user.getAccountStatus())) {
            Timestamp setAt = user.getTempPasswordSetAt();
            boolean isPasswordValid = false;
            
            // Validate password expiration only for Password Mode
            if (loginParam.getActiveLoginMode() == Constants.PASSWORD && setAt != null) {
                LocalDateTime lastUpdate = setAt.toLocalDateTime();
                isPasswordValid = LocalDateTime.now()
                        .isBefore(lastUpdate.plusHours(loginParam.getPasswordValidity()));
            } else {
                // For LDAP/SSO, we rely on their policies, so treat local validity as true
                isPasswordValid = true;
            }

            UserRoles userRole = userRepository.getUserRole(userId);
            out.setRoleStatus(userRole.getRoleStatus());
            
            // Logic: Update Password only needed if Mode is Password AND (Password is null OR Expired)
            boolean updateNeeded = (loginParam.getActiveLoginMode() == Constants.PASSWORD) 
                                   && (user.getPasswordHash() == null || !isPasswordValid);
                                   
            out.setUpdatePassword(updateNeeded);
            out.setUserStatus(Constants.ACTIVE);
            out.setMessage(Constants.ACTIVE_USER);
            out.setPasswordLoginStatus(user.getPasswordLogin());
        } else {
            String accountStatus = user.getAccountStatus();
            out.setUserCheck(true);
            out.setUserStatus(accountStatus);
            out.setMessage(
                    accountStatus.equalsIgnoreCase("locked") ? "Your account is locked. Please contact admin."
                            : accountStatus.equalsIgnoreCase("inactive") ? "Inactive User" : "Verification Pending"
            );
        }

        return out;
    }

    @Transactional
    public UpdatePasswordDTO updatePassword(UpdatePasswordDTO userCredentials) {
        String userId = userCredentials.getUserId();
        String password = userCredentials.getPassword();

        userCredentials.setUpdateFlag(false);
        userCredentials.setPassword("");
        userCredentials.setOtp("");

        try {
            User user = userRepository.findByUserId(userId);
            if (user == null) {
                userCredentials.setMessage("Invalid user id");
                return userCredentials;
            }

            String passwordHash = encoder.encode(password);
            user.setPasswordHash(passwordHash);
            user.setTempPasswordSetAt(Timestamp.valueOf(LocalDateTime.now()));
            userRepository.save(user);

            userCredentials.setMessage("User password successfully updated");
            userCredentials.setUpdateFlag(true);
        } catch (DataIntegrityViolationException e) {
            log.warn("Data integrity violation while updating password for userId={}", userId, e);
            userCredentials.setMessage("Failed to change password, please try again");
        } catch (Exception e) {
            log.error("Unexpected error while updating password for userId={}", userId, e);
            userCredentials.setMessage("Unexpected error while changing password");
        }
        return userCredentials;
    }

    private UserTokenDataDto initializeTokenData(User user, UserRoles userRole) {
        UserTokenDataDto tokenData = new UserTokenDataDto();
        tokenData.setFirstName(user.getFirstName());
        tokenData.setLastName(user.getLastName());
        tokenData.setPhoneNumber(user.getPhoneNumber());
        tokenData.setUserId(user.getUserId());
        tokenData.setBranch(user.getBranch());
        tokenData.setEmail(user.getEmail());
        tokenData.setRole(userRole.getRole());
        tokenData.setRoleName(userRole.getRoleName());
        return tokenData;
    }

    @Override
    @Transactional(readOnly = true)
    public UserDto getUserProfile(String userId) {
        User user = userRepository.findByUserId(userId);
        UserRoles userRole = userRepository.getUserRole(userId);
        if (user == null) return null;
        
        UserDto userDto = new UserDto();
        userDto.setUserId(user.getUserId());
        userDto.setUserStatus(user.getPasswordLogin());
        userDto.setPasswordLoginStatus(user.getPasswordLogin());
        userDto.setUser(initializeTokenData(user, userRole));
        return userDto;
    }
}















